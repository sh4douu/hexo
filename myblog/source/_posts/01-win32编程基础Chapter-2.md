---
title: Win32编程基础Chapter 2：Win32程序结构
date: 2019-04-01 11:07:27
tags: 
	- Win32
	- 汇编语言
categories: Win32
---

#### 0x00 Win32程序基本结构：

```assembly
.386                    
.model flat, stdcall    
option  casemap:none   

<一些include语句>

.stack [堆栈段的大小]     

.data                   
  <Your initialized data>
        ......

.data?
  <Your uninitialized data>
        ......

.const
  <Your constants>
        ......

.code
  <your code>
    
<标号>
  <your code>
  .....
end <标号>

```

<!-- more -->

**结构解析**

```
.386
```

这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。

Win32程序工作在80386及以上的处理器中，所以必须有该语句。

```
.model flat, stdcall 
```

`.MODEL`是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 
`stdcall`告诉编译器参数的传递约定为从右到左传递，即右边的参数最先入栈，恢复堆栈的工作交由被调用者。

```
option  casemap:none
```

程序中变量和子程序名是否大小写敏感。因为Win32 API是大小写敏感的，避免大小写敏感不一致导致错误。

```
.stack [堆栈段的大小]
```

Win32中是不必考虑定义堆栈的，系统会自动分配一个向下扩展的、足够大的段作为栈段。最多只需要定义栈段的大小。
栈的数据是可读可写且可以被执行的。

```
.DATA 
.DATA? 
.CONST 
.CODE
```

它们都是定义段的伪指令，在Win32中实际只有数据和代码之分，前三者定义数据段，`.code`定义代码段。

`.data`包含已初始化的数据，即在程序装入完成时，就存在内存中了。可读可写，不可执行。存放在PE文件的_DATA节区中。

`.data?`包含未初始化的数据，生成可执行文件时只保留大小信息，在程序执行时才开始使用，可节约空间。可读写，不可执                 行。存放在PE文件的_BSS节区。

> 例如，在.data定义一个变量作为缓冲区，大小为5M，那么生成的可执行文件大小是包含这5M的，但如果定义在.data?就不会。

`.const`包含一些在程序执行过程不会改变的常量数据，在程序完成装载时也已经存在，可读不可写，不可执行。尝试对其写入                    将报错。

`.code`定义代码段，所有代码要写于其中，因为所有数据段都是不可执行的，只有代码段具有可执行的属性（栈段也可执行）。

运行在特权3的应用程序，`.code`段是可读不可写的，但不是绝对的，代码段的属性是由PE头部的属性决定的。

`.code`段存放在PE文件的_TEXT节区中。

#### 0x01 程序结束与程序入口

```assembly
<标号>

...  <code> ...

end <标号>
```

程序遇到end时，表示程序结束，同时end后面的标号也指明了程序的入口为标号处。**

在多模块编程中，不必每个模块都要写开始标号，只要在主模块使用标号即可，而每个模块也只用end，而不用end <标号>。

#### 0x02 注释与换行

Win32中，分号（；）是注释符。但在字符串定义中的分号不会作为注释符。

```assembly
szChar db 'Hello;'   ;Hello之后的；不会作为注释符。
```

当程序一行过长时，可在行尾使用\进行多行书写，提高可读性。