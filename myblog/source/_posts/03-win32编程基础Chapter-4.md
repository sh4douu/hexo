---
title: Win32编程基础Chapter 4：调用约定
date: 2019-04-01 14:22:00
tags:
	- Win32
	- 汇编语言
categories: Win32
---

#### 0x00 全局变量

全局变量的作用域是整个程序。

全局变量在`.data`或`.data?`段中定义。在`.data`段中定义变量时可以指定初值，也可以用`?`表示预留。在`.data?`段中定义变量时不能初始化值，只能使用`?`预留空间。使用`?`时，编译器实际是用0替代的。

可以同时定义变量的类型和长度。

```
变量名  类型  初始值1，初始值2...
变量名  类型  重复数量 dup(初始值1,初始值2...)
```

<!-- more -->

常用类型：

```
db  定义字节类型，1B。
dw  定义字类型，2B。
dd  定义双字类型，4B。
df  定义三字类型，6B。
dq  定义四字类型，8B。

;注意，只有在定义全局变量的时候才能使用类型的简写。
```

#### 0x01 局部变量

局部变量的作用域只在当前子程序中。

局部变量存储在栈空间中。

局部变量定义在子程序定义位置的proc之后，子程序内部其他指令前。

局部变量名不能与全局变量名同名。

局部变量定义时不能直接初始化值，因为local伪指令的作用只是预留相应的栈空间给局部变量。

局部变量定义：

MASM提供的伪指令local定义局部变量。

格式：

```assembly
local 变量名 [[重复数量]] [:类型]
```

类型有：

```
:数据结构名   ;数据结构
:byte       ;字节型
:word       ;字型
:dword      ;双字型,默认就是dw，所以可以省略. 
```

**局部变量也存储在堆栈中，进入（执行）子程序时，会修改堆栈指针ESP来预留给局部变量的空间。**

例子：

```assembly
TestPro proc                   ;定义一个子程序

local str1:dword,str2:word     ;定义两个变量，str1时双字型，str2是字型。
local str3:byte                ;定义一个变量，str3是字节型。

mov eax,str1
mov bx,str2
mov cl,str3
ret 

TestPro proc endp  ;子程序结束
```

将上面代码进行编译然后再反汇编得到：

```assembly
push ebp              ;先保存ebp寄存器的原始值。
mov  ebp,esp          ;将此时的esp指针地址给ebp。
add  esp,FFFFFFF8     ;调整esp以预留局部变量所需的空间，上面程序定义的局部变量共需7B,但预留了8B，是因为esp操作都是按dword,就像sp都是+2或-2一样。
                      ;FFFFFFF8是-8,之所以是-8是因为栈是由大往小开始的。

mov  eax,dword ptr [ebp-4]    ;在[ebp-4]内存单元取双字数据（4byte）给eax
mov bx,word ptr [ebp-6]       ;在[ebp-6]内存单元取字数据（2byte）给bx
mov cl,byte ptr [ebp-7]       ;在[ebp-7]内存单元取字数据（2byte）给cl

leave    ;等同于：mov esp,ebp 、 pop ebp
ret
```

- 注意：ebp之后没有任何更改，而是作为一个参考点。ebp指向压入局部变量之前的栈顶元素。

#### 0x02 数据结构

数据结构实际上是包含多个字段的模板，字段的类型可以是任意的（byte、word、dword....）

定义数据结构格式：

```assembly
结构名 struct                例子：
                              WNDCLASS struct             
字段1  类型  ？                     str1  byte  ?
字段2  类型  ？                     str2  dword ?
   ...                        WNDCLASS ends

结构名 ends
```

可以把数据类型当作是一种自定义类型，因此定义了数据结构后，可以使用数据结构作为创建变量类型：

```assembly
.data?
szWndClass  WNDCLASS  <>      ;未初始化值的结构。
```

或者

```assembly
.data
szWndClass  WNDCLASS  <1,2>    ;结构的两个字段分别赋值1,2
```

PS：这样来看定义的结构类似于类，利用结构定义的变量类似于类的实例。

数据结构的字段访问：

```assembly
szWndClass.str1
szWndClass.str2    
```

#### 0x03 变量访问

在MASM中，如果要以变量类型长度以外的长度去访问变量，必须要显式的指明访问长度。（否则操作的寄存器与变量类型长度不一致时，将会报错）

方法：

```
类型  ptr 变量名
```

避免寄存器长度与变量类型长度不一致，可以使用movz指令。

变量尺寸或数据项数：

```
sizeof    变量/数据类型/数据结构      ;取得字节数。
lengthof  变量/数据类型/数据结构      ;变量中的数据项数。
```

获取变量地址：

```
offset 变量名 
```

offset只能用于全局变量，因为局部变量的地址在编译时是不能确定的，因此使用lea指令：

```assembly
lea eax,[ebp-4]    ;取得ebp-4的内存地址并存储到EAX
```

addr用于在参数时使用，addr 全局变量时，会编译成offset;addr 局部变量时，会编译为lea，但能addr的局部变量，必须是在参数中的。

```assembly
addr 局部变量/全局变量 
```

#### 0x04 参数传递与堆栈平衡

我们知道，参数是通过栈来传递的，那么完成函数调用后，参数就已经没有作用了，因此要把栈恢复到压入参数前的状态，这个过程就是堆栈平衡。

参数传递约定：

> - C与Stdcall采用从右往左开始压入栈中。

平衡堆栈：

> - C由调用者平衡堆栈。
> - Stdcall由被调用者平衡堆栈。

Win32使用Stdcall调用约定。

**C调用方式：**

子程序定义及调用（传入参数：1、2）：            ![](03-win32编程基础Chapter-4\QQ截图20190401154311.png)                     

编译子程序后再反汇编：

![](03-win32编程基础Chapter-4\QQ截图20190401154931.png)      

![](03-win32编程基础Chapter-4\QQ截图20190401155014.png)

- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。
- 而平衡堆栈是在call之后使用`add esp,0000008`，因此是调用者平衡的堆栈。

**Stdcal调用方式：**

子程序定义及调用（传入参数：1、2）： 

![](03-win32编程基础Chapter-4\QQ截图20190401155645.png)

编译子程序后再反汇编：

![](03-win32编程基础Chapter-4\QQ截图20190401155758.png)

![](03-win32编程基础Chapter-4\QQ截图20190401155812.png)

- 可以看到参数`2`先被压入栈中，然后才压入`1`，即从右到左。
- 但平衡堆栈是在子程序中使用了`ret 0008`，即被调用者平衡的堆栈。

> ret指令后加一个操作数表示，在ret后，使用esp+操作数。

#### 0x05 完整的栈操作过程

设最初的栈状态为esp。

首先，调用函数并传入参数`invoke 函数名,参数1,参数2`：

- 将两个参数依次压入栈中：
  - `push 参数2`
  - `push 参数1`
  - 此时esp-4-4。
- 然后`call  函数定义地址`。
  - 将此时的EIP压入栈中：`push eip`
    - 此时esp-8-4

进入函数内部执行函数：

- 保存当前ebp的数据：`push ebp`
  - 此时esp-12-4。
- 将当前esp的值给ebp：`mov ebp,esp`
- 为局部变量留空间：`add esp,fffffff8`
  - 此时esp-16-8
- 使用ebp获取参数、局部变量。
- 销毁局部变量：`leave`
  - 恢复esp状态到为局部变量留空间前：`mov esp,ebp`
    - 此时esp-24+8
  - 恢复ebp：`pop ebp`
    - 此时esp-16+4
- 函数返回：`ret 8`
  - `add esp,8`
    - 此时esp-12+8
  - `pop eip`
    - 此时esp-4+4。