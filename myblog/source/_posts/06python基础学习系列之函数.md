---
title: Python基础学习系列Chapter 7：函数
date: 2019-03-29 15:19:43
tags:
	- Python基础
	- Language
categories: Python
---

#### 0x00 函数概述

- def是可执行语句，即运行def语句后，函数才会存在于内存。
- def创建一个函数对象并将其赋值给某一变量名（函数名）。该变量是函数对象的一个引用。
- return语句会将一个结果对象返回给调用者，没有return语句默认返回NONE。也表示函数的调用结束。
- lambda可以创建函数并自动将结果返回。（def需要用return返回）
- yield语句也会将结果返回调用函数者，并且会记住它离开的地方。
- global语句用于声明一个模块级的变量。
- 参数是通过对象引用赋值传递的。

<!-- more -->

#### 0x01 def 函数定义

```python
def <name>(arg1,arg2,arg3.....)
    <statements>
```

- def是实时运行的，运行def语句后才会创建函数对象（封装函数代码并将这个对象赋值给变量名）。 因此运行了def后（运行模块、导入模块等），才能调用函数。(注：调用不能在定义之前，因为Python不像C等语言，有先全部编译的过程，Python的语句都是实时运行的）
- def语句定义的函数名是对象引用赋值，函数名是指向函数对象所在内存的一个引用而已。
- def语句在运行时才会评估（执行），而函数的主体内容在函数调用时才会评估（执行）。
- 可以有0个或以上个参数，称为形参
- function_name（）——函数名加上（args....）表示函数的调用，每调用一次就会运行函数主体代码。

#### 0x02 return 函数返回值

```python
return 1
return 1，'a',{'b':2},[1,2,3]，x+y
```

- return是可选的，没有时默认返回none
- 可以返回任意类型的值，但只能返回表达式，而不能是语句。返回多个值时，这些值将被放入一个元组中。

#### 0x03 变量作用域（LEGB法则）

- 作用域（命名空间） 即能访问到该变量的范围；变量赋值的位置决定了它所在的命名空间。
- Python创建、查找、修改变量名都是在命名空间进行的。不同命名空间的同名变量名不会冲突。
- 函数定义本地作用域，模块定义全局作用域。
- 变量的作用域由赋值的位置决定，分为三种作用域：

> 对于每个def内的，叫本地作用域。
>
> 函数嵌套了函数，那么对于被嵌套函数而言，嵌套函数的变量是非本地的（nonlocal）。
>
> 在def外的（包括函数名），叫全局作用域。

- 全局作用域的作用范围仅限于单个文件（模块），导入模块会得到被导入模块的全局变量访问权。
- 只有对变量赋值才会产生本地变量。如对列表进行索引修改、执行append（）等的这种原处修改的对象不会产生本地变量。
- 默认情况下：
  - 每一个函数内的变量（赋值操作）、形参、被此函数嵌套的函数名、函数内import 模块名都是属于此函数的本地作用域。      
  - 通过 global 【scope】声明变量为全局变量。

```python
a=1
def fun1():
    a=2
    def fun2():
    	global a
    	print (a)
    fun2()    		

#调用函数fun1后，打印的值是1，因为声明了a为全局变量。
```

- 通过 nonlocal 【scope】声明变量为非本地变量。

```python
a=1   #全局变量
def fun1():
   a=2 #本地变量
   def fun2():#fun1下的a对于fun2为非本地变量。
        a=5 #本地变量
    	nonlocal a
    	print (a)
   fun2()

#调用函数fun1后，打印的值是2，因为声明了a为非本地变量。
    
```

- 变量名查找法则（LEGB/LNGB)：

```
L：首先先查找本地作用域。
E/N：若有嵌套，（被嵌套函数）其次查找嵌套函数的作用域（即嵌套函数的本地作用域）
G：再次，查找全局作用域。
B：最后查找内置作用域。

依次按顺序查找，不可逆向查找。
查找到第一个结果后不再继续查找，会将第一个查找结果作为结果。
```

- 每一次函数的调用都会产生一个新的作用域。（这点对去理解函数递归很重要）
- 函数执行完毕后，本次函数调用产生的本地作用域也将消失，意味着变量将消失，但是变量的状态会被记住。

```python
#闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。

#闭包/工厂函数：一个能记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。

def make(x):
    def act(y):
        return x*y
    return act
f1=make(2)
f2=make(4)

f1(2) #返回4，f1记住了x=2的这个状态
f2(2) #返回8，f2记住了x=4的这个状态
```

- 除了上面的闭包，可以让Python函数保存状态的方法还有：共享全局变量、参数使用默认值。最好的方法是OOP。

```python
# 参数使用默认值
def make(x):
    def act(y,x=x):
        return x*y
    return act
#效果等同于闭包，该方法适用于全部Python版本
```



#### 0x04 参数

- 参数是通过引用赋值的，被传递的参数从来不自动拷贝。
- 赋值的变量，即形参，是属于本地作用域的。
- 因为是引用赋值传递，因此在函数内对传入的可变对象参数进行修改，会对其他引用影响。
- 通常情况下，参数通过位置从左到右赋值传递给形参，传递的参数要与形参数量对应。也可以使用name=value的关键字传参赋值方法。位置参数必须在关键字参数之前。
- 可以为形参指定默认值。
- 实参与形参传递规则：         
  - 通过位置分配非关键字参数。    

```
通过匹配变量名（形参名）分配关键字参数。

其他没有分配的非关键字参数分配到 *args的元组中。

其他没有匹配的关键字参数分配到**args的字典中。

没有分配到参数的形参使用默认值参数。
```

- *与 **：

```
*、**在实参前表示对传递的参数对象进行解包。	
	*的参数对象必须为序列，**的为参数对象必须为字典。
	 
*、**在形参前表示让形参接收所有没有匹配其他形参的参数。
	 *将接收的参数放入一个元组。
	 **将接受的关键字赋值参数放入一个字典。
```

- 定义函数时使用 * ，则它之后的形参在函数调用时都必须使用关键字赋值。（keyword-only）

```python
def fun1（a,*b,c,d,e）:
	pass

fun1（1,2,c=3,d=4,e=5） # *之后的必须用关键字赋值
```

- 定义函数时使用**的形参位置必须是最后一个。
- 事实上。*对所有可迭代对象有用。
- name=value在调用中表示关键字参数；name=value在函数定义中表示默认值。

#### 0x05 匿名函数 lambda

- 是def外，另一种生成函数对象的方式。
- lambda是表达式而不是语句，因此可以用于def不能用于的地方。
- lambda主体是表达式，而不是代码块，意味着只能写于一行。
- lambda同样遵循LEGB法则，因此也支持闭包。
- 默认会返回结果。

##### 0x06 函数定义

```python
lambda <arg1,arg2...> : expression

f = lambda x,y : x+y

f(1,2) #返回3
(lambda x,y:x+y)(1,2) #返回3
```

- lambda会创建并返回一个函数对象。
- lambda也可以使用默认参数。